[
  {
    "function_name": "rcu_scale_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "794-896",
    "snippet": "static int __init\nrcu_scale_init(void)\n{\n\tlong i;\n\tint firsterr = 0;\n\tstatic struct rcu_scale_ops *scale_ops[] = {\n\t\t&rcu_ops, &srcu_ops, &srcud_ops, &tasks_ops, &tasks_tracing_ops\n\t};\n\n\tif (!torture_init_begin(scale_type, verbose))\n\t\treturn -EBUSY;\n\n\t/* Process args and announce that the scalability'er is on the job. */\n\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++) {\n\t\tcur_ops = scale_ops[i];\n\t\tif (strcmp(scale_type, cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(scale_ops)) {\n\t\tpr_alert(\"rcu-scale: invalid scale type: \\\"%s\\\"\\n\", scale_type);\n\t\tpr_alert(\"rcu-scale types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++)\n\t\t\tpr_cont(\" %s\", scale_ops[i]->name);\n\t\tpr_cont(\"\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tcur_ops = NULL;\n\t\tgoto unwind;\n\t}\n\tif (cur_ops->init)\n\t\tcur_ops->init();\n\n\tif (kfree_rcu_test)\n\t\treturn kfree_scale_init();\n\n\tnrealwriters = compute_real(nwriters);\n\tnrealreaders = compute_real(nreaders);\n\tatomic_set(&n_rcu_scale_reader_started, 0);\n\tatomic_set(&n_rcu_scale_writer_started, 0);\n\tatomic_set(&n_rcu_scale_writer_finished, 0);\n\trcu_scale_print_module_parms(cur_ops, \"Start of test\");\n\n\t/* Start up the kthreads. */\n\n\tif (shutdown) {\n\t\tinit_waitqueue_head(&shutdown_wq);\n\t\tfirsterr = torture_create_kthread(rcu_scale_shutdown, NULL,\n\t\t\t\t\t\t  shutdown_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\treader_tasks = kcalloc(nrealreaders, sizeof(reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\tif (reader_tasks == NULL) {\n\t\tSCALEOUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nrealreaders; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_scale_reader, (void *)i,\n\t\t\t\t\t\t  reader_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\twhile (atomic_read(&n_rcu_scale_reader_started) < nrealreaders)\n\t\tschedule_timeout_uninterruptible(1);\n\twriter_tasks = kcalloc(nrealwriters, sizeof(reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\twriter_durations = kcalloc(nrealwriters, sizeof(*writer_durations),\n\t\t\t\t   GFP_KERNEL);\n\twriter_n_durations =\n\t\tkcalloc(nrealwriters, sizeof(*writer_n_durations),\n\t\t\tGFP_KERNEL);\n\tif (!writer_tasks || !writer_durations || !writer_n_durations) {\n\t\tSCALEOUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nrealwriters; i++) {\n\t\twriter_durations[i] =\n\t\t\tkcalloc(MAX_MEAS, sizeof(*writer_durations[i]),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!writer_durations[i]) {\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t\tfirsterr = torture_create_kthread(rcu_scale_writer, (void *)i,\n\t\t\t\t\t\t  writer_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\trcu_scale_cleanup();\n\tif (shutdown) {\n\t\tWARN_ON(!IS_MODULE(CONFIG_RCU_SCALE_TEST));\n\t\tkernel_power_off();\n\t}\n\treturn firsterr;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MAX_MEAS 10000"
    ],
    "globals_used": [
      "static char *scale_type = \"rcu\";",
      "static int nrealreaders;",
      "static int nrealwriters;",
      "static struct task_struct **writer_tasks;",
      "static struct task_struct **reader_tasks;",
      "static struct task_struct *shutdown_task;",
      "static u64 **writer_durations;",
      "static int *writer_n_durations;",
      "static atomic_t n_rcu_scale_reader_started;",
      "static atomic_t n_rcu_scale_writer_started;",
      "static atomic_t n_rcu_scale_writer_finished;",
      "static wait_queue_head_t shutdown_wq;",
      "static struct rcu_scale_ops *cur_ops;",
      "static struct rcu_scale_ops rcu_ops = {\n\t.ptype\t\t= RCU_FLAVOR,\n\t.init\t\t= rcu_sync_scale_init,\n\t.readlock\t= rcu_scale_read_lock,\n\t.readunlock\t= rcu_scale_read_unlock,\n\t.get_gp_seq\t= rcu_get_gp_seq,\n\t.gp_diff\t= rcu_seq_diff,\n\t.exp_completed\t= rcu_exp_batches_completed,\n\t.async\t\t= call_rcu,\n\t.gp_barrier\t= rcu_barrier,\n\t.sync\t\t= synchronize_rcu,\n\t.exp_sync\t= synchronize_rcu_expedited,\n\t.name\t\t= \"rcu\"\n};",
      "static struct rcu_scale_ops srcu_ops = {\n\t.ptype\t\t= SRCU_FLAVOR,\n\t.init\t\t= rcu_sync_scale_init,\n\t.readlock\t= srcu_scale_read_lock,\n\t.readunlock\t= srcu_scale_read_unlock,\n\t.get_gp_seq\t= srcu_scale_completed,\n\t.gp_diff\t= rcu_seq_diff,\n\t.exp_completed\t= srcu_scale_completed,\n\t.async\t\t= srcu_call_rcu,\n\t.gp_barrier\t= srcu_rcu_barrier,\n\t.sync\t\t= srcu_scale_synchronize,\n\t.exp_sync\t= srcu_scale_synchronize_expedited,\n\t.name\t\t= \"srcu\"\n};",
      "static struct rcu_scale_ops srcud_ops = {\n\t.ptype\t\t= SRCU_FLAVOR,\n\t.init\t\t= srcu_sync_scale_init,\n\t.cleanup\t= srcu_sync_scale_cleanup,\n\t.readlock\t= srcu_scale_read_lock,\n\t.readunlock\t= srcu_scale_read_unlock,\n\t.get_gp_seq\t= srcu_scale_completed,\n\t.gp_diff\t= rcu_seq_diff,\n\t.exp_completed\t= srcu_scale_completed,\n\t.async\t\t= srcu_call_rcu,\n\t.gp_barrier\t= srcu_rcu_barrier,\n\t.sync\t\t= srcu_scale_synchronize,\n\t.exp_sync\t= srcu_scale_synchronize_expedited,\n\t.name\t\t= \"srcud\"\n};",
      "static struct rcu_scale_ops tasks_ops = {\n\t.ptype\t\t= RCU_TASKS_FLAVOR,\n\t.init\t\t= rcu_sync_scale_init,\n\t.readlock\t= tasks_scale_read_lock,\n\t.readunlock\t= tasks_scale_read_unlock,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.gp_diff\t= rcu_seq_diff,\n\t.async\t\t= call_rcu_tasks,\n\t.gp_barrier\t= rcu_barrier_tasks,\n\t.sync\t\t= synchronize_rcu_tasks,\n\t.exp_sync\t= synchronize_rcu_tasks,\n\t.name\t\t= \"tasks\"\n};",
      "static struct rcu_scale_ops tasks_tracing_ops = {\n\t.ptype\t\t= RCU_TASKS_FLAVOR,\n\t.init\t\t= rcu_sync_scale_init,\n\t.readlock\t= tasks_trace_scale_read_lock,\n\t.readunlock\t= tasks_trace_scale_read_unlock,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.gp_diff\t= rcu_seq_diff,\n\t.async\t\t= call_rcu_tasks_trace,\n\t.gp_barrier\t= rcu_barrier_tasks_trace,\n\t.sync\t\t= synchronize_rcu_tasks_trace,\n\t.exp_sync\t= synchronize_rcu_tasks_trace,\n\t.name\t\t= \"tasks-tracing\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "289-299",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!IS_MODULE(CONFIG_RCU_SCALE_TEST)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MODULE",
          "args": [
            "CONFIG_RCU_SCALE_TEST"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_scale_cleanup",
          "args": [],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_scale_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "503-584",
          "snippet": "static void\nrcu_scale_cleanup(void)\n{\n\tint i;\n\tint j;\n\tint ngps = 0;\n\tu64 *wdp;\n\tu64 *wdpp;\n\n\t/*\n\t * Would like warning at start, but everything is expedited\n\t * during the mid-boot phase, so have to wait till the end.\n\t */\n\tif (rcu_gp_is_expedited() && !rcu_gp_is_normal() && !gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods expedited, no normal ones to measure!\");\n\tif (rcu_gp_is_normal() && gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods normal, no expedited ones to measure!\");\n\tif (gp_exp && gp_async)\n\t\tSCALEOUT_ERRSTRING(\"No expedited async GPs, so went with async!\");\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_scale_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_scale_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\tj = writer_n_durations[i];\n\t\t\tpr_alert(\"%s%s writer %d gps: %d\\n\",\n\t\t\t\t scale_type, SCALE_FLAG, i, j);\n\t\t\tngps += j;\n\t\t}\n\t\tpr_alert(\"%s%s start: %llu end: %llu duration: %llu gps: %d batches: %ld\\n\",\n\t\t\t scale_type, SCALE_FLAG,\n\t\t\t t_rcu_scale_writer_started, t_rcu_scale_writer_finished,\n\t\t\t t_rcu_scale_writer_finished -\n\t\t\t t_rcu_scale_writer_started,\n\t\t\t ngps,\n\t\t\t rcuscale_seq_diff(b_rcu_gp_test_finished,\n\t\t\t\t\t   b_rcu_gp_test_started));\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\tif (!writer_durations)\n\t\t\t\tbreak;\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\twdpp = writer_durations[i];\n\t\t\tif (!wdpp)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < writer_n_durations[i]; j++) {\n\t\t\t\twdp = &wdpp[j];\n\t\t\t\tpr_alert(\"%s%s %4d writer-duration: %5d %llu\\n\",\n\t\t\t\t\tscale_type, SCALE_FLAG,\n\t\t\t\t\ti, j, *wdp);\n\t\t\t\tif (j % 100 == 0)\n\t\t\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\t}\n\t\t\tkfree(writer_durations[i]);\n\t\t}\n\t\tkfree(writer_tasks);\n\t\tkfree(writer_durations);\n\t\tkfree(writer_n_durations);\n\t}\n\n\t/* Do torture-type-specific cleanup operations.  */\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define SCALE_FLAG \"-scale:\""
          ],
          "globals_used": [
            "static char *scale_type = \"rcu\";",
            "static int nrealreaders;",
            "static int nrealwriters;",
            "static struct task_struct **writer_tasks;",
            "static struct task_struct **reader_tasks;",
            "static u64 **writer_durations;",
            "static int *writer_n_durations;",
            "static u64 t_rcu_scale_writer_started;",
            "static u64 t_rcu_scale_writer_finished;",
            "static unsigned long b_rcu_gp_test_started;",
            "static unsigned long b_rcu_gp_test_finished;",
            "static struct rcu_scale_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define SCALE_FLAG \"-scale:\"\n\nstatic char *scale_type = \"rcu\";\nstatic int nrealreaders;\nstatic int nrealwriters;\nstatic struct task_struct **writer_tasks;\nstatic struct task_struct **reader_tasks;\nstatic u64 **writer_durations;\nstatic int *writer_n_durations;\nstatic u64 t_rcu_scale_writer_started;\nstatic u64 t_rcu_scale_writer_finished;\nstatic unsigned long b_rcu_gp_test_started;\nstatic unsigned long b_rcu_gp_test_finished;\nstatic struct rcu_scale_ops *cur_ops;\n\nstatic void\nrcu_scale_cleanup(void)\n{\n\tint i;\n\tint j;\n\tint ngps = 0;\n\tu64 *wdp;\n\tu64 *wdpp;\n\n\t/*\n\t * Would like warning at start, but everything is expedited\n\t * during the mid-boot phase, so have to wait till the end.\n\t */\n\tif (rcu_gp_is_expedited() && !rcu_gp_is_normal() && !gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods expedited, no normal ones to measure!\");\n\tif (rcu_gp_is_normal() && gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods normal, no expedited ones to measure!\");\n\tif (gp_exp && gp_async)\n\t\tSCALEOUT_ERRSTRING(\"No expedited async GPs, so went with async!\");\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_scale_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_scale_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\tj = writer_n_durations[i];\n\t\t\tpr_alert(\"%s%s writer %d gps: %d\\n\",\n\t\t\t\t scale_type, SCALE_FLAG, i, j);\n\t\t\tngps += j;\n\t\t}\n\t\tpr_alert(\"%s%s start: %llu end: %llu duration: %llu gps: %d batches: %ld\\n\",\n\t\t\t scale_type, SCALE_FLAG,\n\t\t\t t_rcu_scale_writer_started, t_rcu_scale_writer_finished,\n\t\t\t t_rcu_scale_writer_finished -\n\t\t\t t_rcu_scale_writer_started,\n\t\t\t ngps,\n\t\t\t rcuscale_seq_diff(b_rcu_gp_test_finished,\n\t\t\t\t\t   b_rcu_gp_test_started));\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\tif (!writer_durations)\n\t\t\t\tbreak;\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\twdpp = writer_durations[i];\n\t\t\tif (!wdpp)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < writer_n_durations[i]; j++) {\n\t\t\t\twdp = &wdpp[j];\n\t\t\t\tpr_alert(\"%s%s %4d writer-duration: %5d %llu\\n\",\n\t\t\t\t\tscale_type, SCALE_FLAG,\n\t\t\t\t\ti, j, *wdp);\n\t\t\t\tif (j % 100 == 0)\n\t\t\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\t}\n\t\t\tkfree(writer_durations[i]);\n\t\t}\n\t\tkfree(writer_tasks);\n\t\tkfree(writer_durations);\n\t\tkfree(writer_n_durations);\n\t}\n\n\t/* Do torture-type-specific cleanup operations.  */\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_end",
          "args": [],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "835-839",
          "snippet": "void torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(fullstop_mutex);",
            "static struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(fullstop_mutex);\nstatic struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};\n\nvoid torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_scale_writer",
            "(void *)i",
            "writer_tasks[i]"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "MAX_MEAS",
            "sizeof(*writer_durations[i])",
            "GFP_KERNEL"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCALEOUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nrealwriters",
            "sizeof(*writer_n_durations)",
            "GFP_KERNEL"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nrealwriters",
            "sizeof(*writer_durations)",
            "GFP_KERNEL"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nrealwriters",
            "sizeof(reader_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_scale_reader_started"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_scale_reader",
            "(void *)i",
            "reader_tasks[i]"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCALEOUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nrealreaders",
            "sizeof(reader_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_scale_shutdown",
            "NULL",
            "shutdown_task"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&shutdown_wq"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_scale_print_module_parms",
          "args": [
            "cur_ops",
            "\"Start of test\""
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_scale_print_module_parms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "495-501",
          "snippet": "static void\nrcu_scale_print_module_parms(struct rcu_scale_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" SCALE_FLAG\n\t\t \"--- %s: nreaders=%d nwriters=%d verbose=%d shutdown=%d\\n\",\n\t\t scale_type, tag, nrealreaders, nrealwriters, verbose, shutdown);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define SCALE_FLAG \"-scale:\""
          ],
          "globals_used": [
            "static char *scale_type = \"rcu\";",
            "static int nrealreaders;",
            "static int nrealwriters;",
            "static struct rcu_scale_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define SCALE_FLAG \"-scale:\"\n\nstatic char *scale_type = \"rcu\";\nstatic int nrealreaders;\nstatic int nrealwriters;\nstatic struct rcu_scale_ops *cur_ops;\n\nstatic void\nrcu_scale_print_module_parms(struct rcu_scale_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" SCALE_FLAG\n\t\t \"--- %s: nreaders=%d nwriters=%d verbose=%d shutdown=%d\\n\",\n\t\t scale_type, tag, nrealreaders, nrealwriters, verbose, shutdown);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_scale_writer_finished",
            "0"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_scale_writer_started",
            "0"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_scale_reader_started",
            "0"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compute_real",
          "args": [
            "nreaders"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "compute_real",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "591-603",
          "snippet": "static int compute_real(int n)\n{\n\tint nr;\n\n\tif (n >= 0) {\n\t\tnr = n;\n\t} else {\n\t\tnr = num_online_cpus() + 1 + n;\n\t\tif (nr <= 0)\n\t\t\tnr = 1;\n\t}\n\treturn nr;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int compute_real(int n)\n{\n\tint nr;\n\n\tif (n >= 0) {\n\t\tnr = n;\n\t} else {\n\t\tnr = num_online_cpus() + 1 + n;\n\t\tif (nr <= 0)\n\t\t\tnr = 1;\n\t}\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_scale_init",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "749-792",
          "snippet": "static int __init\nkfree_scale_init(void)\n{\n\tlong i;\n\tint firsterr = 0;\n\n\tkfree_nrealthreads = compute_real(kfree_nthreads);\n\t/* Start up the kthreads. */\n\tif (shutdown) {\n\t\tinit_waitqueue_head(&shutdown_wq);\n\t\tfirsterr = torture_create_kthread(kfree_scale_shutdown, NULL,\n\t\t\t\t\t\t  shutdown_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\n\tpr_alert(\"kfree object size=%zu\\n\", kfree_mult * sizeof(struct kfree_obj));\n\n\tkfree_reader_tasks = kcalloc(kfree_nrealthreads, sizeof(kfree_reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\tif (kfree_reader_tasks == NULL) {\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\n\tfor (i = 0; i < kfree_nrealthreads; i++) {\n\t\tfirsterr = torture_create_kthread(kfree_scale_thread, (void *)i,\n\t\t\t\t\t\t  kfree_reader_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\twhile (atomic_read(&n_kfree_scale_thread_started) < kfree_nrealthreads)\n\t\tschedule_timeout_uninterruptible(1);\n\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tkfree_scale_cleanup();\n\treturn firsterr;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *shutdown_task;",
            "static wait_queue_head_t shutdown_wq;",
            "static struct task_struct **kfree_reader_tasks;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_started;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *shutdown_task;\nstatic wait_queue_head_t shutdown_wq;\nstatic struct task_struct **kfree_reader_tasks;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_started;\n\nstatic int __init\nkfree_scale_init(void)\n{\n\tlong i;\n\tint firsterr = 0;\n\n\tkfree_nrealthreads = compute_real(kfree_nthreads);\n\t/* Start up the kthreads. */\n\tif (shutdown) {\n\t\tinit_waitqueue_head(&shutdown_wq);\n\t\tfirsterr = torture_create_kthread(kfree_scale_shutdown, NULL,\n\t\t\t\t\t\t  shutdown_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\n\tpr_alert(\"kfree object size=%zu\\n\", kfree_mult * sizeof(struct kfree_obj));\n\n\tkfree_reader_tasks = kcalloc(kfree_nrealthreads, sizeof(kfree_reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\tif (kfree_reader_tasks == NULL) {\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\n\tfor (i = 0; i < kfree_nrealthreads; i++) {\n\t\tfirsterr = torture_create_kthread(kfree_scale_thread, (void *)i,\n\t\t\t\t\t\t  kfree_reader_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\twhile (atomic_read(&n_kfree_scale_thread_started) < kfree_nrealthreads)\n\t\tschedule_timeout_uninterruptible(1);\n\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tkfree_scale_cleanup();\n\treturn firsterr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->init",
          "args": [],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %s\"",
            "scale_ops[i]->name"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "scale_ops"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu-scale types:\""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu-scale: invalid scale type: \\\"%s\\\"\\n\"",
            "scale_type"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "scale_ops"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "scale_type",
            "cur_ops->name"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "scale_ops"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_begin",
          "args": [
            "scale_type",
            "verbose"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "815-829",
          "snippet": "bool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static char *torture_type;",
            "static int verbose;",
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic char *torture_type;\nstatic int verbose;\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define MAX_MEAS 10000\n\nstatic char *scale_type = \"rcu\";\nstatic int nrealreaders;\nstatic int nrealwriters;\nstatic struct task_struct **writer_tasks;\nstatic struct task_struct **reader_tasks;\nstatic struct task_struct *shutdown_task;\nstatic u64 **writer_durations;\nstatic int *writer_n_durations;\nstatic atomic_t n_rcu_scale_reader_started;\nstatic atomic_t n_rcu_scale_writer_started;\nstatic atomic_t n_rcu_scale_writer_finished;\nstatic wait_queue_head_t shutdown_wq;\nstatic struct rcu_scale_ops *cur_ops;\nstatic struct rcu_scale_ops rcu_ops = {\n\t.ptype\t\t= RCU_FLAVOR,\n\t.init\t\t= rcu_sync_scale_init,\n\t.readlock\t= rcu_scale_read_lock,\n\t.readunlock\t= rcu_scale_read_unlock,\n\t.get_gp_seq\t= rcu_get_gp_seq,\n\t.gp_diff\t= rcu_seq_diff,\n\t.exp_completed\t= rcu_exp_batches_completed,\n\t.async\t\t= call_rcu,\n\t.gp_barrier\t= rcu_barrier,\n\t.sync\t\t= synchronize_rcu,\n\t.exp_sync\t= synchronize_rcu_expedited,\n\t.name\t\t= \"rcu\"\n};\nstatic struct rcu_scale_ops srcu_ops = {\n\t.ptype\t\t= SRCU_FLAVOR,\n\t.init\t\t= rcu_sync_scale_init,\n\t.readlock\t= srcu_scale_read_lock,\n\t.readunlock\t= srcu_scale_read_unlock,\n\t.get_gp_seq\t= srcu_scale_completed,\n\t.gp_diff\t= rcu_seq_diff,\n\t.exp_completed\t= srcu_scale_completed,\n\t.async\t\t= srcu_call_rcu,\n\t.gp_barrier\t= srcu_rcu_barrier,\n\t.sync\t\t= srcu_scale_synchronize,\n\t.exp_sync\t= srcu_scale_synchronize_expedited,\n\t.name\t\t= \"srcu\"\n};\nstatic struct rcu_scale_ops srcud_ops = {\n\t.ptype\t\t= SRCU_FLAVOR,\n\t.init\t\t= srcu_sync_scale_init,\n\t.cleanup\t= srcu_sync_scale_cleanup,\n\t.readlock\t= srcu_scale_read_lock,\n\t.readunlock\t= srcu_scale_read_unlock,\n\t.get_gp_seq\t= srcu_scale_completed,\n\t.gp_diff\t= rcu_seq_diff,\n\t.exp_completed\t= srcu_scale_completed,\n\t.async\t\t= srcu_call_rcu,\n\t.gp_barrier\t= srcu_rcu_barrier,\n\t.sync\t\t= srcu_scale_synchronize,\n\t.exp_sync\t= srcu_scale_synchronize_expedited,\n\t.name\t\t= \"srcud\"\n};\nstatic struct rcu_scale_ops tasks_ops = {\n\t.ptype\t\t= RCU_TASKS_FLAVOR,\n\t.init\t\t= rcu_sync_scale_init,\n\t.readlock\t= tasks_scale_read_lock,\n\t.readunlock\t= tasks_scale_read_unlock,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.gp_diff\t= rcu_seq_diff,\n\t.async\t\t= call_rcu_tasks,\n\t.gp_barrier\t= rcu_barrier_tasks,\n\t.sync\t\t= synchronize_rcu_tasks,\n\t.exp_sync\t= synchronize_rcu_tasks,\n\t.name\t\t= \"tasks\"\n};\nstatic struct rcu_scale_ops tasks_tracing_ops = {\n\t.ptype\t\t= RCU_TASKS_FLAVOR,\n\t.init\t\t= rcu_sync_scale_init,\n\t.readlock\t= tasks_trace_scale_read_lock,\n\t.readunlock\t= tasks_trace_scale_read_unlock,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.gp_diff\t= rcu_seq_diff,\n\t.async\t\t= call_rcu_tasks_trace,\n\t.gp_barrier\t= rcu_barrier_tasks_trace,\n\t.sync\t\t= synchronize_rcu_tasks_trace,\n\t.exp_sync\t= synchronize_rcu_tasks_trace,\n\t.name\t\t= \"tasks-tracing\"\n};\n\nstatic int __init\nrcu_scale_init(void)\n{\n\tlong i;\n\tint firsterr = 0;\n\tstatic struct rcu_scale_ops *scale_ops[] = {\n\t\t&rcu_ops, &srcu_ops, &srcud_ops, &tasks_ops, &tasks_tracing_ops\n\t};\n\n\tif (!torture_init_begin(scale_type, verbose))\n\t\treturn -EBUSY;\n\n\t/* Process args and announce that the scalability'er is on the job. */\n\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++) {\n\t\tcur_ops = scale_ops[i];\n\t\tif (strcmp(scale_type, cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(scale_ops)) {\n\t\tpr_alert(\"rcu-scale: invalid scale type: \\\"%s\\\"\\n\", scale_type);\n\t\tpr_alert(\"rcu-scale types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++)\n\t\t\tpr_cont(\" %s\", scale_ops[i]->name);\n\t\tpr_cont(\"\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tcur_ops = NULL;\n\t\tgoto unwind;\n\t}\n\tif (cur_ops->init)\n\t\tcur_ops->init();\n\n\tif (kfree_rcu_test)\n\t\treturn kfree_scale_init();\n\n\tnrealwriters = compute_real(nwriters);\n\tnrealreaders = compute_real(nreaders);\n\tatomic_set(&n_rcu_scale_reader_started, 0);\n\tatomic_set(&n_rcu_scale_writer_started, 0);\n\tatomic_set(&n_rcu_scale_writer_finished, 0);\n\trcu_scale_print_module_parms(cur_ops, \"Start of test\");\n\n\t/* Start up the kthreads. */\n\n\tif (shutdown) {\n\t\tinit_waitqueue_head(&shutdown_wq);\n\t\tfirsterr = torture_create_kthread(rcu_scale_shutdown, NULL,\n\t\t\t\t\t\t  shutdown_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\treader_tasks = kcalloc(nrealreaders, sizeof(reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\tif (reader_tasks == NULL) {\n\t\tSCALEOUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nrealreaders; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_scale_reader, (void *)i,\n\t\t\t\t\t\t  reader_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\twhile (atomic_read(&n_rcu_scale_reader_started) < nrealreaders)\n\t\tschedule_timeout_uninterruptible(1);\n\twriter_tasks = kcalloc(nrealwriters, sizeof(reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\twriter_durations = kcalloc(nrealwriters, sizeof(*writer_durations),\n\t\t\t\t   GFP_KERNEL);\n\twriter_n_durations =\n\t\tkcalloc(nrealwriters, sizeof(*writer_n_durations),\n\t\t\tGFP_KERNEL);\n\tif (!writer_tasks || !writer_durations || !writer_n_durations) {\n\t\tSCALEOUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nrealwriters; i++) {\n\t\twriter_durations[i] =\n\t\t\tkcalloc(MAX_MEAS, sizeof(*writer_durations[i]),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!writer_durations[i]) {\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t\tfirsterr = torture_create_kthread(rcu_scale_writer, (void *)i,\n\t\t\t\t\t\t  writer_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\trcu_scale_cleanup();\n\tif (shutdown) {\n\t\tWARN_ON(!IS_MODULE(CONFIG_RCU_SCALE_TEST));\n\t\tkernel_power_off();\n\t}\n\treturn firsterr;\n}"
  },
  {
    "function_name": "kfree_scale_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "749-792",
    "snippet": "static int __init\nkfree_scale_init(void)\n{\n\tlong i;\n\tint firsterr = 0;\n\n\tkfree_nrealthreads = compute_real(kfree_nthreads);\n\t/* Start up the kthreads. */\n\tif (shutdown) {\n\t\tinit_waitqueue_head(&shutdown_wq);\n\t\tfirsterr = torture_create_kthread(kfree_scale_shutdown, NULL,\n\t\t\t\t\t\t  shutdown_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\n\tpr_alert(\"kfree object size=%zu\\n\", kfree_mult * sizeof(struct kfree_obj));\n\n\tkfree_reader_tasks = kcalloc(kfree_nrealthreads, sizeof(kfree_reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\tif (kfree_reader_tasks == NULL) {\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\n\tfor (i = 0; i < kfree_nrealthreads; i++) {\n\t\tfirsterr = torture_create_kthread(kfree_scale_thread, (void *)i,\n\t\t\t\t\t\t  kfree_reader_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\twhile (atomic_read(&n_kfree_scale_thread_started) < kfree_nrealthreads)\n\t\tschedule_timeout_uninterruptible(1);\n\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tkfree_scale_cleanup();\n\treturn firsterr;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *shutdown_task;",
      "static wait_queue_head_t shutdown_wq;",
      "static struct task_struct **kfree_reader_tasks;",
      "static int kfree_nrealthreads;",
      "static atomic_t n_kfree_scale_thread_started;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_scale_cleanup",
          "args": [],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "715-731",
          "snippet": "static void\nkfree_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (kfree_reader_tasks) {\n\t\tfor (i = 0; i < kfree_nrealthreads; i++)\n\t\t\ttorture_stop_kthread(kfree_scale_thread,\n\t\t\t\t\t     kfree_reader_tasks[i]);\n\t\tkfree(kfree_reader_tasks);\n\t}\n\n\ttorture_cleanup_end();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct **kfree_reader_tasks;",
            "static int kfree_nrealthreads;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct **kfree_reader_tasks;\nstatic int kfree_nrealthreads;\n\nstatic void\nkfree_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (kfree_reader_tasks) {\n\t\tfor (i = 0; i < kfree_nrealthreads; i++)\n\t\t\ttorture_stop_kthread(kfree_scale_thread,\n\t\t\t\t\t     kfree_reader_tasks[i]);\n\t\tkfree(kfree_reader_tasks);\n\t}\n\n\ttorture_cleanup_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_end",
          "args": [],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "835-839",
          "snippet": "void torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(fullstop_mutex);",
            "static struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(fullstop_mutex);\nstatic struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};\n\nvoid torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_kfree_scale_thread_started"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "kfree_scale_thread",
            "(void *)i",
            "kfree_reader_tasks[i]"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "kfree_nrealthreads",
            "sizeof(kfree_reader_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"kfree object size=%zu\\n\"",
            "kfree_mult * sizeof(struct kfree_obj)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "kfree_scale_shutdown",
            "NULL",
            "shutdown_task"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&shutdown_wq"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compute_real",
          "args": [
            "kfree_nthreads"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "compute_real",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "591-603",
          "snippet": "static int compute_real(int n)\n{\n\tint nr;\n\n\tif (n >= 0) {\n\t\tnr = n;\n\t} else {\n\t\tnr = num_online_cpus() + 1 + n;\n\t\tif (nr <= 0)\n\t\t\tnr = 1;\n\t}\n\treturn nr;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int compute_real(int n)\n{\n\tint nr;\n\n\tif (n >= 0) {\n\t\tnr = n;\n\t} else {\n\t\tnr = num_online_cpus() + 1 + n;\n\t\tif (nr <= 0)\n\t\t\tnr = 1;\n\t}\n\treturn nr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *shutdown_task;\nstatic wait_queue_head_t shutdown_wq;\nstatic struct task_struct **kfree_reader_tasks;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_started;\n\nstatic int __init\nkfree_scale_init(void)\n{\n\tlong i;\n\tint firsterr = 0;\n\n\tkfree_nrealthreads = compute_real(kfree_nthreads);\n\t/* Start up the kthreads. */\n\tif (shutdown) {\n\t\tinit_waitqueue_head(&shutdown_wq);\n\t\tfirsterr = torture_create_kthread(kfree_scale_shutdown, NULL,\n\t\t\t\t\t\t  shutdown_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\n\tpr_alert(\"kfree object size=%zu\\n\", kfree_mult * sizeof(struct kfree_obj));\n\n\tkfree_reader_tasks = kcalloc(kfree_nrealthreads, sizeof(kfree_reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\tif (kfree_reader_tasks == NULL) {\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\n\tfor (i = 0; i < kfree_nrealthreads; i++) {\n\t\tfirsterr = torture_create_kthread(kfree_scale_thread, (void *)i,\n\t\t\t\t\t\t  kfree_reader_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\twhile (atomic_read(&n_kfree_scale_thread_started) < kfree_nrealthreads)\n\t\tschedule_timeout_uninterruptible(1);\n\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tkfree_scale_cleanup();\n\treturn firsterr;\n}"
  },
  {
    "function_name": "kfree_scale_shutdown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "736-747",
    "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static wait_queue_head_t shutdown_wq;",
      "static int kfree_nrealthreads;",
      "static atomic_t n_kfree_scale_thread_ended;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "289-299",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_scale_cleanup",
          "args": [],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "715-731",
          "snippet": "static void\nkfree_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (kfree_reader_tasks) {\n\t\tfor (i = 0; i < kfree_nrealthreads; i++)\n\t\t\ttorture_stop_kthread(kfree_scale_thread,\n\t\t\t\t\t     kfree_reader_tasks[i]);\n\t\tkfree(kfree_reader_tasks);\n\t}\n\n\ttorture_cleanup_end();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct **kfree_reader_tasks;",
            "static int kfree_nrealthreads;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct **kfree_reader_tasks;\nstatic int kfree_nrealthreads;\n\nstatic void\nkfree_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (kfree_reader_tasks) {\n\t\tfor (i = 0; i < kfree_nrealthreads; i++)\n\t\t\ttorture_stop_kthread(kfree_scale_thread,\n\t\t\t\t\t     kfree_reader_tasks[i]);\n\t\tkfree(kfree_reader_tasks);\n\t}\n\n\ttorture_cleanup_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "shutdown_wq",
            "atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_kfree_scale_thread_ended"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "kfree_scale_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "715-731",
    "snippet": "static void\nkfree_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (kfree_reader_tasks) {\n\t\tfor (i = 0; i < kfree_nrealthreads; i++)\n\t\t\ttorture_stop_kthread(kfree_scale_thread,\n\t\t\t\t\t     kfree_reader_tasks[i]);\n\t\tkfree(kfree_reader_tasks);\n\t}\n\n\ttorture_cleanup_end();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct **kfree_reader_tasks;",
      "static int kfree_nrealthreads;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_cleanup_end",
          "args": [],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "876-881",
          "snippet": "void torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nvoid torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kfree_reader_tasks"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "kfree_scale_thread",
            "kfree_reader_tasks[i]"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "948-955",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_cleanup_begin",
          "args": [],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "857-873",
          "snippet": "bool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */",
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct **kfree_reader_tasks;\nstatic int kfree_nrealthreads;\n\nstatic void\nkfree_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (kfree_reader_tasks) {\n\t\tfor (i = 0; i < kfree_nrealthreads; i++)\n\t\t\ttorture_stop_kthread(kfree_scale_thread,\n\t\t\t\t\t     kfree_reader_tasks[i]);\n\t\tkfree(kfree_reader_tasks);\n\t}\n\n\ttorture_cleanup_end();\n}"
  },
  {
    "function_name": "kfree_scale_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "641-713",
    "snippet": "static int\nkfree_scale_thread(void *arg)\n{\n\tint i, loop = 0;\n\tlong me = (long)arg;\n\tstruct kfree_obj *alloc_ptr;\n\tu64 start_time, end_time;\n\tlong long mem_begin, mem_during = 0;\n\tbool kfree_rcu_test_both;\n\tDEFINE_TORTURE_RANDOM(tr);\n\n\tVERBOSE_SCALEOUT_STRING(\"kfree_scale_thread task started\");\n\tset_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids));\n\tset_user_nice(current, MAX_NICE);\n\tkfree_rcu_test_both = (kfree_rcu_test_single == kfree_rcu_test_double);\n\n\tstart_time = ktime_get_mono_fast_ns();\n\n\tif (atomic_inc_return(&n_kfree_scale_thread_started) >= kfree_nrealthreads) {\n\t\tif (gp_exp)\n\t\t\tb_rcu_gp_test_started = cur_ops->exp_completed() / 2;\n\t\telse\n\t\t\tb_rcu_gp_test_started = cur_ops->get_gp_seq();\n\t}\n\n\tdo {\n\t\tif (!mem_during) {\n\t\t\tmem_during = mem_begin = si_mem_available();\n\t\t} else if (loop % (kfree_loops / 4) == 0) {\n\t\t\tmem_during = (mem_during + si_mem_available()) / 2;\n\t\t}\n\n\t\tfor (i = 0; i < kfree_alloc_num; i++) {\n\t\t\talloc_ptr = kmalloc(kfree_mult * sizeof(struct kfree_obj), GFP_KERNEL);\n\t\t\tif (!alloc_ptr)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t// By default kfree_rcu_test_single and kfree_rcu_test_double are\n\t\t\t// initialized to false. If both have the same value (false or true)\n\t\t\t// both are randomly tested, otherwise only the one with value true\n\t\t\t// is tested.\n\t\t\tif ((kfree_rcu_test_single && !kfree_rcu_test_double) ||\n\t\t\t\t\t(kfree_rcu_test_both && torture_random(&tr) & 0x800))\n\t\t\t\tkfree_rcu(alloc_ptr);\n\t\t\telse\n\t\t\t\tkfree_rcu(alloc_ptr, rh);\n\t\t}\n\n\t\tcond_resched();\n\t} while (!torture_must_stop() && ++loop < kfree_loops);\n\n\tif (atomic_inc_return(&n_kfree_scale_thread_ended) >= kfree_nrealthreads) {\n\t\tend_time = ktime_get_mono_fast_ns();\n\n\t\tif (gp_exp)\n\t\t\tb_rcu_gp_test_finished = cur_ops->exp_completed() / 2;\n\t\telse\n\t\t\tb_rcu_gp_test_finished = cur_ops->get_gp_seq();\n\n\t\tpr_alert(\"Total time taken by all kfree'ers: %llu ns, loops: %d, batches: %ld, memory footprint: %lldMB\\n\",\n\t\t       (unsigned long long)(end_time - start_time), kfree_loops,\n\t\t       rcuscale_seq_diff(b_rcu_gp_test_finished, b_rcu_gp_test_started),\n\t\t       (mem_begin - mem_during) >> (20 - PAGE_SHIFT));\n\n\t\tif (shutdown) {\n\t\t\tsmp_mb(); /* Assign before wake. */\n\t\t\twake_up(&shutdown_wq);\n\t\t}\n\t}\n\n\ttorture_kthread_stopping(\"kfree_scale_thread\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static wait_queue_head_t shutdown_wq;",
      "static unsigned long b_rcu_gp_test_started;",
      "static unsigned long b_rcu_gp_test_finished;",
      "static struct rcu_scale_ops *cur_ops;",
      "static int kfree_nrealthreads;",
      "static atomic_t n_kfree_scale_thread_started;",
      "static atomic_t n_kfree_scale_thread_ended;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"kfree_scale_thread\""
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&shutdown_wq"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"Total time taken by all kfree'ers: %llu ns, loops: %d, batches: %ld, memory footprint: %lldMB\\n\"",
            "(unsigned long long)(end_time - start_time)",
            "kfree_loops",
            "rcuscale_seq_diff(b_rcu_gp_test_finished, b_rcu_gp_test_started)",
            "(mem_begin - mem_during) >> (20 - PAGE_SHIFT)"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcuscale_seq_diff",
          "args": [
            "b_rcu_gp_test_finished",
            "b_rcu_gp_test_started"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "rcuscale_seq_diff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "327-332",
          "snippet": "static unsigned long rcuscale_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_scale_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_scale_ops *cur_ops;\n\nstatic unsigned long rcuscale_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->exp_completed",
          "args": [],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "485-488",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&n_kfree_scale_thread_ended"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "alloc_ptr",
            "rh"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "alloc_ptr"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_monitor",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3366-3425",
          "snippet": "static void kfree_rcu_monitor(struct work_struct *work)\n{\n\tstruct kfree_rcu_cpu *krcp = container_of(work,\n\t\tstruct kfree_rcu_cpu, monitor_work.work);\n\tunsigned long flags;\n\tint i, j;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\n\t// Attempt to start a new batch.\n\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\tstruct kfree_rcu_cpu_work *krwp = &(krcp->krw_arr[i]);\n\n\t\t// Try to detach bkvhead or head and attach it over any\n\t\t// available corresponding free channel. It can be that\n\t\t// a previous RCU batch is in progress, it means that\n\t\t// immediately to queue another one is not possible so\n\t\t// in that case the monitor work is rearmed.\n\t\tif ((krcp->bkvhead[0] && !krwp->bkvhead_free[0]) ||\n\t\t\t(krcp->bkvhead[1] && !krwp->bkvhead_free[1]) ||\n\t\t\t\t(krcp->head && !krwp->head_free)) {\n\t\t\t// Channel 1 corresponds to the SLAB-pointer bulk path.\n\t\t\t// Channel 2 corresponds to vmalloc-pointer bulk path.\n\t\t\tfor (j = 0; j < FREE_N_CHANNELS; j++) {\n\t\t\t\tif (!krwp->bkvhead_free[j]) {\n\t\t\t\t\tkrwp->bkvhead_free[j] = krcp->bkvhead[j];\n\t\t\t\t\tkrcp->bkvhead[j] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Channel 3 corresponds to both SLAB and vmalloc\n\t\t\t// objects queued on the linked list.\n\t\t\tif (!krwp->head_free) {\n\t\t\t\tkrwp->head_free = krcp->head;\n\t\t\t\tkrcp->head = NULL;\n\t\t\t}\n\n\t\t\tWRITE_ONCE(krcp->count, 0);\n\n\t\t\t// One work is per one batch, so there are three\n\t\t\t// \"free channels\", the batch can handle. It can\n\t\t\t// be that the work is in the pending state when\n\t\t\t// channels have been detached following by each\n\t\t\t// other.\n\t\t\tqueue_rcu_work(system_wq, &krwp->rcu_work);\n\t\t}\n\t}\n\n\t// If there is nothing to detach, it means that our job is\n\t// successfully done here. In case of having at least one\n\t// of the channels that is still busy we should rearm the\n\t// work to repeat an attempt. Because previous batches are\n\t// still in progress.\n\tif (!krcp->bkvhead[0] && !krcp->bkvhead[1] && !krcp->head)\n\t\tkrcp->monitor_todo = false;\n\telse\n\t\tschedule_delayed_work(&krcp->monitor_work, KFREE_DRAIN_JIFFIES);\n\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FREE_N_CHANNELS 2",
            "#define KFREE_N_BATCHES 2",
            "#define KFREE_DRAIN_JIFFIES (HZ / 50)"
          ],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FREE_N_CHANNELS 2\n#define KFREE_N_BATCHES 2\n#define KFREE_DRAIN_JIFFIES (HZ / 50)\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void kfree_rcu_monitor(struct work_struct *work)\n{\n\tstruct kfree_rcu_cpu *krcp = container_of(work,\n\t\tstruct kfree_rcu_cpu, monitor_work.work);\n\tunsigned long flags;\n\tint i, j;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\n\t// Attempt to start a new batch.\n\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\tstruct kfree_rcu_cpu_work *krwp = &(krcp->krw_arr[i]);\n\n\t\t// Try to detach bkvhead or head and attach it over any\n\t\t// available corresponding free channel. It can be that\n\t\t// a previous RCU batch is in progress, it means that\n\t\t// immediately to queue another one is not possible so\n\t\t// in that case the monitor work is rearmed.\n\t\tif ((krcp->bkvhead[0] && !krwp->bkvhead_free[0]) ||\n\t\t\t(krcp->bkvhead[1] && !krwp->bkvhead_free[1]) ||\n\t\t\t\t(krcp->head && !krwp->head_free)) {\n\t\t\t// Channel 1 corresponds to the SLAB-pointer bulk path.\n\t\t\t// Channel 2 corresponds to vmalloc-pointer bulk path.\n\t\t\tfor (j = 0; j < FREE_N_CHANNELS; j++) {\n\t\t\t\tif (!krwp->bkvhead_free[j]) {\n\t\t\t\t\tkrwp->bkvhead_free[j] = krcp->bkvhead[j];\n\t\t\t\t\tkrcp->bkvhead[j] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Channel 3 corresponds to both SLAB and vmalloc\n\t\t\t// objects queued on the linked list.\n\t\t\tif (!krwp->head_free) {\n\t\t\t\tkrwp->head_free = krcp->head;\n\t\t\t\tkrcp->head = NULL;\n\t\t\t}\n\n\t\t\tWRITE_ONCE(krcp->count, 0);\n\n\t\t\t// One work is per one batch, so there are three\n\t\t\t// \"free channels\", the batch can handle. It can\n\t\t\t// be that the work is in the pending state when\n\t\t\t// channels have been detached following by each\n\t\t\t// other.\n\t\t\tqueue_rcu_work(system_wq, &krwp->rcu_work);\n\t\t}\n\t}\n\n\t// If there is nothing to detach, it means that our job is\n\t// successfully done here. In case of having at least one\n\t// of the channels that is still busy we should rearm the\n\t// work to repeat an attempt. Because previous batches are\n\t// still in progress.\n\tif (!krcp->bkvhead[0] && !krcp->bkvhead[1] && !krcp->head)\n\t\tkrcp->monitor_todo = false;\n\telse\n\t\tschedule_delayed_work(&krcp->monitor_work, KFREE_DRAIN_JIFFIES);\n\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&tr"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "kfree_mult * sizeof(struct kfree_obj)",
            "GFP_KERNEL"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "si_mem_available",
          "args": [],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "si_mem_available",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->exp_completed",
          "args": [],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&n_kfree_scale_thread_started"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "current",
            "cpumask_of(me % nr_cpu_ids)"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "me % nr_cpu_ids"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCALEOUT_STRING",
          "args": [
            "\"kfree_scale_thread task started\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_TORTURE_RANDOM",
          "args": [
            "tr"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic unsigned long b_rcu_gp_test_started;\nstatic unsigned long b_rcu_gp_test_finished;\nstatic struct rcu_scale_ops *cur_ops;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_started;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_thread(void *arg)\n{\n\tint i, loop = 0;\n\tlong me = (long)arg;\n\tstruct kfree_obj *alloc_ptr;\n\tu64 start_time, end_time;\n\tlong long mem_begin, mem_during = 0;\n\tbool kfree_rcu_test_both;\n\tDEFINE_TORTURE_RANDOM(tr);\n\n\tVERBOSE_SCALEOUT_STRING(\"kfree_scale_thread task started\");\n\tset_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids));\n\tset_user_nice(current, MAX_NICE);\n\tkfree_rcu_test_both = (kfree_rcu_test_single == kfree_rcu_test_double);\n\n\tstart_time = ktime_get_mono_fast_ns();\n\n\tif (atomic_inc_return(&n_kfree_scale_thread_started) >= kfree_nrealthreads) {\n\t\tif (gp_exp)\n\t\t\tb_rcu_gp_test_started = cur_ops->exp_completed() / 2;\n\t\telse\n\t\t\tb_rcu_gp_test_started = cur_ops->get_gp_seq();\n\t}\n\n\tdo {\n\t\tif (!mem_during) {\n\t\t\tmem_during = mem_begin = si_mem_available();\n\t\t} else if (loop % (kfree_loops / 4) == 0) {\n\t\t\tmem_during = (mem_during + si_mem_available()) / 2;\n\t\t}\n\n\t\tfor (i = 0; i < kfree_alloc_num; i++) {\n\t\t\talloc_ptr = kmalloc(kfree_mult * sizeof(struct kfree_obj), GFP_KERNEL);\n\t\t\tif (!alloc_ptr)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t// By default kfree_rcu_test_single and kfree_rcu_test_double are\n\t\t\t// initialized to false. If both have the same value (false or true)\n\t\t\t// both are randomly tested, otherwise only the one with value true\n\t\t\t// is tested.\n\t\t\tif ((kfree_rcu_test_single && !kfree_rcu_test_double) ||\n\t\t\t\t\t(kfree_rcu_test_both && torture_random(&tr) & 0x800))\n\t\t\t\tkfree_rcu(alloc_ptr);\n\t\t\telse\n\t\t\t\tkfree_rcu(alloc_ptr, rh);\n\t\t}\n\n\t\tcond_resched();\n\t} while (!torture_must_stop() && ++loop < kfree_loops);\n\n\tif (atomic_inc_return(&n_kfree_scale_thread_ended) >= kfree_nrealthreads) {\n\t\tend_time = ktime_get_mono_fast_ns();\n\n\t\tif (gp_exp)\n\t\t\tb_rcu_gp_test_finished = cur_ops->exp_completed() / 2;\n\t\telse\n\t\t\tb_rcu_gp_test_finished = cur_ops->get_gp_seq();\n\n\t\tpr_alert(\"Total time taken by all kfree'ers: %llu ns, loops: %d, batches: %ld, memory footprint: %lldMB\\n\",\n\t\t       (unsigned long long)(end_time - start_time), kfree_loops,\n\t\t       rcuscale_seq_diff(b_rcu_gp_test_finished, b_rcu_gp_test_started),\n\t\t       (mem_begin - mem_during) >> (20 - PAGE_SHIFT));\n\n\t\tif (shutdown) {\n\t\t\tsmp_mb(); /* Assign before wake. */\n\t\t\twake_up(&shutdown_wq);\n\t\t}\n\t}\n\n\ttorture_kthread_stopping(\"kfree_scale_thread\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_scale_shutdown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "609-618",
    "snippet": "static int\nrcu_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_rcu_scale_writer_finished) >= nrealwriters);\n\tsmp_mb(); /* Wake before output. */\n\trcu_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nrealwriters;",
      "static atomic_t n_rcu_scale_writer_finished;",
      "static wait_queue_head_t shutdown_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "289-299",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_scale_cleanup",
          "args": [],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_scale_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "503-584",
          "snippet": "static void\nrcu_scale_cleanup(void)\n{\n\tint i;\n\tint j;\n\tint ngps = 0;\n\tu64 *wdp;\n\tu64 *wdpp;\n\n\t/*\n\t * Would like warning at start, but everything is expedited\n\t * during the mid-boot phase, so have to wait till the end.\n\t */\n\tif (rcu_gp_is_expedited() && !rcu_gp_is_normal() && !gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods expedited, no normal ones to measure!\");\n\tif (rcu_gp_is_normal() && gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods normal, no expedited ones to measure!\");\n\tif (gp_exp && gp_async)\n\t\tSCALEOUT_ERRSTRING(\"No expedited async GPs, so went with async!\");\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_scale_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_scale_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\tj = writer_n_durations[i];\n\t\t\tpr_alert(\"%s%s writer %d gps: %d\\n\",\n\t\t\t\t scale_type, SCALE_FLAG, i, j);\n\t\t\tngps += j;\n\t\t}\n\t\tpr_alert(\"%s%s start: %llu end: %llu duration: %llu gps: %d batches: %ld\\n\",\n\t\t\t scale_type, SCALE_FLAG,\n\t\t\t t_rcu_scale_writer_started, t_rcu_scale_writer_finished,\n\t\t\t t_rcu_scale_writer_finished -\n\t\t\t t_rcu_scale_writer_started,\n\t\t\t ngps,\n\t\t\t rcuscale_seq_diff(b_rcu_gp_test_finished,\n\t\t\t\t\t   b_rcu_gp_test_started));\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\tif (!writer_durations)\n\t\t\t\tbreak;\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\twdpp = writer_durations[i];\n\t\t\tif (!wdpp)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < writer_n_durations[i]; j++) {\n\t\t\t\twdp = &wdpp[j];\n\t\t\t\tpr_alert(\"%s%s %4d writer-duration: %5d %llu\\n\",\n\t\t\t\t\tscale_type, SCALE_FLAG,\n\t\t\t\t\ti, j, *wdp);\n\t\t\t\tif (j % 100 == 0)\n\t\t\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\t}\n\t\t\tkfree(writer_durations[i]);\n\t\t}\n\t\tkfree(writer_tasks);\n\t\tkfree(writer_durations);\n\t\tkfree(writer_n_durations);\n\t}\n\n\t/* Do torture-type-specific cleanup operations.  */\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define SCALE_FLAG \"-scale:\""
          ],
          "globals_used": [
            "static char *scale_type = \"rcu\";",
            "static int nrealreaders;",
            "static int nrealwriters;",
            "static struct task_struct **writer_tasks;",
            "static struct task_struct **reader_tasks;",
            "static u64 **writer_durations;",
            "static int *writer_n_durations;",
            "static u64 t_rcu_scale_writer_started;",
            "static u64 t_rcu_scale_writer_finished;",
            "static unsigned long b_rcu_gp_test_started;",
            "static unsigned long b_rcu_gp_test_finished;",
            "static struct rcu_scale_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define SCALE_FLAG \"-scale:\"\n\nstatic char *scale_type = \"rcu\";\nstatic int nrealreaders;\nstatic int nrealwriters;\nstatic struct task_struct **writer_tasks;\nstatic struct task_struct **reader_tasks;\nstatic u64 **writer_durations;\nstatic int *writer_n_durations;\nstatic u64 t_rcu_scale_writer_started;\nstatic u64 t_rcu_scale_writer_finished;\nstatic unsigned long b_rcu_gp_test_started;\nstatic unsigned long b_rcu_gp_test_finished;\nstatic struct rcu_scale_ops *cur_ops;\n\nstatic void\nrcu_scale_cleanup(void)\n{\n\tint i;\n\tint j;\n\tint ngps = 0;\n\tu64 *wdp;\n\tu64 *wdpp;\n\n\t/*\n\t * Would like warning at start, but everything is expedited\n\t * during the mid-boot phase, so have to wait till the end.\n\t */\n\tif (rcu_gp_is_expedited() && !rcu_gp_is_normal() && !gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods expedited, no normal ones to measure!\");\n\tif (rcu_gp_is_normal() && gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods normal, no expedited ones to measure!\");\n\tif (gp_exp && gp_async)\n\t\tSCALEOUT_ERRSTRING(\"No expedited async GPs, so went with async!\");\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_scale_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_scale_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\tj = writer_n_durations[i];\n\t\t\tpr_alert(\"%s%s writer %d gps: %d\\n\",\n\t\t\t\t scale_type, SCALE_FLAG, i, j);\n\t\t\tngps += j;\n\t\t}\n\t\tpr_alert(\"%s%s start: %llu end: %llu duration: %llu gps: %d batches: %ld\\n\",\n\t\t\t scale_type, SCALE_FLAG,\n\t\t\t t_rcu_scale_writer_started, t_rcu_scale_writer_finished,\n\t\t\t t_rcu_scale_writer_finished -\n\t\t\t t_rcu_scale_writer_started,\n\t\t\t ngps,\n\t\t\t rcuscale_seq_diff(b_rcu_gp_test_finished,\n\t\t\t\t\t   b_rcu_gp_test_started));\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\tif (!writer_durations)\n\t\t\t\tbreak;\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\twdpp = writer_durations[i];\n\t\t\tif (!wdpp)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < writer_n_durations[i]; j++) {\n\t\t\t\twdp = &wdpp[j];\n\t\t\t\tpr_alert(\"%s%s %4d writer-duration: %5d %llu\\n\",\n\t\t\t\t\tscale_type, SCALE_FLAG,\n\t\t\t\t\ti, j, *wdp);\n\t\t\t\tif (j % 100 == 0)\n\t\t\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\t}\n\t\t\tkfree(writer_durations[i]);\n\t\t}\n\t\tkfree(writer_tasks);\n\t\tkfree(writer_durations);\n\t\tkfree(writer_n_durations);\n\t}\n\n\t/* Do torture-type-specific cleanup operations.  */\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "shutdown_wq",
            "atomic_read(&n_rcu_scale_writer_finished) >= nrealwriters"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_scale_writer_finished"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealwriters;\nstatic atomic_t n_rcu_scale_writer_finished;\nstatic wait_queue_head_t shutdown_wq;\n\nstatic int\nrcu_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_rcu_scale_writer_finished) >= nrealwriters);\n\tsmp_mb(); /* Wake before output. */\n\trcu_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "compute_real",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "591-603",
    "snippet": "static int compute_real(int n)\n{\n\tint nr;\n\n\tif (n >= 0) {\n\t\tnr = n;\n\t} else {\n\t\tnr = num_online_cpus() + 1 + n;\n\t\tif (nr <= 0)\n\t\t\tnr = 1;\n\t}\n\treturn nr;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int compute_real(int n)\n{\n\tint nr;\n\n\tif (n >= 0) {\n\t\tnr = n;\n\t} else {\n\t\tnr = num_online_cpus() + 1 + n;\n\t\tif (nr <= 0)\n\t\t\tnr = 1;\n\t}\n\treturn nr;\n}"
  },
  {
    "function_name": "rcu_scale_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "503-584",
    "snippet": "static void\nrcu_scale_cleanup(void)\n{\n\tint i;\n\tint j;\n\tint ngps = 0;\n\tu64 *wdp;\n\tu64 *wdpp;\n\n\t/*\n\t * Would like warning at start, but everything is expedited\n\t * during the mid-boot phase, so have to wait till the end.\n\t */\n\tif (rcu_gp_is_expedited() && !rcu_gp_is_normal() && !gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods expedited, no normal ones to measure!\");\n\tif (rcu_gp_is_normal() && gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods normal, no expedited ones to measure!\");\n\tif (gp_exp && gp_async)\n\t\tSCALEOUT_ERRSTRING(\"No expedited async GPs, so went with async!\");\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_scale_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_scale_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\tj = writer_n_durations[i];\n\t\t\tpr_alert(\"%s%s writer %d gps: %d\\n\",\n\t\t\t\t scale_type, SCALE_FLAG, i, j);\n\t\t\tngps += j;\n\t\t}\n\t\tpr_alert(\"%s%s start: %llu end: %llu duration: %llu gps: %d batches: %ld\\n\",\n\t\t\t scale_type, SCALE_FLAG,\n\t\t\t t_rcu_scale_writer_started, t_rcu_scale_writer_finished,\n\t\t\t t_rcu_scale_writer_finished -\n\t\t\t t_rcu_scale_writer_started,\n\t\t\t ngps,\n\t\t\t rcuscale_seq_diff(b_rcu_gp_test_finished,\n\t\t\t\t\t   b_rcu_gp_test_started));\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\tif (!writer_durations)\n\t\t\t\tbreak;\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\twdpp = writer_durations[i];\n\t\t\tif (!wdpp)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < writer_n_durations[i]; j++) {\n\t\t\t\twdp = &wdpp[j];\n\t\t\t\tpr_alert(\"%s%s %4d writer-duration: %5d %llu\\n\",\n\t\t\t\t\tscale_type, SCALE_FLAG,\n\t\t\t\t\ti, j, *wdp);\n\t\t\t\tif (j % 100 == 0)\n\t\t\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\t}\n\t\t\tkfree(writer_durations[i]);\n\t\t}\n\t\tkfree(writer_tasks);\n\t\tkfree(writer_durations);\n\t\tkfree(writer_n_durations);\n\t}\n\n\t/* Do torture-type-specific cleanup operations.  */\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define SCALE_FLAG \"-scale:\""
    ],
    "globals_used": [
      "static char *scale_type = \"rcu\";",
      "static int nrealreaders;",
      "static int nrealwriters;",
      "static struct task_struct **writer_tasks;",
      "static struct task_struct **reader_tasks;",
      "static u64 **writer_durations;",
      "static int *writer_n_durations;",
      "static u64 t_rcu_scale_writer_started;",
      "static u64 t_rcu_scale_writer_finished;",
      "static unsigned long b_rcu_gp_test_started;",
      "static unsigned long b_rcu_gp_test_finished;",
      "static struct rcu_scale_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_cleanup_end",
          "args": [],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "876-881",
          "snippet": "void torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nvoid torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->cleanup",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "writer_n_durations"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s %4d writer-duration: %5d %llu\\n\"",
            "scale_type",
            "SCALE_FLAG",
            "i",
            "j",
            "*wdp"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s start: %llu end: %llu duration: %llu gps: %d batches: %ld\\n\"",
            "scale_type",
            "SCALE_FLAG",
            "t_rcu_scale_writer_started",
            "t_rcu_scale_writer_finished",
            "t_rcu_scale_writer_finished -\n\t\t\t t_rcu_scale_writer_started",
            "ngps",
            "rcuscale_seq_diff(b_rcu_gp_test_finished,\n\t\t\t\t\t   b_rcu_gp_test_started)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcuscale_seq_diff",
          "args": [
            "b_rcu_gp_test_finished",
            "b_rcu_gp_test_started"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "rcuscale_seq_diff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "327-332",
          "snippet": "static unsigned long rcuscale_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_scale_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_scale_ops *cur_ops;\n\nstatic unsigned long rcuscale_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s writer %d gps: %d\\n\"",
            "scale_type",
            "SCALE_FLAG",
            "i",
            "j"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "rcu_scale_writer",
            "writer_tasks[i]"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "948-955",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_cleanup_begin",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "857-873",
          "snippet": "bool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */",
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCALEOUT_ERRSTRING",
          "args": [
            "\"No expedited async GPs, so went with async!\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCALEOUT_ERRSTRING",
          "args": [
            "\"All grace periods normal, no expedited ones to measure!\""
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_normal",
          "args": [],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "140-144",
          "snippet": "bool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCALEOUT_ERRSTRING",
          "args": [
            "\"All grace periods expedited, no normal ones to measure!\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_expedited",
          "args": [],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "156-159",
          "snippet": "bool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define SCALE_FLAG \"-scale:\"\n\nstatic char *scale_type = \"rcu\";\nstatic int nrealreaders;\nstatic int nrealwriters;\nstatic struct task_struct **writer_tasks;\nstatic struct task_struct **reader_tasks;\nstatic u64 **writer_durations;\nstatic int *writer_n_durations;\nstatic u64 t_rcu_scale_writer_started;\nstatic u64 t_rcu_scale_writer_finished;\nstatic unsigned long b_rcu_gp_test_started;\nstatic unsigned long b_rcu_gp_test_finished;\nstatic struct rcu_scale_ops *cur_ops;\n\nstatic void\nrcu_scale_cleanup(void)\n{\n\tint i;\n\tint j;\n\tint ngps = 0;\n\tu64 *wdp;\n\tu64 *wdpp;\n\n\t/*\n\t * Would like warning at start, but everything is expedited\n\t * during the mid-boot phase, so have to wait till the end.\n\t */\n\tif (rcu_gp_is_expedited() && !rcu_gp_is_normal() && !gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods expedited, no normal ones to measure!\");\n\tif (rcu_gp_is_normal() && gp_exp)\n\t\tSCALEOUT_ERRSTRING(\"All grace periods normal, no expedited ones to measure!\");\n\tif (gp_exp && gp_async)\n\t\tSCALEOUT_ERRSTRING(\"No expedited async GPs, so went with async!\");\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_scale_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_scale_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\tj = writer_n_durations[i];\n\t\t\tpr_alert(\"%s%s writer %d gps: %d\\n\",\n\t\t\t\t scale_type, SCALE_FLAG, i, j);\n\t\t\tngps += j;\n\t\t}\n\t\tpr_alert(\"%s%s start: %llu end: %llu duration: %llu gps: %d batches: %ld\\n\",\n\t\t\t scale_type, SCALE_FLAG,\n\t\t\t t_rcu_scale_writer_started, t_rcu_scale_writer_finished,\n\t\t\t t_rcu_scale_writer_finished -\n\t\t\t t_rcu_scale_writer_started,\n\t\t\t ngps,\n\t\t\t rcuscale_seq_diff(b_rcu_gp_test_finished,\n\t\t\t\t\t   b_rcu_gp_test_started));\n\t\tfor (i = 0; i < nrealwriters; i++) {\n\t\t\tif (!writer_durations)\n\t\t\t\tbreak;\n\t\t\tif (!writer_n_durations)\n\t\t\t\tcontinue;\n\t\t\twdpp = writer_durations[i];\n\t\t\tif (!wdpp)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < writer_n_durations[i]; j++) {\n\t\t\t\twdp = &wdpp[j];\n\t\t\t\tpr_alert(\"%s%s %4d writer-duration: %5d %llu\\n\",\n\t\t\t\t\tscale_type, SCALE_FLAG,\n\t\t\t\t\ti, j, *wdp);\n\t\t\t\tif (j % 100 == 0)\n\t\t\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\t}\n\t\t\tkfree(writer_durations[i]);\n\t\t}\n\t\tkfree(writer_tasks);\n\t\tkfree(writer_durations);\n\t\tkfree(writer_n_durations);\n\t}\n\n\t/* Do torture-type-specific cleanup operations.  */\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}"
  },
  {
    "function_name": "rcu_scale_print_module_parms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "495-501",
    "snippet": "static void\nrcu_scale_print_module_parms(struct rcu_scale_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" SCALE_FLAG\n\t\t \"--- %s: nreaders=%d nwriters=%d verbose=%d shutdown=%d\\n\",\n\t\t scale_type, tag, nrealreaders, nrealwriters, verbose, shutdown);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define SCALE_FLAG \"-scale:\""
    ],
    "globals_used": [
      "static char *scale_type = \"rcu\";",
      "static int nrealreaders;",
      "static int nrealwriters;",
      "static struct rcu_scale_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" SCALE_FLAG\n\t\t \"--- %s: nreaders=%d nwriters=%d verbose=%d shutdown=%d\\n\"",
            "scale_type",
            "tag",
            "nrealreaders",
            "nrealwriters",
            "verbose",
            "shutdown"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define SCALE_FLAG \"-scale:\"\n\nstatic char *scale_type = \"rcu\";\nstatic int nrealreaders;\nstatic int nrealwriters;\nstatic struct rcu_scale_ops *cur_ops;\n\nstatic void\nrcu_scale_print_module_parms(struct rcu_scale_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" SCALE_FLAG\n\t\t \"--- %s: nreaders=%d nwriters=%d verbose=%d shutdown=%d\\n\",\n\t\t scale_type, tag, nrealreaders, nrealwriters, verbose, shutdown);\n}"
  },
  {
    "function_name": "rcu_scale_writer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "387-493",
    "snippet": "static int\nrcu_scale_writer(void *arg)\n{\n\tint i = 0;\n\tint i_max;\n\tlong me = (long)arg;\n\tstruct rcu_head *rhp = NULL;\n\tbool started = false, done = false, alldone = false;\n\tu64 t;\n\tu64 *wdp;\n\tu64 *wdpp = writer_durations[me];\n\n\tVERBOSE_SCALEOUT_STRING(\"rcu_scale_writer task started\");\n\tWARN_ON(!wdpp);\n\tset_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids));\n\tsched_set_fifo_low(current);\n\n\tif (holdoff)\n\t\tschedule_timeout_uninterruptible(holdoff * HZ);\n\n\t/*\n\t * Wait until rcu_end_inkernel_boot() is called for normal GP tests\n\t * so that RCU is not always expedited for normal GP tests.\n\t * The system_state test is approximate, but works well in practice.\n\t */\n\twhile (!gp_exp && system_state != SYSTEM_RUNNING)\n\t\tschedule_timeout_uninterruptible(1);\n\n\tt = ktime_get_mono_fast_ns();\n\tif (atomic_inc_return(&n_rcu_scale_writer_started) >= nrealwriters) {\n\t\tt_rcu_scale_writer_started = t;\n\t\tif (gp_exp) {\n\t\t\tb_rcu_gp_test_started =\n\t\t\t\tcur_ops->exp_completed() / 2;\n\t\t} else {\n\t\t\tb_rcu_gp_test_started = cur_ops->get_gp_seq();\n\t\t}\n\t}\n\n\tdo {\n\t\tif (writer_holdoff)\n\t\t\tudelay(writer_holdoff);\n\t\twdp = &wdpp[i];\n\t\t*wdp = ktime_get_mono_fast_ns();\n\t\tif (gp_async) {\nretry:\n\t\t\tif (!rhp)\n\t\t\t\trhp = kmalloc(sizeof(*rhp), GFP_KERNEL);\n\t\t\tif (rhp && atomic_read(this_cpu_ptr(&n_async_inflight)) < gp_async_max) {\n\t\t\t\tatomic_inc(this_cpu_ptr(&n_async_inflight));\n\t\t\t\tcur_ops->async(rhp, rcu_scale_async_cb);\n\t\t\t\trhp = NULL;\n\t\t\t} else if (!kthread_should_stop()) {\n\t\t\t\tcur_ops->gp_barrier();\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\tkfree(rhp); /* Because we are stopping. */\n\t\t\t}\n\t\t} else if (gp_exp) {\n\t\t\tcur_ops->exp_sync();\n\t\t} else {\n\t\t\tcur_ops->sync();\n\t\t}\n\t\tt = ktime_get_mono_fast_ns();\n\t\t*wdp = t - *wdp;\n\t\ti_max = i;\n\t\tif (!started &&\n\t\t    atomic_read(&n_rcu_scale_writer_started) >= nrealwriters)\n\t\t\tstarted = true;\n\t\tif (!done && i >= MIN_MEAS) {\n\t\t\tdone = true;\n\t\t\tsched_set_normal(current, 0);\n\t\t\tpr_alert(\"%s%s rcu_scale_writer %ld has %d measurements\\n\",\n\t\t\t\t scale_type, SCALE_FLAG, me, MIN_MEAS);\n\t\t\tif (atomic_inc_return(&n_rcu_scale_writer_finished) >=\n\t\t\t    nrealwriters) {\n\t\t\t\tschedule_timeout_interruptible(10);\n\t\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\t\t\tSCALEOUT_STRING(\"Test complete\");\n\t\t\t\tt_rcu_scale_writer_finished = t;\n\t\t\t\tif (gp_exp) {\n\t\t\t\t\tb_rcu_gp_test_finished =\n\t\t\t\t\t\tcur_ops->exp_completed() / 2;\n\t\t\t\t} else {\n\t\t\t\t\tb_rcu_gp_test_finished =\n\t\t\t\t\t\tcur_ops->get_gp_seq();\n\t\t\t\t}\n\t\t\t\tif (shutdown) {\n\t\t\t\t\tsmp_mb(); /* Assign before wake. */\n\t\t\t\t\twake_up(&shutdown_wq);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (done && !alldone &&\n\t\t    atomic_read(&n_rcu_scale_writer_finished) >= nrealwriters)\n\t\t\talldone = true;\n\t\tif (started && !alldone && i < MAX_MEAS - 1)\n\t\t\ti++;\n\t\trcu_scale_wait_shutdown();\n\t} while (!torture_must_stop());\n\tif (gp_async) {\n\t\tcur_ops->gp_barrier();\n\t}\n\twriter_n_durations[me] = i_max + 1;\n\ttorture_kthread_stopping(\"rcu_scale_writer\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MIN_MEAS 100",
      "#define MAX_MEAS 10000",
      "#define SCALE_FLAG \"-scale:\""
    ],
    "globals_used": [
      "static char *scale_type = \"rcu\";",
      "static int nrealwriters;",
      "static u64 **writer_durations;",
      "static int *writer_n_durations;",
      "static atomic_t n_rcu_scale_writer_started;",
      "static atomic_t n_rcu_scale_writer_finished;",
      "static wait_queue_head_t shutdown_wq;",
      "static u64 t_rcu_scale_writer_started;",
      "static u64 t_rcu_scale_writer_finished;",
      "static unsigned long b_rcu_gp_test_started;",
      "static unsigned long b_rcu_gp_test_finished;",
      "static DEFINE_PER_CPU(atomic_t, n_async_inflight);",
      "static struct rcu_scale_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_scale_writer\""
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->gp_barrier",
          "args": [],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_scale_wait_shutdown",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_scale_wait_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "337-344",
          "snippet": "static void rcu_scale_wait_shutdown(void)\n{\n\tcond_resched_tasks_rcu_qs();\n\tif (atomic_read(&n_rcu_scale_writer_finished) < nrealwriters)\n\t\treturn;\n\twhile (!torture_must_stop())\n\t\tschedule_timeout_uninterruptible(1);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nrealwriters;",
            "static atomic_t n_rcu_scale_writer_finished;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealwriters;\nstatic atomic_t n_rcu_scale_writer_finished;\n\nstatic void rcu_scale_wait_shutdown(void)\n{\n\tcond_resched_tasks_rcu_qs();\n\tif (atomic_read(&n_rcu_scale_writer_finished) < nrealwriters)\n\t\treturn;\n\twhile (!torture_must_stop())\n\t\tschedule_timeout_uninterruptible(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_scale_writer_finished"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&shutdown_wq"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->exp_completed",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCALEOUT_STRING",
          "args": [
            "\"Test complete\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "10"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&n_rcu_scale_writer_finished"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s rcu_scale_writer %ld has %d measurements\\n\"",
            "scale_type",
            "SCALE_FLAG",
            "me",
            "MIN_MEAS"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_set_normal",
          "args": [
            "current",
            "0"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7606-7613",
          "snippet": "void sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_scale_writer_started"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "485-488",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->sync",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->exp_sync",
          "args": [],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rhp"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->gp_barrier",
          "args": [],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->async",
          "args": [
            "rhp",
            "rcu_scale_async_cb"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "this_cpu_ptr(&n_async_inflight)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&n_async_inflight"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "this_cpu_ptr(&n_async_inflight)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&n_async_inflight"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*rhp)",
            "GFP_KERNEL"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "writer_holdoff"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->exp_completed",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&n_rcu_scale_writer_started"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_set_fifo_low",
          "args": [
            "current"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_fifo_low",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7599-7603",
          "snippet": "void sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "current",
            "cpumask_of(me % nr_cpu_ids)"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "me % nr_cpu_ids"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!wdpp"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCALEOUT_STRING",
          "args": [
            "\"rcu_scale_writer task started\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define MIN_MEAS 100\n#define MAX_MEAS 10000\n#define SCALE_FLAG \"-scale:\"\n\nstatic char *scale_type = \"rcu\";\nstatic int nrealwriters;\nstatic u64 **writer_durations;\nstatic int *writer_n_durations;\nstatic atomic_t n_rcu_scale_writer_started;\nstatic atomic_t n_rcu_scale_writer_finished;\nstatic wait_queue_head_t shutdown_wq;\nstatic u64 t_rcu_scale_writer_started;\nstatic u64 t_rcu_scale_writer_finished;\nstatic unsigned long b_rcu_gp_test_started;\nstatic unsigned long b_rcu_gp_test_finished;\nstatic DEFINE_PER_CPU(atomic_t, n_async_inflight);\nstatic struct rcu_scale_ops *cur_ops;\n\nstatic int\nrcu_scale_writer(void *arg)\n{\n\tint i = 0;\n\tint i_max;\n\tlong me = (long)arg;\n\tstruct rcu_head *rhp = NULL;\n\tbool started = false, done = false, alldone = false;\n\tu64 t;\n\tu64 *wdp;\n\tu64 *wdpp = writer_durations[me];\n\n\tVERBOSE_SCALEOUT_STRING(\"rcu_scale_writer task started\");\n\tWARN_ON(!wdpp);\n\tset_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids));\n\tsched_set_fifo_low(current);\n\n\tif (holdoff)\n\t\tschedule_timeout_uninterruptible(holdoff * HZ);\n\n\t/*\n\t * Wait until rcu_end_inkernel_boot() is called for normal GP tests\n\t * so that RCU is not always expedited for normal GP tests.\n\t * The system_state test is approximate, but works well in practice.\n\t */\n\twhile (!gp_exp && system_state != SYSTEM_RUNNING)\n\t\tschedule_timeout_uninterruptible(1);\n\n\tt = ktime_get_mono_fast_ns();\n\tif (atomic_inc_return(&n_rcu_scale_writer_started) >= nrealwriters) {\n\t\tt_rcu_scale_writer_started = t;\n\t\tif (gp_exp) {\n\t\t\tb_rcu_gp_test_started =\n\t\t\t\tcur_ops->exp_completed() / 2;\n\t\t} else {\n\t\t\tb_rcu_gp_test_started = cur_ops->get_gp_seq();\n\t\t}\n\t}\n\n\tdo {\n\t\tif (writer_holdoff)\n\t\t\tudelay(writer_holdoff);\n\t\twdp = &wdpp[i];\n\t\t*wdp = ktime_get_mono_fast_ns();\n\t\tif (gp_async) {\nretry:\n\t\t\tif (!rhp)\n\t\t\t\trhp = kmalloc(sizeof(*rhp), GFP_KERNEL);\n\t\t\tif (rhp && atomic_read(this_cpu_ptr(&n_async_inflight)) < gp_async_max) {\n\t\t\t\tatomic_inc(this_cpu_ptr(&n_async_inflight));\n\t\t\t\tcur_ops->async(rhp, rcu_scale_async_cb);\n\t\t\t\trhp = NULL;\n\t\t\t} else if (!kthread_should_stop()) {\n\t\t\t\tcur_ops->gp_barrier();\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\tkfree(rhp); /* Because we are stopping. */\n\t\t\t}\n\t\t} else if (gp_exp) {\n\t\t\tcur_ops->exp_sync();\n\t\t} else {\n\t\t\tcur_ops->sync();\n\t\t}\n\t\tt = ktime_get_mono_fast_ns();\n\t\t*wdp = t - *wdp;\n\t\ti_max = i;\n\t\tif (!started &&\n\t\t    atomic_read(&n_rcu_scale_writer_started) >= nrealwriters)\n\t\t\tstarted = true;\n\t\tif (!done && i >= MIN_MEAS) {\n\t\t\tdone = true;\n\t\t\tsched_set_normal(current, 0);\n\t\t\tpr_alert(\"%s%s rcu_scale_writer %ld has %d measurements\\n\",\n\t\t\t\t scale_type, SCALE_FLAG, me, MIN_MEAS);\n\t\t\tif (atomic_inc_return(&n_rcu_scale_writer_finished) >=\n\t\t\t    nrealwriters) {\n\t\t\t\tschedule_timeout_interruptible(10);\n\t\t\t\trcu_ftrace_dump(DUMP_ALL);\n\t\t\t\tSCALEOUT_STRING(\"Test complete\");\n\t\t\t\tt_rcu_scale_writer_finished = t;\n\t\t\t\tif (gp_exp) {\n\t\t\t\t\tb_rcu_gp_test_finished =\n\t\t\t\t\t\tcur_ops->exp_completed() / 2;\n\t\t\t\t} else {\n\t\t\t\t\tb_rcu_gp_test_finished =\n\t\t\t\t\t\tcur_ops->get_gp_seq();\n\t\t\t\t}\n\t\t\t\tif (shutdown) {\n\t\t\t\t\tsmp_mb(); /* Assign before wake. */\n\t\t\t\t\twake_up(&shutdown_wq);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (done && !alldone &&\n\t\t    atomic_read(&n_rcu_scale_writer_finished) >= nrealwriters)\n\t\t\talldone = true;\n\t\tif (started && !alldone && i < MAX_MEAS - 1)\n\t\t\ti++;\n\t\trcu_scale_wait_shutdown();\n\t} while (!torture_must_stop());\n\tif (gp_async) {\n\t\tcur_ops->gp_barrier();\n\t}\n\twriter_n_durations[me] = i_max + 1;\n\ttorture_kthread_stopping(\"rcu_scale_writer\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_scale_async_cb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "378-382",
    "snippet": "static void rcu_scale_async_cb(struct rcu_head *rhp)\n{\n\tatomic_dec(this_cpu_ptr(&n_async_inflight));\n\tkfree(rhp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(atomic_t, n_async_inflight);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rhp"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "this_cpu_ptr(&n_async_inflight)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&n_async_inflight"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(atomic_t, n_async_inflight);\n\nstatic void rcu_scale_async_cb(struct rcu_head *rhp)\n{\n\tatomic_dec(this_cpu_ptr(&n_async_inflight));\n\tkfree(rhp);\n}"
  },
  {
    "function_name": "rcu_scale_reader",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "352-373",
    "snippet": "static int\nrcu_scale_reader(void *arg)\n{\n\tunsigned long flags;\n\tint idx;\n\tlong me = (long)arg;\n\n\tVERBOSE_SCALEOUT_STRING(\"rcu_scale_reader task started\");\n\tset_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids));\n\tset_user_nice(current, MAX_NICE);\n\tatomic_inc(&n_rcu_scale_reader_started);\n\n\tdo {\n\t\tlocal_irq_save(flags);\n\t\tidx = cur_ops->readlock();\n\t\tcur_ops->readunlock(idx);\n\t\tlocal_irq_restore(flags);\n\t\trcu_scale_wait_shutdown();\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_scale_reader\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t n_rcu_scale_reader_started;",
      "static struct rcu_scale_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_scale_reader\""
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_scale_wait_shutdown",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_scale_wait_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "337-344",
          "snippet": "static void rcu_scale_wait_shutdown(void)\n{\n\tcond_resched_tasks_rcu_qs();\n\tif (atomic_read(&n_rcu_scale_writer_finished) < nrealwriters)\n\t\treturn;\n\twhile (!torture_must_stop())\n\t\tschedule_timeout_uninterruptible(1);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nrealwriters;",
            "static atomic_t n_rcu_scale_writer_finished;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealwriters;\nstatic atomic_t n_rcu_scale_writer_finished;\n\nstatic void rcu_scale_wait_shutdown(void)\n{\n\tcond_resched_tasks_rcu_qs();\n\tif (atomic_read(&n_rcu_scale_writer_finished) < nrealwriters)\n\t\treturn;\n\twhile (!torture_must_stop())\n\t\tschedule_timeout_uninterruptible(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readunlock",
          "args": [
            "idx"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readlock",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_scale_reader_started"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "current",
            "cpumask_of(me % nr_cpu_ids)"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "me % nr_cpu_ids"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCALEOUT_STRING",
          "args": [
            "\"rcu_scale_reader task started\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t n_rcu_scale_reader_started;\nstatic struct rcu_scale_ops *cur_ops;\n\nstatic int\nrcu_scale_reader(void *arg)\n{\n\tunsigned long flags;\n\tint idx;\n\tlong me = (long)arg;\n\n\tVERBOSE_SCALEOUT_STRING(\"rcu_scale_reader task started\");\n\tset_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids));\n\tset_user_nice(current, MAX_NICE);\n\tatomic_inc(&n_rcu_scale_reader_started);\n\n\tdo {\n\t\tlocal_irq_save(flags);\n\t\tidx = cur_ops->readlock();\n\t\tcur_ops->readunlock(idx);\n\t\tlocal_irq_restore(flags);\n\t\trcu_scale_wait_shutdown();\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_scale_reader\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_scale_wait_shutdown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "337-344",
    "snippet": "static void rcu_scale_wait_shutdown(void)\n{\n\tcond_resched_tasks_rcu_qs();\n\tif (atomic_read(&n_rcu_scale_writer_finished) < nrealwriters)\n\t\treturn;\n\twhile (!torture_must_stop())\n\t\tschedule_timeout_uninterruptible(1);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nrealwriters;",
      "static atomic_t n_rcu_scale_writer_finished;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_scale_writer_finished"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealwriters;\nstatic atomic_t n_rcu_scale_writer_finished;\n\nstatic void rcu_scale_wait_shutdown(void)\n{\n\tcond_resched_tasks_rcu_qs();\n\tif (atomic_read(&n_rcu_scale_writer_finished) < nrealwriters)\n\t\treturn;\n\twhile (!torture_must_stop())\n\t\tschedule_timeout_uninterruptible(1);\n}"
  },
  {
    "function_name": "rcuscale_seq_diff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "327-332",
    "snippet": "static unsigned long rcuscale_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_scale_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->gp_diff",
          "args": [
            "new",
            "old"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_scale_ops *cur_ops;\n\nstatic unsigned long rcuscale_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
  },
  {
    "function_name": "tasks_trace_scale_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "308-311",
    "snippet": "static void tasks_trace_scale_read_unlock(int idx)\n{\n\trcu_read_unlock_trace();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_trace",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_trace_scale_read_unlock(int idx)\n{\n\trcu_read_unlock_trace();\n}"
  },
  {
    "function_name": "tasks_trace_scale_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "302-306",
    "snippet": "static int tasks_trace_scale_read_lock(void)\n{\n\trcu_read_lock_trace();\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_lock_trace",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int tasks_trace_scale_read_lock(void)\n{\n\trcu_read_lock_trace();\n\treturn 0;\n}"
  },
  {
    "function_name": "tasks_scale_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "280-282",
    "snippet": "static void tasks_scale_read_unlock(int idx)\n{\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_scale_read_unlock(int idx)\n{\n}"
  },
  {
    "function_name": "tasks_scale_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "275-278",
    "snippet": "static int tasks_scale_read_lock(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int tasks_scale_read_lock(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "srcu_sync_scale_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "250-253",
    "snippet": "static void srcu_sync_scale_cleanup(void)\n{\n\tcleanup_srcu_struct(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_srcu_struct",
          "args": [
            "srcu_ctlp"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_srcu_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "367-392",
          "snippet": "void cleanup_srcu_struct(struct srcu_struct *ssp)\n{\n\tint cpu;\n\n\tif (WARN_ON(!srcu_get_delay(ssp)))\n\t\treturn; /* Just leak it! */\n\tif (WARN_ON(srcu_readers_active(ssp)))\n\t\treturn; /* Just leak it! */\n\tflush_delayed_work(&ssp->work);\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *sdp = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tdel_timer_sync(&sdp->delay_work);\n\t\tflush_work(&sdp->work);\n\t\tif (WARN_ON(rcu_segcblist_n_cbs(&sdp->srcu_cblist)))\n\t\t\treturn; /* Forgot srcu_barrier(), so just leak it! */\n\t}\n\tif (WARN_ON(rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) != SRCU_STATE_IDLE) ||\n\t    WARN_ON(srcu_readers_active(ssp))) {\n\t\tpr_info(\"%s: Active srcu_struct %p state: %d\\n\",\n\t\t\t__func__, ssp, rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)));\n\t\treturn; /* Caller forgot to stop doing call_srcu()? */\n\t}\n\tfree_percpu(ssp->sda);\n\tssp->sda = NULL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid cleanup_srcu_struct(struct srcu_struct *ssp)\n{\n\tint cpu;\n\n\tif (WARN_ON(!srcu_get_delay(ssp)))\n\t\treturn; /* Just leak it! */\n\tif (WARN_ON(srcu_readers_active(ssp)))\n\t\treturn; /* Just leak it! */\n\tflush_delayed_work(&ssp->work);\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *sdp = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tdel_timer_sync(&sdp->delay_work);\n\t\tflush_work(&sdp->work);\n\t\tif (WARN_ON(rcu_segcblist_n_cbs(&sdp->srcu_cblist)))\n\t\t\treturn; /* Forgot srcu_barrier(), so just leak it! */\n\t}\n\tif (WARN_ON(rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) != SRCU_STATE_IDLE) ||\n\t    WARN_ON(srcu_readers_active(ssp))) {\n\t\tpr_info(\"%s: Active srcu_struct %p state: %d\\n\",\n\t\t\t__func__, ssp, rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)));\n\t\treturn; /* Caller forgot to stop doing call_srcu()? */\n\t}\n\tfree_percpu(ssp->sda);\n\tssp->sda = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;\n\nstatic void srcu_sync_scale_cleanup(void)\n{\n\tcleanup_srcu_struct(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_sync_scale_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "244-248",
    "snippet": "static void srcu_sync_scale_init(void)\n{\n\tsrcu_ctlp = &srcud;\n\tinit_srcu_struct(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;",
      "static struct srcu_struct srcud;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_srcu_struct",
          "args": [
            "srcu_ctlp"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "224-238",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;\nstatic struct srcu_struct srcud;\n\nstatic void srcu_sync_scale_init(void)\n{\n\tsrcu_ctlp = &srcud;\n\tinit_srcu_struct(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_scale_synchronize_expedited",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "222-225",
    "snippet": "static void srcu_scale_synchronize_expedited(void)\n{\n\tsynchronize_srcu_expedited(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_srcu_expedited",
          "args": [
            "srcu_ctlp"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_srcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "953-956",
          "snippet": "void synchronize_srcu_expedited(struct srcu_struct *ssp)\n{\n\t__synchronize_srcu(ssp, rcu_gp_is_normal());\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid synchronize_srcu_expedited(struct srcu_struct *ssp)\n{\n\t__synchronize_srcu(ssp, rcu_gp_is_normal());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;\n\nstatic void srcu_scale_synchronize_expedited(void)\n{\n\tsynchronize_srcu_expedited(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_scale_synchronize",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "217-220",
    "snippet": "static void srcu_scale_synchronize(void)\n{\n\tsynchronize_srcu(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "srcu_ctlp"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "start_poll_synchronize_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1044-1047",
          "snippet": "unsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;\n\nstatic void srcu_scale_synchronize(void)\n{\n\tsynchronize_srcu(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_rcu_barrier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "212-215",
    "snippet": "static void srcu_rcu_barrier(void)\n{\n\tsrcu_barrier(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_barrier",
          "args": [
            "srcu_ctlp"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_barrier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1104-1152",
          "snippet": "void srcu_barrier(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tstruct srcu_data *sdp;\n\tunsigned long s = rcu_seq_snap(&ssp->srcu_barrier_seq);\n\n\tcheck_init_srcu_struct(ssp);\n\tmutex_lock(&ssp->srcu_barrier_mutex);\n\tif (rcu_seq_done(&ssp->srcu_barrier_seq, s)) {\n\t\tsmp_mb(); /* Force ordering following return. */\n\t\tmutex_unlock(&ssp->srcu_barrier_mutex);\n\t\treturn; /* Someone else did our work for us. */\n\t}\n\trcu_seq_start(&ssp->srcu_barrier_seq);\n\tinit_completion(&ssp->srcu_barrier_completion);\n\n\t/* Initial count prevents reaching zero until all CBs are posted. */\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 1);\n\n\t/*\n\t * Each pass through this loop enqueues a callback, but only\n\t * on CPUs already having callbacks enqueued.  Note that if\n\t * a CPU already has callbacks enqueue, it must have already\n\t * registered the need for a future grace period, so all we\n\t * need do is enqueue a callback that will use the same\n\t * grace period as the last callback already in the queue.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tspin_lock_irq_rcu_node(sdp);\n\t\tatomic_inc(&ssp->srcu_barrier_cpu_cnt);\n\t\tsdp->srcu_barrier_head.func = srcu_barrier_cb;\n\t\tdebug_rcu_head_queue(&sdp->srcu_barrier_head);\n\t\tif (!rcu_segcblist_entrain(&sdp->srcu_cblist,\n\t\t\t\t\t   &sdp->srcu_barrier_head)) {\n\t\t\tdebug_rcu_head_unqueue(&sdp->srcu_barrier_head);\n\t\t\tatomic_dec(&ssp->srcu_barrier_cpu_cnt);\n\t\t}\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t}\n\n\t/* Remove the initial count, at which point reaching zero can happen. */\n\tif (atomic_dec_and_test(&ssp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&ssp->srcu_barrier_completion);\n\twait_for_completion(&ssp->srcu_barrier_completion);\n\n\trcu_seq_end(&ssp->srcu_barrier_seq);\n\tmutex_unlock(&ssp->srcu_barrier_mutex);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid srcu_barrier(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tstruct srcu_data *sdp;\n\tunsigned long s = rcu_seq_snap(&ssp->srcu_barrier_seq);\n\n\tcheck_init_srcu_struct(ssp);\n\tmutex_lock(&ssp->srcu_barrier_mutex);\n\tif (rcu_seq_done(&ssp->srcu_barrier_seq, s)) {\n\t\tsmp_mb(); /* Force ordering following return. */\n\t\tmutex_unlock(&ssp->srcu_barrier_mutex);\n\t\treturn; /* Someone else did our work for us. */\n\t}\n\trcu_seq_start(&ssp->srcu_barrier_seq);\n\tinit_completion(&ssp->srcu_barrier_completion);\n\n\t/* Initial count prevents reaching zero until all CBs are posted. */\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 1);\n\n\t/*\n\t * Each pass through this loop enqueues a callback, but only\n\t * on CPUs already having callbacks enqueued.  Note that if\n\t * a CPU already has callbacks enqueue, it must have already\n\t * registered the need for a future grace period, so all we\n\t * need do is enqueue a callback that will use the same\n\t * grace period as the last callback already in the queue.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tspin_lock_irq_rcu_node(sdp);\n\t\tatomic_inc(&ssp->srcu_barrier_cpu_cnt);\n\t\tsdp->srcu_barrier_head.func = srcu_barrier_cb;\n\t\tdebug_rcu_head_queue(&sdp->srcu_barrier_head);\n\t\tif (!rcu_segcblist_entrain(&sdp->srcu_cblist,\n\t\t\t\t\t   &sdp->srcu_barrier_head)) {\n\t\t\tdebug_rcu_head_unqueue(&sdp->srcu_barrier_head);\n\t\t\tatomic_dec(&ssp->srcu_barrier_cpu_cnt);\n\t\t}\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t}\n\n\t/* Remove the initial count, at which point reaching zero can happen. */\n\tif (atomic_dec_and_test(&ssp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&ssp->srcu_barrier_completion);\n\twait_for_completion(&ssp->srcu_barrier_completion);\n\n\trcu_seq_end(&ssp->srcu_barrier_seq);\n\tmutex_unlock(&ssp->srcu_barrier_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;\n\nstatic void srcu_rcu_barrier(void)\n{\n\tsrcu_barrier(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_call_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "207-210",
    "snippet": "static void srcu_call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\tcall_srcu(srcu_ctlp, head, func);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_srcu",
          "args": [
            "srcu_ctlp",
            "head",
            "func"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "call_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "903-907",
          "snippet": "void call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(ssp, rhp, func, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(ssp, rhp, func, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;\n\nstatic void srcu_call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\tcall_srcu(srcu_ctlp, head, func);\n}"
  },
  {
    "function_name": "srcu_scale_completed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "202-205",
    "snippet": "static unsigned long srcu_scale_completed(void)\n{\n\treturn srcu_batches_completed(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_batches_completed",
          "args": [
            "srcu_ctlp"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_batches_completed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1162-1165",
          "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;\n\nstatic unsigned long srcu_scale_completed(void)\n{\n\treturn srcu_batches_completed(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_scale_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "197-200",
    "snippet": "static void srcu_scale_read_unlock(int idx) __releases(srcu_ctlp)\n{\n\tsrcu_read_unlock(srcu_ctlp, idx);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "srcu_ctlp",
            "idx"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "416-420",
          "snippet": "void __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "srcu_ctlp"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;\n\nstatic void srcu_scale_read_unlock(int idx) __releases(srcu_ctlp)\n{\n\tsrcu_read_unlock(srcu_ctlp, idx);\n}"
  },
  {
    "function_name": "srcu_scale_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "192-195",
    "snippet": "static int srcu_scale_read_lock(void) __acquires(srcu_ctlp)\n{\n\treturn srcu_read_lock(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "srcu_ctlp"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "400-408",
          "snippet": "int __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "srcu_ctlp"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl_scale;\n\nstatic int srcu_scale_read_lock(void) __acquires(srcu_ctlp)\n{\n\treturn srcu_read_lock(srcu_ctlp);\n}"
  },
  {
    "function_name": "rcu_sync_scale_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "166-168",
    "snippet": "static void rcu_sync_scale_init(void)\n{\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_sync_scale_init(void)\n{\n}"
  },
  {
    "function_name": "rcu_no_completed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "161-164",
    "snippet": "static unsigned long __maybe_unused rcu_no_completed(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long __maybe_unused rcu_no_completed(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_scale_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "156-159",
    "snippet": "static void rcu_scale_read_unlock(int idx) __releases(RCU)\n{\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "RCU"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_scale_read_unlock(int idx) __releases(RCU)\n{\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "rcu_scale_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
    "lines": "150-154",
    "snippet": "static int rcu_scale_read_lock(void) __acquires(RCU)\n{\n\trcu_read_lock();\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_scale_read_lock(void) __acquires(RCU)\n{\n\trcu_read_lock();\n\treturn 0;\n}"
  }
]