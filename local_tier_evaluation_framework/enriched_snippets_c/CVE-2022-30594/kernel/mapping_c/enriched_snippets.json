[
  {
    "function_name": "dma_get_merge_boundary",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "790-798",
    "snippet": "unsigned long dma_get_merge_boundary(struct device *dev)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (!ops || !ops->get_merge_boundary)\n\t\treturn 0;\t/* can't merge */\n\n\treturn ops->get_merge_boundary(dev);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->get_merge_boundary",
          "args": [
            "dev"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nunsigned long dma_get_merge_boundary(struct device *dev)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (!ops || !ops->get_merge_boundary)\n\t\treturn 0;\t/* can't merge */\n\n\treturn ops->get_merge_boundary(dev);\n}"
  },
  {
    "function_name": "dma_need_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "780-787",
    "snippet": "bool dma_need_sync(struct device *dev, dma_addr_t dma_addr)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_map_direct(dev, ops))\n\t\treturn dma_direct_need_sync(dev, dma_addr);\n\treturn ops->sync_single_for_cpu || ops->sync_single_for_device;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_direct_need_sync",
          "args": [
            "dev",
            "dma_addr"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_need_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "586-590",
          "snippet": "bool dma_direct_need_sync(struct device *dev, dma_addr_t dma_addr)\n{\n\treturn !dev_is_dma_coherent(dev) ||\n\t       is_swiotlb_buffer(dev, dma_to_phys(dev, dma_addr));\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nbool dma_direct_need_sync(struct device *dev, dma_addr_t dma_addr)\n{\n\treturn !dev_is_dma_coherent(dev) ||\n\t       is_swiotlb_buffer(dev, dma_to_phys(dev, dma_addr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nbool dma_need_sync(struct device *dev, dma_addr_t dma_addr)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_map_direct(dev, ops))\n\t\treturn dma_direct_need_sync(dev, dma_addr);\n\treturn ops->sync_single_for_cpu || ops->sync_single_for_device;\n}"
  },
  {
    "function_name": "dma_max_mapping_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "766-777",
    "snippet": "size_t dma_max_mapping_size(struct device *dev)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tsize_t size = SIZE_MAX;\n\n\tif (dma_map_direct(dev, ops))\n\t\tsize = dma_direct_max_mapping_size(dev);\n\telse if (ops && ops->max_mapping_size)\n\t\tsize = ops->max_mapping_size(dev);\n\n\treturn size;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->max_mapping_size",
          "args": [
            "dev"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_max_mapping_size",
          "args": [
            "dev"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_max_mapping_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "577-584",
          "snippet": "size_t dma_direct_max_mapping_size(struct device *dev)\n{\n\t/* If SWIOTLB is active, use its maximum mapping size */\n\tif (is_swiotlb_active(dev) &&\n\t    (dma_addressing_limited(dev) || is_swiotlb_force_bounce(dev)))\n\t\treturn swiotlb_max_mapping_size(dev);\n\treturn SIZE_MAX;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nsize_t dma_direct_max_mapping_size(struct device *dev)\n{\n\t/* If SWIOTLB is active, use its maximum mapping size */\n\tif (is_swiotlb_active(dev) &&\n\t    (dma_addressing_limited(dev) || is_swiotlb_force_bounce(dev)))\n\t\treturn swiotlb_max_mapping_size(dev);\n\treturn SIZE_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nsize_t dma_max_mapping_size(struct device *dev)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tsize_t size = SIZE_MAX;\n\n\tif (dma_map_direct(dev, ops))\n\t\tsize = dma_direct_max_mapping_size(dev);\n\telse if (ops && ops->max_mapping_size)\n\t\tsize = ops->max_mapping_size(dev);\n\n\treturn size;\n}"
  },
  {
    "function_name": "dma_set_coherent_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "749-762",
    "snippet": "int dma_set_coherent_mask(struct device *dev, u64 mask)\n{\n\t/*\n\t * Truncate the mask to the actually supported dma_addr_t width to\n\t * avoid generating unsupportable addresses.\n\t */\n\tmask = (dma_addr_t)mask;\n\n\tif (!dma_supported(dev, mask))\n\t\treturn -EIO;\n\n\tdev->coherent_dma_mask = mask;\n\treturn 0;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_supported",
          "args": [
            "dev",
            "mask"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "dma_supported",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "709-722",
          "snippet": "int dma_supported(struct device *dev, u64 mask)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\t/*\n\t * ->dma_supported sets the bypass flag, so we must always call\n\t * into the method here unless the device is truly direct mapped.\n\t */\n\tif (!ops)\n\t\treturn dma_direct_supported(dev, mask);\n\tif (!ops->dma_supported)\n\t\treturn 1;\n\treturn ops->dma_supported(dev, mask);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_supported(struct device *dev, u64 mask)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\t/*\n\t * ->dma_supported sets the bypass flag, so we must always call\n\t * into the method here unless the device is truly direct mapped.\n\t */\n\tif (!ops)\n\t\treturn dma_direct_supported(dev, mask);\n\tif (!ops->dma_supported)\n\t\treturn 1;\n\treturn ops->dma_supported(dev, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_set_coherent_mask(struct device *dev, u64 mask)\n{\n\t/*\n\t * Truncate the mask to the actually supported dma_addr_t width to\n\t * avoid generating unsupportable addresses.\n\t */\n\tmask = (dma_addr_t)mask;\n\n\tif (!dma_supported(dev, mask))\n\t\treturn -EIO;\n\n\tdev->coherent_dma_mask = mask;\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_set_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "731-745",
    "snippet": "int dma_set_mask(struct device *dev, u64 mask)\n{\n\t/*\n\t * Truncate the mask to the actually supported dma_addr_t width to\n\t * avoid generating unsupportable addresses.\n\t */\n\tmask = (dma_addr_t)mask;\n\n\tif (!dev->dma_mask || !dma_supported(dev, mask))\n\t\treturn -EIO;\n\n\tarch_dma_set_mask(dev, mask);\n\t*dev->dma_mask = mask;\n\treturn 0;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_dma_set_mask",
          "args": [
            "dev",
            "mask"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_supported",
          "args": [
            "dev",
            "mask"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "dma_supported",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "709-722",
          "snippet": "int dma_supported(struct device *dev, u64 mask)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\t/*\n\t * ->dma_supported sets the bypass flag, so we must always call\n\t * into the method here unless the device is truly direct mapped.\n\t */\n\tif (!ops)\n\t\treturn dma_direct_supported(dev, mask);\n\tif (!ops->dma_supported)\n\t\treturn 1;\n\treturn ops->dma_supported(dev, mask);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_supported(struct device *dev, u64 mask)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\t/*\n\t * ->dma_supported sets the bypass flag, so we must always call\n\t * into the method here unless the device is truly direct mapped.\n\t */\n\tif (!ops)\n\t\treturn dma_direct_supported(dev, mask);\n\tif (!ops->dma_supported)\n\t\treturn 1;\n\treturn ops->dma_supported(dev, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_set_mask(struct device *dev, u64 mask)\n{\n\t/*\n\t * Truncate the mask to the actually supported dma_addr_t width to\n\t * avoid generating unsupportable addresses.\n\t */\n\tmask = (dma_addr_t)mask;\n\n\tif (!dev->dma_mask || !dma_supported(dev, mask))\n\t\treturn -EIO;\n\n\tarch_dma_set_mask(dev, mask);\n\t*dev->dma_mask = mask;\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_supported",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "709-722",
    "snippet": "int dma_supported(struct device *dev, u64 mask)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\t/*\n\t * ->dma_supported sets the bypass flag, so we must always call\n\t * into the method here unless the device is truly direct mapped.\n\t */\n\tif (!ops)\n\t\treturn dma_direct_supported(dev, mask);\n\tif (!ops->dma_supported)\n\t\treturn 1;\n\treturn ops->dma_supported(dev, mask);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->dma_supported",
          "args": [
            "dev",
            "mask"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "dma_supported",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "709-722",
          "snippet": "int dma_supported(struct device *dev, u64 mask)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\t/*\n\t * ->dma_supported sets the bypass flag, so we must always call\n\t * into the method here unless the device is truly direct mapped.\n\t */\n\tif (!ops)\n\t\treturn dma_direct_supported(dev, mask);\n\tif (!ops->dma_supported)\n\t\treturn 1;\n\treturn ops->dma_supported(dev, mask);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "dma_direct_supported",
          "args": [
            "dev",
            "mask"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_supported",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "554-575",
          "snippet": "int dma_direct_supported(struct device *dev, u64 mask)\n{\n\tu64 min_mask = (max_pfn - 1) << PAGE_SHIFT;\n\n\t/*\n\t * Because 32-bit DMA masks are so common we expect every architecture\n\t * to be able to satisfy them - either by not supporting more physical\n\t * memory, or by providing a ZONE_DMA32.  If neither is the case, the\n\t * architecture needs to use an IOMMU instead of the direct mapping.\n\t */\n\tif (mask >= DMA_BIT_MASK(32))\n\t\treturn 1;\n\n\t/*\n\t * This check needs to be against the actual bit mask value, so use\n\t * phys_to_dma_unencrypted() here so that the SME encryption mask isn't\n\t * part of the check.\n\t */\n\tif (IS_ENABLED(CONFIG_ZONE_DMA))\n\t\tmin_mask = min_t(u64, min_mask, DMA_BIT_MASK(zone_dma_bits));\n\treturn mask >= phys_to_dma_unencrypted(dev, min_mask);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int zone_dma_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nunsigned int zone_dma_bits;\n\nint dma_direct_supported(struct device *dev, u64 mask)\n{\n\tu64 min_mask = (max_pfn - 1) << PAGE_SHIFT;\n\n\t/*\n\t * Because 32-bit DMA masks are so common we expect every architecture\n\t * to be able to satisfy them - either by not supporting more physical\n\t * memory, or by providing a ZONE_DMA32.  If neither is the case, the\n\t * architecture needs to use an IOMMU instead of the direct mapping.\n\t */\n\tif (mask >= DMA_BIT_MASK(32))\n\t\treturn 1;\n\n\t/*\n\t * This check needs to be against the actual bit mask value, so use\n\t * phys_to_dma_unencrypted() here so that the SME encryption mask isn't\n\t * part of the check.\n\t */\n\tif (IS_ENABLED(CONFIG_ZONE_DMA))\n\t\tmin_mask = min_t(u64, min_mask, DMA_BIT_MASK(zone_dma_bits));\n\treturn mask >= phys_to_dma_unencrypted(dev, min_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_supported(struct device *dev, u64 mask)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\t/*\n\t * ->dma_supported sets the bypass flag, so we must always call\n\t * into the method here unless the device is truly direct mapped.\n\t */\n\tif (!ops)\n\t\treturn dma_direct_supported(dev, mask);\n\tif (!ops->dma_supported)\n\t\treturn 1;\n\treturn ops->dma_supported(dev, mask);\n}"
  },
  {
    "function_name": "dma_mmap_noncontiguous",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "692-706",
    "snippet": "int dma_mmap_noncontiguous(struct device *dev, struct vm_area_struct *vma,\n\t\tsize_t size, struct sg_table *sgt)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (ops && ops->alloc_noncontiguous) {\n\t\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t\tif (vma->vm_pgoff >= count ||\n\t\t    vma_pages(vma) > count - vma->vm_pgoff)\n\t\t\treturn -ENXIO;\n\t\treturn vm_map_pages(vma, sgt_handle(sgt)->pages, count);\n\t}\n\treturn dma_mmap_pages(dev, vma, size, sg_page(sgt->sgl));\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_mmap_pages",
          "args": [
            "dev",
            "vma",
            "size",
            "sg_page(sgt->sgl)"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "dma_mmap_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "590-600",
          "snippet": "int dma_mmap_pages(struct device *dev, struct vm_area_struct *vma,\n\t\tsize_t size, struct page *page)\n{\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\tif (vma->vm_pgoff >= count || vma_pages(vma) > count - vma->vm_pgoff)\n\t\treturn -ENXIO;\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t       page_to_pfn(page) + vma->vm_pgoff,\n\t\t\t       vma_pages(vma) << PAGE_SHIFT, vma->vm_page_prot);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_mmap_pages(struct device *dev, struct vm_area_struct *vma,\n\t\tsize_t size, struct page *page)\n{\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\tif (vma->vm_pgoff >= count || vma_pages(vma) > count - vma->vm_pgoff)\n\t\treturn -ENXIO;\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t       page_to_pfn(page) + vma->vm_pgoff,\n\t\t\t       vma_pages(vma) << PAGE_SHIFT, vma->vm_page_prot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "sgt->sgl"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_map_pages",
          "args": [
            "vma",
            "sgt_handle(sgt)->pages",
            "count"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sgt_handle",
          "args": [
            "sgt"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_mmap_noncontiguous(struct device *dev, struct vm_area_struct *vma,\n\t\tsize_t size, struct sg_table *sgt)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (ops && ops->alloc_noncontiguous) {\n\t\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t\tif (vma->vm_pgoff >= count ||\n\t\t    vma_pages(vma) > count - vma->vm_pgoff)\n\t\t\treturn -ENXIO;\n\t\treturn vm_map_pages(vma, sgt_handle(sgt)->pages, count);\n\t}\n\treturn dma_mmap_pages(dev, vma, size, sg_page(sgt->sgl));\n}"
  },
  {
    "function_name": "dma_vunmap_noncontiguous",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "683-689",
    "snippet": "void dma_vunmap_noncontiguous(struct device *dev, void *vaddr)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (ops && ops->alloc_noncontiguous)\n\t\tvunmap(vaddr);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vunmap",
          "args": [
            "vaddr"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_vunmap_noncontiguous(struct device *dev, void *vaddr)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (ops && ops->alloc_noncontiguous)\n\t\tvunmap(vaddr);\n}"
  },
  {
    "function_name": "dma_vmap_noncontiguous",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "671-680",
    "snippet": "void *dma_vmap_noncontiguous(struct device *dev, size_t size,\n\t\tstruct sg_table *sgt)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\tif (ops && ops->alloc_noncontiguous)\n\t\treturn vmap(sgt_handle(sgt)->pages, count, VM_MAP, PAGE_KERNEL);\n\treturn page_address(sg_page(sgt->sgl));\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "sg_page(sgt->sgl)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "sgt->sgl"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmap",
          "args": [
            "sgt_handle(sgt)->pages",
            "count",
            "VM_MAP",
            "PAGE_KERNEL"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sgt_handle",
          "args": [
            "sgt"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid *dma_vmap_noncontiguous(struct device *dev, size_t size,\n\t\tstruct sg_table *sgt)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\tif (ops && ops->alloc_noncontiguous)\n\t\treturn vmap(sgt_handle(sgt)->pages, count, VM_MAP, PAGE_KERNEL);\n\treturn page_address(sg_page(sgt->sgl));\n}"
  },
  {
    "function_name": "dma_free_noncontiguous",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "658-668",
    "snippet": "void dma_free_noncontiguous(struct device *dev, size_t size,\n\t\tstruct sg_table *sgt, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tdebug_dma_unmap_sg(dev, sgt->sgl, sgt->orig_nents, dir);\n\tif (ops && ops->free_noncontiguous)\n\t\tops->free_noncontiguous(dev, size, sgt, dir);\n\telse\n\t\tfree_single_sgt(dev, size, sgt, dir);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_single_sgt",
          "args": [
            "dev",
            "size",
            "sgt",
            "dir"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "free_single_sgt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "649-656",
          "snippet": "static void free_single_sgt(struct device *dev, size_t size,\n\t\tstruct sg_table *sgt, enum dma_data_direction dir)\n{\n\t__dma_free_pages(dev, size, sg_page(sgt->sgl), sgt->sgl->dma_address,\n\t\t\t dir);\n\tsg_free_table(sgt);\n\tkfree(sgt);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void free_single_sgt(struct device *dev, size_t size,\n\t\tstruct sg_table *sgt, enum dma_data_direction dir)\n{\n\t__dma_free_pages(dev, size, sg_page(sgt->sgl), sgt->sgl->dma_address,\n\t\t\t dir);\n\tsg_free_table(sgt);\n\tkfree(sgt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->free_noncontiguous",
          "args": [
            "dev",
            "size",
            "sgt",
            "dir"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_dma_unmap_sg",
          "args": [
            "dev",
            "sgt->sgl",
            "sgt->orig_nents",
            "dir"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_unmap_sg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "76-80",
          "snippet": "static inline void debug_dma_unmap_sg(struct device *dev,\n\t\t\t\t      struct scatterlist *sglist,\n\t\t\t\t      int nelems, int dir)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_unmap_sg(struct device *dev,\n\t\t\t\t      struct scatterlist *sglist,\n\t\t\t\t      int nelems, int dir)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_free_noncontiguous(struct device *dev, size_t size,\n\t\tstruct sg_table *sgt, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tdebug_dma_unmap_sg(dev, sgt->sgl, sgt->orig_nents, dir);\n\tif (ops && ops->free_noncontiguous)\n\t\tops->free_noncontiguous(dev, size, sgt, dir);\n\telse\n\t\tfree_single_sgt(dev, size, sgt, dir);\n}"
  },
  {
    "function_name": "free_single_sgt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "649-656",
    "snippet": "static void free_single_sgt(struct device *dev, size_t size,\n\t\tstruct sg_table *sgt, enum dma_data_direction dir)\n{\n\t__dma_free_pages(dev, size, sg_page(sgt->sgl), sgt->sgl->dma_address,\n\t\t\t dir);\n\tsg_free_table(sgt);\n\tkfree(sgt);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sgt"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_free_table",
          "args": [
            "sgt"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_free_pages",
          "args": [
            "dev",
            "size",
            "sg_page(sgt->sgl)",
            "sgt->sgl->dma_address",
            "dir"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "570-580",
          "snippet": "static void __dma_free_pages(struct device *dev, size_t size, struct page *page,\n\t\tdma_addr_t dma_handle, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\tdma_direct_free_pages(dev, size, page, dma_handle, dir);\n\telse if (ops->free_pages)\n\t\tops->free_pages(dev, size, page, dma_handle, dir);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void __dma_free_pages(struct device *dev, size_t size, struct page *page,\n\t\tdma_addr_t dma_handle, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\tdma_direct_free_pages(dev, size, page, dma_handle, dir);\n\telse if (ops->free_pages)\n\t\tops->free_pages(dev, size, page, dma_handle, dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "sgt->sgl"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void free_single_sgt(struct device *dev, size_t size,\n\t\tstruct sg_table *sgt, enum dma_data_direction dir)\n{\n\t__dma_free_pages(dev, size, sg_page(sgt->sgl), sgt->sgl->dma_address,\n\t\t\t dir);\n\tsg_free_table(sgt);\n\tkfree(sgt);\n}"
  },
  {
    "function_name": "dma_alloc_noncontiguous",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "627-646",
    "snippet": "struct sg_table *dma_alloc_noncontiguous(struct device *dev, size_t size,\n\t\tenum dma_data_direction dir, gfp_t gfp, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tstruct sg_table *sgt;\n\n\tif (WARN_ON_ONCE(attrs & ~DMA_ATTR_ALLOC_SINGLE_PAGES))\n\t\treturn NULL;\n\n\tif (ops && ops->alloc_noncontiguous)\n\t\tsgt = ops->alloc_noncontiguous(dev, size, dir, gfp, attrs);\n\telse\n\t\tsgt = alloc_single_sgt(dev, size, dir, gfp);\n\n\tif (sgt) {\n\t\tsgt->nents = 1;\n\t\tdebug_dma_map_sg(dev, sgt->sgl, sgt->orig_nents, 1, dir, attrs);\n\t}\n\treturn sgt;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_dma_map_sg",
          "args": [
            "dev",
            "sgt->sgl",
            "sgt->orig_nents",
            "1",
            "dir",
            "attrs"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_map_sg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "70-74",
          "snippet": "static inline void debug_dma_map_sg(struct device *dev, struct scatterlist *sg,\n\t\t\t\t    int nents, int mapped_ents, int direction,\n\t\t\t\t    unsigned long attrs)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_map_sg(struct device *dev, struct scatterlist *sg,\n\t\t\t\t    int nents, int mapped_ents, int direction,\n\t\t\t\t    unsigned long attrs)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_single_sgt",
          "args": [
            "dev",
            "size",
            "dir",
            "gfp"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_single_sgt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "603-625",
          "snippet": "static struct sg_table *alloc_single_sgt(struct device *dev, size_t size,\n\t\tenum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct sg_table *sgt;\n\tstruct page *page;\n\n\tsgt = kmalloc(sizeof(*sgt), gfp);\n\tif (!sgt)\n\t\treturn NULL;\n\tif (sg_alloc_table(sgt, 1, gfp))\n\t\tgoto out_free_sgt;\n\tpage = __dma_alloc_pages(dev, size, &sgt->sgl->dma_address, dir, gfp);\n\tif (!page)\n\t\tgoto out_free_table;\n\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\tsg_dma_len(sgt->sgl) = sgt->sgl->length;\n\treturn sgt;\nout_free_table:\n\tsg_free_table(sgt);\nout_free_sgt:\n\tkfree(sgt);\n\treturn NULL;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic struct sg_table *alloc_single_sgt(struct device *dev, size_t size,\n\t\tenum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct sg_table *sgt;\n\tstruct page *page;\n\n\tsgt = kmalloc(sizeof(*sgt), gfp);\n\tif (!sgt)\n\t\treturn NULL;\n\tif (sg_alloc_table(sgt, 1, gfp))\n\t\tgoto out_free_sgt;\n\tpage = __dma_alloc_pages(dev, size, &sgt->sgl->dma_address, dir, gfp);\n\tif (!page)\n\t\tgoto out_free_table;\n\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\tsg_dma_len(sgt->sgl) = sgt->sgl->length;\n\treturn sgt;\nout_free_table:\n\tsg_free_table(sgt);\nout_free_sgt:\n\tkfree(sgt);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->alloc_noncontiguous",
          "args": [
            "dev",
            "size",
            "dir",
            "gfp",
            "attrs"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "attrs & ~DMA_ATTR_ALLOC_SINGLE_PAGES"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstruct sg_table *dma_alloc_noncontiguous(struct device *dev, size_t size,\n\t\tenum dma_data_direction dir, gfp_t gfp, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tstruct sg_table *sgt;\n\n\tif (WARN_ON_ONCE(attrs & ~DMA_ATTR_ALLOC_SINGLE_PAGES))\n\t\treturn NULL;\n\n\tif (ops && ops->alloc_noncontiguous)\n\t\tsgt = ops->alloc_noncontiguous(dev, size, dir, gfp, attrs);\n\telse\n\t\tsgt = alloc_single_sgt(dev, size, dir, gfp);\n\n\tif (sgt) {\n\t\tsgt->nents = 1;\n\t\tdebug_dma_map_sg(dev, sgt->sgl, sgt->orig_nents, 1, dir, attrs);\n\t}\n\treturn sgt;\n}"
  },
  {
    "function_name": "alloc_single_sgt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "603-625",
    "snippet": "static struct sg_table *alloc_single_sgt(struct device *dev, size_t size,\n\t\tenum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct sg_table *sgt;\n\tstruct page *page;\n\n\tsgt = kmalloc(sizeof(*sgt), gfp);\n\tif (!sgt)\n\t\treturn NULL;\n\tif (sg_alloc_table(sgt, 1, gfp))\n\t\tgoto out_free_sgt;\n\tpage = __dma_alloc_pages(dev, size, &sgt->sgl->dma_address, dir, gfp);\n\tif (!page)\n\t\tgoto out_free_table;\n\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\tsg_dma_len(sgt->sgl) = sgt->sgl->length;\n\treturn sgt;\nout_free_table:\n\tsg_free_table(sgt);\nout_free_sgt:\n\tkfree(sgt);\n\treturn NULL;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sgt"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_free_table",
          "args": [
            "sgt"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "sgt->sgl"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_set_page",
          "args": [
            "sgt->sgl",
            "page",
            "PAGE_ALIGN(size)",
            "0"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_alloc_pages",
          "args": [
            "dev",
            "size",
            "&sgt->sgl->dma_address",
            "dir",
            "gfp"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_alloc_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "541-557",
          "snippet": "static struct page *__dma_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (WARN_ON_ONCE(!dev->coherent_dma_mask))\n\t\treturn NULL;\n\tif (WARN_ON_ONCE(gfp & (__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM)))\n\t\treturn NULL;\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_alloc_pages(dev, size, dma_handle, dir, gfp);\n\tif (!ops->alloc_pages)\n\t\treturn NULL;\n\treturn ops->alloc_pages(dev, size, dma_handle, dir, gfp);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic struct page *__dma_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (WARN_ON_ONCE(!dev->coherent_dma_mask))\n\t\treturn NULL;\n\tif (WARN_ON_ONCE(gfp & (__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM)))\n\t\treturn NULL;\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_alloc_pages(dev, size, dma_handle, dir, gfp);\n\tif (!ops->alloc_pages)\n\t\treturn NULL;\n\treturn ops->alloc_pages(dev, size, dma_handle, dir, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_alloc_table",
          "args": [
            "sgt",
            "1",
            "gfp"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*sgt)",
            "gfp"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic struct sg_table *alloc_single_sgt(struct device *dev, size_t size,\n\t\tenum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct sg_table *sgt;\n\tstruct page *page;\n\n\tsgt = kmalloc(sizeof(*sgt), gfp);\n\tif (!sgt)\n\t\treturn NULL;\n\tif (sg_alloc_table(sgt, 1, gfp))\n\t\tgoto out_free_sgt;\n\tpage = __dma_alloc_pages(dev, size, &sgt->sgl->dma_address, dir, gfp);\n\tif (!page)\n\t\tgoto out_free_table;\n\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\tsg_dma_len(sgt->sgl) = sgt->sgl->length;\n\treturn sgt;\nout_free_table:\n\tsg_free_table(sgt);\nout_free_sgt:\n\tkfree(sgt);\n\treturn NULL;\n}"
  },
  {
    "function_name": "dma_mmap_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "590-600",
    "snippet": "int dma_mmap_pages(struct device *dev, struct vm_area_struct *vma,\n\t\tsize_t size, struct page *page)\n{\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\tif (vma->vm_pgoff >= count || vma_pages(vma) > count - vma->vm_pgoff)\n\t\treturn -ENXIO;\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t       page_to_pfn(page) + vma->vm_pgoff,\n\t\t\t       vma_pages(vma) << PAGE_SHIFT, vma->vm_page_prot);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pfn_range",
          "args": [
            "vma",
            "vma->vm_start",
            "page_to_pfn(page) + vma->vm_pgoff",
            "vma_pages(vma) << PAGE_SHIFT",
            "vma->vm_page_prot"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_mmap_pages(struct device *dev, struct vm_area_struct *vma,\n\t\tsize_t size, struct page *page)\n{\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\tif (vma->vm_pgoff >= count || vma_pages(vma) > count - vma->vm_pgoff)\n\t\treturn -ENXIO;\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t       page_to_pfn(page) + vma->vm_pgoff,\n\t\t\t       vma_pages(vma) << PAGE_SHIFT, vma->vm_page_prot);\n}"
  },
  {
    "function_name": "dma_free_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "582-587",
    "snippet": "void dma_free_pages(struct device *dev, size_t size, struct page *page,\n\t\tdma_addr_t dma_handle, enum dma_data_direction dir)\n{\n\tdebug_dma_unmap_page(dev, dma_handle, size, dir);\n\t__dma_free_pages(dev, size, page, dma_handle, dir);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_free_pages",
          "args": [
            "dev",
            "size",
            "page",
            "dma_handle",
            "dir"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "570-580",
          "snippet": "static void __dma_free_pages(struct device *dev, size_t size, struct page *page,\n\t\tdma_addr_t dma_handle, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\tdma_direct_free_pages(dev, size, page, dma_handle, dir);\n\telse if (ops->free_pages)\n\t\tops->free_pages(dev, size, page, dma_handle, dir);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void __dma_free_pages(struct device *dev, size_t size, struct page *page,\n\t\tdma_addr_t dma_handle, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\tdma_direct_free_pages(dev, size, page, dma_handle, dir);\n\telse if (ops->free_pages)\n\t\tops->free_pages(dev, size, page, dma_handle, dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_dma_unmap_page",
          "args": [
            "dev",
            "dma_handle",
            "size",
            "dir"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_unmap_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "65-68",
          "snippet": "static inline void debug_dma_unmap_page(struct device *dev, dma_addr_t addr,\n\t\t\t\t\tsize_t size, int direction)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_unmap_page(struct device *dev, dma_addr_t addr,\n\t\t\t\t\tsize_t size, int direction)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_free_pages(struct device *dev, size_t size, struct page *page,\n\t\tdma_addr_t dma_handle, enum dma_data_direction dir)\n{\n\tdebug_dma_unmap_page(dev, dma_handle, size, dir);\n\t__dma_free_pages(dev, size, page, dma_handle, dir);\n}"
  },
  {
    "function_name": "__dma_free_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "570-580",
    "snippet": "static void __dma_free_pages(struct device *dev, size_t size, struct page *page,\n\t\tdma_addr_t dma_handle, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\tdma_direct_free_pages(dev, size, page, dma_handle, dir);\n\telse if (ops->free_pages)\n\t\tops->free_pages(dev, size, page, dma_handle, dir);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->free_pages",
          "args": [
            "dev",
            "size",
            "page",
            "dma_handle",
            "dir"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_free_pages",
          "args": [
            "dev",
            "size",
            "page",
            "dma_handle",
            "dir"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "398-413",
          "snippet": "void dma_direct_free_pages(struct device *dev, size_t size,\n\t\tstruct page *page, dma_addr_t dma_addr,\n\t\tenum dma_data_direction dir)\n{\n\tunsigned int page_order = get_order(size);\n\tvoid *vaddr = page_address(page);\n\n\t/* If cpu_addr is not from an atomic pool, dma_free_from_pool() fails */\n\tif (IS_ENABLED(CONFIG_DMA_COHERENT_POOL) &&\n\t    dma_free_from_pool(dev, vaddr, size))\n\t\treturn;\n\n\tif (dma_set_encrypted(dev, vaddr, 1 << page_order))\n\t\treturn;\n\t__dma_direct_free_pages(dev, page, size);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_free_pages(struct device *dev, size_t size,\n\t\tstruct page *page, dma_addr_t dma_addr,\n\t\tenum dma_data_direction dir)\n{\n\tunsigned int page_order = get_order(size);\n\tvoid *vaddr = page_address(page);\n\n\t/* If cpu_addr is not from an atomic pool, dma_free_from_pool() fails */\n\tif (IS_ENABLED(CONFIG_DMA_COHERENT_POOL) &&\n\t    dma_free_from_pool(dev, vaddr, size))\n\t\treturn;\n\n\tif (dma_set_encrypted(dev, vaddr, 1 << page_order))\n\t\treturn;\n\t__dma_direct_free_pages(dev, page, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_alloc_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "130-134",
          "snippet": "static inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void __dma_free_pages(struct device *dev, size_t size, struct page *page,\n\t\tdma_addr_t dma_handle, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\tdma_direct_free_pages(dev, size, page, dma_handle, dir);\n\telse if (ops->free_pages)\n\t\tops->free_pages(dev, size, page, dma_handle, dir);\n}"
  },
  {
    "function_name": "dma_alloc_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "559-567",
    "snippet": "struct page *dma_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct page *page = __dma_alloc_pages(dev, size, dma_handle, dir, gfp);\n\n\tif (page)\n\t\tdebug_dma_map_page(dev, page, 0, size, dir, *dma_handle, 0);\n\treturn page;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_dma_map_page",
          "args": [
            "dev",
            "page",
            "0",
            "size",
            "dir",
            "*dma_handle",
            "0"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_map_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "58-63",
          "snippet": "static inline void debug_dma_map_page(struct device *dev, struct page *page,\n\t\t\t\t      size_t offset, size_t size,\n\t\t\t\t      int direction, dma_addr_t dma_addr,\n\t\t\t\t      unsigned long attrs)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_map_page(struct device *dev, struct page *page,\n\t\t\t\t      size_t offset, size_t size,\n\t\t\t\t      int direction, dma_addr_t dma_addr,\n\t\t\t\t      unsigned long attrs)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dma_alloc_pages",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "dir",
            "gfp"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_alloc_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "541-557",
          "snippet": "static struct page *__dma_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (WARN_ON_ONCE(!dev->coherent_dma_mask))\n\t\treturn NULL;\n\tif (WARN_ON_ONCE(gfp & (__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM)))\n\t\treturn NULL;\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_alloc_pages(dev, size, dma_handle, dir, gfp);\n\tif (!ops->alloc_pages)\n\t\treturn NULL;\n\treturn ops->alloc_pages(dev, size, dma_handle, dir, gfp);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic struct page *__dma_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (WARN_ON_ONCE(!dev->coherent_dma_mask))\n\t\treturn NULL;\n\tif (WARN_ON_ONCE(gfp & (__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM)))\n\t\treturn NULL;\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_alloc_pages(dev, size, dma_handle, dir, gfp);\n\tif (!ops->alloc_pages)\n\t\treturn NULL;\n\treturn ops->alloc_pages(dev, size, dma_handle, dir, gfp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstruct page *dma_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct page *page = __dma_alloc_pages(dev, size, dma_handle, dir, gfp);\n\n\tif (page)\n\t\tdebug_dma_map_page(dev, page, 0, size, dir, *dma_handle, 0);\n\treturn page;\n}"
  },
  {
    "function_name": "__dma_alloc_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "541-557",
    "snippet": "static struct page *__dma_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (WARN_ON_ONCE(!dev->coherent_dma_mask))\n\t\treturn NULL;\n\tif (WARN_ON_ONCE(gfp & (__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM)))\n\t\treturn NULL;\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_alloc_pages(dev, size, dma_handle, dir, gfp);\n\tif (!ops->alloc_pages)\n\t\treturn NULL;\n\treturn ops->alloc_pages(dev, size, dma_handle, dir, gfp);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->alloc_pages",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "dir",
            "gfp"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_alloc_pages",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "dir",
            "gfp"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_alloc_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "364-396",
          "snippet": "struct page *dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct page *page;\n\tvoid *ret;\n\n\tif (force_dma_unencrypted(dev) && dma_direct_use_pool(dev, gfp))\n\t\treturn dma_direct_alloc_from_pool(dev, size, dma_handle, gfp);\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp);\n\tif (!page)\n\t\treturn NULL;\n\tif (PageHighMem(page)) {\n\t\t/*\n\t\t * Depending on the cma= arguments and per-arch setup\n\t\t * dma_alloc_contiguous could return highmem pages.\n\t\t * Without remapping there is no way to return them here,\n\t\t * so log an error and fail.\n\t\t */\n\t\tdev_info(dev, \"Rejecting highmem page from CMA.\\n\");\n\t\tgoto out_free_pages;\n\t}\n\n\tret = page_address(page);\n\tif (dma_set_decrypted(dev, ret, size))\n\t\tgoto out_free_pages;\n\tmemset(ret, 0, size);\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\nout_free_pages:\n\t__dma_direct_free_pages(dev, page, size);\n\treturn NULL;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstruct page *dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct page *page;\n\tvoid *ret;\n\n\tif (force_dma_unencrypted(dev) && dma_direct_use_pool(dev, gfp))\n\t\treturn dma_direct_alloc_from_pool(dev, size, dma_handle, gfp);\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp);\n\tif (!page)\n\t\treturn NULL;\n\tif (PageHighMem(page)) {\n\t\t/*\n\t\t * Depending on the cma= arguments and per-arch setup\n\t\t * dma_alloc_contiguous could return highmem pages.\n\t\t * Without remapping there is no way to return them here,\n\t\t * so log an error and fail.\n\t\t */\n\t\tdev_info(dev, \"Rejecting highmem page from CMA.\\n\");\n\t\tgoto out_free_pages;\n\t}\n\n\tret = page_address(page);\n\tif (dma_set_decrypted(dev, ret, size))\n\t\tgoto out_free_pages;\n\tmemset(ret, 0, size);\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\nout_free_pages:\n\t__dma_direct_free_pages(dev, page, size);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_alloc_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "130-134",
          "snippet": "static inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "gfp & (__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!dev->coherent_dma_mask"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic struct page *__dma_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (WARN_ON_ONCE(!dev->coherent_dma_mask))\n\t\treturn NULL;\n\tif (WARN_ON_ONCE(gfp & (__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM)))\n\t\treturn NULL;\n\n\tsize = PAGE_ALIGN(size);\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_alloc_pages(dev, size, dma_handle, dir, gfp);\n\tif (!ops->alloc_pages)\n\t\treturn NULL;\n\treturn ops->alloc_pages(dev, size, dma_handle, dir, gfp);\n}"
  },
  {
    "function_name": "dma_free_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "514-538",
    "snippet": "void dma_free_attrs(struct device *dev, size_t size, void *cpu_addr,\n\t\tdma_addr_t dma_handle, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_release_from_dev_coherent(dev, get_order(size), cpu_addr))\n\t\treturn;\n\t/*\n\t * On non-coherent platforms which implement DMA-coherent buffers via\n\t * non-cacheable remaps, ops->free() may call vunmap(). Thus getting\n\t * this far in IRQ context is a) at risk of a BUG_ON() or trying to\n\t * sleep on some machines, and b) an indication that the driver is\n\t * probably misusing the coherent API anyway.\n\t */\n\tWARN_ON(irqs_disabled());\n\n\tif (!cpu_addr)\n\t\treturn;\n\n\tdebug_dma_free_coherent(dev, size, cpu_addr, dma_handle);\n\tif (dma_alloc_direct(dev, ops))\n\t\tdma_direct_free(dev, size, cpu_addr, dma_handle, attrs);\n\telse if (ops->free)\n\t\tops->free(dev, size, cpu_addr, dma_handle, attrs);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->free",
          "args": [
            "dev",
            "size",
            "cpu_addr",
            "dma_handle",
            "attrs"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_free",
          "args": [
            "dev",
            "size",
            "cpu_addr",
            "dma_handle",
            "attrs"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "398-413",
          "snippet": "void dma_direct_free_pages(struct device *dev, size_t size,\n\t\tstruct page *page, dma_addr_t dma_addr,\n\t\tenum dma_data_direction dir)\n{\n\tunsigned int page_order = get_order(size);\n\tvoid *vaddr = page_address(page);\n\n\t/* If cpu_addr is not from an atomic pool, dma_free_from_pool() fails */\n\tif (IS_ENABLED(CONFIG_DMA_COHERENT_POOL) &&\n\t    dma_free_from_pool(dev, vaddr, size))\n\t\treturn;\n\n\tif (dma_set_encrypted(dev, vaddr, 1 << page_order))\n\t\treturn;\n\t__dma_direct_free_pages(dev, page, size);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_free_pages(struct device *dev, size_t size,\n\t\tstruct page *page, dma_addr_t dma_addr,\n\t\tenum dma_data_direction dir)\n{\n\tunsigned int page_order = get_order(size);\n\tvoid *vaddr = page_address(page);\n\n\t/* If cpu_addr is not from an atomic pool, dma_free_from_pool() fails */\n\tif (IS_ENABLED(CONFIG_DMA_COHERENT_POOL) &&\n\t    dma_free_from_pool(dev, vaddr, size))\n\t\treturn;\n\n\tif (dma_set_encrypted(dev, vaddr, 1 << page_order))\n\t\treturn;\n\t__dma_direct_free_pages(dev, page, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_alloc_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "130-134",
          "snippet": "static inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_dma_free_coherent",
          "args": [
            "dev",
            "size",
            "cpu_addr",
            "dma_handle"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_free_coherent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "88-91",
          "snippet": "static inline void debug_dma_free_coherent(struct device *dev, size_t size,\n\t\t\t\t\t   void *virt, dma_addr_t addr)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_free_coherent(struct device *dev, size_t size,\n\t\t\t\t\t   void *virt, dma_addr_t addr)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irqs_disabled()"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_release_from_dev_coherent",
          "args": [
            "dev",
            "get_order(size)",
            "cpu_addr"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "dma_release_from_dev_coherent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/coherent.c",
          "lines": "219-224",
          "snippet": "int dma_release_from_dev_coherent(struct device *dev, int order, void *vaddr)\n{\n\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);\n\n\treturn __dma_release_from_coherent(mem, order, vaddr);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nint dma_release_from_dev_coherent(struct device *dev, int order, void *vaddr)\n{\n\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);\n\n\treturn __dma_release_from_coherent(mem, order, vaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_free_attrs(struct device *dev, size_t size, void *cpu_addr,\n\t\tdma_addr_t dma_handle, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_release_from_dev_coherent(dev, get_order(size), cpu_addr))\n\t\treturn;\n\t/*\n\t * On non-coherent platforms which implement DMA-coherent buffers via\n\t * non-cacheable remaps, ops->free() may call vunmap(). Thus getting\n\t * this far in IRQ context is a) at risk of a BUG_ON() or trying to\n\t * sleep on some machines, and b) an indication that the driver is\n\t * probably misusing the coherent API anyway.\n\t */\n\tWARN_ON(irqs_disabled());\n\n\tif (!cpu_addr)\n\t\treturn;\n\n\tdebug_dma_free_coherent(dev, size, cpu_addr, dma_handle);\n\tif (dma_alloc_direct(dev, ops))\n\t\tdma_direct_free(dev, size, cpu_addr, dma_handle, attrs);\n\telse if (ops->free)\n\t\tops->free(dev, size, cpu_addr, dma_handle, attrs);\n}"
  },
  {
    "function_name": "dma_alloc_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "488-511",
    "snippet": "void *dma_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,\n\t\tgfp_t flag, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tvoid *cpu_addr;\n\n\tWARN_ON_ONCE(!dev->coherent_dma_mask);\n\n\tif (dma_alloc_from_dev_coherent(dev, size, dma_handle, &cpu_addr))\n\t\treturn cpu_addr;\n\n\t/* let the implementation decide on the zone to allocate from: */\n\tflag &= ~(__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\tcpu_addr = dma_direct_alloc(dev, size, dma_handle, flag, attrs);\n\telse if (ops->alloc)\n\t\tcpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);\n\telse\n\t\treturn NULL;\n\n\tdebug_dma_alloc_coherent(dev, size, *dma_handle, cpu_addr, attrs);\n\treturn cpu_addr;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_dma_alloc_coherent",
          "args": [
            "dev",
            "size",
            "*dma_handle",
            "cpu_addr",
            "attrs"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_alloc_coherent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "82-86",
          "snippet": "static inline void debug_dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t\t    dma_addr_t dma_addr, void *virt,\n\t\t\t\t\t    unsigned long attrs)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t\t    dma_addr_t dma_addr, void *virt,\n\t\t\t\t\t    unsigned long attrs)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->alloc",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "flag",
            "attrs"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_alloc",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "flag",
            "attrs"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_alloc_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "364-396",
          "snippet": "struct page *dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct page *page;\n\tvoid *ret;\n\n\tif (force_dma_unencrypted(dev) && dma_direct_use_pool(dev, gfp))\n\t\treturn dma_direct_alloc_from_pool(dev, size, dma_handle, gfp);\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp);\n\tif (!page)\n\t\treturn NULL;\n\tif (PageHighMem(page)) {\n\t\t/*\n\t\t * Depending on the cma= arguments and per-arch setup\n\t\t * dma_alloc_contiguous could return highmem pages.\n\t\t * Without remapping there is no way to return them here,\n\t\t * so log an error and fail.\n\t\t */\n\t\tdev_info(dev, \"Rejecting highmem page from CMA.\\n\");\n\t\tgoto out_free_pages;\n\t}\n\n\tret = page_address(page);\n\tif (dma_set_decrypted(dev, ret, size))\n\t\tgoto out_free_pages;\n\tmemset(ret, 0, size);\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\nout_free_pages:\n\t__dma_direct_free_pages(dev, page, size);\n\treturn NULL;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstruct page *dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct page *page;\n\tvoid *ret;\n\n\tif (force_dma_unencrypted(dev) && dma_direct_use_pool(dev, gfp))\n\t\treturn dma_direct_alloc_from_pool(dev, size, dma_handle, gfp);\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp);\n\tif (!page)\n\t\treturn NULL;\n\tif (PageHighMem(page)) {\n\t\t/*\n\t\t * Depending on the cma= arguments and per-arch setup\n\t\t * dma_alloc_contiguous could return highmem pages.\n\t\t * Without remapping there is no way to return them here,\n\t\t * so log an error and fail.\n\t\t */\n\t\tdev_info(dev, \"Rejecting highmem page from CMA.\\n\");\n\t\tgoto out_free_pages;\n\t}\n\n\tret = page_address(page);\n\tif (dma_set_decrypted(dev, ret, size))\n\t\tgoto out_free_pages;\n\tmemset(ret, 0, size);\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\nout_free_pages:\n\t__dma_direct_free_pages(dev, page, size);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_alloc_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "130-134",
          "snippet": "static inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_alloc_from_dev_coherent",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "&cpu_addr"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_from_dev_coherent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/coherent.c",
          "lines": "179-189",
          "snippet": "int dma_alloc_from_dev_coherent(struct device *dev, ssize_t size,\n\t\tdma_addr_t *dma_handle, void **ret)\n{\n\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);\n\n\tif (!mem)\n\t\treturn 0;\n\n\t*ret = __dma_alloc_from_coherent(dev, mem, size, dma_handle);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nint dma_alloc_from_dev_coherent(struct device *dev, ssize_t size,\n\t\tdma_addr_t *dma_handle, void **ret)\n{\n\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);\n\n\tif (!mem)\n\t\treturn 0;\n\n\t*ret = __dma_alloc_from_coherent(dev, mem, size, dma_handle);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!dev->coherent_dma_mask"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid *dma_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,\n\t\tgfp_t flag, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tvoid *cpu_addr;\n\n\tWARN_ON_ONCE(!dev->coherent_dma_mask);\n\n\tif (dma_alloc_from_dev_coherent(dev, size, dma_handle, &cpu_addr))\n\t\treturn cpu_addr;\n\n\t/* let the implementation decide on the zone to allocate from: */\n\tflag &= ~(__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\tcpu_addr = dma_direct_alloc(dev, size, dma_handle, flag, attrs);\n\telse if (ops->alloc)\n\t\tcpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);\n\telse\n\t\treturn NULL;\n\n\tdebug_dma_alloc_coherent(dev, size, *dma_handle, cpu_addr, attrs);\n\treturn cpu_addr;\n}"
  },
  {
    "function_name": "dma_get_required_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "467-485",
    "snippet": "u64 dma_get_required_mask(struct device *dev)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_get_required_mask(dev);\n\tif (ops->get_required_mask)\n\t\treturn ops->get_required_mask(dev);\n\n\t/*\n\t * We require every DMA ops implementation to at least support a 32-bit\n\t * DMA mask (and use bounce buffering if that isn't supported in\n\t * hardware).  As the direct mapping code has its own routine to\n\t * actually report an optimal mask we default to 32-bit here as that\n\t * is the right thing for most IOMMUs, and at least not actively\n\t * harmful in general.\n\t */\n\treturn DMA_BIT_MASK(32);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "32"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->get_required_mask",
          "args": [
            "dev"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_get_required_mask",
          "args": [
            "dev"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_get_required_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "39-45",
          "snippet": "u64 dma_direct_get_required_mask(struct device *dev)\n{\n\tphys_addr_t phys = (phys_addr_t)(max_pfn - 1) << PAGE_SHIFT;\n\tu64 max_dma = phys_to_dma_direct(dev, phys);\n\n\treturn (1ULL << (fls64(max_dma) - 1)) * 2 - 1;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nu64 dma_direct_get_required_mask(struct device *dev)\n{\n\tphys_addr_t phys = (phys_addr_t)(max_pfn - 1) << PAGE_SHIFT;\n\tu64 max_dma = phys_to_dma_direct(dev, phys);\n\n\treturn (1ULL << (fls64(max_dma) - 1)) * 2 - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_alloc_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "130-134",
          "snippet": "static inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nu64 dma_get_required_mask(struct device *dev)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_get_required_mask(dev);\n\tif (ops->get_required_mask)\n\t\treturn ops->get_required_mask(dev);\n\n\t/*\n\t * We require every DMA ops implementation to at least support a 32-bit\n\t * DMA mask (and use bounce buffering if that isn't supported in\n\t * hardware).  As the direct mapping code has its own routine to\n\t * actually report an optimal mask we default to 32-bit here as that\n\t * is the right thing for most IOMMUs, and at least not actively\n\t * harmful in general.\n\t */\n\treturn DMA_BIT_MASK(32);\n}"
  },
  {
    "function_name": "dma_mmap_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "452-464",
    "snippet": "int dma_mmap_attrs(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_mmap(dev, vma, cpu_addr, dma_addr, size,\n\t\t\t\tattrs);\n\tif (!ops->mmap)\n\t\treturn -ENXIO;\n\treturn ops->mmap(dev, vma, cpu_addr, dma_addr, size, attrs);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->mmap",
          "args": [
            "dev",
            "vma",
            "cpu_addr",
            "dma_addr",
            "size",
            "attrs"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_mmap",
          "args": [
            "dev",
            "vma",
            "cpu_addr",
            "dma_addr",
            "size",
            "attrs"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_mmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "532-552",
          "snippet": "int dma_direct_mmap(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tunsigned long user_count = vma_pages(vma);\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned long pfn = PHYS_PFN(dma_to_phys(dev, dma_addr));\n\tint ret = -ENXIO;\n\n\tvma->vm_page_prot = dma_pgprot(dev, vma->vm_page_prot, attrs);\n\n\tif (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\tif (dma_mmap_from_global_coherent(vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\n\tif (vma->vm_pgoff >= count || user_count > count - vma->vm_pgoff)\n\t\treturn -ENXIO;\n\treturn remap_pfn_range(vma, vma->vm_start, pfn + vma->vm_pgoff,\n\t\t\tuser_count << PAGE_SHIFT, vma->vm_page_prot);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_direct_mmap(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tunsigned long user_count = vma_pages(vma);\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned long pfn = PHYS_PFN(dma_to_phys(dev, dma_addr));\n\tint ret = -ENXIO;\n\n\tvma->vm_page_prot = dma_pgprot(dev, vma->vm_page_prot, attrs);\n\n\tif (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\tif (dma_mmap_from_global_coherent(vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\n\tif (vma->vm_pgoff >= count || user_count > count - vma->vm_pgoff)\n\t\treturn -ENXIO;\n\treturn remap_pfn_range(vma, vma->vm_start, pfn + vma->vm_pgoff,\n\t\t\tuser_count << PAGE_SHIFT, vma->vm_page_prot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_alloc_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "130-134",
          "snippet": "static inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_mmap_attrs(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_mmap(dev, vma, cpu_addr, dma_addr, size,\n\t\t\t\tattrs);\n\tif (!ops->mmap)\n\t\treturn -ENXIO;\n\treturn ops->mmap(dev, vma, cpu_addr, dma_addr, size, attrs);\n}"
  },
  {
    "function_name": "dma_can_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "429-436",
    "snippet": "bool dma_can_mmap(struct device *dev)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_can_mmap(dev);\n\treturn ops->mmap != NULL;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_direct_can_mmap",
          "args": [
            "dev"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_can_mmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "526-530",
          "snippet": "bool dma_direct_can_mmap(struct device *dev)\n{\n\treturn dev_is_dma_coherent(dev) ||\n\t\tIS_ENABLED(CONFIG_DMA_NONCOHERENT_MMAP);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nbool dma_direct_can_mmap(struct device *dev)\n{\n\treturn dev_is_dma_coherent(dev) ||\n\t\tIS_ENABLED(CONFIG_DMA_NONCOHERENT_MMAP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_alloc_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "130-134",
          "snippet": "static inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nbool dma_can_mmap(struct device *dev)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_can_mmap(dev);\n\treturn ops->mmap != NULL;\n}"
  },
  {
    "function_name": "dma_pgprot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "408-419",
    "snippet": "pgprot_t dma_pgprot(struct device *dev, pgprot_t prot, unsigned long attrs)\n{\n\tif (force_dma_unencrypted(dev))\n\t\tprot = pgprot_decrypted(prot);\n\tif (dev_is_dma_coherent(dev))\n\t\treturn prot;\n#ifdef CONFIG_ARCH_HAS_DMA_WRITE_COMBINE\n\tif (attrs & DMA_ATTR_WRITE_COMBINE)\n\t\treturn pgprot_writecombine(prot);\n#endif\n\treturn pgprot_dmacoherent(prot);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pgprot_dmacoherent",
          "args": [
            "prot"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_writecombine",
          "args": [
            "prot"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_decrypted",
          "args": [
            "prot"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [
            "dev"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\npgprot_t dma_pgprot(struct device *dev, pgprot_t prot, unsigned long attrs)\n{\n\tif (force_dma_unencrypted(dev))\n\t\tprot = pgprot_decrypted(prot);\n\tif (dev_is_dma_coherent(dev))\n\t\treturn prot;\n#ifdef CONFIG_ARCH_HAS_DMA_WRITE_COMBINE\n\tif (attrs & DMA_ATTR_WRITE_COMBINE)\n\t\treturn pgprot_writecombine(prot);\n#endif\n\treturn pgprot_dmacoherent(prot);\n}"
  },
  {
    "function_name": "dma_get_sgtable_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "388-400",
    "snippet": "int dma_get_sgtable_attrs(struct device *dev, struct sg_table *sgt,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_get_sgtable(dev, sgt, cpu_addr, dma_addr,\n\t\t\t\tsize, attrs);\n\tif (!ops->get_sgtable)\n\t\treturn -ENXIO;\n\treturn ops->get_sgtable(dev, sgt, cpu_addr, dma_addr, size, attrs);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->get_sgtable",
          "args": [
            "dev",
            "sgt",
            "cpu_addr",
            "dma_addr",
            "size",
            "attrs"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_get_sgtable",
          "args": [
            "dev",
            "sgt",
            "cpu_addr",
            "dma_addr",
            "size",
            "attrs"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_get_sgtable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "513-524",
          "snippet": "int dma_direct_get_sgtable(struct device *dev, struct sg_table *sgt,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tstruct page *page = dma_direct_to_page(dev, dma_addr);\n\tint ret;\n\n\tret = sg_alloc_table(sgt, 1, GFP_KERNEL);\n\tif (!ret)\n\t\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_direct_get_sgtable(struct device *dev, struct sg_table *sgt,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tstruct page *page = dma_direct_to_page(dev, dma_addr);\n\tint ret;\n\n\tret = sg_alloc_table(sgt, 1, GFP_KERNEL);\n\tif (!ret)\n\t\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_alloc_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "130-134",
          "snippet": "static inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_get_sgtable_attrs(struct device *dev, struct sg_table *sgt,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\treturn dma_direct_get_sgtable(dev, sgt, cpu_addr, dma_addr,\n\t\t\t\tsize, attrs);\n\tif (!ops->get_sgtable)\n\t\treturn -ENXIO;\n\treturn ops->get_sgtable(dev, sgt, cpu_addr, dma_addr, size, attrs);\n}"
  },
  {
    "function_name": "dma_sync_sg_for_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "363-374",
    "snippet": "void dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,\n\t\t       int nelems, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (dma_map_direct(dev, ops))\n\t\tdma_direct_sync_sg_for_device(dev, sg, nelems, dir);\n\telse if (ops->sync_sg_for_device)\n\t\tops->sync_sg_for_device(dev, sg, nelems, dir);\n\tdebug_dma_sync_sg_for_device(dev, sg, nelems, dir);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_dma_sync_sg_for_device",
          "args": [
            "dev",
            "sg",
            "nelems",
            "dir"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_sync_sg_for_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "124-128",
          "snippet": "static inline void debug_dma_sync_sg_for_device(struct device *dev,\n\t\t\t\t\t\tstruct scatterlist *sg,\n\t\t\t\t\t\tint nelems, int direction)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_sync_sg_for_device(struct device *dev,\n\t\t\t\t\t\tstruct scatterlist *sg,\n\t\t\t\t\t\tint nelems, int direction)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->sync_sg_for_device",
          "args": [
            "dev",
            "sg",
            "nelems",
            "dir"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_sync_sg_for_device",
          "args": [
            "dev",
            "sg",
            "nelems",
            "dir"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_sync_sg_for_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "417-434",
          "snippet": "void dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tphys_addr_t paddr = dma_to_phys(dev, sg_dma_address(sg));\n\n\t\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\t\tswiotlb_sync_single_for_device(dev, paddr, sg->length,\n\t\t\t\t\t\t       dir);\n\n\t\tif (!dev_is_dma_coherent(dev))\n\t\t\tarch_sync_dma_for_device(paddr, sg->length,\n\t\t\t\t\tdir);\n\t}\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tphys_addr_t paddr = dma_to_phys(dev, sg_dma_address(sg));\n\n\t\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\t\tswiotlb_sync_single_for_device(dev, paddr, sg->length,\n\t\t\t\t\t\t       dir);\n\n\t\tif (!dev_is_dma_coherent(dev))\n\t\t\tarch_sync_dma_for_device(paddr, sg->length,\n\t\t\t\t\tdir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!valid_dma_direction(dir)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_dma_direction",
          "args": [
            "dir"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,\n\t\t       int nelems, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (dma_map_direct(dev, ops))\n\t\tdma_direct_sync_sg_for_device(dev, sg, nelems, dir);\n\telse if (ops->sync_sg_for_device)\n\t\tops->sync_sg_for_device(dev, sg, nelems, dir);\n\tdebug_dma_sync_sg_for_device(dev, sg, nelems, dir);\n}"
  },
  {
    "function_name": "dma_sync_sg_for_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "349-360",
    "snippet": "void dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,\n\t\t    int nelems, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (dma_map_direct(dev, ops))\n\t\tdma_direct_sync_sg_for_cpu(dev, sg, nelems, dir);\n\telse if (ops->sync_sg_for_cpu)\n\t\tops->sync_sg_for_cpu(dev, sg, nelems, dir);\n\tdebug_dma_sync_sg_for_cpu(dev, sg, nelems, dir);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_dma_sync_sg_for_cpu",
          "args": [
            "dev",
            "sg",
            "nelems",
            "dir"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_sync_sg_for_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "118-122",
          "snippet": "static inline void debug_dma_sync_sg_for_cpu(struct device *dev,\n\t\t\t\t\t     struct scatterlist *sg,\n\t\t\t\t\t     int nelems, int direction)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_sync_sg_for_cpu(struct device *dev,\n\t\t\t\t\t     struct scatterlist *sg,\n\t\t\t\t\t     int nelems, int direction)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->sync_sg_for_cpu",
          "args": [
            "dev",
            "sg",
            "nelems",
            "dir"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_sync_sg_for_cpu",
          "args": [
            "dev",
            "sg",
            "nelems",
            "dir"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_sync_sg_for_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "440-462",
          "snippet": "void dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tphys_addr_t paddr = dma_to_phys(dev, sg_dma_address(sg));\n\n\t\tif (!dev_is_dma_coherent(dev))\n\t\t\tarch_sync_dma_for_cpu(paddr, sg->length, dir);\n\n\t\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\t\tswiotlb_sync_single_for_cpu(dev, paddr, sg->length,\n\t\t\t\t\t\t    dir);\n\n\t\tif (dir == DMA_FROM_DEVICE)\n\t\t\tarch_dma_mark_clean(paddr, sg->length);\n\t}\n\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_sync_dma_for_cpu_all();\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tphys_addr_t paddr = dma_to_phys(dev, sg_dma_address(sg));\n\n\t\tif (!dev_is_dma_coherent(dev))\n\t\t\tarch_sync_dma_for_cpu(paddr, sg->length, dir);\n\n\t\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\t\tswiotlb_sync_single_for_cpu(dev, paddr, sg->length,\n\t\t\t\t\t\t    dir);\n\n\t\tif (dir == DMA_FROM_DEVICE)\n\t\t\tarch_dma_mark_clean(paddr, sg->length);\n\t}\n\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_sync_dma_for_cpu_all();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!valid_dma_direction(dir)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_dma_direction",
          "args": [
            "dir"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,\n\t\t    int nelems, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (dma_map_direct(dev, ops))\n\t\tdma_direct_sync_sg_for_cpu(dev, sg, nelems, dir);\n\telse if (ops->sync_sg_for_cpu)\n\t\tops->sync_sg_for_cpu(dev, sg, nelems, dir);\n\tdebug_dma_sync_sg_for_cpu(dev, sg, nelems, dir);\n}"
  },
  {
    "function_name": "dma_sync_single_for_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "335-346",
    "snippet": "void dma_sync_single_for_device(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (dma_map_direct(dev, ops))\n\t\tdma_direct_sync_single_for_device(dev, addr, size, dir);\n\telse if (ops->sync_single_for_device)\n\t\tops->sync_single_for_device(dev, addr, size, dir);\n\tdebug_dma_sync_single_for_device(dev, addr, size, dir);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_dma_sync_single_for_device",
          "args": [
            "dev",
            "addr",
            "size",
            "dir"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_sync_single_for_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "112-116",
          "snippet": "static inline void debug_dma_sync_single_for_device(struct device *dev,\n\t\t\t\t\t\t    dma_addr_t dma_handle,\n\t\t\t\t\t\t    size_t size, int direction)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_sync_single_for_device(struct device *dev,\n\t\t\t\t\t\t    dma_addr_t dma_handle,\n\t\t\t\t\t\t    size_t size, int direction)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->sync_single_for_device",
          "args": [
            "dev",
            "addr",
            "size",
            "dir"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_sync_single_for_device",
          "args": [
            "dev",
            "addr",
            "size",
            "dir"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_sync_single_for_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
          "lines": "54-64",
          "snippet": "static inline void dma_direct_sync_single_for_device(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_device(dev, paddr, size, dir);\n\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_sync_dma_for_device(paddr, size, dir);\n}",
          "includes": [
            "#include <linux/dma-direct.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline void dma_direct_sync_single_for_device(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_device(dev, paddr, size, dir);\n\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_sync_dma_for_device(paddr, size, dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!valid_dma_direction(dir)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_dma_direction",
          "args": [
            "dir"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_sync_single_for_device(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (dma_map_direct(dev, ops))\n\t\tdma_direct_sync_single_for_device(dev, addr, size, dir);\n\telse if (ops->sync_single_for_device)\n\t\tops->sync_single_for_device(dev, addr, size, dir);\n\tdebug_dma_sync_single_for_device(dev, addr, size, dir);\n}"
  },
  {
    "function_name": "dma_sync_single_for_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "321-332",
    "snippet": "void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size,\n\t\tenum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (dma_map_direct(dev, ops))\n\t\tdma_direct_sync_single_for_cpu(dev, addr, size, dir);\n\telse if (ops->sync_single_for_cpu)\n\t\tops->sync_single_for_cpu(dev, addr, size, dir);\n\tdebug_dma_sync_single_for_cpu(dev, addr, size, dir);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_dma_sync_single_for_cpu",
          "args": [
            "dev",
            "addr",
            "size",
            "dir"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_sync_single_for_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "106-110",
          "snippet": "static inline void debug_dma_sync_single_for_cpu(struct device *dev,\n\t\t\t\t\t\t dma_addr_t dma_handle,\n\t\t\t\t\t\t size_t size, int direction)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_sync_single_for_cpu(struct device *dev,\n\t\t\t\t\t\t dma_addr_t dma_handle,\n\t\t\t\t\t\t size_t size, int direction)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->sync_single_for_cpu",
          "args": [
            "dev",
            "addr",
            "size",
            "dir"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_sync_single_for_cpu",
          "args": [
            "dev",
            "addr",
            "size",
            "dir"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_sync_single_for_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
          "lines": "66-81",
          "snippet": "static inline void dma_direct_sync_single_for_cpu(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\tarch_sync_dma_for_cpu(paddr, size, dir);\n\t\tarch_sync_dma_for_cpu_all();\n\t}\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_cpu(dev, paddr, size, dir);\n\n\tif (dir == DMA_FROM_DEVICE)\n\t\tarch_dma_mark_clean(paddr, size);\n}",
          "includes": [
            "#include <linux/dma-direct.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline void dma_direct_sync_single_for_cpu(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\tarch_sync_dma_for_cpu(paddr, size, dir);\n\t\tarch_sync_dma_for_cpu_all();\n\t}\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_cpu(dev, paddr, size, dir);\n\n\tif (dir == DMA_FROM_DEVICE)\n\t\tarch_dma_mark_clean(paddr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!valid_dma_direction(dir)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_dma_direction",
          "args": [
            "dir"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size,\n\t\tenum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (dma_map_direct(dev, ops))\n\t\tdma_direct_sync_single_for_cpu(dev, addr, size, dir);\n\telse if (ops->sync_single_for_cpu)\n\t\tops->sync_single_for_cpu(dev, addr, size, dir);\n\tdebug_dma_sync_single_for_cpu(dev, addr, size, dir);\n}"
  },
  {
    "function_name": "dma_unmap_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "309-318",
    "snippet": "void dma_unmap_resource(struct device *dev, dma_addr_t addr, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (!dma_map_direct(dev, ops) && ops->unmap_resource)\n\t\tops->unmap_resource(dev, addr, size, dir, attrs);\n\tdebug_dma_unmap_resource(dev, addr, size, dir);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_dma_unmap_resource",
          "args": [
            "dev",
            "addr",
            "size",
            "dir"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_unmap_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "100-104",
          "snippet": "static inline void debug_dma_unmap_resource(struct device *dev,\n\t\t\t\t\t    dma_addr_t dma_addr, size_t size,\n\t\t\t\t\t    int direction)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_unmap_resource(struct device *dev,\n\t\t\t\t\t    dma_addr_t dma_addr, size_t size,\n\t\t\t\t\t    int direction)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->unmap_resource",
          "args": [
            "dev",
            "addr",
            "size",
            "dir",
            "attrs"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!valid_dma_direction(dir)"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_dma_direction",
          "args": [
            "dir"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_unmap_resource(struct device *dev, dma_addr_t addr, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (!dma_map_direct(dev, ops) && ops->unmap_resource)\n\t\tops->unmap_resource(dev, addr, size, dir, attrs);\n\tdebug_dma_unmap_resource(dev, addr, size, dir);\n}"
  },
  {
    "function_name": "dma_map_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "288-306",
    "snippet": "dma_addr_t dma_map_resource(struct device *dev, phys_addr_t phys_addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tdma_addr_t addr = DMA_MAPPING_ERROR;\n\n\tBUG_ON(!valid_dma_direction(dir));\n\n\tif (WARN_ON_ONCE(!dev->dma_mask))\n\t\treturn DMA_MAPPING_ERROR;\n\n\tif (dma_map_direct(dev, ops))\n\t\taddr = dma_direct_map_resource(dev, phys_addr, size, dir, attrs);\n\telse if (ops->map_resource)\n\t\taddr = ops->map_resource(dev, phys_addr, size, dir, attrs);\n\n\tdebug_dma_map_resource(dev, phys_addr, size, dir, addr, attrs);\n\treturn addr;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_dma_map_resource",
          "args": [
            "dev",
            "phys_addr",
            "size",
            "dir",
            "addr",
            "attrs"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_map_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "93-98",
          "snippet": "static inline void debug_dma_map_resource(struct device *dev, phys_addr_t addr,\n\t\t\t\t\t  size_t size, int direction,\n\t\t\t\t\t  dma_addr_t dma_addr,\n\t\t\t\t\t  unsigned long attrs)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_map_resource(struct device *dev, phys_addr_t addr,\n\t\t\t\t\t  size_t size, int direction,\n\t\t\t\t\t  dma_addr_t dma_addr,\n\t\t\t\t\t  unsigned long attrs)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->map_resource",
          "args": [
            "dev",
            "phys_addr",
            "size",
            "dir",
            "attrs"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_map_resource",
          "args": [
            "dev",
            "phys_addr",
            "size",
            "dir",
            "attrs"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_map_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "497-511",
          "snippet": "dma_addr_t dma_direct_map_resource(struct device *dev, phys_addr_t paddr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tdma_addr_t dma_addr = paddr;\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, false))) {\n\t\tdev_err_once(dev,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\tWARN_ON_ONCE(1);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\treturn dma_addr;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\ndma_addr_t dma_direct_map_resource(struct device *dev, phys_addr_t paddr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tdma_addr_t dma_addr = paddr;\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, false))) {\n\t\tdev_err_once(dev,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\tWARN_ON_ONCE(1);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\treturn dma_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!dev->dma_mask"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!valid_dma_direction(dir)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_dma_direction",
          "args": [
            "dir"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\ndma_addr_t dma_map_resource(struct device *dev, phys_addr_t phys_addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tdma_addr_t addr = DMA_MAPPING_ERROR;\n\n\tBUG_ON(!valid_dma_direction(dir));\n\n\tif (WARN_ON_ONCE(!dev->dma_mask))\n\t\treturn DMA_MAPPING_ERROR;\n\n\tif (dma_map_direct(dev, ops))\n\t\taddr = dma_direct_map_resource(dev, phys_addr, size, dir, attrs);\n\telse if (ops->map_resource)\n\t\taddr = ops->map_resource(dev, phys_addr, size, dir, attrs);\n\n\tdebug_dma_map_resource(dev, phys_addr, size, dir, addr, attrs);\n\treturn addr;\n}"
  },
  {
    "function_name": "dma_unmap_sg_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "272-285",
    "snippet": "void dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sg,\n\t\t\t\t      int nents, enum dma_data_direction dir,\n\t\t\t\t      unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tdebug_dma_unmap_sg(dev, sg, nents, dir);\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_unmap_sg_direct(dev, sg, nents))\n\t\tdma_direct_unmap_sg(dev, sg, nents, dir, attrs);\n\telse if (ops->unmap_sg)\n\t\tops->unmap_sg(dev, sg, nents, dir, attrs);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->unmap_sg",
          "args": [
            "dev",
            "sg",
            "nents",
            "dir",
            "attrs"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_unmap_sg",
          "args": [
            "dev",
            "sg",
            "nents",
            "dir",
            "attrs"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_unmap_sg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "464-473",
          "snippet": "void dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,\n\t\tint nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tdma_direct_unmap_page(dev, sg->dma_address, sg_dma_len(sg), dir,\n\t\t\t     attrs);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,\n\t\tint nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tdma_direct_unmap_page(dev, sg->dma_address, sg_dma_len(sg), dir,\n\t\t\t     attrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_dma_unmap_sg_direct",
          "args": [
            "dev",
            "sg",
            "nents"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_dma_unmap_sg",
          "args": [
            "dev",
            "sg",
            "nents",
            "dir"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_unmap_sg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "76-80",
          "snippet": "static inline void debug_dma_unmap_sg(struct device *dev,\n\t\t\t\t      struct scatterlist *sglist,\n\t\t\t\t      int nelems, int dir)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_unmap_sg(struct device *dev,\n\t\t\t\t      struct scatterlist *sglist,\n\t\t\t\t      int nelems, int dir)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!valid_dma_direction(dir)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_dma_direction",
          "args": [
            "dir"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sg,\n\t\t\t\t      int nents, enum dma_data_direction dir,\n\t\t\t\t      unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tdebug_dma_unmap_sg(dev, sg, nents, dir);\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_unmap_sg_direct(dev, sg, nents))\n\t\tdma_direct_unmap_sg(dev, sg, nents, dir, attrs);\n\telse if (ops->unmap_sg)\n\t\tops->unmap_sg(dev, sg, nents, dir, attrs);\n}"
  },
  {
    "function_name": "dma_map_sgtable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "259-269",
    "snippet": "int dma_map_sgtable(struct device *dev, struct sg_table *sgt,\n\t\t    enum dma_data_direction dir, unsigned long attrs)\n{\n\tint nents;\n\n\tnents = __dma_map_sg_attrs(dev, sgt->sgl, sgt->orig_nents, dir, attrs);\n\tif (nents < 0)\n\t\treturn nents;\n\tsgt->nents = nents;\n\treturn 0;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_map_sg_attrs",
          "args": [
            "dev",
            "sgt->sgl",
            "sgt->orig_nents",
            "dir",
            "attrs"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_map_sg_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "180-204",
          "snippet": "static int __dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,\n\t int nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tint ents;\n\n\tBUG_ON(!valid_dma_direction(dir));\n\n\tif (WARN_ON_ONCE(!dev->dma_mask))\n\t\treturn 0;\n\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_map_sg_direct(dev, sg, nents))\n\t\tents = dma_direct_map_sg(dev, sg, nents, dir, attrs);\n\telse\n\t\tents = ops->map_sg(dev, sg, nents, dir, attrs);\n\n\tif (ents > 0)\n\t\tdebug_dma_map_sg(dev, sg, nents, ents, dir, attrs);\n\telse if (WARN_ON_ONCE(ents != -EINVAL && ents != -ENOMEM &&\n\t\t\t      ents != -EIO))\n\t\treturn -EIO;\n\n\treturn ents;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic int __dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,\n\t int nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tint ents;\n\n\tBUG_ON(!valid_dma_direction(dir));\n\n\tif (WARN_ON_ONCE(!dev->dma_mask))\n\t\treturn 0;\n\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_map_sg_direct(dev, sg, nents))\n\t\tents = dma_direct_map_sg(dev, sg, nents, dir, attrs);\n\telse\n\t\tents = ops->map_sg(dev, sg, nents, dir, attrs);\n\n\tif (ents > 0)\n\t\tdebug_dma_map_sg(dev, sg, nents, ents, dir, attrs);\n\telse if (WARN_ON_ONCE(ents != -EINVAL && ents != -ENOMEM &&\n\t\t\t      ents != -EIO))\n\t\treturn -EIO;\n\n\treturn ents;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_map_sgtable(struct device *dev, struct sg_table *sgt,\n\t\t    enum dma_data_direction dir, unsigned long attrs)\n{\n\tint nents;\n\n\tnents = __dma_map_sg_attrs(dev, sgt->sgl, sgt->orig_nents, dir, attrs);\n\tif (nents < 0)\n\t\treturn nents;\n\tsgt->nents = nents;\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_map_sg_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "223-232",
    "snippet": "unsigned int dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,\n\t\t    int nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tint ret;\n\n\tret = __dma_map_sg_attrs(dev, sg, nents, dir, attrs);\n\tif (ret < 0)\n\t\treturn 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_map_sg_attrs",
          "args": [
            "dev",
            "sg",
            "nents",
            "dir",
            "attrs"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_map_sg_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "180-204",
          "snippet": "static int __dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,\n\t int nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tint ents;\n\n\tBUG_ON(!valid_dma_direction(dir));\n\n\tif (WARN_ON_ONCE(!dev->dma_mask))\n\t\treturn 0;\n\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_map_sg_direct(dev, sg, nents))\n\t\tents = dma_direct_map_sg(dev, sg, nents, dir, attrs);\n\telse\n\t\tents = ops->map_sg(dev, sg, nents, dir, attrs);\n\n\tif (ents > 0)\n\t\tdebug_dma_map_sg(dev, sg, nents, ents, dir, attrs);\n\telse if (WARN_ON_ONCE(ents != -EINVAL && ents != -ENOMEM &&\n\t\t\t      ents != -EIO))\n\t\treturn -EIO;\n\n\treturn ents;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic int __dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,\n\t int nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tint ents;\n\n\tBUG_ON(!valid_dma_direction(dir));\n\n\tif (WARN_ON_ONCE(!dev->dma_mask))\n\t\treturn 0;\n\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_map_sg_direct(dev, sg, nents))\n\t\tents = dma_direct_map_sg(dev, sg, nents, dir, attrs);\n\telse\n\t\tents = ops->map_sg(dev, sg, nents, dir, attrs);\n\n\tif (ents > 0)\n\t\tdebug_dma_map_sg(dev, sg, nents, ents, dir, attrs);\n\telse if (WARN_ON_ONCE(ents != -EINVAL && ents != -ENOMEM &&\n\t\t\t      ents != -EIO))\n\t\treturn -EIO;\n\n\treturn ents;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nunsigned int dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,\n\t\t    int nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tint ret;\n\n\tret = __dma_map_sg_attrs(dev, sg, nents, dir, attrs);\n\tif (ret < 0)\n\t\treturn 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "__dma_map_sg_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "180-204",
    "snippet": "static int __dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,\n\t int nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tint ents;\n\n\tBUG_ON(!valid_dma_direction(dir));\n\n\tif (WARN_ON_ONCE(!dev->dma_mask))\n\t\treturn 0;\n\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_map_sg_direct(dev, sg, nents))\n\t\tents = dma_direct_map_sg(dev, sg, nents, dir, attrs);\n\telse\n\t\tents = ops->map_sg(dev, sg, nents, dir, attrs);\n\n\tif (ents > 0)\n\t\tdebug_dma_map_sg(dev, sg, nents, ents, dir, attrs);\n\telse if (WARN_ON_ONCE(ents != -EINVAL && ents != -ENOMEM &&\n\t\t\t      ents != -EIO))\n\t\treturn -EIO;\n\n\treturn ents;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ents != -EINVAL && ents != -ENOMEM &&\n\t\t\t      ents != -EIO"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_dma_map_sg",
          "args": [
            "dev",
            "sg",
            "nents",
            "ents",
            "dir",
            "attrs"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_map_sg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "70-74",
          "snippet": "static inline void debug_dma_map_sg(struct device *dev, struct scatterlist *sg,\n\t\t\t\t    int nents, int mapped_ents, int direction,\n\t\t\t\t    unsigned long attrs)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_map_sg(struct device *dev, struct scatterlist *sg,\n\t\t\t\t    int nents, int mapped_ents, int direction,\n\t\t\t\t    unsigned long attrs)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->map_sg",
          "args": [
            "dev",
            "sg",
            "nents",
            "dir",
            "attrs"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_map_sg",
          "args": [
            "dev",
            "sg",
            "nents",
            "dir",
            "attrs"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_map_sg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "476-495",
          "snippet": "int dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tsg->dma_address = dma_direct_map_page(dev, sg_page(sg),\n\t\t\t\tsg->offset, sg->length, dir, attrs);\n\t\tif (sg->dma_address == DMA_MAPPING_ERROR)\n\t\t\tgoto out_unmap;\n\t\tsg_dma_len(sg) = sg->length;\n\t}\n\n\treturn nents;\n\nout_unmap:\n\tdma_direct_unmap_sg(dev, sgl, i, dir, attrs | DMA_ATTR_SKIP_CPU_SYNC);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tsg->dma_address = dma_direct_map_page(dev, sg_page(sg),\n\t\t\t\tsg->offset, sg->length, dir, attrs);\n\t\tif (sg->dma_address == DMA_MAPPING_ERROR)\n\t\t\tgoto out_unmap;\n\t\tsg_dma_len(sg) = sg->length;\n\t}\n\n\treturn nents;\n\nout_unmap:\n\tdma_direct_unmap_sg(dev, sgl, i, dir, attrs | DMA_ATTR_SKIP_CPU_SYNC);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_dma_map_sg_direct",
          "args": [
            "dev",
            "sg",
            "nents"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!dev->dma_mask"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!valid_dma_direction(dir)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_dma_direction",
          "args": [
            "dir"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic int __dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,\n\t int nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tint ents;\n\n\tBUG_ON(!valid_dma_direction(dir));\n\n\tif (WARN_ON_ONCE(!dev->dma_mask))\n\t\treturn 0;\n\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_map_sg_direct(dev, sg, nents))\n\t\tents = dma_direct_map_sg(dev, sg, nents, dir, attrs);\n\telse\n\t\tents = ops->map_sg(dev, sg, nents, dir, attrs);\n\n\tif (ents > 0)\n\t\tdebug_dma_map_sg(dev, sg, nents, ents, dir, attrs);\n\telse if (WARN_ON_ONCE(ents != -EINVAL && ents != -ENOMEM &&\n\t\t\t      ents != -EIO))\n\t\treturn -EIO;\n\n\treturn ents;\n}"
  },
  {
    "function_name": "dma_unmap_page_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "165-177",
    "snippet": "void dma_unmap_page_attrs(struct device *dev, dma_addr_t addr, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_unmap_page_direct(dev, addr + size))\n\t\tdma_direct_unmap_page(dev, addr, size, dir, attrs);\n\telse if (ops->unmap_page)\n\t\tops->unmap_page(dev, addr, size, dir, attrs);\n\tdebug_dma_unmap_page(dev, addr, size, dir);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_dma_unmap_page",
          "args": [
            "dev",
            "addr",
            "size",
            "dir"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_unmap_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "65-68",
          "snippet": "static inline void debug_dma_unmap_page(struct device *dev, dma_addr_t addr,\n\t\t\t\t\tsize_t size, int direction)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_unmap_page(struct device *dev, dma_addr_t addr,\n\t\t\t\t\tsize_t size, int direction)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->unmap_page",
          "args": [
            "dev",
            "addr",
            "size",
            "dir",
            "attrs"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_unmap_page",
          "args": [
            "dev",
            "addr",
            "size",
            "dir",
            "attrs"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_unmap_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
          "lines": "108-118",
          "snippet": "static inline void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = dma_to_phys(dev, addr);\n\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_single_for_cpu(dev, addr, size, dir);\n\n\tif (unlikely(is_swiotlb_buffer(dev, phys)))\n\t\tswiotlb_tbl_unmap_single(dev, phys, size, dir, attrs);\n}",
          "includes": [
            "#include <linux/dma-direct.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = dma_to_phys(dev, addr);\n\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_single_for_cpu(dev, addr, size, dir);\n\n\tif (unlikely(is_swiotlb_buffer(dev, phys)))\n\t\tswiotlb_tbl_unmap_single(dev, phys, size, dir, attrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_dma_unmap_page_direct",
          "args": [
            "dev",
            "addr + size"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!valid_dma_direction(dir)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_dma_direction",
          "args": [
            "dir"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_unmap_page_attrs(struct device *dev, dma_addr_t addr, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_unmap_page_direct(dev, addr + size))\n\t\tdma_direct_unmap_page(dev, addr, size, dir, attrs);\n\telse if (ops->unmap_page)\n\t\tops->unmap_page(dev, addr, size, dir, attrs);\n\tdebug_dma_unmap_page(dev, addr, size, dir);\n}"
  },
  {
    "function_name": "dma_map_page_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "142-162",
    "snippet": "dma_addr_t dma_map_page_attrs(struct device *dev, struct page *page,\n\t\tsize_t offset, size_t size, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tdma_addr_t addr;\n\n\tBUG_ON(!valid_dma_direction(dir));\n\n\tif (WARN_ON_ONCE(!dev->dma_mask))\n\t\treturn DMA_MAPPING_ERROR;\n\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_map_page_direct(dev, page_to_phys(page) + offset + size))\n\t\taddr = dma_direct_map_page(dev, page, offset, size, dir, attrs);\n\telse\n\t\taddr = ops->map_page(dev, page, offset, size, dir, attrs);\n\tdebug_dma_map_page(dev, page, offset, size, dir, addr, attrs);\n\n\treturn addr;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_dma_map_page",
          "args": [
            "dev",
            "page",
            "offset",
            "size",
            "dir",
            "addr",
            "attrs"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_map_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "58-63",
          "snippet": "static inline void debug_dma_map_page(struct device *dev, struct page *page,\n\t\t\t\t      size_t offset, size_t size,\n\t\t\t\t      int direction, dma_addr_t dma_addr,\n\t\t\t\t      unsigned long attrs)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_map_page(struct device *dev, struct page *page,\n\t\t\t\t      size_t offset, size_t size,\n\t\t\t\t      int direction, dma_addr_t dma_addr,\n\t\t\t\t      unsigned long attrs)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->map_page",
          "args": [
            "dev",
            "page",
            "offset",
            "size",
            "dir",
            "attrs"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_map_page",
          "args": [
            "dev",
            "page",
            "offset",
            "size",
            "dir",
            "attrs"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_map_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
          "lines": "83-106",
          "snippet": "static inline dma_addr_t dma_direct_map_page(struct device *dev,\n\t\tstruct page *page, unsigned long offset, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dma_addr = phys_to_dma(dev, phys);\n\n\tif (is_swiotlb_force_bounce(dev))\n\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, true))) {\n\t\tif (swiotlb_force != SWIOTLB_NO_FORCE)\n\t\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tarch_sync_dma_for_device(phys, size, dir);\n\treturn dma_addr;\n}",
          "includes": [
            "#include <linux/dma-direct.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline dma_addr_t dma_direct_map_page(struct device *dev,\n\t\tstruct page *page, unsigned long offset, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dma_addr = phys_to_dma(dev, phys);\n\n\tif (is_swiotlb_force_bounce(dev))\n\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, true))) {\n\t\tif (swiotlb_force != SWIOTLB_NO_FORCE)\n\t\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tarch_sync_dma_for_device(phys, size, dir);\n\treturn dma_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_dma_map_page_direct",
          "args": [
            "dev",
            "page_to_phys(page) + offset + size"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_map_direct",
          "args": [
            "dev",
            "ops"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "dma_map_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "136-140",
          "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!dev->dma_mask"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!valid_dma_direction(dir)"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_dma_direction",
          "args": [
            "dir"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\ndma_addr_t dma_map_page_attrs(struct device *dev, struct page *page,\n\t\tsize_t offset, size_t size, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tdma_addr_t addr;\n\n\tBUG_ON(!valid_dma_direction(dir));\n\n\tif (WARN_ON_ONCE(!dev->dma_mask))\n\t\treturn DMA_MAPPING_ERROR;\n\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_map_page_direct(dev, page_to_phys(page) + offset + size))\n\t\taddr = dma_direct_map_page(dev, page, offset, size, dir, attrs);\n\telse\n\t\taddr = ops->map_page(dev, page, offset, size, dir, attrs);\n\tdebug_dma_map_page(dev, page, offset, size, dir, addr, attrs);\n\n\treturn addr;\n}"
  },
  {
    "function_name": "dma_map_direct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "136-140",
    "snippet": "static inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_go_direct",
          "args": [
            "dev",
            "*dev->dma_mask",
            "ops"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "dma_go_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "111-122",
          "snippet": "static bool dma_go_direct(struct device *dev, dma_addr_t mask,\n\t\tconst struct dma_map_ops *ops)\n{\n\tif (likely(!ops))\n\t\treturn true;\n#ifdef CONFIG_DMA_OPS_BYPASS\n\tif (dev->dma_ops_bypass)\n\t\treturn min_not_zero(mask, dev->bus_dma_limit) >=\n\t\t\t    dma_direct_get_required_mask(dev);\n#endif\n\treturn false;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool dma_go_direct(struct device *dev, dma_addr_t mask,\n\t\tconst struct dma_map_ops *ops)\n{\n\tif (likely(!ops))\n\t\treturn true;\n#ifdef CONFIG_DMA_OPS_BYPASS\n\tif (dev->dma_ops_bypass)\n\t\treturn min_not_zero(mask, dev->bus_dma_limit) >=\n\t\t\t    dma_direct_get_required_mask(dev);\n#endif\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_map_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, *dev->dma_mask, ops);\n}"
  },
  {
    "function_name": "dma_alloc_direct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "130-134",
    "snippet": "static inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_go_direct",
          "args": [
            "dev",
            "dev->coherent_dma_mask",
            "ops"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "dma_go_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "111-122",
          "snippet": "static bool dma_go_direct(struct device *dev, dma_addr_t mask,\n\t\tconst struct dma_map_ops *ops)\n{\n\tif (likely(!ops))\n\t\treturn true;\n#ifdef CONFIG_DMA_OPS_BYPASS\n\tif (dev->dma_ops_bypass)\n\t\treturn min_not_zero(mask, dev->bus_dma_limit) >=\n\t\t\t    dma_direct_get_required_mask(dev);\n#endif\n\treturn false;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool dma_go_direct(struct device *dev, dma_addr_t mask,\n\t\tconst struct dma_map_ops *ops)\n{\n\tif (likely(!ops))\n\t\treturn true;\n#ifdef CONFIG_DMA_OPS_BYPASS\n\tif (dev->dma_ops_bypass)\n\t\treturn min_not_zero(mask, dev->bus_dma_limit) >=\n\t\t\t    dma_direct_get_required_mask(dev);\n#endif\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline bool dma_alloc_direct(struct device *dev,\n\t\tconst struct dma_map_ops *ops)\n{\n\treturn dma_go_direct(dev, dev->coherent_dma_mask, ops);\n}"
  },
  {
    "function_name": "dma_go_direct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "111-122",
    "snippet": "static bool dma_go_direct(struct device *dev, dma_addr_t mask,\n\t\tconst struct dma_map_ops *ops)\n{\n\tif (likely(!ops))\n\t\treturn true;\n#ifdef CONFIG_DMA_OPS_BYPASS\n\tif (dev->dma_ops_bypass)\n\t\treturn min_not_zero(mask, dev->bus_dma_limit) >=\n\t\t\t    dma_direct_get_required_mask(dev);\n#endif\n\treturn false;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_direct_get_required_mask",
          "args": [
            "dev"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_get_required_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "39-45",
          "snippet": "u64 dma_direct_get_required_mask(struct device *dev)\n{\n\tphys_addr_t phys = (phys_addr_t)(max_pfn - 1) << PAGE_SHIFT;\n\tu64 max_dma = phys_to_dma_direct(dev, phys);\n\n\treturn (1ULL << (fls64(max_dma) - 1)) * 2 - 1;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nu64 dma_direct_get_required_mask(struct device *dev)\n{\n\tphys_addr_t phys = (phys_addr_t)(max_pfn - 1) << PAGE_SHIFT;\n\tu64 max_dma = phys_to_dma_direct(dev, phys);\n\n\treturn (1ULL << (fls64(max_dma) - 1)) * 2 - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_not_zero",
          "args": [
            "mask",
            "dev->bus_dma_limit"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ops"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool dma_go_direct(struct device *dev, dma_addr_t mask,\n\t\tconst struct dma_map_ops *ops)\n{\n\tif (likely(!ops))\n\t\treturn true;\n#ifdef CONFIG_DMA_OPS_BYPASS\n\tif (dev->dma_ops_bypass)\n\t\treturn min_not_zero(mask, dev->bus_dma_limit) >=\n\t\t\t    dma_direct_get_required_mask(dev);\n#endif\n\treturn false;\n}"
  },
  {
    "function_name": "dmam_alloc_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "84-108",
    "snippet": "void *dmam_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,\n\t\tgfp_t gfp, unsigned long attrs)\n{\n\tstruct dma_devres *dr;\n\tvoid *vaddr;\n\n\tdr = devres_alloc(dmam_release, sizeof(*dr), gfp);\n\tif (!dr)\n\t\treturn NULL;\n\n\tvaddr = dma_alloc_attrs(dev, size, dma_handle, gfp, attrs);\n\tif (!vaddr) {\n\t\tdevres_free(dr);\n\t\treturn NULL;\n\t}\n\n\tdr->vaddr = vaddr;\n\tdr->dma_handle = *dma_handle;\n\tdr->size = size;\n\tdr->attrs = attrs;\n\n\tdevres_add(dev, dr);\n\n\treturn vaddr;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "dr"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "dr"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_alloc_attrs",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "gfp",
            "attrs"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "488-511",
          "snippet": "void *dma_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,\n\t\tgfp_t flag, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tvoid *cpu_addr;\n\n\tWARN_ON_ONCE(!dev->coherent_dma_mask);\n\n\tif (dma_alloc_from_dev_coherent(dev, size, dma_handle, &cpu_addr))\n\t\treturn cpu_addr;\n\n\t/* let the implementation decide on the zone to allocate from: */\n\tflag &= ~(__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\tcpu_addr = dma_direct_alloc(dev, size, dma_handle, flag, attrs);\n\telse if (ops->alloc)\n\t\tcpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);\n\telse\n\t\treturn NULL;\n\n\tdebug_dma_alloc_coherent(dev, size, *dma_handle, cpu_addr, attrs);\n\treturn cpu_addr;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid *dma_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,\n\t\tgfp_t flag, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tvoid *cpu_addr;\n\n\tWARN_ON_ONCE(!dev->coherent_dma_mask);\n\n\tif (dma_alloc_from_dev_coherent(dev, size, dma_handle, &cpu_addr))\n\t\treturn cpu_addr;\n\n\t/* let the implementation decide on the zone to allocate from: */\n\tflag &= ~(__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM);\n\n\tif (dma_alloc_direct(dev, ops))\n\t\tcpu_addr = dma_direct_alloc(dev, size, dma_handle, flag, attrs);\n\telse if (ops->alloc)\n\t\tcpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);\n\telse\n\t\treturn NULL;\n\n\tdebug_dma_alloc_coherent(dev, size, *dma_handle, cpu_addr, attrs);\n\treturn cpu_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "dmam_release",
            "sizeof(*dr)",
            "gfp"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid *dmam_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,\n\t\tgfp_t gfp, unsigned long attrs)\n{\n\tstruct dma_devres *dr;\n\tvoid *vaddr;\n\n\tdr = devres_alloc(dmam_release, sizeof(*dr), gfp);\n\tif (!dr)\n\t\treturn NULL;\n\n\tvaddr = dma_alloc_attrs(dev, size, dma_handle, gfp, attrs);\n\tif (!vaddr) {\n\t\tdevres_free(dr);\n\t\treturn NULL;\n\t}\n\n\tdr->vaddr = vaddr;\n\tdr->dma_handle = *dma_handle;\n\tdr->size = size;\n\tdr->attrs = attrs;\n\n\tdevres_add(dev, dr);\n\n\treturn vaddr;\n}"
  },
  {
    "function_name": "dmam_free_coherent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "60-67",
    "snippet": "void dmam_free_coherent(struct device *dev, size_t size, void *vaddr,\n\t\t\tdma_addr_t dma_handle)\n{\n\tstruct dma_devres match_data = { size, vaddr, dma_handle };\n\n\tdma_free_coherent(dev, size, vaddr, dma_handle);\n\tWARN_ON(devres_destroy(dev, dmam_release, dmam_match, &match_data));\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "devres_destroy(dev, dmam_release, dmam_match, &match_data)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_destroy",
          "args": [
            "dev",
            "dmam_release",
            "dmam_match",
            "&match_data"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_free_coherent",
          "args": [
            "dev",
            "size",
            "vaddr",
            "dma_handle"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_free_coherent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.h",
          "lines": "88-91",
          "snippet": "static inline void debug_dma_free_coherent(struct device *dev, size_t size,\n\t\t\t\t\t   void *virt, dma_addr_t addr)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void debug_dma_free_coherent(struct device *dev, size_t size,\n\t\t\t\t\t   void *virt, dma_addr_t addr)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dmam_free_coherent(struct device *dev, size_t size, void *vaddr,\n\t\t\tdma_addr_t dma_handle)\n{\n\tstruct dma_devres match_data = { size, vaddr, dma_handle };\n\n\tdma_free_coherent(dev, size, vaddr, dma_handle);\n\tWARN_ON(devres_destroy(dev, dmam_release, dmam_match, &match_data));\n}"
  },
  {
    "function_name": "dmam_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "39-49",
    "snippet": "static int dmam_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct dma_devres *this = res, *match = match_data;\n\n\tif (this->vaddr == match->vaddr) {\n\t\tWARN_ON(this->size != match->size ||\n\t\t\tthis->dma_handle != match->dma_handle);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "this->size != match->size ||\n\t\t\tthis->dma_handle != match->dma_handle"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic int dmam_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct dma_devres *this = res, *match = match_data;\n\n\tif (this->vaddr == match->vaddr) {\n\t\tWARN_ON(this->size != match->size ||\n\t\t\tthis->dma_handle != match->dma_handle);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dmam_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
    "lines": "31-37",
    "snippet": "static void dmam_release(struct device *dev, void *res)\n{\n\tstruct dma_devres *this = res;\n\n\tdma_free_attrs(dev, this->size, this->vaddr, this->dma_handle,\n\t\t\tthis->attrs);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include \"debug.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/acpi.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_free_attrs",
          "args": [
            "dev",
            "this->size",
            "this->vaddr",
            "this->dma_handle",
            "this->attrs"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "dma_free_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "514-538",
          "snippet": "void dma_free_attrs(struct device *dev, size_t size, void *cpu_addr,\n\t\tdma_addr_t dma_handle, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_release_from_dev_coherent(dev, get_order(size), cpu_addr))\n\t\treturn;\n\t/*\n\t * On non-coherent platforms which implement DMA-coherent buffers via\n\t * non-cacheable remaps, ops->free() may call vunmap(). Thus getting\n\t * this far in IRQ context is a) at risk of a BUG_ON() or trying to\n\t * sleep on some machines, and b) an indication that the driver is\n\t * probably misusing the coherent API anyway.\n\t */\n\tWARN_ON(irqs_disabled());\n\n\tif (!cpu_addr)\n\t\treturn;\n\n\tdebug_dma_free_coherent(dev, size, cpu_addr, dma_handle);\n\tif (dma_alloc_direct(dev, ops))\n\t\tdma_direct_free(dev, size, cpu_addr, dma_handle, attrs);\n\telse if (ops->free)\n\t\tops->free(dev, size, cpu_addr, dma_handle, attrs);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_free_attrs(struct device *dev, size_t size, void *cpu_addr,\n\t\tdma_addr_t dma_handle, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (dma_release_from_dev_coherent(dev, get_order(size), cpu_addr))\n\t\treturn;\n\t/*\n\t * On non-coherent platforms which implement DMA-coherent buffers via\n\t * non-cacheable remaps, ops->free() may call vunmap(). Thus getting\n\t * this far in IRQ context is a) at risk of a BUG_ON() or trying to\n\t * sleep on some machines, and b) an indication that the driver is\n\t * probably misusing the coherent API anyway.\n\t */\n\tWARN_ON(irqs_disabled());\n\n\tif (!cpu_addr)\n\t\treturn;\n\n\tdebug_dma_free_coherent(dev, size, cpu_addr, dma_handle);\n\tif (dma_alloc_direct(dev, ops))\n\t\tdma_direct_free(dev, size, cpu_addr, dma_handle, attrs);\n\telse if (ops->free)\n\t\tops->free(dev, size, cpu_addr, dma_handle, attrs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void dmam_release(struct device *dev, void *res)\n{\n\tstruct dma_devres *this = res;\n\n\tdma_free_attrs(dev, this->size, this->vaddr, this->dma_handle,\n\t\t\tthis->attrs);\n}"
  }
]