[
  {
    "function_name": "audit_update_lsm_rules",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1437-1455",
    "snippet": "int audit_update_lsm_rules(void)\n{\n\tstruct audit_krule *r, *n;\n\tint i, err = 0;\n\n\t/* audit_filter_mutex synchronizes the writers */\n\tmutex_lock(&audit_filter_mutex);\n\n\tfor (i = 0; i < AUDIT_NR_FILTERS; i++) {\n\t\tlist_for_each_entry_safe(r, n, &audit_rules_list[i], list) {\n\t\t\tint res = update_lsm_rule(r);\n\t\t\tif (!err)\n\t\t\t\terr = res;\n\t\t}\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n\tLIST_HEAD_INIT(audit_rules_list[7]),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_lsm_rule",
          "args": [
            "r"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "update_lsm_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1400-1430",
          "snippet": "static int update_lsm_rule(struct audit_krule *r)\n{\n\tstruct audit_entry *entry = container_of(r, struct audit_entry, rule);\n\tstruct audit_entry *nentry;\n\tint err = 0;\n\n\tif (!security_audit_rule_known(r))\n\t\treturn 0;\n\n\tnentry = audit_dupe_rule(r);\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe);\n\tif (IS_ERR(nentry)) {\n\t\t/* save the first error encountered for the\n\t\t * return value */\n\t\terr = PTR_ERR(nentry);\n\t\taudit_panic(\"error updating LSM filters\");\n\t\tif (r->watch)\n\t\t\tlist_del(&r->rlist);\n\t\tlist_del_rcu(&entry->list);\n\t\tlist_del(&r->list);\n\t} else {\n\t\tif (r->watch || r->tree)\n\t\t\tlist_replace_init(&r->rlist, &nentry->rule.rlist);\n\t\tlist_replace_rcu(&entry->list, &nentry->list);\n\t\tlist_replace(&r->list, &nentry->rule.list);\n\t}\n\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\n\treturn err;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int update_lsm_rule(struct audit_krule *r)\n{\n\tstruct audit_entry *entry = container_of(r, struct audit_entry, rule);\n\tstruct audit_entry *nentry;\n\tint err = 0;\n\n\tif (!security_audit_rule_known(r))\n\t\treturn 0;\n\n\tnentry = audit_dupe_rule(r);\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe);\n\tif (IS_ERR(nentry)) {\n\t\t/* save the first error encountered for the\n\t\t * return value */\n\t\terr = PTR_ERR(nentry);\n\t\taudit_panic(\"error updating LSM filters\");\n\t\tif (r->watch)\n\t\t\tlist_del(&r->rlist);\n\t\tlist_del_rcu(&entry->list);\n\t\tlist_del(&r->list);\n\t} else {\n\t\tif (r->watch || r->tree)\n\t\t\tlist_replace_init(&r->rlist, &nentry->rule.rlist);\n\t\tlist_replace_rcu(&entry->list, &nentry->list);\n\t\tlist_replace(&r->list, &nentry->rule.list);\n\t}\n\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "r",
            "n",
            "&audit_rules_list[i]",
            "list"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n\tLIST_HEAD_INIT(audit_rules_list[7]),\n};\n\nint audit_update_lsm_rules(void)\n{\n\tstruct audit_krule *r, *n;\n\tint i, err = 0;\n\n\t/* audit_filter_mutex synchronizes the writers */\n\tmutex_lock(&audit_filter_mutex);\n\n\tfor (i = 0; i < AUDIT_NR_FILTERS; i++) {\n\t\tlist_for_each_entry_safe(r, n, &audit_rules_list[i], list) {\n\t\t\tint res = update_lsm_rule(r);\n\t\t\tif (!err)\n\t\t\t\terr = res;\n\t\t}\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "update_lsm_rule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1400-1430",
    "snippet": "static int update_lsm_rule(struct audit_krule *r)\n{\n\tstruct audit_entry *entry = container_of(r, struct audit_entry, rule);\n\tstruct audit_entry *nentry;\n\tint err = 0;\n\n\tif (!security_audit_rule_known(r))\n\t\treturn 0;\n\n\tnentry = audit_dupe_rule(r);\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe);\n\tif (IS_ERR(nentry)) {\n\t\t/* save the first error encountered for the\n\t\t * return value */\n\t\terr = PTR_ERR(nentry);\n\t\taudit_panic(\"error updating LSM filters\");\n\t\tif (r->watch)\n\t\t\tlist_del(&r->rlist);\n\t\tlist_del_rcu(&entry->list);\n\t\tlist_del(&r->list);\n\t} else {\n\t\tif (r->watch || r->tree)\n\t\t\tlist_replace_init(&r->rlist, &nentry->rule.rlist);\n\t\tlist_replace_rcu(&entry->list, &nentry->list);\n\t\tlist_replace(&r->list, &nentry->rule.list);\n\t}\n\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&entry->rcu",
            "audit_free_rule_rcu"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace",
          "args": [
            "&r->list",
            "&nentry->rule.list"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_rcu",
          "args": [
            "&entry->list",
            "&nentry->list"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&r->rlist",
            "&nentry->rule.rlist"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&r->list"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&entry->list"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"error updating LSM filters\""
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "302-315",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nentry"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nentry"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "entry->rule.exe"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "138-143",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_dupe_rule",
          "args": [
            "r"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "audit_dupe_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "819-895",
          "snippet": "struct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_audit_rule_known",
          "args": [
            "r"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "r",
            "structaudit_entry",
            "rule"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int update_lsm_rule(struct audit_krule *r)\n{\n\tstruct audit_entry *entry = container_of(r, struct audit_entry, rule);\n\tstruct audit_entry *nentry;\n\tint err = 0;\n\n\tif (!security_audit_rule_known(r))\n\t\treturn 0;\n\n\tnentry = audit_dupe_rule(r);\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe);\n\tif (IS_ERR(nentry)) {\n\t\t/* save the first error encountered for the\n\t\t * return value */\n\t\terr = PTR_ERR(nentry);\n\t\taudit_panic(\"error updating LSM filters\");\n\t\tif (r->watch)\n\t\t\tlist_del(&r->rlist);\n\t\tlist_del_rcu(&entry->list);\n\t\tlist_del(&r->list);\n\t} else {\n\t\tif (r->watch || r->tree)\n\t\t\tlist_replace_init(&r->rlist, &nentry->rule.rlist);\n\t\tlist_replace_rcu(&entry->list, &nentry->list);\n\t\tlist_replace(&r->list, &nentry->rule.list);\n\t}\n\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\n\treturn err;\n}"
  },
  {
    "function_name": "audit_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1329-1398",
    "snippet": "int audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t   f->type, f->op, f->lsm_rule);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_exe_compare",
          "args": [
            "current",
            "e->rule.exe"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "audit_exe_compare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "524-537",
          "snippet": "int audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_audit_rule_match",
          "args": [
            "sid",
            "f->type",
            "f->op",
            "f->lsm_rule"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_current_getsecid_subj",
          "args": [
            "&sid"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_comparator",
          "args": [
            "msgtype",
            "f->op",
            "f->val"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "audit_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1204-1226",
          "snippet": "int audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_loginuid_set",
          "args": [
            "current"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_uid_comparator",
          "args": [
            "audit_get_loginuid(current)",
            "f->op",
            "f->uid"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "audit_uid_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1228-1248",
          "snippet": "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_gid_comparator",
          "args": [
            "current_gid()",
            "f->op",
            "f->gid"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "audit_gid_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1250-1270",
          "snippet": "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "&audit_filter_list[listtype]",
            "list"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nint audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1; /* Audit by default */\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t   f->type, f->op, f->lsm_rule);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0) /* error */\n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "audit_compare_dname_path",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1310-1327",
    "snippet": "int audit_compare_dname_path(const struct qstr *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = dname->len;\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname->name, dlen);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "dname->name",
            "dlen"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_len",
          "args": [
            "path"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "parent_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1276-1300",
          "snippet": "int parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_compare_dname_path(const struct qstr *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = dname->len;\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname->name, dlen);\n}"
  },
  {
    "function_name": "parent_len",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1276-1300",
    "snippet": "int parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}"
  },
  {
    "function_name": "audit_gid_comparator",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1250-1270",
    "snippet": "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_gte",
          "args": [
            "left",
            "right"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_gt",
          "args": [
            "left",
            "right"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_lte",
          "args": [
            "left",
            "right"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_lt",
          "args": [
            "left",
            "right"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "left",
            "right"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "left",
            "right"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "audit_uid_comparator",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1228-1248",
    "snippet": "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_gte",
          "args": [
            "left",
            "right"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_gt",
          "args": [
            "left",
            "right"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_lte",
          "args": [
            "left",
            "right"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_lt",
          "args": [
            "left",
            "right"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "left",
            "right"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "left",
            "right"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "audit_comparator",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1204-1226",
    "snippet": "int audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "audit_list_rules_send",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1171-1202",
    "snippet": "int audit_list_rules_send(struct sk_buff *request_skb, int seq)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_netlink_list *dest;\n\n\t/* We can't just spew out the rules here because we might fill\n\t * the available socket buffer space and deadlock waiting for\n\t * auditctl to read from it... which isn't ever going to\n\t * happen if we're actually running in the context of auditctl\n\t * trying to _send_ the stuff */\n\n\tdest = kmalloc(sizeof(*dest), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\tdest->portid = NETLINK_CB(request_skb).portid;\n\tskb_queue_head_init(&dest->q);\n\n\tmutex_lock(&audit_filter_mutex);\n\taudit_list_rules(seq, &dest->q);\n\tmutex_unlock(&audit_filter_mutex);\n\n\ttsk = kthread_run(audit_send_list_thread, dest, \"audit_send_list\");\n\tif (IS_ERR(tsk)) {\n\t\tskb_queue_purge(&dest->q);\n\t\tput_net(dest->net);\n\t\tkfree(dest);\n\t\treturn PTR_ERR(tsk);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tsk"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dest"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "dest->net"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_purge",
          "args": [
            "&dest->q"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tsk"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "audit_send_list_thread",
            "dest",
            "\"audit_send_list\""
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_list_rules",
          "args": [
            "seq",
            "&dest->q"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "audit_list_rules_send",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1171-1202",
          "snippet": "int audit_list_rules_send(struct sk_buff *request_skb, int seq)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_netlink_list *dest;\n\n\t/* We can't just spew out the rules here because we might fill\n\t * the available socket buffer space and deadlock waiting for\n\t * auditctl to read from it... which isn't ever going to\n\t * happen if we're actually running in the context of auditctl\n\t * trying to _send_ the stuff */\n\n\tdest = kmalloc(sizeof(*dest), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\tdest->portid = NETLINK_CB(request_skb).portid;\n\tskb_queue_head_init(&dest->q);\n\n\tmutex_lock(&audit_filter_mutex);\n\taudit_list_rules(seq, &dest->q);\n\tmutex_unlock(&audit_filter_mutex);\n\n\ttsk = kthread_run(audit_send_list_thread, dest, \"audit_send_list\");\n\tif (IS_ERR(tsk)) {\n\t\tskb_queue_purge(&dest->q);\n\t\tput_net(dest->net);\n\t\tkfree(dest);\n\t\treturn PTR_ERR(tsk);\n\t}\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_queue_head_init",
          "args": [
            "&dest->q"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "request_skb"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "sock_net(NETLINK_CB(request_skb).sk)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_net",
          "args": [
            "NETLINK_CB(request_skb).sk"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_CB",
          "args": [
            "request_skb"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*dest)",
            "GFP_KERNEL"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_list_rules_send(struct sk_buff *request_skb, int seq)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_netlink_list *dest;\n\n\t/* We can't just spew out the rules here because we might fill\n\t * the available socket buffer space and deadlock waiting for\n\t * auditctl to read from it... which isn't ever going to\n\t * happen if we're actually running in the context of auditctl\n\t * trying to _send_ the stuff */\n\n\tdest = kmalloc(sizeof(*dest), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\tdest->portid = NETLINK_CB(request_skb).portid;\n\tskb_queue_head_init(&dest->q);\n\n\tmutex_lock(&audit_filter_mutex);\n\taudit_list_rules(seq, &dest->q);\n\tmutex_unlock(&audit_filter_mutex);\n\n\ttsk = kthread_run(audit_send_list_thread, dest, \"audit_send_list\");\n\tif (IS_ERR(tsk)) {\n\t\tskb_queue_purge(&dest->q);\n\t\tput_net(dest->net);\n\t\tkfree(dest);\n\t\treturn PTR_ERR(tsk);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_rule_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1132-1164",
    "snippet": "int audit_rule_change(int type, int seq, void *data, size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\n\tswitch (type) {\n\tcase AUDIT_ADD_RULE:\n\t\tentry = audit_data_to_entry(data, datasz);\n\t\tif (IS_ERR(entry))\n\t\t\treturn PTR_ERR(entry);\n\t\terr = audit_add_rule(entry);\n\t\taudit_log_rule_change(\"add_rule\", &entry->rule, !err);\n\t\tbreak;\n\tcase AUDIT_DEL_RULE:\n\t\tentry = audit_data_to_entry(data, datasz);\n\t\tif (IS_ERR(entry))\n\t\t\treturn PTR_ERR(entry);\n\t\terr = audit_del_rule(entry);\n\t\taudit_log_rule_change(\"remove_rule\", &entry->rule, !err);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (err || type == AUDIT_DEL_RULE) {\n\t\tif (entry->rule.exe)\n\t\t\taudit_remove_mark(entry->rule.exe);\n\t\taudit_free_rule(entry);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_free_rule",
          "args": [
            "entry"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_rule_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "99-103",
          "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "entry->rule.exe"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "138-143",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_rule_change",
          "args": [
            "\"remove_rule\"",
            "&entry->rule",
            "!err"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_rule_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1107-1123",
          "snippet": "static void audit_log_rule_change(char *action, struct audit_krule *rule, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" op=%s\", action);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=%d\", rule->listnr, res);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic void audit_log_rule_change(char *action, struct audit_krule *rule, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" op=%s\", action);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=%d\", rule->listnr, res);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_del_rule",
          "args": [
            "entry"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "audit_del_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1022-1075",
          "snippet": "int audit_del_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (!e) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (e->rule.watch)\n\t\taudit_remove_watch_rule(&e->rule);\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tif (e->rule.exe)\n\t\taudit_remove_mark_rule(&e->rule);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\n\tlist_del_rcu(&e->list);\n\tlist_del(&e->rule.list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\nout:\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (tree)\n\t\taudit_put_tree(tree);\t/* that's the temporary one */\n\n\treturn ret;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_del_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (!e) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (e->rule.watch)\n\t\taudit_remove_watch_rule(&e->rule);\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tif (e->rule.exe)\n\t\taudit_remove_mark_rule(&e->rule);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\n\tlist_del_rcu(&e->list);\n\tlist_del(&e->rule.list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\nout:\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (tree)\n\t\taudit_put_tree(tree);\t/* that's the temporary one */\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "entry"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "entry"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_data_to_entry",
          "args": [
            "data",
            "datasz"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "audit_data_to_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "449-620",
          "snippet": "static struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,\n\t\t\t\t\t       size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\tvoid *bufp;\n\tsize_t remain = datasz - sizeof(struct audit_rule_data);\n\tint i;\n\tchar *str;\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\tentry = audit_to_entry_common(data);\n\tif (IS_ERR(entry))\n\t\tgoto exit_nofree;\n\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &entry->rule.fields[i];\n\t\tu32 f_val;\n\n\t\terr = -EINVAL;\n\n\t\tf->op = audit_to_op(data->fieldflags[i]);\n\t\tif (f->op == Audit_bad)\n\t\t\tgoto exit_free;\n\n\t\tf->type = data->fields[i];\n\t\tf_val = data->values[i];\n\n\t\t/* Support legacy tests for a valid loginuid */\n\t\tif ((f->type == AUDIT_LOGINUID) && (f_val == AUDIT_UID_UNSET)) {\n\t\t\tf->type = AUDIT_LOGINUID_SET;\n\t\t\tf_val = 0;\n\t\t\tentry->rule.pflags |= AUDIT_LOGINUID_LEGACY;\n\t\t}\n\n\t\terr = audit_field_valid(entry, f);\n\t\tif (err)\n\t\t\tgoto exit_free;\n\n\t\terr = -EINVAL;\n\t\tswitch (f->type) {\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tf->uid = make_kuid(current_user_ns(), f_val);\n\t\t\tif (!uid_valid(f->uid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tf->gid = make_kgid(current_user_ns(), f_val);\n\t\t\tif (!gid_valid(f->gid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tf->val = f_val;\n\t\t\tentry->rule.arch_f = f;\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tf->lsm_str = str;\n\t\t\terr = security_audit_rule_init(f->type, f->op, str,\n\t\t\t\t\t\t       (void **)&f->lsm_rule);\n\t\t\t/* Keep currently invalid fields around in case they\n\t\t\t * become valid after a policy reload. */\n\t\t\tif (err == -EINVAL) {\n\t\t\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\t\t\tstr);\n\t\t\t\terr = 0;\n\t\t\t} else if (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\terr = audit_to_watch(&entry->rule, str, f_val, f->op);\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\terr = audit_make_tree(&entry->rule, str, f->op);\n\t\t\tkfree(str);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tf->val = f_val;\n\t\t\terr = audit_to_inode(&entry->rule, f);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tif (entry->rule.filterkey || f_val > AUDIT_MAX_KEY_LEN)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tentry->rule.filterkey = str;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tif (entry->rule.exe || f_val > PATH_MAX)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\taudit_mark = audit_alloc_mark(&entry->rule, str, f_val);\n\t\t\tif (IS_ERR(audit_mark)) {\n\t\t\t\tkfree(str);\n\t\t\t\terr = PTR_ERR(audit_mark);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tentry->rule.exe = audit_mark;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf->val = f_val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (entry->rule.inode_f && entry->rule.inode_f->op == Audit_not_equal)\n\t\tentry->rule.inode_f = NULL;\n\nexit_nofree:\n\treturn entry;\n\nexit_free:\n\tif (entry->rule.tree)\n\t\taudit_put_tree(entry->rule.tree); /* that's the temporary one */\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe); /* that's the template one */\n\taudit_free_rule(entry);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,\n\t\t\t\t\t       size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\tvoid *bufp;\n\tsize_t remain = datasz - sizeof(struct audit_rule_data);\n\tint i;\n\tchar *str;\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\tentry = audit_to_entry_common(data);\n\tif (IS_ERR(entry))\n\t\tgoto exit_nofree;\n\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &entry->rule.fields[i];\n\t\tu32 f_val;\n\n\t\terr = -EINVAL;\n\n\t\tf->op = audit_to_op(data->fieldflags[i]);\n\t\tif (f->op == Audit_bad)\n\t\t\tgoto exit_free;\n\n\t\tf->type = data->fields[i];\n\t\tf_val = data->values[i];\n\n\t\t/* Support legacy tests for a valid loginuid */\n\t\tif ((f->type == AUDIT_LOGINUID) && (f_val == AUDIT_UID_UNSET)) {\n\t\t\tf->type = AUDIT_LOGINUID_SET;\n\t\t\tf_val = 0;\n\t\t\tentry->rule.pflags |= AUDIT_LOGINUID_LEGACY;\n\t\t}\n\n\t\terr = audit_field_valid(entry, f);\n\t\tif (err)\n\t\t\tgoto exit_free;\n\n\t\terr = -EINVAL;\n\t\tswitch (f->type) {\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tf->uid = make_kuid(current_user_ns(), f_val);\n\t\t\tif (!uid_valid(f->uid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tf->gid = make_kgid(current_user_ns(), f_val);\n\t\t\tif (!gid_valid(f->gid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tf->val = f_val;\n\t\t\tentry->rule.arch_f = f;\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tf->lsm_str = str;\n\t\t\terr = security_audit_rule_init(f->type, f->op, str,\n\t\t\t\t\t\t       (void **)&f->lsm_rule);\n\t\t\t/* Keep currently invalid fields around in case they\n\t\t\t * become valid after a policy reload. */\n\t\t\tif (err == -EINVAL) {\n\t\t\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\t\t\tstr);\n\t\t\t\terr = 0;\n\t\t\t} else if (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\terr = audit_to_watch(&entry->rule, str, f_val, f->op);\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\terr = audit_make_tree(&entry->rule, str, f->op);\n\t\t\tkfree(str);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tf->val = f_val;\n\t\t\terr = audit_to_inode(&entry->rule, f);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tif (entry->rule.filterkey || f_val > AUDIT_MAX_KEY_LEN)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tentry->rule.filterkey = str;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tif (entry->rule.exe || f_val > PATH_MAX)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\taudit_mark = audit_alloc_mark(&entry->rule, str, f_val);\n\t\t\tif (IS_ERR(audit_mark)) {\n\t\t\t\tkfree(str);\n\t\t\t\terr = PTR_ERR(audit_mark);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tentry->rule.exe = audit_mark;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf->val = f_val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (entry->rule.inode_f && entry->rule.inode_f->op == Audit_not_equal)\n\t\tentry->rule.inode_f = NULL;\n\nexit_nofree:\n\treturn entry;\n\nexit_free:\n\tif (entry->rule.tree)\n\t\taudit_put_tree(entry->rule.tree); /* that's the temporary one */\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe); /* that's the template one */\n\taudit_free_rule(entry);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_add_rule",
          "args": [
            "entry"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "audit_add_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "938-1019",
          "snippet": "static inline int audit_add_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry *e;\n\tstruct audit_watch *watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint err = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\terr = -EEXIST;\n\t\t/* normally audit_add_tree_rule() will free it on failure */\n\t\tif (tree)\n\t\t\taudit_put_tree(tree);\n\t\treturn err;\n\t}\n\n\tif (watch) {\n\t\t/* audit_filter_mutex is dropped and re-taken during this call */\n\t\terr = audit_add_watch(&entry->rule, &list);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\t/*\n\t\t\t * normally audit_add_tree_rule() will free it\n\t\t\t * on failure\n\t\t\t */\n\t\t\tif (tree)\n\t\t\t\taudit_put_tree(tree);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (tree) {\n\t\terr = audit_add_tree_rule(&entry->rule);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tentry->rule.prio = ~0ULL;\n\tif (entry->rule.listnr == AUDIT_FILTER_EXIT ||\n\t    entry->rule.listnr == AUDIT_FILTER_URING_EXIT) {\n\t\tif (entry->rule.flags & AUDIT_FILTER_PREPEND)\n\t\t\tentry->rule.prio = ++prio_high;\n\t\telse\n\t\t\tentry->rule.prio = --prio_low;\n\t}\n\n\tif (entry->rule.flags & AUDIT_FILTER_PREPEND) {\n\t\tlist_add(&entry->rule.list,\n\t\t\t &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_rcu(&entry->list, list);\n\t\tentry->rule.flags &= ~AUDIT_FILTER_PREPEND;\n\t} else {\n\t\tlist_add_tail(&entry->rule.list,\n\t\t\t      &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_tail_rcu(&entry->list, list);\n\t}\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules++;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals++;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n\tLIST_HEAD_INIT(audit_rules_list[7]),\n};",
            "static u64 prio_low = ~0ULL/2;",
            "static u64 prio_high = ~0ULL/2 - 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n\tLIST_HEAD_INIT(audit_rules_list[7]),\n};\nstatic u64 prio_low = ~0ULL/2;\nstatic u64 prio_high = ~0ULL/2 - 1;\n\nstatic inline int audit_add_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry *e;\n\tstruct audit_watch *watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint err = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\terr = -EEXIST;\n\t\t/* normally audit_add_tree_rule() will free it on failure */\n\t\tif (tree)\n\t\t\taudit_put_tree(tree);\n\t\treturn err;\n\t}\n\n\tif (watch) {\n\t\t/* audit_filter_mutex is dropped and re-taken during this call */\n\t\terr = audit_add_watch(&entry->rule, &list);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\t/*\n\t\t\t * normally audit_add_tree_rule() will free it\n\t\t\t * on failure\n\t\t\t */\n\t\t\tif (tree)\n\t\t\t\taudit_put_tree(tree);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (tree) {\n\t\terr = audit_add_tree_rule(&entry->rule);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tentry->rule.prio = ~0ULL;\n\tif (entry->rule.listnr == AUDIT_FILTER_EXIT ||\n\t    entry->rule.listnr == AUDIT_FILTER_URING_EXIT) {\n\t\tif (entry->rule.flags & AUDIT_FILTER_PREPEND)\n\t\t\tentry->rule.prio = ++prio_high;\n\t\telse\n\t\t\tentry->rule.prio = --prio_low;\n\t}\n\n\tif (entry->rule.flags & AUDIT_FILTER_PREPEND) {\n\t\tlist_add(&entry->rule.list,\n\t\t\t &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_rcu(&entry->list, list);\n\t\tentry->rule.flags &= ~AUDIT_FILTER_PREPEND;\n\t} else {\n\t\tlist_add_tail(&entry->rule.list,\n\t\t\t      &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_tail_rcu(&entry->list, list);\n\t}\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules++;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals++;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "entry"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "entry"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_rule_change(int type, int seq, void *data, size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\n\tswitch (type) {\n\tcase AUDIT_ADD_RULE:\n\t\tentry = audit_data_to_entry(data, datasz);\n\t\tif (IS_ERR(entry))\n\t\t\treturn PTR_ERR(entry);\n\t\terr = audit_add_rule(entry);\n\t\taudit_log_rule_change(\"add_rule\", &entry->rule, !err);\n\t\tbreak;\n\tcase AUDIT_DEL_RULE:\n\t\tentry = audit_data_to_entry(data, datasz);\n\t\tif (IS_ERR(entry))\n\t\t\treturn PTR_ERR(entry);\n\t\terr = audit_del_rule(entry);\n\t\taudit_log_rule_change(\"remove_rule\", &entry->rule, !err);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (err || type == AUDIT_DEL_RULE) {\n\t\tif (entry->rule.exe)\n\t\t\taudit_remove_mark(entry->rule.exe);\n\t\taudit_free_rule(entry);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "audit_log_rule_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1107-1123",
    "snippet": "static void audit_log_rule_change(char *action, struct audit_krule *rule, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" op=%s\", action);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=%d\", rule->listnr, res);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" list=%d res=%d\"",
            "rule->listnr",
            "res"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_key",
          "args": [
            "ab",
            "rule->filterkey"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2134-2141",
          "snippet": "void audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2143-2168",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_session_info",
          "args": [
            "ab"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_session_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2126-2132",
          "snippet": "void audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic void audit_log_rule_change(char *action, struct audit_krule *rule, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" op=%s\", action);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=%d\", rule->listnr, res);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_list_rules",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1078-1104",
    "snippet": "static void audit_list_rules(int seq, struct sk_buff_head *q)\n{\n\tstruct sk_buff *skb;\n\tstruct audit_krule *r;\n\tint i;\n\n\t/* This is a blocking read, so use audit_filter_mutex instead of rcu\n\t * iterator to sync with list writers. */\n\tfor (i=0; i<AUDIT_NR_FILTERS; i++) {\n\t\tlist_for_each_entry(r, &audit_rules_list[i], list) {\n\t\t\tstruct audit_rule_data *data;\n\n\t\t\tdata = audit_krule_to_data(r);\n\t\t\tif (unlikely(!data))\n\t\t\t\tbreak;\n\t\t\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 0, 1,\n\t\t\t\t\t       data,\n\t\t\t\t\t       struct_size(data, buf, data->buflen));\n\t\t\tif (skb)\n\t\t\t\tskb_queue_tail(q, skb);\n\t\t\tkfree(data);\n\t\t}\n\t}\n\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 1, 1, NULL, 0);\n\tif (skb)\n\t\tskb_queue_tail(q, skb);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n\tLIST_HEAD_INIT(audit_rules_list[7]),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "q",
            "skb"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_make_reply",
          "args": [
            "seq",
            "AUDIT_LIST_RULES",
            "1",
            "1",
            "NULL",
            "0"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "audit_make_reply",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "905-928",
          "snippet": "struct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "q",
            "skb"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "data",
            "buf",
            "data->buflen"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_krule_to_data",
          "args": [
            "r"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "audit_krule_to_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "634-700",
          "snippet": "static struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)\n{\n\tstruct audit_rule_data *data;\n\tvoid *bufp;\n\tint i;\n\n\tdata = kmalloc(struct_size(data, buf, krule->buflen), GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn NULL;\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->flags = krule->flags | krule->listnr;\n\tdata->action = krule->action;\n\tdata->field_count = krule->field_count;\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &krule->fields[i];\n\n\t\tdata->fields[i] = f->type;\n\t\tdata->fieldflags[i] = audit_ops[f->op];\n\t\tswitch(f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, f->lsm_str);\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_watch_path(krule->watch));\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_tree_path(krule->tree));\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, krule->filterkey);\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, audit_mark_path(krule->exe));\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tif (krule->pflags & AUDIT_LOGINUID_LEGACY && !f->val) {\n\t\t\t\tdata->fields[i] = AUDIT_LOGINUID;\n\t\t\t\tdata->values[i] = AUDIT_UID_UNSET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t/* if set */\n\t\tdefault:\n\t\t\tdata->values[i] = f->val;\n\t\t}\n\t}\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++) data->mask[i] = krule->mask[i];\n\n\treturn data;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};\n\nstatic struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)\n{\n\tstruct audit_rule_data *data;\n\tvoid *bufp;\n\tint i;\n\n\tdata = kmalloc(struct_size(data, buf, krule->buflen), GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn NULL;\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->flags = krule->flags | krule->listnr;\n\tdata->action = krule->action;\n\tdata->field_count = krule->field_count;\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &krule->fields[i];\n\n\t\tdata->fields[i] = f->type;\n\t\tdata->fieldflags[i] = audit_ops[f->op];\n\t\tswitch(f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, f->lsm_str);\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_watch_path(krule->watch));\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_tree_path(krule->tree));\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, krule->filterkey);\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, audit_mark_path(krule->exe));\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tif (krule->pflags & AUDIT_LOGINUID_LEGACY && !f->val) {\n\t\t\t\tdata->fields[i] = AUDIT_LOGINUID;\n\t\t\t\tdata->values[i] = AUDIT_UID_UNSET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t/* if set */\n\t\tdefault:\n\t\t\tdata->values[i] = f->val;\n\t\t}\n\t}\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++) data->mask[i] = krule->mask[i];\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "r",
            "&audit_rules_list[i]",
            "list"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n\tLIST_HEAD_INIT(audit_rules_list[7]),\n};\n\nstatic void audit_list_rules(int seq, struct sk_buff_head *q)\n{\n\tstruct sk_buff *skb;\n\tstruct audit_krule *r;\n\tint i;\n\n\t/* This is a blocking read, so use audit_filter_mutex instead of rcu\n\t * iterator to sync with list writers. */\n\tfor (i=0; i<AUDIT_NR_FILTERS; i++) {\n\t\tlist_for_each_entry(r, &audit_rules_list[i], list) {\n\t\t\tstruct audit_rule_data *data;\n\n\t\t\tdata = audit_krule_to_data(r);\n\t\t\tif (unlikely(!data))\n\t\t\t\tbreak;\n\t\t\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 0, 1,\n\t\t\t\t\t       data,\n\t\t\t\t\t       struct_size(data, buf, data->buflen));\n\t\t\tif (skb)\n\t\t\t\tskb_queue_tail(q, skb);\n\t\t\tkfree(data);\n\t\t}\n\t}\n\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 1, 1, NULL, 0);\n\tif (skb)\n\t\tskb_queue_tail(q, skb);\n}"
  },
  {
    "function_name": "audit_del_rule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "1022-1075",
    "snippet": "int audit_del_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (!e) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (e->rule.watch)\n\t\taudit_remove_watch_rule(&e->rule);\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tif (e->rule.exe)\n\t\taudit_remove_mark_rule(&e->rule);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\n\tlist_del_rcu(&e->list);\n\tlist_del(&e->rule.list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\nout:\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (tree)\n\t\taudit_put_tree(tree);\t/* that's the temporary one */\n\n\treturn ret;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_tree",
          "args": [
            "tree"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "740-743",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&e->rcu",
            "audit_free_rule_rcu"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&e->rule.list"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&e->list"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_match_signal",
          "args": [
            "entry"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "211-234",
          "snippet": "static int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark_rule",
          "args": [
            "&e->rule"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "138-143",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_tree_rule",
          "args": [
            "&e->rule"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_tree_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "647-669",
          "snippet": "int audit_remove_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *tree;\n\ttree = rule->tree;\n\tif (tree) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&rule->rlist);\n\t\tif (list_empty(&tree->rules) && !tree->goner) {\n\t\t\ttree->root = NULL;\n\t\t\tlist_del_init(&tree->same_root);\n\t\t\ttree->goner = 1;\n\t\t\tlist_move(&tree->list, &prune_list);\n\t\t\trule->tree = NULL;\n\t\t\tspin_unlock(&hash_lock);\n\t\t\taudit_schedule_prune();\n\t\t\treturn 1;\n\t\t}\n\t\trule->tree = NULL;\n\t\tspin_unlock(&hash_lock);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(prune_list);",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(prune_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\nstatic void audit_schedule_prune(void);\n\nint audit_remove_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *tree;\n\ttree = rule->tree;\n\tif (tree) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&rule->rlist);\n\t\tif (list_empty(&tree->rules) && !tree->goner) {\n\t\t\ttree->root = NULL;\n\t\t\tlist_del_init(&tree->same_root);\n\t\t\ttree->goner = 1;\n\t\t\tlist_move(&tree->list, &prune_list);\n\t\t\trule->tree = NULL;\n\t\t\tspin_unlock(&hash_lock);\n\t\t\taudit_schedule_prune();\n\t\t\treturn 1;\n\t\t}\n\t\trule->tree = NULL;\n\t\tspin_unlock(&hash_lock);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_watch_rule",
          "args": [
            "&e->rule"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_watch_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "447-465",
          "snippet": "void audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nvoid audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_find_rule",
          "args": [
            "entry",
            "&list"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "audit_find_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "899-932",
          "snippet": "static struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nstatic struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_del_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (!e) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (e->rule.watch)\n\t\taudit_remove_watch_rule(&e->rule);\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tif (e->rule.exe)\n\t\taudit_remove_mark_rule(&e->rule);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\n\tlist_del_rcu(&e->list);\n\tlist_del(&e->rule.list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\nout:\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (tree)\n\t\taudit_put_tree(tree);\t/* that's the temporary one */\n\n\treturn ret;\n}"
  },
  {
    "function_name": "audit_add_rule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "938-1019",
    "snippet": "static inline int audit_add_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry *e;\n\tstruct audit_watch *watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint err = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\terr = -EEXIST;\n\t\t/* normally audit_add_tree_rule() will free it on failure */\n\t\tif (tree)\n\t\t\taudit_put_tree(tree);\n\t\treturn err;\n\t}\n\n\tif (watch) {\n\t\t/* audit_filter_mutex is dropped and re-taken during this call */\n\t\terr = audit_add_watch(&entry->rule, &list);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\t/*\n\t\t\t * normally audit_add_tree_rule() will free it\n\t\t\t * on failure\n\t\t\t */\n\t\t\tif (tree)\n\t\t\t\taudit_put_tree(tree);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (tree) {\n\t\terr = audit_add_tree_rule(&entry->rule);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tentry->rule.prio = ~0ULL;\n\tif (entry->rule.listnr == AUDIT_FILTER_EXIT ||\n\t    entry->rule.listnr == AUDIT_FILTER_URING_EXIT) {\n\t\tif (entry->rule.flags & AUDIT_FILTER_PREPEND)\n\t\t\tentry->rule.prio = ++prio_high;\n\t\telse\n\t\t\tentry->rule.prio = --prio_low;\n\t}\n\n\tif (entry->rule.flags & AUDIT_FILTER_PREPEND) {\n\t\tlist_add(&entry->rule.list,\n\t\t\t &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_rcu(&entry->list, list);\n\t\tentry->rule.flags &= ~AUDIT_FILTER_PREPEND;\n\t} else {\n\t\tlist_add_tail(&entry->rule.list,\n\t\t\t      &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_tail_rcu(&entry->list, list);\n\t}\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules++;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals++;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n\tLIST_HEAD_INIT(audit_rules_list[7]),\n};",
      "static u64 prio_low = ~0ULL/2;",
      "static u64 prio_high = ~0ULL/2 - 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_match_signal",
          "args": [
            "entry"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "211-234",
          "snippet": "static int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&entry->list",
            "list"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->rule.list",
            "&audit_rules_list[entry->rule.listnr]"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&entry->list",
            "list"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&entry->rule.list",
            "&audit_rules_list[entry->rule.listnr]"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_add_tree_rule",
          "args": [
            "&entry->rule"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "audit_add_tree_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "800-868",
          "snippet": "int audit_add_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *seed = rule->tree, *tree;\n\tstruct path path;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\trule->tree = NULL;\n\tlist_for_each_entry(tree, &tree_list, list) {\n\t\tif (!strcmp(seed->pathname, tree->pathname)) {\n\t\t\tput_tree(seed);\n\t\t\trule->tree = tree;\n\t\t\tlist_add(&rule->rlist, &tree->rules);\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttree = seed;\n\tlist_add(&tree->list, &tree_list);\n\tlist_add(&rule->rlist, &tree->rules);\n\t/* do not set rule->tree yet */\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (unlikely(!prune_thread)) {\n\t\terr = audit_launch_prune();\n\t\tif (err)\n\t\t\tgoto Err;\n\t}\n\n\terr = kern_path(tree->pathname, 0, &path);\n\tif (err)\n\t\tgoto Err;\n\tmnt = collect_mounts(&path);\n\tpath_put(&path);\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto Err;\n\t}\n\n\tget_tree(tree);\n\terr = iterate_mounts(tag_mount, tree, mnt);\n\tdrop_collected_mounts(mnt);\n\n\tif (!err) {\n\t\tstruct audit_node *node;\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\tnode->index &= ~(1U<<31);\n\t\tspin_unlock(&hash_lock);\n\t} else {\n\t\ttrim_marked(tree);\n\t\tgoto Err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tif (list_empty(&rule->rlist)) {\n\t\tput_tree(tree);\n\t\treturn -ENOENT;\n\t}\n\trule->tree = tree;\n\tput_tree(tree);\n\n\treturn 0;\nErr:\n\tmutex_lock(&audit_filter_mutex);\n\tlist_del_init(&tree->list);\n\tlist_del_init(&tree->rules);\n\tput_tree(tree);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(tree_list);",
            "static struct task_struct *prune_thread;",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic struct task_struct *prune_thread;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nint audit_add_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *seed = rule->tree, *tree;\n\tstruct path path;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\trule->tree = NULL;\n\tlist_for_each_entry(tree, &tree_list, list) {\n\t\tif (!strcmp(seed->pathname, tree->pathname)) {\n\t\t\tput_tree(seed);\n\t\t\trule->tree = tree;\n\t\t\tlist_add(&rule->rlist, &tree->rules);\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttree = seed;\n\tlist_add(&tree->list, &tree_list);\n\tlist_add(&rule->rlist, &tree->rules);\n\t/* do not set rule->tree yet */\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (unlikely(!prune_thread)) {\n\t\terr = audit_launch_prune();\n\t\tif (err)\n\t\t\tgoto Err;\n\t}\n\n\terr = kern_path(tree->pathname, 0, &path);\n\tif (err)\n\t\tgoto Err;\n\tmnt = collect_mounts(&path);\n\tpath_put(&path);\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto Err;\n\t}\n\n\tget_tree(tree);\n\terr = iterate_mounts(tag_mount, tree, mnt);\n\tdrop_collected_mounts(mnt);\n\n\tif (!err) {\n\t\tstruct audit_node *node;\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\tnode->index &= ~(1U<<31);\n\t\tspin_unlock(&hash_lock);\n\t} else {\n\t\ttrim_marked(tree);\n\t\tgoto Err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tif (list_empty(&rule->rlist)) {\n\t\tput_tree(tree);\n\t\treturn -ENOENT;\n\t}\n\trule->tree = tree;\n\tput_tree(tree);\n\n\treturn 0;\nErr:\n\tmutex_lock(&audit_filter_mutex);\n\tlist_del_init(&tree->list);\n\tlist_del_init(&tree->rules);\n\tput_tree(tree);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_tree",
          "args": [
            "tree"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "740-743",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_add_watch",
          "args": [
            "&entry->rule",
            "&list"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "audit_add_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "400-445",
          "snippet": "int audit_add_watch(struct audit_krule *krule, struct list_head **list)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent;\n\tstruct path parent_path;\n\tint h, ret = 0;\n\n\t/*\n\t * When we will be calling audit_add_to_parent, krule->watch might have\n\t * been updated and watch might have been freed.\n\t * So we need to keep a reference of watch.\n\t */\n\taudit_get_watch(watch);\n\n\tmutex_unlock(&audit_filter_mutex);\n\n\t/* Avoid calling path_lookup under audit_filter_mutex. */\n\tret = audit_get_nd(watch, &parent_path);\n\n\t/* caller expects mutex locked */\n\tmutex_lock(&audit_filter_mutex);\n\n\tif (ret) {\n\t\taudit_put_watch(watch);\n\t\treturn ret;\n\t}\n\n\t/* either find an old parent or attach a new one */\n\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));\n\tif (!parent) {\n\t\tparent = audit_init_parent(&parent_path);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\taudit_add_to_parent(krule, parent);\n\n\th = audit_hash_ino((u32)watch->ino);\n\t*list = &audit_inode_hash[h];\nerror:\n\tpath_put(&parent_path);\n\taudit_put_watch(watch);\n\treturn ret;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_add_watch(struct audit_krule *krule, struct list_head **list)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent;\n\tstruct path parent_path;\n\tint h, ret = 0;\n\n\t/*\n\t * When we will be calling audit_add_to_parent, krule->watch might have\n\t * been updated and watch might have been freed.\n\t * So we need to keep a reference of watch.\n\t */\n\taudit_get_watch(watch);\n\n\tmutex_unlock(&audit_filter_mutex);\n\n\t/* Avoid calling path_lookup under audit_filter_mutex. */\n\tret = audit_get_nd(watch, &parent_path);\n\n\t/* caller expects mutex locked */\n\tmutex_lock(&audit_filter_mutex);\n\n\tif (ret) {\n\t\taudit_put_watch(watch);\n\t\treturn ret;\n\t}\n\n\t/* either find an old parent or attach a new one */\n\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));\n\tif (!parent) {\n\t\tparent = audit_init_parent(&parent_path);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\taudit_add_to_parent(krule, parent);\n\n\th = audit_hash_ino((u32)watch->ino);\n\t*list = &audit_inode_hash[h];\nerror:\n\tpath_put(&parent_path);\n\taudit_put_watch(watch);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_find_rule",
          "args": [
            "entry",
            "&list"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "audit_find_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "899-932",
          "snippet": "static struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nstatic struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n\tLIST_HEAD_INIT(audit_rules_list[7]),\n};\nstatic u64 prio_low = ~0ULL/2;\nstatic u64 prio_high = ~0ULL/2 - 1;\n\nstatic inline int audit_add_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry *e;\n\tstruct audit_watch *watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint err = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If any of these, don't count towards total */\n\tswitch(entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\terr = -EEXIST;\n\t\t/* normally audit_add_tree_rule() will free it on failure */\n\t\tif (tree)\n\t\t\taudit_put_tree(tree);\n\t\treturn err;\n\t}\n\n\tif (watch) {\n\t\t/* audit_filter_mutex is dropped and re-taken during this call */\n\t\terr = audit_add_watch(&entry->rule, &list);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\t/*\n\t\t\t * normally audit_add_tree_rule() will free it\n\t\t\t * on failure\n\t\t\t */\n\t\t\tif (tree)\n\t\t\t\taudit_put_tree(tree);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (tree) {\n\t\terr = audit_add_tree_rule(&entry->rule);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tentry->rule.prio = ~0ULL;\n\tif (entry->rule.listnr == AUDIT_FILTER_EXIT ||\n\t    entry->rule.listnr == AUDIT_FILTER_URING_EXIT) {\n\t\tif (entry->rule.flags & AUDIT_FILTER_PREPEND)\n\t\t\tentry->rule.prio = ++prio_high;\n\t\telse\n\t\t\tentry->rule.prio = --prio_low;\n\t}\n\n\tif (entry->rule.flags & AUDIT_FILTER_PREPEND) {\n\t\tlist_add(&entry->rule.list,\n\t\t\t &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_rcu(&entry->list, list);\n\t\tentry->rule.flags &= ~AUDIT_FILTER_PREPEND;\n\t} else {\n\t\tlist_add_tail(&entry->rule.list,\n\t\t\t      &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_tail_rcu(&entry->list, list);\n\t}\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules++;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals++;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "audit_find_rule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "899-932",
    "snippet": "static struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_compare_rule",
          "args": [
            "&entry->rule",
            "&e->rule"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "audit_compare_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "704-783",
          "snippet": "static int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)\n{\n\tint i;\n\n\tif (a->flags != b->flags ||\n\t    a->pflags != b->pflags ||\n\t    a->listnr != b->listnr ||\n\t    a->action != b->action ||\n\t    a->field_count != b->field_count)\n\t\treturn 1;\n\n\tfor (i = 0; i < a->field_count; i++) {\n\t\tif (a->fields[i].type != b->fields[i].type ||\n\t\t    a->fields[i].op != b->fields[i].op)\n\t\t\treturn 1;\n\n\t\tswitch(a->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (strcmp(audit_watch_path(a->watch),\n\t\t\t\t   audit_watch_path(b->watch)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (strcmp(audit_tree_path(a->tree),\n\t\t\t\t   audit_tree_path(b->tree)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* both filterkeys exist based on above type compare */\n\t\t\tif (strcmp(a->filterkey, b->filterkey))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\t/* both paths exist based on above type compare */\n\t\t\tif (strcmp(audit_mark_path(a->exe),\n\t\t\t\t   audit_mark_path(b->exe)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (!uid_eq(a->fields[i].uid, b->fields[i].uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (!gid_eq(a->fields[i].gid, b->fields[i].gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (a->fields[i].val != b->fields[i].val)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tif (a->mask[i] != b->mask[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)\n{\n\tint i;\n\n\tif (a->flags != b->flags ||\n\t    a->pflags != b->pflags ||\n\t    a->listnr != b->listnr ||\n\t    a->action != b->action ||\n\t    a->field_count != b->field_count)\n\t\treturn 1;\n\n\tfor (i = 0; i < a->field_count; i++) {\n\t\tif (a->fields[i].type != b->fields[i].type ||\n\t\t    a->fields[i].op != b->fields[i].op)\n\t\t\treturn 1;\n\n\t\tswitch(a->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (strcmp(audit_watch_path(a->watch),\n\t\t\t\t   audit_watch_path(b->watch)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (strcmp(audit_tree_path(a->tree),\n\t\t\t\t   audit_tree_path(b->tree)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* both filterkeys exist based on above type compare */\n\t\t\tif (strcmp(a->filterkey, b->filterkey))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\t/* both paths exist based on above type compare */\n\t\t\tif (strcmp(audit_mark_path(a->exe),\n\t\t\t\t   audit_mark_path(b->exe)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (!uid_eq(a->fields[i].uid, b->fields[i].uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (!gid_eq(a->fields[i].gid, b->fields[i].gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (a->fields[i].val != b->fields[i].val)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tif (a->mask[i] != b->mask[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "e",
            "list",
            "list"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "e",
            "list",
            "list"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_hash_ino",
          "args": [
            "entry->rule.inode_f->val"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "audit_hash_ino",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.h",
          "lines": "218-221",
          "snippet": "static inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}",
          "includes": [
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <linux/tty.h>",
            "#include <uapi/linux/mqueue.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/audit.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define AUDIT_INODE_BUCKETS\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/openat2.h> // struct open_how\n#include <linux/tty.h>\n#include <uapi/linux/mqueue.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <linux/fs.h>\n\n#define AUDIT_INODE_BUCKETS\t32\n\nstatic inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};\n\nstatic struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t/* we don't know the inode number, so must walk entire hash */\n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}"
  },
  {
    "function_name": "audit_dupe_rule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "819-895",
    "snippet": "struct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_get_watch",
          "args": [
            "old->watch"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "100-103",
          "snippet": "void audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_free_rule",
          "args": [
            "entry"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_rule_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "99-103",
          "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "new->exe"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "138-143",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_dupe_exe",
          "args": [
            "new",
            "old"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "audit_dupe_exe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "505-522",
          "snippet": "int audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tchar *pathname;\n\n\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));\n\tif (IS_ERR(audit_mark)) {\n\t\tkfree(pathname);\n\t\treturn PTR_ERR(audit_mark);\n\t}\n\tnew->exe = audit_mark;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tchar *pathname;\n\n\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));\n\tif (IS_ERR(audit_mark)) {\n\t\tkfree(pathname);\n\t\treturn PTR_ERR(audit_mark);\n\t}\n\tnew->exe = audit_mark;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fk"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "old->filterkey",
            "GFP_KERNEL"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dupe_lsm_field",
          "args": [
            "&new->fields[i]",
            "&old->fields[i]"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "audit_dupe_lsm_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "787-811",
          "snippet": "static inline int audit_dupe_lsm_field(struct audit_field *df,\n\t\t\t\t\t   struct audit_field *sf)\n{\n\tint ret = 0;\n\tchar *lsm_str;\n\n\t/* our own copy of lsm_str */\n\tlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);\n\tif (unlikely(!lsm_str))\n\t\treturn -ENOMEM;\n\tdf->lsm_str = lsm_str;\n\n\t/* our own (refreshed) copy of lsm_rule */\n\tret = security_audit_rule_init(df->type, df->op, df->lsm_str,\n\t\t\t\t       (void **)&df->lsm_rule);\n\t/* Keep currently invalid fields around in case they\n\t * become valid after a policy reload. */\n\tif (ret == -EINVAL) {\n\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\tdf->lsm_str);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline int audit_dupe_lsm_field(struct audit_field *df,\n\t\t\t\t\t   struct audit_field *sf)\n{\n\tint ret = 0;\n\tchar *lsm_str;\n\n\t/* our own copy of lsm_str */\n\tlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);\n\tif (unlikely(!lsm_str))\n\t\treturn -ENOMEM;\n\tdf->lsm_str = lsm_str;\n\n\t/* our own (refreshed) copy of lsm_rule */\n\tret = security_audit_rule_init(df->type, df->op, df->lsm_str,\n\t\t\t\t       (void **)&df->lsm_rule);\n\t/* Keep currently invalid fields around in case they\n\t * become valid after a policy reload. */\n\tif (ret == -EINVAL) {\n\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\tdf->lsm_str);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new->fields",
            "old->fields",
            "sizeof(struct audit_field) * fcount"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!entry"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_init_entry",
          "args": [
            "fcount"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "audit_init_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "106-123",
          "snippet": "static inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}"
  },
  {
    "function_name": "audit_dupe_lsm_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "787-811",
    "snippet": "static inline int audit_dupe_lsm_field(struct audit_field *df,\n\t\t\t\t\t   struct audit_field *sf)\n{\n\tint ret = 0;\n\tchar *lsm_str;\n\n\t/* our own copy of lsm_str */\n\tlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);\n\tif (unlikely(!lsm_str))\n\t\treturn -ENOMEM;\n\tdf->lsm_str = lsm_str;\n\n\t/* our own (refreshed) copy of lsm_rule */\n\tret = security_audit_rule_init(df->type, df->op, df->lsm_str,\n\t\t\t\t       (void **)&df->lsm_rule);\n\t/* Keep currently invalid fields around in case they\n\t * become valid after a policy reload. */\n\tif (ret == -EINVAL) {\n\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\tdf->lsm_str);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"audit rule for LSM \\'%s\\' is invalid\\n\"",
            "df->lsm_str"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_audit_rule_init",
          "args": [
            "df->type",
            "df->op",
            "df->lsm_str",
            "(void **)&df->lsm_rule"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lsm_str"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "sf->lsm_str",
            "GFP_KERNEL"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline int audit_dupe_lsm_field(struct audit_field *df,\n\t\t\t\t\t   struct audit_field *sf)\n{\n\tint ret = 0;\n\tchar *lsm_str;\n\n\t/* our own copy of lsm_str */\n\tlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);\n\tif (unlikely(!lsm_str))\n\t\treturn -ENOMEM;\n\tdf->lsm_str = lsm_str;\n\n\t/* our own (refreshed) copy of lsm_rule */\n\tret = security_audit_rule_init(df->type, df->op, df->lsm_str,\n\t\t\t\t       (void **)&df->lsm_rule);\n\t/* Keep currently invalid fields around in case they\n\t * become valid after a policy reload. */\n\tif (ret == -EINVAL) {\n\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\tdf->lsm_str);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "audit_compare_rule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "704-783",
    "snippet": "static int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)\n{\n\tint i;\n\n\tif (a->flags != b->flags ||\n\t    a->pflags != b->pflags ||\n\t    a->listnr != b->listnr ||\n\t    a->action != b->action ||\n\t    a->field_count != b->field_count)\n\t\treturn 1;\n\n\tfor (i = 0; i < a->field_count; i++) {\n\t\tif (a->fields[i].type != b->fields[i].type ||\n\t\t    a->fields[i].op != b->fields[i].op)\n\t\t\treturn 1;\n\n\t\tswitch(a->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (strcmp(audit_watch_path(a->watch),\n\t\t\t\t   audit_watch_path(b->watch)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (strcmp(audit_tree_path(a->tree),\n\t\t\t\t   audit_tree_path(b->tree)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* both filterkeys exist based on above type compare */\n\t\t\tif (strcmp(a->filterkey, b->filterkey))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\t/* both paths exist based on above type compare */\n\t\t\tif (strcmp(audit_mark_path(a->exe),\n\t\t\t\t   audit_mark_path(b->exe)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (!uid_eq(a->fields[i].uid, b->fields[i].uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (!gid_eq(a->fields[i].gid, b->fields[i].gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (a->fields[i].val != b->fields[i].val)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tif (a->mask[i] != b->mask[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "a->fields[i].gid",
            "b->fields[i].gid"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "a->fields[i].uid",
            "b->fields[i].uid"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "audit_mark_path(a->exe)",
            "audit_mark_path(b->exe)"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_mark_path",
          "args": [
            "b->exe"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "55-58",
          "snippet": "char *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_tree_path",
          "args": [
            "b->tree"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "123-126",
          "snippet": "const char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nconst char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_watch_path",
          "args": [
            "b->watch"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "audit_watch_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "123-126",
          "snippet": "char *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nchar *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)\n{\n\tint i;\n\n\tif (a->flags != b->flags ||\n\t    a->pflags != b->pflags ||\n\t    a->listnr != b->listnr ||\n\t    a->action != b->action ||\n\t    a->field_count != b->field_count)\n\t\treturn 1;\n\n\tfor (i = 0; i < a->field_count; i++) {\n\t\tif (a->fields[i].type != b->fields[i].type ||\n\t\t    a->fields[i].op != b->fields[i].op)\n\t\t\treturn 1;\n\n\t\tswitch(a->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (strcmp(audit_watch_path(a->watch),\n\t\t\t\t   audit_watch_path(b->watch)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (strcmp(audit_tree_path(a->tree),\n\t\t\t\t   audit_tree_path(b->tree)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* both filterkeys exist based on above type compare */\n\t\t\tif (strcmp(a->filterkey, b->filterkey))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\t/* both paths exist based on above type compare */\n\t\t\tif (strcmp(audit_mark_path(a->exe),\n\t\t\t\t   audit_mark_path(b->exe)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (!uid_eq(a->fields[i].uid, b->fields[i].uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (!gid_eq(a->fields[i].gid, b->fields[i].gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (a->fields[i].val != b->fields[i].val)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tif (a->mask[i] != b->mask[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_krule_to_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "634-700",
    "snippet": "static struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)\n{\n\tstruct audit_rule_data *data;\n\tvoid *bufp;\n\tint i;\n\n\tdata = kmalloc(struct_size(data, buf, krule->buflen), GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn NULL;\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->flags = krule->flags | krule->listnr;\n\tdata->action = krule->action;\n\tdata->field_count = krule->field_count;\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &krule->fields[i];\n\n\t\tdata->fields[i] = f->type;\n\t\tdata->fieldflags[i] = audit_ops[f->op];\n\t\tswitch(f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, f->lsm_str);\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_watch_path(krule->watch));\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_tree_path(krule->tree));\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, krule->filterkey);\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, audit_mark_path(krule->exe));\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tif (krule->pflags & AUDIT_LOGINUID_LEGACY && !f->val) {\n\t\t\t\tdata->fields[i] = AUDIT_LOGINUID;\n\t\t\t\tdata->values[i] = AUDIT_UID_UNSET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t/* if set */\n\t\tdefault:\n\t\t\tdata->values[i] = f->val;\n\t\t}\n\t}\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++) data->mask[i] = krule->mask[i];\n\n\treturn data;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_pack_string",
          "args": [
            "&bufp",
            "audit_mark_path(krule->exe)"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "audit_pack_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "623-631",
          "snippet": "static inline size_t audit_pack_string(void **bufp, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tmemcpy(*bufp, str, len);\n\t*bufp += len;\n\n\treturn len;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline size_t audit_pack_string(void **bufp, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tmemcpy(*bufp, str, len);\n\t*bufp += len;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_mark_path",
          "args": [
            "krule->exe"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "55-58",
          "snippet": "char *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_tree_path",
          "args": [
            "krule->tree"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "123-126",
          "snippet": "const char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nconst char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_watch_path",
          "args": [
            "krule->watch"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "audit_watch_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "123-126",
          "snippet": "char *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nchar *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "sizeof(*data)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "struct_size(data, buf, krule->buflen)",
            "GFP_KERNEL"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "data",
            "buf",
            "krule->buflen"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};\n\nstatic struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)\n{\n\tstruct audit_rule_data *data;\n\tvoid *bufp;\n\tint i;\n\n\tdata = kmalloc(struct_size(data, buf, krule->buflen), GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn NULL;\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->flags = krule->flags | krule->listnr;\n\tdata->action = krule->action;\n\tdata->field_count = krule->field_count;\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &krule->fields[i];\n\n\t\tdata->fields[i] = f->type;\n\t\tdata->fieldflags[i] = audit_ops[f->op];\n\t\tswitch(f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, f->lsm_str);\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_watch_path(krule->watch));\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_tree_path(krule->tree));\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, krule->filterkey);\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, audit_mark_path(krule->exe));\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tif (krule->pflags & AUDIT_LOGINUID_LEGACY && !f->val) {\n\t\t\t\tdata->fields[i] = AUDIT_LOGINUID;\n\t\t\t\tdata->values[i] = AUDIT_UID_UNSET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t/* if set */\n\t\tdefault:\n\t\t\tdata->values[i] = f->val;\n\t\t}\n\t}\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++) data->mask[i] = krule->mask[i];\n\n\treturn data;\n}"
  },
  {
    "function_name": "audit_pack_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "623-631",
    "snippet": "static inline size_t audit_pack_string(void **bufp, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tmemcpy(*bufp, str, len);\n\t*bufp += len;\n\n\treturn len;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*bufp",
            "str",
            "len"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline size_t audit_pack_string(void **bufp, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tmemcpy(*bufp, str, len);\n\t*bufp += len;\n\n\treturn len;\n}"
  },
  {
    "function_name": "audit_data_to_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "449-620",
    "snippet": "static struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,\n\t\t\t\t\t       size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\tvoid *bufp;\n\tsize_t remain = datasz - sizeof(struct audit_rule_data);\n\tint i;\n\tchar *str;\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\tentry = audit_to_entry_common(data);\n\tif (IS_ERR(entry))\n\t\tgoto exit_nofree;\n\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &entry->rule.fields[i];\n\t\tu32 f_val;\n\n\t\terr = -EINVAL;\n\n\t\tf->op = audit_to_op(data->fieldflags[i]);\n\t\tif (f->op == Audit_bad)\n\t\t\tgoto exit_free;\n\n\t\tf->type = data->fields[i];\n\t\tf_val = data->values[i];\n\n\t\t/* Support legacy tests for a valid loginuid */\n\t\tif ((f->type == AUDIT_LOGINUID) && (f_val == AUDIT_UID_UNSET)) {\n\t\t\tf->type = AUDIT_LOGINUID_SET;\n\t\t\tf_val = 0;\n\t\t\tentry->rule.pflags |= AUDIT_LOGINUID_LEGACY;\n\t\t}\n\n\t\terr = audit_field_valid(entry, f);\n\t\tif (err)\n\t\t\tgoto exit_free;\n\n\t\terr = -EINVAL;\n\t\tswitch (f->type) {\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tf->uid = make_kuid(current_user_ns(), f_val);\n\t\t\tif (!uid_valid(f->uid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tf->gid = make_kgid(current_user_ns(), f_val);\n\t\t\tif (!gid_valid(f->gid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tf->val = f_val;\n\t\t\tentry->rule.arch_f = f;\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tf->lsm_str = str;\n\t\t\terr = security_audit_rule_init(f->type, f->op, str,\n\t\t\t\t\t\t       (void **)&f->lsm_rule);\n\t\t\t/* Keep currently invalid fields around in case they\n\t\t\t * become valid after a policy reload. */\n\t\t\tif (err == -EINVAL) {\n\t\t\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\t\t\tstr);\n\t\t\t\terr = 0;\n\t\t\t} else if (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\terr = audit_to_watch(&entry->rule, str, f_val, f->op);\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\terr = audit_make_tree(&entry->rule, str, f->op);\n\t\t\tkfree(str);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tf->val = f_val;\n\t\t\terr = audit_to_inode(&entry->rule, f);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tif (entry->rule.filterkey || f_val > AUDIT_MAX_KEY_LEN)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tentry->rule.filterkey = str;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tif (entry->rule.exe || f_val > PATH_MAX)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\taudit_mark = audit_alloc_mark(&entry->rule, str, f_val);\n\t\t\tif (IS_ERR(audit_mark)) {\n\t\t\t\tkfree(str);\n\t\t\t\terr = PTR_ERR(audit_mark);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tentry->rule.exe = audit_mark;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf->val = f_val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (entry->rule.inode_f && entry->rule.inode_f->op == Audit_not_equal)\n\t\tentry->rule.inode_f = NULL;\n\nexit_nofree:\n\treturn entry;\n\nexit_free:\n\tif (entry->rule.tree)\n\t\taudit_put_tree(entry->rule.tree); /* that's the temporary one */\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe); /* that's the template one */\n\taudit_free_rule(entry);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_free_rule",
          "args": [
            "entry"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_rule_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "99-103",
          "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "entry->rule.exe"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "138-143",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_tree",
          "args": [
            "entry->rule.tree"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "740-743",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "audit_mark"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "str"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "audit_mark"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_alloc_mark",
          "args": [
            "&entry->rule",
            "str",
            "f_val"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_mark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "74-112",
          "snippet": "struct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule, char *pathname, int len)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint ret;\n\n\tif (pathname[0] != '/' || pathname[len-1] == '/')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdentry = kern_path_locked(pathname, &path);\n\tif (IS_ERR(dentry))\n\t\treturn ERR_CAST(dentry); /* returning an error */\n\tinode = path.dentry->d_inode;\n\tinode_unlock(inode);\n\n\taudit_mark = kzalloc(sizeof(*audit_mark), GFP_KERNEL);\n\tif (unlikely(!audit_mark)) {\n\t\taudit_mark = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfsnotify_init_mark(&audit_mark->mark, audit_fsnotify_group);\n\taudit_mark->mark.mask = AUDIT_FS_EVENTS;\n\taudit_mark->path = pathname;\n\taudit_update_mark(audit_mark, dentry->d_inode);\n\taudit_mark->rule = krule;\n\n\tret = fsnotify_add_inode_mark(&audit_mark->mark, inode, true);\n\tif (ret < 0) {\n\t\tfsnotify_put_mark(&audit_mark->mark);\n\t\taudit_mark = ERR_PTR(ret);\n\t}\nout:\n\tdput(dentry);\n\tpath_put(&path);\n\treturn audit_mark;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AUDIT_FS_EVENTS (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\t FS_MOVE_SELF)"
          ],
          "globals_used": [
            "static struct fsnotify_group *audit_fsnotify_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\n#define AUDIT_FS_EVENTS (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\t FS_MOVE_SELF)\n\nstatic struct fsnotify_group *audit_fsnotify_group;\n\nstruct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule, char *pathname, int len)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint ret;\n\n\tif (pathname[0] != '/' || pathname[len-1] == '/')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdentry = kern_path_locked(pathname, &path);\n\tif (IS_ERR(dentry))\n\t\treturn ERR_CAST(dentry); /* returning an error */\n\tinode = path.dentry->d_inode;\n\tinode_unlock(inode);\n\n\taudit_mark = kzalloc(sizeof(*audit_mark), GFP_KERNEL);\n\tif (unlikely(!audit_mark)) {\n\t\taudit_mark = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfsnotify_init_mark(&audit_mark->mark, audit_fsnotify_group);\n\taudit_mark->mark.mask = AUDIT_FS_EVENTS;\n\taudit_mark->path = pathname;\n\taudit_update_mark(audit_mark, dentry->d_inode);\n\taudit_mark->rule = krule;\n\n\tret = fsnotify_add_inode_mark(&audit_mark->mark, inode, true);\n\tif (ret < 0) {\n\t\tfsnotify_put_mark(&audit_mark->mark);\n\t\taudit_mark = ERR_PTR(ret);\n\t}\nout:\n\tdput(dentry);\n\tpath_put(&path);\n\treturn audit_mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "str"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_unpack_string",
          "args": [
            "&bufp",
            "&remain",
            "f_val"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "audit_unpack_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "127-150",
          "snippet": "char *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "str"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_to_inode",
          "args": [
            "&entry->rule",
            "f"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "audit_to_inode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "153-164",
          "snippet": "static inline int audit_to_inode(struct audit_krule *krule,\n\t\t\t\t struct audit_field *f)\n{\n\tif ((krule->listnr != AUDIT_FILTER_EXIT &&\n\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    krule->inode_f || krule->watch || krule->tree ||\n\t    (f->op != Audit_equal && f->op != Audit_not_equal))\n\t\treturn -EINVAL;\n\n\tkrule->inode_f = f;\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline int audit_to_inode(struct audit_krule *krule,\n\t\t\t\t struct audit_field *f)\n{\n\tif ((krule->listnr != AUDIT_FILTER_EXIT &&\n\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    krule->inode_f || krule->watch || krule->tree ||\n\t    (f->op != Audit_equal && f->op != Audit_not_equal))\n\t\treturn -EINVAL;\n\n\tkrule->inode_f = f;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_make_tree",
          "args": [
            "&entry->rule",
            "str",
            "f->op"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "audit_make_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "725-738",
          "snippet": "int audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)\n{\n\n\tif (pathname[0] != '/' ||\n\t    (rule->listnr != AUDIT_FILTER_EXIT &&\n\t     rule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    op != Audit_equal ||\n\t    rule->inode_f || rule->watch || rule->tree)\n\t\treturn -EINVAL;\n\trule->tree = alloc_tree(pathname);\n\tif (!rule->tree)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nint audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)\n{\n\n\tif (pathname[0] != '/' ||\n\t    (rule->listnr != AUDIT_FILTER_EXIT &&\n\t     rule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    op != Audit_equal ||\n\t    rule->inode_f || rule->watch || rule->tree)\n\t\treturn -EINVAL;\n\trule->tree = alloc_tree(pathname);\n\tif (!rule->tree)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "str"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_to_watch",
          "args": [
            "&entry->rule",
            "str",
            "f_val",
            "f->op"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "audit_to_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "178-199",
          "snippet": "int audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)\n{\n\tstruct audit_watch *watch;\n\n\tif (!audit_watch_group)\n\t\treturn -EOPNOTSUPP;\n\n\tif (path[0] != '/' || path[len-1] == '/' ||\n\t    (krule->listnr != AUDIT_FILTER_EXIT &&\n\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    op != Audit_equal ||\n\t    krule->inode_f || krule->watch || krule->tree)\n\t\treturn -EINVAL;\n\n\twatch = audit_init_watch(path);\n\tif (IS_ERR(watch))\n\t\treturn PTR_ERR(watch);\n\n\tkrule->watch = watch;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nint audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)\n{\n\tstruct audit_watch *watch;\n\n\tif (!audit_watch_group)\n\t\treturn -EOPNOTSUPP;\n\n\tif (path[0] != '/' || path[len-1] == '/' ||\n\t    (krule->listnr != AUDIT_FILTER_EXIT &&\n\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    op != Audit_equal ||\n\t    krule->inode_f || krule->watch || krule->tree)\n\t\treturn -EINVAL;\n\n\twatch = audit_init_watch(path);\n\tif (IS_ERR(watch))\n\t\treturn PTR_ERR(watch);\n\n\tkrule->watch = watch;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "str"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"audit rule for LSM \\'%s\\' is invalid\\n\"",
            "str"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_audit_rule_init",
          "args": [
            "f->type",
            "f->op",
            "str",
            "(void **)&f->lsm_rule"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "str"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "f->gid"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "f_val"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "make_kgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "459-463",
          "snippet": "kgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "f->uid"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "f_val"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "make_kuid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "391-395",
          "snippet": "kuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_field_valid",
          "args": [
            "entry",
            "f"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "audit_field_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "327-446",
          "snippet": "static int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_MSGTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_EXCLUDE &&\n\t\t    entry->rule.listnr != AUDIT_FILTER_USER)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FSTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_FS)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (entry->rule.listnr == AUDIT_FILTER_URING_EXIT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tswitch (entry->rule.listnr) {\n\tcase AUDIT_FILTER_FS:\n\t\tswitch(f->type) {\n\t\tcase AUDIT_FSTYPE:\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check for valid field type and op */\n\tswitch (f->type) {\n\tcase AUDIT_ARG0:\n\tcase AUDIT_ARG1:\n\tcase AUDIT_ARG2:\n\tcase AUDIT_ARG3:\n\tcase AUDIT_PERS: /* <uapi/linux/personality.h> */\n\tcase AUDIT_DEVMINOR:\n\t\t/* all ops are valid */\n\t\tbreak;\n\tcase AUDIT_UID:\n\tcase AUDIT_EUID:\n\tcase AUDIT_SUID:\n\tcase AUDIT_FSUID:\n\tcase AUDIT_LOGINUID:\n\tcase AUDIT_OBJ_UID:\n\tcase AUDIT_GID:\n\tcase AUDIT_EGID:\n\tcase AUDIT_SGID:\n\tcase AUDIT_FSGID:\n\tcase AUDIT_OBJ_GID:\n\tcase AUDIT_PID:\n\tcase AUDIT_MSGTYPE:\n\tcase AUDIT_PPID:\n\tcase AUDIT_DEVMAJOR:\n\tcase AUDIT_EXIT:\n\tcase AUDIT_SUCCESS:\n\tcase AUDIT_INODE:\n\tcase AUDIT_SESSIONID:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\tcase AUDIT_SADDR_FAM:\n\t\t/* bit ops are only useful on syscall args */\n\t\tif (f->op == Audit_bitmask || f->op == Audit_bittest)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_WATCH:\n\tcase AUDIT_DIR:\n\tcase AUDIT_FILTERKEY:\n\tcase AUDIT_LOGINUID_SET:\n\tcase AUDIT_ARCH:\n\tcase AUDIT_FSTYPE:\n\tcase AUDIT_PERM:\n\tcase AUDIT_FILETYPE:\n\tcase AUDIT_FIELD_COMPARE:\n\tcase AUDIT_EXE:\n\t\t/* only equal and not equal valid ops */\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t/* field not recognized */\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check for select valid field values */\n\tswitch (f->type) {\n\tcase AUDIT_LOGINUID_SET:\n\t\tif ((f->val != 0) && (f->val != 1))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (f->val & ~15)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FILETYPE:\n\t\tif (f->val & ~S_IFMT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FIELD_COMPARE:\n\t\tif (f->val > AUDIT_MAX_FIELD_COMPARE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SADDR_FAM:\n\t\tif (f->val >= AF_MAX)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_MSGTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_EXCLUDE &&\n\t\t    entry->rule.listnr != AUDIT_FILTER_USER)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FSTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_FS)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (entry->rule.listnr == AUDIT_FILTER_URING_EXIT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tswitch (entry->rule.listnr) {\n\tcase AUDIT_FILTER_FS:\n\t\tswitch(f->type) {\n\t\tcase AUDIT_FSTYPE:\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check for valid field type and op */\n\tswitch (f->type) {\n\tcase AUDIT_ARG0:\n\tcase AUDIT_ARG1:\n\tcase AUDIT_ARG2:\n\tcase AUDIT_ARG3:\n\tcase AUDIT_PERS: /* <uapi/linux/personality.h> */\n\tcase AUDIT_DEVMINOR:\n\t\t/* all ops are valid */\n\t\tbreak;\n\tcase AUDIT_UID:\n\tcase AUDIT_EUID:\n\tcase AUDIT_SUID:\n\tcase AUDIT_FSUID:\n\tcase AUDIT_LOGINUID:\n\tcase AUDIT_OBJ_UID:\n\tcase AUDIT_GID:\n\tcase AUDIT_EGID:\n\tcase AUDIT_SGID:\n\tcase AUDIT_FSGID:\n\tcase AUDIT_OBJ_GID:\n\tcase AUDIT_PID:\n\tcase AUDIT_MSGTYPE:\n\tcase AUDIT_PPID:\n\tcase AUDIT_DEVMAJOR:\n\tcase AUDIT_EXIT:\n\tcase AUDIT_SUCCESS:\n\tcase AUDIT_INODE:\n\tcase AUDIT_SESSIONID:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\tcase AUDIT_SADDR_FAM:\n\t\t/* bit ops are only useful on syscall args */\n\t\tif (f->op == Audit_bitmask || f->op == Audit_bittest)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_WATCH:\n\tcase AUDIT_DIR:\n\tcase AUDIT_FILTERKEY:\n\tcase AUDIT_LOGINUID_SET:\n\tcase AUDIT_ARCH:\n\tcase AUDIT_FSTYPE:\n\tcase AUDIT_PERM:\n\tcase AUDIT_FILETYPE:\n\tcase AUDIT_FIELD_COMPARE:\n\tcase AUDIT_EXE:\n\t\t/* only equal and not equal valid ops */\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t/* field not recognized */\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check for select valid field values */\n\tswitch (f->type) {\n\tcase AUDIT_LOGINUID_SET:\n\t\tif ((f->val != 0) && (f->val != 1))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (f->val & ~15)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FILETYPE:\n\t\tif (f->val & ~S_IFMT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FIELD_COMPARE:\n\t\tif (f->val > AUDIT_MAX_FIELD_COMPARE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SADDR_FAM:\n\t\tif (f->val >= AF_MAX)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_to_op",
          "args": [
            "data->fieldflags[i]"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "audit_to_op",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "318-324",
          "snippet": "static u32 audit_to_op(u32 op)\n{\n\tu32 n;\n\tfor (n = Audit_equal; n < Audit_bad && audit_ops[n] != op; n++)\n\t\t;\n\treturn n;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};\n\nstatic u32 audit_to_op(u32 op)\n{\n\tu32 n;\n\tfor (n = Audit_equal; n < Audit_bad && audit_ops[n] != op; n++)\n\t\t;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "entry"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_to_entry_common",
          "args": [
            "data"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "audit_to_entry_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "238-304",
          "snippet": "static inline struct audit_entry *audit_to_entry_common(struct audit_rule_data *rule)\n{\n\tunsigned listnr;\n\tstruct audit_entry *entry;\n\tint i, err;\n\n\terr = -EINVAL;\n\tlistnr = rule->flags & ~AUDIT_FILTER_PREPEND;\n\tswitch(listnr) {\n\tdefault:\n\t\tgoto exit_err;\n#ifdef CONFIG_AUDITSYSCALL\n\tcase AUDIT_FILTER_ENTRY:\n\t\tpr_err(\"AUDIT_FILTER_ENTRY is deprecated\\n\");\n\t\tgoto exit_err;\n\tcase AUDIT_FILTER_EXIT:\n\tcase AUDIT_FILTER_URING_EXIT:\n\tcase AUDIT_FILTER_TASK:\n#endif\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\t;\n\t}\n\tif (unlikely(rule->action == AUDIT_POSSIBLE)) {\n\t\tpr_err(\"AUDIT_POSSIBLE is deprecated\\n\");\n\t\tgoto exit_err;\n\t}\n\tif (rule->action != AUDIT_NEVER && rule->action != AUDIT_ALWAYS)\n\t\tgoto exit_err;\n\tif (rule->field_count > AUDIT_MAX_FIELDS)\n\t\tgoto exit_err;\n\n\terr = -ENOMEM;\n\tentry = audit_init_entry(rule->field_count);\n\tif (!entry)\n\t\tgoto exit_err;\n\n\tentry->rule.flags = rule->flags & AUDIT_FILTER_PREPEND;\n\tentry->rule.listnr = listnr;\n\tentry->rule.action = rule->action;\n\tentry->rule.field_count = rule->field_count;\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tentry->rule.mask[i] = rule->mask[i];\n\n\tfor (i = 0; i < AUDIT_SYSCALL_CLASSES; i++) {\n\t\tint bit = AUDIT_BITMASK_SIZE * 32 - i - 1;\n\t\t__u32 *p = &entry->rule.mask[AUDIT_WORD(bit)];\n\t\t__u32 *class;\n\n\t\tif (!(*p & AUDIT_BIT(bit)))\n\t\t\tcontinue;\n\t\t*p &= ~AUDIT_BIT(bit);\n\t\tclass = classes[i];\n\t\tif (class) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < AUDIT_BITMASK_SIZE; j++)\n\t\t\t\tentry->rule.mask[j] |= class[j];\n\t\t}\n\t}\n\n\treturn entry;\n\nexit_err:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nstatic inline struct audit_entry *audit_to_entry_common(struct audit_rule_data *rule)\n{\n\tunsigned listnr;\n\tstruct audit_entry *entry;\n\tint i, err;\n\n\terr = -EINVAL;\n\tlistnr = rule->flags & ~AUDIT_FILTER_PREPEND;\n\tswitch(listnr) {\n\tdefault:\n\t\tgoto exit_err;\n#ifdef CONFIG_AUDITSYSCALL\n\tcase AUDIT_FILTER_ENTRY:\n\t\tpr_err(\"AUDIT_FILTER_ENTRY is deprecated\\n\");\n\t\tgoto exit_err;\n\tcase AUDIT_FILTER_EXIT:\n\tcase AUDIT_FILTER_URING_EXIT:\n\tcase AUDIT_FILTER_TASK:\n#endif\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\t;\n\t}\n\tif (unlikely(rule->action == AUDIT_POSSIBLE)) {\n\t\tpr_err(\"AUDIT_POSSIBLE is deprecated\\n\");\n\t\tgoto exit_err;\n\t}\n\tif (rule->action != AUDIT_NEVER && rule->action != AUDIT_ALWAYS)\n\t\tgoto exit_err;\n\tif (rule->field_count > AUDIT_MAX_FIELDS)\n\t\tgoto exit_err;\n\n\terr = -ENOMEM;\n\tentry = audit_init_entry(rule->field_count);\n\tif (!entry)\n\t\tgoto exit_err;\n\n\tentry->rule.flags = rule->flags & AUDIT_FILTER_PREPEND;\n\tentry->rule.listnr = listnr;\n\tentry->rule.action = rule->action;\n\tentry->rule.field_count = rule->field_count;\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tentry->rule.mask[i] = rule->mask[i];\n\n\tfor (i = 0; i < AUDIT_SYSCALL_CLASSES; i++) {\n\t\tint bit = AUDIT_BITMASK_SIZE * 32 - i - 1;\n\t\t__u32 *p = &entry->rule.mask[AUDIT_WORD(bit)];\n\t\t__u32 *class;\n\n\t\tif (!(*p & AUDIT_BIT(bit)))\n\t\t\tcontinue;\n\t\t*p &= ~AUDIT_BIT(bit);\n\t\tclass = classes[i];\n\t\tif (class) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < AUDIT_BITMASK_SIZE; j++)\n\t\t\t\tentry->rule.mask[j] |= class[j];\n\t\t}\n\t}\n\n\treturn entry;\n\nexit_err:\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,\n\t\t\t\t\t       size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\tvoid *bufp;\n\tsize_t remain = datasz - sizeof(struct audit_rule_data);\n\tint i;\n\tchar *str;\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\tentry = audit_to_entry_common(data);\n\tif (IS_ERR(entry))\n\t\tgoto exit_nofree;\n\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &entry->rule.fields[i];\n\t\tu32 f_val;\n\n\t\terr = -EINVAL;\n\n\t\tf->op = audit_to_op(data->fieldflags[i]);\n\t\tif (f->op == Audit_bad)\n\t\t\tgoto exit_free;\n\n\t\tf->type = data->fields[i];\n\t\tf_val = data->values[i];\n\n\t\t/* Support legacy tests for a valid loginuid */\n\t\tif ((f->type == AUDIT_LOGINUID) && (f_val == AUDIT_UID_UNSET)) {\n\t\t\tf->type = AUDIT_LOGINUID_SET;\n\t\t\tf_val = 0;\n\t\t\tentry->rule.pflags |= AUDIT_LOGINUID_LEGACY;\n\t\t}\n\n\t\terr = audit_field_valid(entry, f);\n\t\tif (err)\n\t\t\tgoto exit_free;\n\n\t\terr = -EINVAL;\n\t\tswitch (f->type) {\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tf->uid = make_kuid(current_user_ns(), f_val);\n\t\t\tif (!uid_valid(f->uid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tf->gid = make_kgid(current_user_ns(), f_val);\n\t\t\tif (!gid_valid(f->gid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tf->val = f_val;\n\t\t\tentry->rule.arch_f = f;\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tf->lsm_str = str;\n\t\t\terr = security_audit_rule_init(f->type, f->op, str,\n\t\t\t\t\t\t       (void **)&f->lsm_rule);\n\t\t\t/* Keep currently invalid fields around in case they\n\t\t\t * become valid after a policy reload. */\n\t\t\tif (err == -EINVAL) {\n\t\t\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\t\t\tstr);\n\t\t\t\terr = 0;\n\t\t\t} else if (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\terr = audit_to_watch(&entry->rule, str, f_val, f->op);\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\terr = audit_make_tree(&entry->rule, str, f->op);\n\t\t\tkfree(str);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tf->val = f_val;\n\t\t\terr = audit_to_inode(&entry->rule, f);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tif (entry->rule.filterkey || f_val > AUDIT_MAX_KEY_LEN)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tentry->rule.filterkey = str;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tif (entry->rule.exe || f_val > PATH_MAX)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\taudit_mark = audit_alloc_mark(&entry->rule, str, f_val);\n\t\t\tif (IS_ERR(audit_mark)) {\n\t\t\t\tkfree(str);\n\t\t\t\terr = PTR_ERR(audit_mark);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tentry->rule.exe = audit_mark;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf->val = f_val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (entry->rule.inode_f && entry->rule.inode_f->op == Audit_not_equal)\n\t\tentry->rule.inode_f = NULL;\n\nexit_nofree:\n\treturn entry;\n\nexit_free:\n\tif (entry->rule.tree)\n\t\taudit_put_tree(entry->rule.tree); /* that's the temporary one */\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe); /* that's the template one */\n\taudit_free_rule(entry);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "audit_field_valid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "327-446",
    "snippet": "static int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_MSGTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_EXCLUDE &&\n\t\t    entry->rule.listnr != AUDIT_FILTER_USER)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FSTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_FS)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (entry->rule.listnr == AUDIT_FILTER_URING_EXIT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tswitch (entry->rule.listnr) {\n\tcase AUDIT_FILTER_FS:\n\t\tswitch(f->type) {\n\t\tcase AUDIT_FSTYPE:\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check for valid field type and op */\n\tswitch (f->type) {\n\tcase AUDIT_ARG0:\n\tcase AUDIT_ARG1:\n\tcase AUDIT_ARG2:\n\tcase AUDIT_ARG3:\n\tcase AUDIT_PERS: /* <uapi/linux/personality.h> */\n\tcase AUDIT_DEVMINOR:\n\t\t/* all ops are valid */\n\t\tbreak;\n\tcase AUDIT_UID:\n\tcase AUDIT_EUID:\n\tcase AUDIT_SUID:\n\tcase AUDIT_FSUID:\n\tcase AUDIT_LOGINUID:\n\tcase AUDIT_OBJ_UID:\n\tcase AUDIT_GID:\n\tcase AUDIT_EGID:\n\tcase AUDIT_SGID:\n\tcase AUDIT_FSGID:\n\tcase AUDIT_OBJ_GID:\n\tcase AUDIT_PID:\n\tcase AUDIT_MSGTYPE:\n\tcase AUDIT_PPID:\n\tcase AUDIT_DEVMAJOR:\n\tcase AUDIT_EXIT:\n\tcase AUDIT_SUCCESS:\n\tcase AUDIT_INODE:\n\tcase AUDIT_SESSIONID:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\tcase AUDIT_SADDR_FAM:\n\t\t/* bit ops are only useful on syscall args */\n\t\tif (f->op == Audit_bitmask || f->op == Audit_bittest)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_WATCH:\n\tcase AUDIT_DIR:\n\tcase AUDIT_FILTERKEY:\n\tcase AUDIT_LOGINUID_SET:\n\tcase AUDIT_ARCH:\n\tcase AUDIT_FSTYPE:\n\tcase AUDIT_PERM:\n\tcase AUDIT_FILETYPE:\n\tcase AUDIT_FIELD_COMPARE:\n\tcase AUDIT_EXE:\n\t\t/* only equal and not equal valid ops */\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t/* field not recognized */\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check for select valid field values */\n\tswitch (f->type) {\n\tcase AUDIT_LOGINUID_SET:\n\t\tif ((f->val != 0) && (f->val != 1))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (f->val & ~15)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FILETYPE:\n\t\tif (f->val & ~S_IFMT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FIELD_COMPARE:\n\t\tif (f->val > AUDIT_MAX_FIELD_COMPARE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SADDR_FAM:\n\t\tif (f->val >= AF_MAX)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_MSGTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_EXCLUDE &&\n\t\t    entry->rule.listnr != AUDIT_FILTER_USER)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FSTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_FS)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (entry->rule.listnr == AUDIT_FILTER_URING_EXIT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tswitch (entry->rule.listnr) {\n\tcase AUDIT_FILTER_FS:\n\t\tswitch(f->type) {\n\t\tcase AUDIT_FSTYPE:\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check for valid field type and op */\n\tswitch (f->type) {\n\tcase AUDIT_ARG0:\n\tcase AUDIT_ARG1:\n\tcase AUDIT_ARG2:\n\tcase AUDIT_ARG3:\n\tcase AUDIT_PERS: /* <uapi/linux/personality.h> */\n\tcase AUDIT_DEVMINOR:\n\t\t/* all ops are valid */\n\t\tbreak;\n\tcase AUDIT_UID:\n\tcase AUDIT_EUID:\n\tcase AUDIT_SUID:\n\tcase AUDIT_FSUID:\n\tcase AUDIT_LOGINUID:\n\tcase AUDIT_OBJ_UID:\n\tcase AUDIT_GID:\n\tcase AUDIT_EGID:\n\tcase AUDIT_SGID:\n\tcase AUDIT_FSGID:\n\tcase AUDIT_OBJ_GID:\n\tcase AUDIT_PID:\n\tcase AUDIT_MSGTYPE:\n\tcase AUDIT_PPID:\n\tcase AUDIT_DEVMAJOR:\n\tcase AUDIT_EXIT:\n\tcase AUDIT_SUCCESS:\n\tcase AUDIT_INODE:\n\tcase AUDIT_SESSIONID:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\tcase AUDIT_SADDR_FAM:\n\t\t/* bit ops are only useful on syscall args */\n\t\tif (f->op == Audit_bitmask || f->op == Audit_bittest)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_WATCH:\n\tcase AUDIT_DIR:\n\tcase AUDIT_FILTERKEY:\n\tcase AUDIT_LOGINUID_SET:\n\tcase AUDIT_ARCH:\n\tcase AUDIT_FSTYPE:\n\tcase AUDIT_PERM:\n\tcase AUDIT_FILETYPE:\n\tcase AUDIT_FIELD_COMPARE:\n\tcase AUDIT_EXE:\n\t\t/* only equal and not equal valid ops */\n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t/* field not recognized */\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check for select valid field values */\n\tswitch (f->type) {\n\tcase AUDIT_LOGINUID_SET:\n\t\tif ((f->val != 0) && (f->val != 1))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (f->val & ~15)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FILETYPE:\n\t\tif (f->val & ~S_IFMT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FIELD_COMPARE:\n\t\tif (f->val > AUDIT_MAX_FIELD_COMPARE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SADDR_FAM:\n\t\tif (f->val >= AF_MAX)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_to_op",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "318-324",
    "snippet": "static u32 audit_to_op(u32 op)\n{\n\tu32 n;\n\tfor (n = Audit_equal; n < Audit_bad && audit_ops[n] != op; n++)\n\t\t;\n\treturn n;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};\n\nstatic u32 audit_to_op(u32 op)\n{\n\tu32 n;\n\tfor (n = Audit_equal; n < Audit_bad && audit_ops[n] != op; n++)\n\t\t;\n\treturn n;\n}"
  },
  {
    "function_name": "audit_to_entry_common",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "238-304",
    "snippet": "static inline struct audit_entry *audit_to_entry_common(struct audit_rule_data *rule)\n{\n\tunsigned listnr;\n\tstruct audit_entry *entry;\n\tint i, err;\n\n\terr = -EINVAL;\n\tlistnr = rule->flags & ~AUDIT_FILTER_PREPEND;\n\tswitch(listnr) {\n\tdefault:\n\t\tgoto exit_err;\n#ifdef CONFIG_AUDITSYSCALL\n\tcase AUDIT_FILTER_ENTRY:\n\t\tpr_err(\"AUDIT_FILTER_ENTRY is deprecated\\n\");\n\t\tgoto exit_err;\n\tcase AUDIT_FILTER_EXIT:\n\tcase AUDIT_FILTER_URING_EXIT:\n\tcase AUDIT_FILTER_TASK:\n#endif\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\t;\n\t}\n\tif (unlikely(rule->action == AUDIT_POSSIBLE)) {\n\t\tpr_err(\"AUDIT_POSSIBLE is deprecated\\n\");\n\t\tgoto exit_err;\n\t}\n\tif (rule->action != AUDIT_NEVER && rule->action != AUDIT_ALWAYS)\n\t\tgoto exit_err;\n\tif (rule->field_count > AUDIT_MAX_FIELDS)\n\t\tgoto exit_err;\n\n\terr = -ENOMEM;\n\tentry = audit_init_entry(rule->field_count);\n\tif (!entry)\n\t\tgoto exit_err;\n\n\tentry->rule.flags = rule->flags & AUDIT_FILTER_PREPEND;\n\tentry->rule.listnr = listnr;\n\tentry->rule.action = rule->action;\n\tentry->rule.field_count = rule->field_count;\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tentry->rule.mask[i] = rule->mask[i];\n\n\tfor (i = 0; i < AUDIT_SYSCALL_CLASSES; i++) {\n\t\tint bit = AUDIT_BITMASK_SIZE * 32 - i - 1;\n\t\t__u32 *p = &entry->rule.mask[AUDIT_WORD(bit)];\n\t\t__u32 *class;\n\n\t\tif (!(*p & AUDIT_BIT(bit)))\n\t\t\tcontinue;\n\t\t*p &= ~AUDIT_BIT(bit);\n\t\tclass = classes[i];\n\t\tif (class) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < AUDIT_BITMASK_SIZE; j++)\n\t\t\t\tentry->rule.mask[j] |= class[j];\n\t\t}\n\t}\n\n\treturn entry;\n\nexit_err:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_BIT",
          "args": [
            "bit"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_BIT",
          "args": [
            "bit"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_WORD",
          "args": [
            "bit"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_init_entry",
          "args": [
            "rule->field_count"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "audit_init_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "106-123",
          "snippet": "static inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"AUDIT_POSSIBLE is deprecated\\n\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rule->action == AUDIT_POSSIBLE"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"AUDIT_FILTER_ENTRY is deprecated\\n\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nstatic inline struct audit_entry *audit_to_entry_common(struct audit_rule_data *rule)\n{\n\tunsigned listnr;\n\tstruct audit_entry *entry;\n\tint i, err;\n\n\terr = -EINVAL;\n\tlistnr = rule->flags & ~AUDIT_FILTER_PREPEND;\n\tswitch(listnr) {\n\tdefault:\n\t\tgoto exit_err;\n#ifdef CONFIG_AUDITSYSCALL\n\tcase AUDIT_FILTER_ENTRY:\n\t\tpr_err(\"AUDIT_FILTER_ENTRY is deprecated\\n\");\n\t\tgoto exit_err;\n\tcase AUDIT_FILTER_EXIT:\n\tcase AUDIT_FILTER_URING_EXIT:\n\tcase AUDIT_FILTER_TASK:\n#endif\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\t;\n\t}\n\tif (unlikely(rule->action == AUDIT_POSSIBLE)) {\n\t\tpr_err(\"AUDIT_POSSIBLE is deprecated\\n\");\n\t\tgoto exit_err;\n\t}\n\tif (rule->action != AUDIT_NEVER && rule->action != AUDIT_ALWAYS)\n\t\tgoto exit_err;\n\tif (rule->field_count > AUDIT_MAX_FIELDS)\n\t\tgoto exit_err;\n\n\terr = -ENOMEM;\n\tentry = audit_init_entry(rule->field_count);\n\tif (!entry)\n\t\tgoto exit_err;\n\n\tentry->rule.flags = rule->flags & AUDIT_FILTER_PREPEND;\n\tentry->rule.listnr = listnr;\n\tentry->rule.action = rule->action;\n\tentry->rule.field_count = rule->field_count;\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tentry->rule.mask[i] = rule->mask[i];\n\n\tfor (i = 0; i < AUDIT_SYSCALL_CLASSES; i++) {\n\t\tint bit = AUDIT_BITMASK_SIZE * 32 - i - 1;\n\t\t__u32 *p = &entry->rule.mask[AUDIT_WORD(bit)];\n\t\t__u32 *class;\n\n\t\tif (!(*p & AUDIT_BIT(bit)))\n\t\t\tcontinue;\n\t\t*p &= ~AUDIT_BIT(bit);\n\t\tclass = classes[i];\n\t\tif (class) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < AUDIT_BITMASK_SIZE; j++)\n\t\t\t\tentry->rule.mask[j] |= class[j];\n\t\t}\n\t}\n\n\treturn entry;\n\nexit_err:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "audit_match_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "211-234",
    "snippet": "static int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_match_class_bits",
          "args": [
            "AUDIT_CLASS_SIGNAL_32",
            "entry->rule.mask"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_class_bits",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "199-209",
          "snippet": "static inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nstatic inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_classify_arch",
          "args": [
            "arch->val"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t/* When arch is unspecified, we must check both masks on biarch\n\t\t * as syscall number alone is ambiguous. */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch(audit_classify_arch(arch->val)) {\n\tcase 0: /* native */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1: /* 32bit on biarch */\n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "audit_match_class_bits",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "199-209",
    "snippet": "static inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nstatic inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "audit_match_class",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "189-196",
    "snippet": "int audit_match_class(int class, unsigned syscall)\n{\n\tif (unlikely(syscall >= AUDIT_BITMASK_SIZE * 32))\n\t\treturn 0;\n\tif (unlikely(class >= AUDIT_SYSCALL_CLASSES || !classes[class]))\n\t\treturn 0;\n\treturn classes[class][AUDIT_WORD(syscall)] & AUDIT_BIT(syscall);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUDIT_BIT",
          "args": [
            "syscall"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_WORD",
          "args": [
            "syscall"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "class >= AUDIT_SYSCALL_CLASSES || !classes[class]"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "syscall >= AUDIT_BITMASK_SIZE * 32"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nint audit_match_class(int class, unsigned syscall)\n{\n\tif (unlikely(syscall >= AUDIT_BITMASK_SIZE * 32))\n\t\treturn 0;\n\tif (unlikely(class >= AUDIT_SYSCALL_CLASSES || !classes[class]))\n\t\treturn 0;\n\treturn classes[class][AUDIT_WORD(syscall)] & AUDIT_BIT(syscall);\n}"
  },
  {
    "function_name": "audit_register_class",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "168-187",
    "snippet": "int __init audit_register_class(int class, unsigned *list)\n{\n\t__u32 *p = kcalloc(AUDIT_BITMASK_SIZE, sizeof(__u32), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\twhile (*list != ~0U) {\n\t\tunsigned n = *list++;\n\t\tif (n >= AUDIT_BITMASK_SIZE * 32 - AUDIT_SYSCALL_CLASSES) {\n\t\t\tkfree(p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp[AUDIT_WORD(n)] |= AUDIT_BIT(n);\n\t}\n\tif (class >= AUDIT_SYSCALL_CLASSES || classes[class]) {\n\t\tkfree(p);\n\t\treturn -EINVAL;\n\t}\n\tclasses[class] = p;\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUDIT_BIT",
          "args": [
            "n"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_WORD",
          "args": [
            "n"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "AUDIT_BITMASK_SIZE",
            "sizeof(__u32)",
            "GFP_KERNEL"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nint __init audit_register_class(int class, unsigned *list)\n{\n\t__u32 *p = kcalloc(AUDIT_BITMASK_SIZE, sizeof(__u32), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\twhile (*list != ~0U) {\n\t\tunsigned n = *list++;\n\t\tif (n >= AUDIT_BITMASK_SIZE * 32 - AUDIT_SYSCALL_CLASSES) {\n\t\t\tkfree(p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp[AUDIT_WORD(n)] |= AUDIT_BIT(n);\n\t}\n\tif (class >= AUDIT_SYSCALL_CLASSES || classes[class]) {\n\t\tkfree(p);\n\t\treturn -EINVAL;\n\t}\n\tclasses[class] = p;\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_to_inode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "153-164",
    "snippet": "static inline int audit_to_inode(struct audit_krule *krule,\n\t\t\t\t struct audit_field *f)\n{\n\tif ((krule->listnr != AUDIT_FILTER_EXIT &&\n\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    krule->inode_f || krule->watch || krule->tree ||\n\t    (f->op != Audit_equal && f->op != Audit_not_equal))\n\t\treturn -EINVAL;\n\n\tkrule->inode_f = f;\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline int audit_to_inode(struct audit_krule *krule,\n\t\t\t\t struct audit_field *f)\n{\n\tif ((krule->listnr != AUDIT_FILTER_EXIT &&\n\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    krule->inode_f || krule->watch || krule->tree ||\n\t    (f->op != Audit_equal && f->op != Audit_not_equal))\n\t\treturn -EINVAL;\n\n\tkrule->inode_f = f;\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_unpack_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "127-150",
    "snippet": "char *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "str",
            "*bufp",
            "len"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!str"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Of the currently implemented string fields, PATH_MAX\n\t * defines the longest valid length.\n\t */\n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}"
  },
  {
    "function_name": "audit_init_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "106-123",
    "snippet": "static inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fields"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "field_count",
            "sizeof(*fields)",
            "GFP_KERNEL"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!entry"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*entry)",
            "GFP_KERNEL"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}"
  },
  {
    "function_name": "audit_free_rule_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "99-103",
    "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_free_rule",
          "args": [
            "e"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_rule_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "99-103",
          "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structaudit_entry",
            "rcu"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}"
  },
  {
    "function_name": "audit_free_rule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "83-97",
    "snippet": "static inline void audit_free_rule(struct audit_entry *e)\n{\n\tint i;\n\tstruct audit_krule *erule = &e->rule;\n\n\t/* some rules don't have associated watches */\n\tif (erule->watch)\n\t\taudit_put_watch(erule->watch);\n\tif (erule->fields)\n\t\tfor (i = 0; i < erule->field_count; i++)\n\t\t\taudit_free_lsm_field(&erule->fields[i]);\n\tkfree(erule->fields);\n\tkfree(erule->filterkey);\n\tkfree(e);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "e"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_free_lsm_field",
          "args": [
            "&erule->fields[i]"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_lsm_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "65-81",
          "snippet": "static void audit_free_lsm_field(struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tkfree(f->lsm_str);\n\t\tsecurity_audit_rule_free(f->lsm_rule);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic void audit_free_lsm_field(struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tkfree(f->lsm_str);\n\t\tsecurity_audit_rule_free(f->lsm_rule);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_watch",
          "args": [
            "erule->watch"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "105-113",
          "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic inline void audit_free_rule(struct audit_entry *e)\n{\n\tint i;\n\tstruct audit_krule *erule = &e->rule;\n\n\t/* some rules don't have associated watches */\n\tif (erule->watch)\n\t\taudit_put_watch(erule->watch);\n\tif (erule->fields)\n\t\tfor (i = 0; i < erule->field_count; i++)\n\t\t\taudit_free_lsm_field(&erule->fields[i]);\n\tkfree(erule->fields);\n\tkfree(erule->filterkey);\n\tkfree(e);\n}"
  },
  {
    "function_name": "audit_free_lsm_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
    "lines": "65-81",
    "snippet": "static void audit_free_lsm_field(struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tkfree(f->lsm_str);\n\t\tsecurity_audit_rule_free(f->lsm_rule);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <net/sock.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_audit_rule_free",
          "args": [
            "f->lsm_rule"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "f->lsm_str"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic void audit_free_lsm_field(struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tkfree(f->lsm_str);\n\t\tsecurity_audit_rule_free(f->lsm_rule);\n\t}\n}"
  }
]