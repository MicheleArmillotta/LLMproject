[
  {
    "function_name": "bpf_mmap_unlock_mm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/mmap_unlock_work.h",
    "lines": "49-63",
    "snippet": "static inline void bpf_mmap_unlock_mm(struct mmap_unlock_irq_work *work, struct mm_struct *mm)\n{\n\tif (!work) {\n\t\tmmap_read_unlock(mm);\n\t} else {\n\t\twork->mm = mm;\n\n\t\t/* The lock will be released once we're out of interrupt\n\t\t * context. Tell lockdep that we've released it now so\n\t\t * it doesn't complain that we forgot to release it.\n\t\t */\n\t\trwsem_release(&mm->mmap_lock.dep_map, _RET_IP_);\n\t\tirq_work_queue(&work->irq_work);\n\t}\n}",
    "includes": [
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&work->irq_work"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "106-118",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rwsem_release",
          "args": [
            "&mm->mmap_lock.dep_map",
            "_RET_IP_"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap_read_unlock",
          "args": [
            "mm"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/irq_work.h>\n\nstatic inline void bpf_mmap_unlock_mm(struct mmap_unlock_irq_work *work, struct mm_struct *mm)\n{\n\tif (!work) {\n\t\tmmap_read_unlock(mm);\n\t} else {\n\t\twork->mm = mm;\n\n\t\t/* The lock will be released once we're out of interrupt\n\t\t * context. Tell lockdep that we've released it now so\n\t\t * it doesn't complain that we forgot to release it.\n\t\t */\n\t\trwsem_release(&mm->mmap_lock.dep_map, _RET_IP_);\n\t\tirq_work_queue(&work->irq_work);\n\t}\n}"
  },
  {
    "function_name": "bpf_mmap_unlock_get_irq_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/mmap_unlock_work.h",
    "lines": "24-47",
    "snippet": "static inline bool bpf_mmap_unlock_get_irq_work(struct mmap_unlock_irq_work **work_ptr)\n{\n\tstruct mmap_unlock_irq_work *work = NULL;\n\tbool irq_work_busy = false;\n\n\tif (irqs_disabled()) {\n\t\tif (!IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\t\twork = this_cpu_ptr(&mmap_unlock_work);\n\t\t\tif (irq_work_is_busy(&work->irq_work)) {\n\t\t\t\t/* cannot queue more up_read, fallback */\n\t\t\t\tirq_work_busy = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * PREEMPT_RT does not allow to trylock mmap sem in\n\t\t\t * interrupt disabled context. Force the fallback code.\n\t\t\t */\n\t\t\tirq_work_busy = true;\n\t\t}\n\t}\n\n\t*work_ptr = work;\n\treturn irq_work_busy;\n}",
    "includes": [
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_is_busy",
          "args": [
            "&work->irq_work"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&mmap_unlock_work"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/irq_work.h>\n\nstatic inline bool bpf_mmap_unlock_get_irq_work(struct mmap_unlock_irq_work **work_ptr)\n{\n\tstruct mmap_unlock_irq_work *work = NULL;\n\tbool irq_work_busy = false;\n\n\tif (irqs_disabled()) {\n\t\tif (!IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\t\twork = this_cpu_ptr(&mmap_unlock_work);\n\t\t\tif (irq_work_is_busy(&work->irq_work)) {\n\t\t\t\t/* cannot queue more up_read, fallback */\n\t\t\t\tirq_work_busy = true;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * PREEMPT_RT does not allow to trylock mmap sem in\n\t\t\t * interrupt disabled context. Force the fallback code.\n\t\t\t */\n\t\t\tirq_work_busy = true;\n\t\t}\n\t}\n\n\t*work_ptr = work;\n\treturn irq_work_busy;\n}"
  }
]