[
  {
    "function_name": "clockid_to_kclock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1398-1411",
    "snippet": "static const struct k_clock *clockid_to_kclock(const clockid_t id)\n{\n\tclockid_t idx = id;\n\n\tif (id < 0) {\n\t\treturn (id & CLOCKFD_MASK) == CLOCKFD ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\t}\n\n\tif (id >= ARRAY_SIZE(posix_clocks))\n\t\treturn NULL;\n\n\treturn posix_clocks[array_index_nospec(idx, ARRAY_SIZE(posix_clocks))];\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct k_clock * const posix_clocks[];",
      "static const struct k_clock *clockid_to_kclock(const clockid_t id);",
      "static const struct k_clock * const posix_clocks[] = {\n\t[CLOCK_REALTIME]\t\t= &clock_realtime,\n\t[CLOCK_MONOTONIC]\t\t= &clock_monotonic,\n\t[CLOCK_PROCESS_CPUTIME_ID]\t= &clock_process,\n\t[CLOCK_THREAD_CPUTIME_ID]\t= &clock_thread,\n\t[CLOCK_MONOTONIC_RAW]\t\t= &clock_monotonic_raw,\n\t[CLOCK_REALTIME_COARSE]\t\t= &clock_realtime_coarse,\n\t[CLOCK_MONOTONIC_COARSE]\t= &clock_monotonic_coarse,\n\t[CLOCK_BOOTTIME]\t\t= &clock_boottime,\n\t[CLOCK_REALTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_BOOTTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_TAI]\t\t\t= &clock_tai,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "idx",
            "ARRAY_SIZE(posix_clocks)"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "posix_clocks"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "posix_clocks"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic const struct k_clock * const posix_clocks[];\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\nstatic const struct k_clock * const posix_clocks[] = {\n\t[CLOCK_REALTIME]\t\t= &clock_realtime,\n\t[CLOCK_MONOTONIC]\t\t= &clock_monotonic,\n\t[CLOCK_PROCESS_CPUTIME_ID]\t= &clock_process,\n\t[CLOCK_THREAD_CPUTIME_ID]\t= &clock_thread,\n\t[CLOCK_MONOTONIC_RAW]\t\t= &clock_monotonic_raw,\n\t[CLOCK_REALTIME_COARSE]\t\t= &clock_realtime_coarse,\n\t[CLOCK_MONOTONIC_COARSE]\t= &clock_monotonic_coarse,\n\t[CLOCK_BOOTTIME]\t\t= &clock_boottime,\n\t[CLOCK_REALTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_BOOTTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_TAI]\t\t\t= &clock_tai,\n};\n\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id)\n{\n\tclockid_t idx = id;\n\n\tif (id < 0) {\n\t\treturn (id & CLOCKFD_MASK) == CLOCKFD ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\t}\n\n\tif (id >= ARRAY_SIZE(posix_clocks))\n\t\treturn NULL;\n\n\treturn posix_clocks[array_index_nospec(idx, ARRAY_SIZE(posix_clocks))];\n}"
  },
  {
    "function_name": "common_nsleep_timens",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1232-1243",
    "snippet": "static int common_nsleep_timens(const clockid_t which_clock, int flags,\n\t\t\t const struct timespec64 *rqtp)\n{\n\tktime_t texp = timespec64_to_ktime(*rqtp);\n\n\tif (flags & TIMER_ABSTIME)\n\t\ttexp = timens_ktime_to_host(which_clock, texp);\n\n\treturn hrtimer_nanosleep(texp, flags & TIMER_ABSTIME ?\n\t\t\t\t HRTIMER_MODE_ABS : HRTIMER_MODE_REL,\n\t\t\t\t which_clock);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_nanosleep",
          "args": [
            "texp",
            "flags & TIMER_ABSTIME ?\n\t\t\t\t HRTIMER_MODE_ABS : HRTIMER_MODE_REL",
            "which_clock"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_nanosleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2083-2114",
          "snippet": "long hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,\n\t\t       const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tu64 slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_sleeper_on_stack(&t, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, rqtp, slack);\n\tret = do_nanosleep(&t, mode);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\tgoto out;\n\n\t/* Absolute timers do not update the rmtp value and restart: */\n\tif (mode == HRTIMER_MODE_ABS) {\n\t\tret = -ERESTARTNOHAND;\n\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\n\tset_restart_fn(restart, hrtimer_nanosleep_restart);\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nlong hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,\n\t\t       const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tu64 slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_sleeper_on_stack(&t, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, rqtp, slack);\n\tret = do_nanosleep(&t, mode);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\tgoto out;\n\n\t/* Absolute timers do not update the rmtp value and restart: */\n\tif (mode == HRTIMER_MODE_ABS) {\n\t\tret = -ERESTARTNOHAND;\n\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\n\tset_restart_fn(restart, hrtimer_nanosleep_restart);\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timens_ktime_to_host",
          "args": [
            "which_clock",
            "texp"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*rqtp"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic int common_nsleep_timens(const clockid_t which_clock, int flags,\n\t\t\t const struct timespec64 *rqtp)\n{\n\tktime_t texp = timespec64_to_ktime(*rqtp);\n\n\tif (flags & TIMER_ABSTIME)\n\t\ttexp = timens_ktime_to_host(which_clock, texp);\n\n\treturn hrtimer_nanosleep(texp, flags & TIMER_ABSTIME ?\n\t\t\t\t HRTIMER_MODE_ABS : HRTIMER_MODE_REL,\n\t\t\t\t which_clock);\n}"
  },
  {
    "function_name": "common_nsleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1222-1230",
    "snippet": "static int common_nsleep(const clockid_t which_clock, int flags,\n\t\t\t const struct timespec64 *rqtp)\n{\n\tktime_t texp = timespec64_to_ktime(*rqtp);\n\n\treturn hrtimer_nanosleep(texp, flags & TIMER_ABSTIME ?\n\t\t\t\t HRTIMER_MODE_ABS : HRTIMER_MODE_REL,\n\t\t\t\t which_clock);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_nanosleep",
          "args": [
            "texp",
            "flags & TIMER_ABSTIME ?\n\t\t\t\t HRTIMER_MODE_ABS : HRTIMER_MODE_REL",
            "which_clock"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_nanosleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2083-2114",
          "snippet": "long hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,\n\t\t       const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tu64 slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_sleeper_on_stack(&t, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, rqtp, slack);\n\tret = do_nanosleep(&t, mode);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\tgoto out;\n\n\t/* Absolute timers do not update the rmtp value and restart: */\n\tif (mode == HRTIMER_MODE_ABS) {\n\t\tret = -ERESTARTNOHAND;\n\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\n\tset_restart_fn(restart, hrtimer_nanosleep_restart);\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nlong hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,\n\t\t       const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tu64 slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_sleeper_on_stack(&t, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, rqtp, slack);\n\tret = do_nanosleep(&t, mode);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\tgoto out;\n\n\t/* Absolute timers do not update the rmtp value and restart: */\n\tif (mode == HRTIMER_MODE_ABS) {\n\t\tret = -ERESTARTNOHAND;\n\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\n\tset_restart_fn(restart, hrtimer_nanosleep_restart);\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*rqtp"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic int common_nsleep(const clockid_t which_clock, int flags,\n\t\t\t const struct timespec64 *rqtp)\n{\n\tktime_t texp = timespec64_to_ktime(*rqtp);\n\n\treturn hrtimer_nanosleep(texp, flags & TIMER_ABSTIME ?\n\t\t\t\t HRTIMER_MODE_ABS : HRTIMER_MODE_REL,\n\t\t\t\t which_clock);\n}"
  },
  {
    "function_name": "do_clock_adjtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1100-1110",
    "snippet": "int do_clock_adjtime(const clockid_t which_clock, struct __kernel_timex * ktx)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->clock_adj)\n\t\treturn -EOPNOTSUPP;\n\n\treturn kc->clock_adj(which_clock, ktx);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kc->clock_adj",
          "args": [
            "which_clock",
            "ktx"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockid_to_kclock",
          "args": [
            "which_clock"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "clockid_to_kclock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "1398-1411",
          "snippet": "static const struct k_clock *clockid_to_kclock(const clockid_t id)\n{\n\tclockid_t idx = id;\n\n\tif (id < 0) {\n\t\treturn (id & CLOCKFD_MASK) == CLOCKFD ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\t}\n\n\tif (id >= ARRAY_SIZE(posix_clocks))\n\t\treturn NULL;\n\n\treturn posix_clocks[array_index_nospec(idx, ARRAY_SIZE(posix_clocks))];\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct k_clock * const posix_clocks[];",
            "static const struct k_clock *clockid_to_kclock(const clockid_t id);",
            "static const struct k_clock * const posix_clocks[] = {\n\t[CLOCK_REALTIME]\t\t= &clock_realtime,\n\t[CLOCK_MONOTONIC]\t\t= &clock_monotonic,\n\t[CLOCK_PROCESS_CPUTIME_ID]\t= &clock_process,\n\t[CLOCK_THREAD_CPUTIME_ID]\t= &clock_thread,\n\t[CLOCK_MONOTONIC_RAW]\t\t= &clock_monotonic_raw,\n\t[CLOCK_REALTIME_COARSE]\t\t= &clock_realtime_coarse,\n\t[CLOCK_MONOTONIC_COARSE]\t= &clock_monotonic_coarse,\n\t[CLOCK_BOOTTIME]\t\t= &clock_boottime,\n\t[CLOCK_REALTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_BOOTTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_TAI]\t\t\t= &clock_tai,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic const struct k_clock * const posix_clocks[];\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\nstatic const struct k_clock * const posix_clocks[] = {\n\t[CLOCK_REALTIME]\t\t= &clock_realtime,\n\t[CLOCK_MONOTONIC]\t\t= &clock_monotonic,\n\t[CLOCK_PROCESS_CPUTIME_ID]\t= &clock_process,\n\t[CLOCK_THREAD_CPUTIME_ID]\t= &clock_thread,\n\t[CLOCK_MONOTONIC_RAW]\t\t= &clock_monotonic_raw,\n\t[CLOCK_REALTIME_COARSE]\t\t= &clock_realtime_coarse,\n\t[CLOCK_MONOTONIC_COARSE]\t= &clock_monotonic_coarse,\n\t[CLOCK_BOOTTIME]\t\t= &clock_boottime,\n\t[CLOCK_REALTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_BOOTTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_TAI]\t\t\t= &clock_tai,\n};\n\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id)\n{\n\tclockid_t idx = id;\n\n\tif (id < 0) {\n\t\treturn (id & CLOCKFD_MASK) == CLOCKFD ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\t}\n\n\tif (id >= ARRAY_SIZE(posix_clocks))\n\t\treturn NULL;\n\n\treturn posix_clocks[array_index_nospec(idx, ARRAY_SIZE(posix_clocks))];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint do_clock_adjtime(const clockid_t which_clock, struct __kernel_timex * ktx)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->clock_adj)\n\t\treturn -EOPNOTSUPP;\n\n\treturn kc->clock_adj(which_clock, ktx);\n}"
  },
  {
    "function_name": "exit_itimers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1057-1065",
    "snippet": "void exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "itimer_delete",
          "args": [
            "tmr"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "itimer_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "1038-1051",
          "snippet": "static void itimer_delete(struct k_itimer *timer)\n{\nretry_delete:\n\tspin_lock_irq(&timer->it_lock);\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tspin_unlock_irq(&timer->it_lock);\n\t\tgoto retry_delete;\n\t}\n\tlist_del(&timer->list);\n\n\tspin_unlock_irq(&timer->it_lock);\n\trelease_posix_timer(timer, IT_ID_SET);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define IT_ID_SET\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\n#define IT_ID_SET\t1\n\nstatic void itimer_delete(struct k_itimer *timer)\n{\nretry_delete:\n\tspin_lock_irq(&timer->it_lock);\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tspin_unlock_irq(&timer->it_lock);\n\t\tgoto retry_delete;\n\t}\n\tlist_del(&timer->list);\n\n\tspin_unlock_irq(&timer->it_lock);\n\trelease_posix_timer(timer, IT_ID_SET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "sig->posix_timers.next",
            "structk_itimer",
            "list"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sig->posix_timers"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nvoid exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}"
  },
  {
    "function_name": "itimer_delete",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1038-1051",
    "snippet": "static void itimer_delete(struct k_itimer *timer)\n{\nretry_delete:\n\tspin_lock_irq(&timer->it_lock);\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tspin_unlock_irq(&timer->it_lock);\n\t\tgoto retry_delete;\n\t}\n\tlist_del(&timer->list);\n\n\tspin_unlock_irq(&timer->it_lock);\n\trelease_posix_timer(timer, IT_ID_SET);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define IT_ID_SET\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_posix_timer",
          "args": [
            "timer",
            "IT_ID_SET"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "release_posix_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "478-489",
          "snippet": "static void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->rcu, k_itimer_rcu_free);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(hash_lock);",
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(hash_lock);\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->rcu, k_itimer_rcu_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&timer->it_lock"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&timer->list"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_delete_hook",
          "args": [
            "timer"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "timer_delete_hook",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "994-1001",
          "snippet": "static inline int timer_delete_hook(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\tif (WARN_ON_ONCE(!kc || !kc->timer_del))\n\t\treturn -EINVAL;\n\treturn kc->timer_del(timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic inline int timer_delete_hook(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\tif (WARN_ON_ONCE(!kc || !kc->timer_del))\n\t\treturn -EINVAL;\n\treturn kc->timer_del(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&timer->it_lock"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\n#define IT_ID_SET\t1\n\nstatic void itimer_delete(struct k_itimer *timer)\n{\nretry_delete:\n\tspin_lock_irq(&timer->it_lock);\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tspin_unlock_irq(&timer->it_lock);\n\t\tgoto retry_delete;\n\t}\n\tlist_del(&timer->list);\n\n\tspin_unlock_irq(&timer->it_lock);\n\trelease_posix_timer(timer, IT_ID_SET);\n}"
  },
  {
    "function_name": "timer_delete_hook",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "994-1001",
    "snippet": "static inline int timer_delete_hook(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\tif (WARN_ON_ONCE(!kc || !kc->timer_del))\n\t\treturn -EINVAL;\n\treturn kc->timer_del(timer);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kc->timer_del",
          "args": [
            "timer"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!kc || !kc->timer_del"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic inline int timer_delete_hook(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\tif (WARN_ON_ONCE(!kc || !kc->timer_del))\n\t\treturn -EINVAL;\n\treturn kc->timer_del(timer);\n}"
  },
  {
    "function_name": "common_timer_del",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "983-992",
    "snippet": "int common_timer_del(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\ttimer->it_interval = 0;\n\tif (kc->timer_try_to_cancel(timer) < 0)\n\t\treturn TIMER_RETRY;\n\ttimer->it_active = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kc->timer_try_to_cancel",
          "args": [
            "timer"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint common_timer_del(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\ttimer->it_interval = 0;\n\tif (kc->timer_try_to_cancel(timer) < 0)\n\t\treturn TIMER_RETRY;\n\ttimer->it_active = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "do_timer_settime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "898-935",
    "snippet": "static int do_timer_settime(timer_t timer_id, int tmr_flags,\n\t\t\t    struct itimerspec64 *new_spec64,\n\t\t\t    struct itimerspec64 *old_spec64)\n{\n\tconst struct k_clock *kc;\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint error = 0;\n\n\tif (!timespec64_valid(&new_spec64->it_interval) ||\n\t    !timespec64_valid(&new_spec64->it_value))\n\t\treturn -EINVAL;\n\n\tif (old_spec64)\n\t\tmemset(old_spec64, 0, sizeof(*old_spec64));\n\n\ttimr = lock_timer(timer_id, &flags);\nretry:\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\tkc = timr->kclock;\n\tif (WARN_ON_ONCE(!kc || !kc->timer_set))\n\t\terror = -EINVAL;\n\telse\n\t\terror = kc->timer_set(timr, tmr_flags, new_spec64, old_spec64);\n\n\tif (error == TIMER_RETRY) {\n\t\t// We already got the old time...\n\t\told_spec64 = NULL;\n\t\t/* Unlocks and relocks the timer if it still exists */\n\t\ttimr = timer_wait_running(timr, &flags);\n\t\tgoto retry;\n\t}\n\tunlock_timer(timr, flags);\n\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_timer",
          "args": [
            "timr",
            "flags"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "164-167",
          "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_wait_running",
          "args": [
            "timr",
            "&flags"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "timer_wait_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "839-855",
          "snippet": "static struct k_itimer *timer_wait_running(struct k_itimer *timer,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tconst struct k_clock *kc = READ_ONCE(timer->kclock);\n\ttimer_t timer_id = READ_ONCE(timer->it_id);\n\n\t/* Prevent kfree(timer) after dropping the lock */\n\trcu_read_lock();\n\tunlock_timer(timer, *flags);\n\n\tif (!WARN_ON_ONCE(!kc->timer_wait_running))\n\t\tkc->timer_wait_running(timer);\n\n\trcu_read_unlock();\n\t/* Relock the timer. It might be not longer hashed. */\n\treturn lock_timer(timer_id, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic struct k_itimer *timer_wait_running(struct k_itimer *timer,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tconst struct k_clock *kc = READ_ONCE(timer->kclock);\n\ttimer_t timer_id = READ_ONCE(timer->it_id);\n\n\t/* Prevent kfree(timer) after dropping the lock */\n\trcu_read_lock();\n\tunlock_timer(timer, *flags);\n\n\tif (!WARN_ON_ONCE(!kc->timer_wait_running))\n\t\tkc->timer_wait_running(timer);\n\n\trcu_read_unlock();\n\t/* Relock the timer. It might be not longer hashed. */\n\treturn lock_timer(timer_id, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kc->timer_set",
          "args": [
            "timr",
            "tmr_flags",
            "new_spec64",
            "old_spec64"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!kc || !kc->timer_set"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_timer",
          "args": [
            "timer_id",
            "&flags"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "614-638",
          "snippet": "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "old_spec64",
            "0",
            "sizeof(*old_spec64)"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_valid",
          "args": [
            "&new_spec64->it_value"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_valid",
          "args": [
            "&new_spec64->it_interval"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic int do_timer_settime(timer_t timer_id, int tmr_flags,\n\t\t\t    struct itimerspec64 *new_spec64,\n\t\t\t    struct itimerspec64 *old_spec64)\n{\n\tconst struct k_clock *kc;\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint error = 0;\n\n\tif (!timespec64_valid(&new_spec64->it_interval) ||\n\t    !timespec64_valid(&new_spec64->it_value))\n\t\treturn -EINVAL;\n\n\tif (old_spec64)\n\t\tmemset(old_spec64, 0, sizeof(*old_spec64));\n\n\ttimr = lock_timer(timer_id, &flags);\nretry:\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\tkc = timr->kclock;\n\tif (WARN_ON_ONCE(!kc || !kc->timer_set))\n\t\terror = -EINVAL;\n\telse\n\t\terror = kc->timer_set(timr, tmr_flags, new_spec64, old_spec64);\n\n\tif (error == TIMER_RETRY) {\n\t\t// We already got the old time...\n\t\told_spec64 = NULL;\n\t\t/* Unlocks and relocks the timer if it still exists */\n\t\ttimr = timer_wait_running(timr, &flags);\n\t\tgoto retry;\n\t}\n\tunlock_timer(timr, flags);\n\n\treturn error;\n}"
  },
  {
    "function_name": "common_timer_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "858-896",
    "snippet": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tif (flags & TIMER_ABSTIME)\n\t\texpires = timens_ktime_to_host(timr->it_clock, expires);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kc->timer_arm",
          "args": [
            "timr",
            "expires",
            "flags & TIMER_ABSTIME",
            "sigev_none"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timens_ktime_to_host",
          "args": [
            "timr->it_clock",
            "expires"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "new_setting->it_value"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "new_setting->it_interval"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kc->timer_try_to_cancel",
          "args": [
            "timr"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "common_timer_get",
          "args": [
            "timr",
            "old_setting"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "common_timer_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "670-712",
          "snippet": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\tnow = kc->clock_get_ktime(timr->it_clock);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nvoid common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\tnow = kc->clock_get_ktime(timr->it_clock);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nint common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tif (flags & TIMER_ABSTIME)\n\t\texpires = timens_ktime_to_host(timr->it_clock, expires);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}"
  },
  {
    "function_name": "timer_wait_running",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "839-855",
    "snippet": "static struct k_itimer *timer_wait_running(struct k_itimer *timer,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tconst struct k_clock *kc = READ_ONCE(timer->kclock);\n\ttimer_t timer_id = READ_ONCE(timer->it_id);\n\n\t/* Prevent kfree(timer) after dropping the lock */\n\trcu_read_lock();\n\tunlock_timer(timer, *flags);\n\n\tif (!WARN_ON_ONCE(!kc->timer_wait_running))\n\t\tkc->timer_wait_running(timer);\n\n\trcu_read_unlock();\n\t/* Relock the timer. It might be not longer hashed. */\n\treturn lock_timer(timer_id, flags);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_timer",
          "args": [
            "timer_id",
            "flags"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "614-638",
          "snippet": "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kc->timer_wait_running",
          "args": [
            "timer"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!kc->timer_wait_running"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_timer",
          "args": [
            "timer",
            "*flags"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "164-167",
          "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "timer->it_id"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "timer->kclock"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic struct k_itimer *timer_wait_running(struct k_itimer *timer,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tconst struct k_clock *kc = READ_ONCE(timer->kclock);\n\ttimer_t timer_id = READ_ONCE(timer->it_id);\n\n\t/* Prevent kfree(timer) after dropping the lock */\n\trcu_read_lock();\n\tunlock_timer(timer, *flags);\n\n\tif (!WARN_ON_ONCE(!kc->timer_wait_running))\n\t\tkc->timer_wait_running(timer);\n\n\trcu_read_unlock();\n\t/* Relock the timer. It might be not longer hashed. */\n\treturn lock_timer(timer_id, flags);\n}"
  },
  {
    "function_name": "common_timer_wait_running",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "828-831",
    "snippet": "static void common_timer_wait_running(struct k_itimer *timer)\n{\n\thrtimer_cancel_wait_running(&timer->it.real.timer);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_cancel_wait_running",
          "args": [
            "&timer->it.real.timer"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel_wait_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1393-1418",
          "snippet": "void hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic void common_timer_wait_running(struct k_itimer *timer)\n{\n\thrtimer_cancel_wait_running(&timer->it.real.timer);\n}"
  },
  {
    "function_name": "common_hrtimer_try_to_cancel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "823-826",
    "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&timr->it.real.timer"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "823-826",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
  },
  {
    "function_name": "common_hrtimer_arm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "793-821",
    "snippet": "static void common_hrtimer_arm(struct k_itimer *timr, ktime_t expires,\n\t\t\t       bool absolute, bool sigev_none)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tenum hrtimer_mode mode;\n\n\tmode = absolute ? HRTIMER_MODE_ABS : HRTIMER_MODE_REL;\n\t/*\n\t * Posix magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they become CLOCK_MONOTONIC based under the\n\t * hood. See hrtimer_init(). Update timr->kclock, so the generic\n\t * functions which use timr->kclock->clock_get_*() work.\n\t *\n\t * Note: it_clock stays unmodified, because the next timer_set() might\n\t * use ABSTIME, so it needs to switch back.\n\t */\n\tif (timr->it_clock == CLOCK_REALTIME)\n\t\ttimr->kclock = absolute ? &clock_realtime : &clock_monotonic;\n\n\thrtimer_init(&timr->it.real.timer, timr->it_clock, mode);\n\ttimr->it.real.timer.function = posix_timer_fn;\n\n\tif (!absolute)\n\t\texpires = ktime_add_safe(expires, timer->base->get_time());\n\thrtimer_set_expires(timer, expires);\n\n\tif (!sigev_none)\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct k_clock clock_realtime, clock_monotonic;",
      "static const struct k_clock clock_realtime = {\n\t.clock_getres\t\t= posix_get_hrtimer_res,\n\t.clock_get_timespec\t= posix_get_realtime_timespec,\n\t.clock_get_ktime\t= posix_get_realtime_ktime,\n\t.clock_set\t\t= posix_clock_realtime_set,\n\t.clock_adj\t\t= posix_clock_realtime_adj,\n\t.nsleep\t\t\t= common_nsleep,\n\t.timer_create\t\t= common_timer_create,\n\t.timer_set\t\t= common_timer_set,\n\t.timer_get\t\t= common_timer_get,\n\t.timer_del\t\t= common_timer_del,\n\t.timer_rearm\t\t= common_hrtimer_rearm,\n\t.timer_forward\t\t= common_hrtimer_forward,\n\t.timer_remaining\t= common_hrtimer_remaining,\n\t.timer_try_to_cancel\t= common_hrtimer_try_to_cancel,\n\t.timer_wait_running\t= common_timer_wait_running,\n\t.timer_arm\t\t= common_hrtimer_arm,\n};",
      "static const struct k_clock clock_monotonic = {\n\t.clock_getres\t\t= posix_get_hrtimer_res,\n\t.clock_get_timespec\t= posix_get_monotonic_timespec,\n\t.clock_get_ktime\t= posix_get_monotonic_ktime,\n\t.nsleep\t\t\t= common_nsleep_timens,\n\t.timer_create\t\t= common_timer_create,\n\t.timer_set\t\t= common_timer_set,\n\t.timer_get\t\t= common_timer_get,\n\t.timer_del\t\t= common_timer_del,\n\t.timer_rearm\t\t= common_hrtimer_rearm,\n\t.timer_forward\t\t= common_hrtimer_forward,\n\t.timer_remaining\t= common_hrtimer_remaining,\n\t.timer_try_to_cancel\t= common_hrtimer_try_to_cancel,\n\t.timer_wait_running\t= common_timer_wait_running,\n\t.timer_arm\t\t= common_hrtimer_arm,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "timer",
            "HRTIMER_MODE_ABS"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "timer",
            "expires"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "expires",
            "timer->base->get_time()"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer->base->get_time",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&timr->it.real.timer",
            "timr->it_clock",
            "mode"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic const struct k_clock clock_realtime, clock_monotonic;\nstatic const struct k_clock clock_realtime = {\n\t.clock_getres\t\t= posix_get_hrtimer_res,\n\t.clock_get_timespec\t= posix_get_realtime_timespec,\n\t.clock_get_ktime\t= posix_get_realtime_ktime,\n\t.clock_set\t\t= posix_clock_realtime_set,\n\t.clock_adj\t\t= posix_clock_realtime_adj,\n\t.nsleep\t\t\t= common_nsleep,\n\t.timer_create\t\t= common_timer_create,\n\t.timer_set\t\t= common_timer_set,\n\t.timer_get\t\t= common_timer_get,\n\t.timer_del\t\t= common_timer_del,\n\t.timer_rearm\t\t= common_hrtimer_rearm,\n\t.timer_forward\t\t= common_hrtimer_forward,\n\t.timer_remaining\t= common_hrtimer_remaining,\n\t.timer_try_to_cancel\t= common_hrtimer_try_to_cancel,\n\t.timer_wait_running\t= common_timer_wait_running,\n\t.timer_arm\t\t= common_hrtimer_arm,\n};\nstatic const struct k_clock clock_monotonic = {\n\t.clock_getres\t\t= posix_get_hrtimer_res,\n\t.clock_get_timespec\t= posix_get_monotonic_timespec,\n\t.clock_get_ktime\t= posix_get_monotonic_ktime,\n\t.nsleep\t\t\t= common_nsleep_timens,\n\t.timer_create\t\t= common_timer_create,\n\t.timer_set\t\t= common_timer_set,\n\t.timer_get\t\t= common_timer_get,\n\t.timer_del\t\t= common_timer_del,\n\t.timer_rearm\t\t= common_hrtimer_rearm,\n\t.timer_forward\t\t= common_hrtimer_forward,\n\t.timer_remaining\t= common_hrtimer_remaining,\n\t.timer_try_to_cancel\t= common_hrtimer_try_to_cancel,\n\t.timer_wait_running\t= common_timer_wait_running,\n\t.timer_arm\t\t= common_hrtimer_arm,\n};\n\nstatic void common_hrtimer_arm(struct k_itimer *timr, ktime_t expires,\n\t\t\t       bool absolute, bool sigev_none)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tenum hrtimer_mode mode;\n\n\tmode = absolute ? HRTIMER_MODE_ABS : HRTIMER_MODE_REL;\n\t/*\n\t * Posix magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they become CLOCK_MONOTONIC based under the\n\t * hood. See hrtimer_init(). Update timr->kclock, so the generic\n\t * functions which use timr->kclock->clock_get_*() work.\n\t *\n\t * Note: it_clock stays unmodified, because the next timer_set() might\n\t * use ABSTIME, so it needs to switch back.\n\t */\n\tif (timr->it_clock == CLOCK_REALTIME)\n\t\ttimr->kclock = absolute ? &clock_realtime : &clock_monotonic;\n\n\thrtimer_init(&timr->it.real.timer, timr->it_clock, mode);\n\ttimr->it.real.timer.function = posix_timer_fn;\n\n\tif (!absolute)\n\t\texpires = ktime_add_safe(expires, timer->base->get_time());\n\thrtimer_set_expires(timer, expires);\n\n\tif (!sigev_none)\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}"
  },
  {
    "function_name": "do_timer_gettime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "715-735",
    "snippet": "static int do_timer_gettime(timer_t timer_id,  struct itimerspec64 *setting)\n{\n\tstruct k_itimer *timr;\n\tconst struct k_clock *kc;\n\tunsigned long flags;\n\tint ret = 0;\n\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\tmemset(setting, 0, sizeof(*setting));\n\tkc = timr->kclock;\n\tif (WARN_ON_ONCE(!kc || !kc->timer_get))\n\t\tret = -EINVAL;\n\telse\n\t\tkc->timer_get(timr, setting);\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_timer",
          "args": [
            "timr",
            "flags"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "164-167",
          "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kc->timer_get",
          "args": [
            "timr",
            "setting"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!kc || !kc->timer_get"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "setting",
            "0",
            "sizeof(*setting)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_timer",
          "args": [
            "timer_id",
            "&flags"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "614-638",
          "snippet": "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic int do_timer_gettime(timer_t timer_id,  struct itimerspec64 *setting)\n{\n\tstruct k_itimer *timr;\n\tconst struct k_clock *kc;\n\tunsigned long flags;\n\tint ret = 0;\n\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\tmemset(setting, 0, sizeof(*setting));\n\tkc = timr->kclock;\n\tif (WARN_ON_ONCE(!kc || !kc->timer_get))\n\t\tret = -EINVAL;\n\telse\n\t\tkc->timer_get(timr, setting);\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "common_timer_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "670-712",
    "snippet": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\tnow = kc->clock_get_ktime(timr->it_clock);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "remaining"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kc->timer_remaining",
          "args": [
            "timr",
            "now"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kc->timer_forward",
          "args": [
            "timr",
            "now"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kc->clock_get_ktime",
          "args": [
            "timr->it_clock"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "iv"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nvoid common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\tnow = kc->clock_get_ktime(timr->it_clock);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}"
  },
  {
    "function_name": "common_hrtimer_forward",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "647-652",
    "snippet": "static s64 common_hrtimer_forward(struct k_itimer *timr, ktime_t now)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\treturn hrtimer_forward(timer, now, timr->it_interval);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "timer",
            "now",
            "timr->it_interval"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1037-1069",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic s64 common_hrtimer_forward(struct k_itimer *timr, ktime_t now)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\treturn hrtimer_forward(timer, now, timr->it_interval);\n}"
  },
  {
    "function_name": "common_hrtimer_remaining",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "640-645",
    "snippet": "static ktime_t common_hrtimer_remaining(struct k_itimer *timr, ktime_t now)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\treturn __hrtimer_expires_remaining_adjusted(timer, now);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_expires_remaining_adjusted",
          "args": [
            "timer",
            "now"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic ktime_t common_hrtimer_remaining(struct k_itimer *timr, ktime_t now)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\treturn __hrtimer_expires_remaining_adjusted(timer, now);\n}"
  },
  {
    "function_name": "__lock_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "614-638",
    "snippet": "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&timr->it_lock",
            "*flags"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&timr->it_lock",
            "*flags"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_timer_by_id",
          "args": [
            "timer_id"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "132-138",
          "snippet": "static struct k_itimer *posix_timer_by_id(timer_t id)\n{\n\tstruct signal_struct *sig = current->signal;\n\tstruct hlist_head *head = &posix_timers_hashtable[hash(sig, id)];\n\n\treturn __posix_timers_find(head, sig, id);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);",
            "static const struct k_clock *clockid_to_kclock(const clockid_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\n\nstatic struct k_itimer *posix_timer_by_id(timer_t id)\n{\n\tstruct signal_struct *sig = current->signal;\n\tstruct hlist_head *head = &posix_timers_hashtable[hash(sig, id)];\n\n\treturn __posix_timers_find(head, sig, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "do_timer_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "498-575",
    "snippet": "static int do_timer_create(clockid_t which_clock, struct sigevent *event,\n\t\t\t   timer_t __user *created_timer_id)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct k_itimer *new_timer;\n\tint error, new_timer_id;\n\tint it_id_set = IT_ID_NOT_SET;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->timer_create)\n\t\treturn -EOPNOTSUPP;\n\n\tnew_timer = alloc_posix_timer();\n\tif (unlikely(!new_timer))\n\t\treturn -EAGAIN;\n\n\tspin_lock_init(&new_timer->it_lock);\n\tnew_timer_id = posix_timer_add(new_timer);\n\tif (new_timer_id < 0) {\n\t\terror = new_timer_id;\n\t\tgoto out;\n\t}\n\n\tit_id_set = IT_ID_SET;\n\tnew_timer->it_id = (timer_t) new_timer_id;\n\tnew_timer->it_clock = which_clock;\n\tnew_timer->kclock = kc;\n\tnew_timer->it_overrun = -1LL;\n\n\tif (event) {\n\t\trcu_read_lock();\n\t\tnew_timer->it_pid = get_pid(good_sigevent(event));\n\t\trcu_read_unlock();\n\t\tif (!new_timer->it_pid) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_timer->it_sigev_notify     = event->sigev_notify;\n\t\tnew_timer->sigq->info.si_signo = event->sigev_signo;\n\t\tnew_timer->sigq->info.si_value = event->sigev_value;\n\t} else {\n\t\tnew_timer->it_sigev_notify     = SIGEV_SIGNAL;\n\t\tnew_timer->sigq->info.si_signo = SIGALRM;\n\t\tmemset(&new_timer->sigq->info.si_value, 0, sizeof(sigval_t));\n\t\tnew_timer->sigq->info.si_value.sival_int = new_timer->it_id;\n\t\tnew_timer->it_pid = get_pid(task_tgid(current));\n\t}\n\n\tnew_timer->sigq->info.si_tid   = new_timer->it_id;\n\tnew_timer->sigq->info.si_code  = SI_TIMER;\n\n\tif (copy_to_user(created_timer_id,\n\t\t\t &new_timer_id, sizeof (new_timer_id))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = kc->timer_create(new_timer);\n\tif (error)\n\t\tgoto out;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tnew_timer->it_signal = current->signal;\n\tlist_add(&new_timer->list, &current->signal->posix_timers);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn 0;\n\t/*\n\t * In the case of the timer belonging to another task, after\n\t * the task is unlocked, the timer is owned by the other task\n\t * and may cease to exist at any time.  Don't use or modify\n\t * new_timer after the unlock call.\n\t */\nout:\n\trelease_posix_timer(new_timer, it_id_set);\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define IT_ID_NOT_SET\t0",
      "#define IT_ID_SET\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_posix_timer",
          "args": [
            "new_timer",
            "it_id_set"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "release_posix_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "478-489",
          "snippet": "static void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->rcu, k_itimer_rcu_free);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(hash_lock);",
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(hash_lock);\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->rcu, k_itimer_rcu_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_timer->list",
            "&current->signal->posix_timers"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kc->timer_create",
          "args": [
            "new_timer"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "created_timer_id",
            "&new_timer_id",
            "sizeof (new_timer_id)"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "task_tgid(current)"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "460-469",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new_timer->sigq->info.si_value",
            "0",
            "sizeof(sigval_t)"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "good_sigevent",
          "args": [
            "event"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "good_sigevent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "431-453",
          "snippet": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct pid *pid = task_tgid(current);\n\tstruct task_struct *rtn;\n\n\tswitch (event->sigev_notify) {\n\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n\t\tpid = find_vpid(event->sigev_notify_thread_id);\n\t\trtn = pid_task(pid, PIDTYPE_PID);\n\t\tif (!rtn || !same_thread_group(rtn, current))\n\t\t\treturn NULL;\n\t\tfallthrough;\n\tcase SIGEV_SIGNAL:\n\tcase SIGEV_THREAD:\n\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n\t\t\treturn NULL;\n\t\tfallthrough;\n\tcase SIGEV_NONE:\n\t\treturn pid;\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct pid *pid = task_tgid(current);\n\tstruct task_struct *rtn;\n\n\tswitch (event->sigev_notify) {\n\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n\t\tpid = find_vpid(event->sigev_notify_thread_id);\n\t\trtn = pid_task(pid, PIDTYPE_PID);\n\t\tif (!rtn || !same_thread_group(rtn, current))\n\t\t\treturn NULL;\n\t\tfallthrough;\n\tcase SIGEV_SIGNAL:\n\tcase SIGEV_THREAD:\n\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n\t\t\treturn NULL;\n\t\tfallthrough;\n\tcase SIGEV_NONE:\n\t\treturn pid;\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_timer_add",
          "args": [
            "new_timer"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "140-162",
          "snippet": "static int posix_timer_add(struct k_itimer *timer)\n{\n\tstruct signal_struct *sig = current->signal;\n\tint first_free_id = sig->posix_timer_id;\n\tstruct hlist_head *head;\n\tint ret = -ENOENT;\n\n\tdo {\n\t\tspin_lock(&hash_lock);\n\t\thead = &posix_timers_hashtable[hash(sig, sig->posix_timer_id)];\n\t\tif (!__posix_timers_find(head, sig, sig->posix_timer_id)) {\n\t\t\thlist_add_head_rcu(&timer->t_hash, head);\n\t\t\tret = sig->posix_timer_id;\n\t\t}\n\t\tif (++sig->posix_timer_id < 0)\n\t\t\tsig->posix_timer_id = 0;\n\t\tif ((sig->posix_timer_id == first_free_id) && (ret == -ENOENT))\n\t\t\t/* Loop over all possible ids completed */\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&hash_lock);\n\t} while (ret == -ENOENT);\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);",
            "static DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\nstatic DEFINE_SPINLOCK(hash_lock);\n\nstatic int posix_timer_add(struct k_itimer *timer)\n{\n\tstruct signal_struct *sig = current->signal;\n\tint first_free_id = sig->posix_timer_id;\n\tstruct hlist_head *head;\n\tint ret = -ENOENT;\n\n\tdo {\n\t\tspin_lock(&hash_lock);\n\t\thead = &posix_timers_hashtable[hash(sig, sig->posix_timer_id)];\n\t\tif (!__posix_timers_find(head, sig, sig->posix_timer_id)) {\n\t\t\thlist_add_head_rcu(&timer->t_hash, head);\n\t\t\tret = sig->posix_timer_id;\n\t\t}\n\t\tif (++sig->posix_timer_id < 0)\n\t\t\tsig->posix_timer_id = 0;\n\t\tif ((sig->posix_timer_id == first_free_id) && (ret == -ENOENT))\n\t\t\t/* Loop over all possible ids completed */\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&hash_lock);\n\t} while (ret == -ENOENT);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&new_timer->it_lock"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new_timer"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_posix_timer",
          "args": [],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_posix_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "455-467",
          "snippet": "static struct k_itimer * alloc_posix_timer(void)\n{\n\tstruct k_itimer *tmr;\n\ttmr = kmem_cache_zalloc(posix_timers_cache, GFP_KERNEL);\n\tif (!tmr)\n\t\treturn tmr;\n\tif (unlikely(!(tmr->sigq = sigqueue_alloc()))) {\n\t\tkmem_cache_free(posix_timers_cache, tmr);\n\t\treturn NULL;\n\t}\n\tclear_siginfo(&tmr->sigq->info);\n\treturn tmr;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *posix_timers_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *posix_timers_cache;\n\nstatic struct k_itimer * alloc_posix_timer(void)\n{\n\tstruct k_itimer *tmr;\n\ttmr = kmem_cache_zalloc(posix_timers_cache, GFP_KERNEL);\n\tif (!tmr)\n\t\treturn tmr;\n\tif (unlikely(!(tmr->sigq = sigqueue_alloc()))) {\n\t\tkmem_cache_free(posix_timers_cache, tmr);\n\t\treturn NULL;\n\t}\n\tclear_siginfo(&tmr->sigq->info);\n\treturn tmr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockid_to_kclock",
          "args": [
            "which_clock"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "clockid_to_kclock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "1398-1411",
          "snippet": "static const struct k_clock *clockid_to_kclock(const clockid_t id)\n{\n\tclockid_t idx = id;\n\n\tif (id < 0) {\n\t\treturn (id & CLOCKFD_MASK) == CLOCKFD ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\t}\n\n\tif (id >= ARRAY_SIZE(posix_clocks))\n\t\treturn NULL;\n\n\treturn posix_clocks[array_index_nospec(idx, ARRAY_SIZE(posix_clocks))];\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct k_clock * const posix_clocks[];",
            "static const struct k_clock *clockid_to_kclock(const clockid_t id);",
            "static const struct k_clock * const posix_clocks[] = {\n\t[CLOCK_REALTIME]\t\t= &clock_realtime,\n\t[CLOCK_MONOTONIC]\t\t= &clock_monotonic,\n\t[CLOCK_PROCESS_CPUTIME_ID]\t= &clock_process,\n\t[CLOCK_THREAD_CPUTIME_ID]\t= &clock_thread,\n\t[CLOCK_MONOTONIC_RAW]\t\t= &clock_monotonic_raw,\n\t[CLOCK_REALTIME_COARSE]\t\t= &clock_realtime_coarse,\n\t[CLOCK_MONOTONIC_COARSE]\t= &clock_monotonic_coarse,\n\t[CLOCK_BOOTTIME]\t\t= &clock_boottime,\n\t[CLOCK_REALTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_BOOTTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_TAI]\t\t\t= &clock_tai,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic const struct k_clock * const posix_clocks[];\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\nstatic const struct k_clock * const posix_clocks[] = {\n\t[CLOCK_REALTIME]\t\t= &clock_realtime,\n\t[CLOCK_MONOTONIC]\t\t= &clock_monotonic,\n\t[CLOCK_PROCESS_CPUTIME_ID]\t= &clock_process,\n\t[CLOCK_THREAD_CPUTIME_ID]\t= &clock_thread,\n\t[CLOCK_MONOTONIC_RAW]\t\t= &clock_monotonic_raw,\n\t[CLOCK_REALTIME_COARSE]\t\t= &clock_realtime_coarse,\n\t[CLOCK_MONOTONIC_COARSE]\t= &clock_monotonic_coarse,\n\t[CLOCK_BOOTTIME]\t\t= &clock_boottime,\n\t[CLOCK_REALTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_BOOTTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_TAI]\t\t\t= &clock_tai,\n};\n\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id)\n{\n\tclockid_t idx = id;\n\n\tif (id < 0) {\n\t\treturn (id & CLOCKFD_MASK) == CLOCKFD ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\t}\n\n\tif (id >= ARRAY_SIZE(posix_clocks))\n\t\treturn NULL;\n\n\treturn posix_clocks[array_index_nospec(idx, ARRAY_SIZE(posix_clocks))];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\n#define IT_ID_NOT_SET\t0\n#define IT_ID_SET\t1\n\nstatic int do_timer_create(clockid_t which_clock, struct sigevent *event,\n\t\t\t   timer_t __user *created_timer_id)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct k_itimer *new_timer;\n\tint error, new_timer_id;\n\tint it_id_set = IT_ID_NOT_SET;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->timer_create)\n\t\treturn -EOPNOTSUPP;\n\n\tnew_timer = alloc_posix_timer();\n\tif (unlikely(!new_timer))\n\t\treturn -EAGAIN;\n\n\tspin_lock_init(&new_timer->it_lock);\n\tnew_timer_id = posix_timer_add(new_timer);\n\tif (new_timer_id < 0) {\n\t\terror = new_timer_id;\n\t\tgoto out;\n\t}\n\n\tit_id_set = IT_ID_SET;\n\tnew_timer->it_id = (timer_t) new_timer_id;\n\tnew_timer->it_clock = which_clock;\n\tnew_timer->kclock = kc;\n\tnew_timer->it_overrun = -1LL;\n\n\tif (event) {\n\t\trcu_read_lock();\n\t\tnew_timer->it_pid = get_pid(good_sigevent(event));\n\t\trcu_read_unlock();\n\t\tif (!new_timer->it_pid) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_timer->it_sigev_notify     = event->sigev_notify;\n\t\tnew_timer->sigq->info.si_signo = event->sigev_signo;\n\t\tnew_timer->sigq->info.si_value = event->sigev_value;\n\t} else {\n\t\tnew_timer->it_sigev_notify     = SIGEV_SIGNAL;\n\t\tnew_timer->sigq->info.si_signo = SIGALRM;\n\t\tmemset(&new_timer->sigq->info.si_value, 0, sizeof(sigval_t));\n\t\tnew_timer->sigq->info.si_value.sival_int = new_timer->it_id;\n\t\tnew_timer->it_pid = get_pid(task_tgid(current));\n\t}\n\n\tnew_timer->sigq->info.si_tid   = new_timer->it_id;\n\tnew_timer->sigq->info.si_code  = SI_TIMER;\n\n\tif (copy_to_user(created_timer_id,\n\t\t\t &new_timer_id, sizeof (new_timer_id))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = kc->timer_create(new_timer);\n\tif (error)\n\t\tgoto out;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tnew_timer->it_signal = current->signal;\n\tlist_add(&new_timer->list, &current->signal->posix_timers);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn 0;\n\t/*\n\t * In the case of the timer belonging to another task, after\n\t * the task is unlocked, the timer is owned by the other task\n\t * and may cease to exist at any time.  Don't use or modify\n\t * new_timer after the unlock call.\n\t */\nout:\n\trelease_posix_timer(new_timer, it_id_set);\n\treturn error;\n}"
  },
  {
    "function_name": "common_timer_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "491-495",
    "snippet": "static int common_timer_create(struct k_itimer *new_timer)\n{\n\thrtimer_init(&new_timer->it.real.timer, new_timer->it_clock, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&new_timer->it.real.timer",
            "new_timer->it_clock",
            "0"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_timer_create(struct k_itimer *new_timer)\n{\n\thrtimer_init(&new_timer->it.real.timer, new_timer->it_clock, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "release_posix_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "478-489",
    "snippet": "static void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->rcu, k_itimer_rcu_free);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(hash_lock);",
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&tmr->rcu",
            "k_itimer_rcu_free"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigqueue_free",
          "args": [
            "tmr->sigq"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "sigqueue_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1925-1948",
          "snippet": "void sigqueue_free(struct sigqueue *q)\n{\n\tunsigned long flags;\n\tspinlock_t *lock = &current->sighand->siglock;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\t/*\n\t * We must hold ->siglock while testing q->list\n\t * to serialize with collect_signal() or with\n\t * __exit_signal()->flush_sigqueue().\n\t */\n\tspin_lock_irqsave(lock, flags);\n\tq->flags &= ~SIGQUEUE_PREALLOC;\n\t/*\n\t * If it is queued it will be freed when dequeued,\n\t * like the \"regular\" sigqueue.\n\t */\n\tif (!list_empty(&q->list))\n\t\tq = NULL;\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (q)\n\t\t__sigqueue_free(q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid sigqueue_free(struct sigqueue *q)\n{\n\tunsigned long flags;\n\tspinlock_t *lock = &current->sighand->siglock;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\t/*\n\t * We must hold ->siglock while testing q->list\n\t * to serialize with collect_signal() or with\n\t * __exit_signal()->flush_sigqueue().\n\t */\n\tspin_lock_irqsave(lock, flags);\n\tq->flags &= ~SIGQUEUE_PREALLOC;\n\t/*\n\t * If it is queued it will be freed when dequeued,\n\t * like the \"regular\" sigqueue.\n\t */\n\tif (!list_empty(&q->list))\n\t\tq = NULL;\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (q)\n\t\t__sigqueue_free(q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "tmr->it_pid"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "120-124",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&hash_lock",
            "flags"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&tmr->t_hash"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&hash_lock",
            "flags"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(hash_lock);\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->rcu, k_itimer_rcu_free);\n}"
  },
  {
    "function_name": "k_itimer_rcu_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "469-474",
    "snippet": "static void k_itimer_rcu_free(struct rcu_head *head)\n{\n\tstruct k_itimer *tmr = container_of(head, struct k_itimer, rcu);\n\n\tkmem_cache_free(posix_timers_cache, tmr);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *posix_timers_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "posix_timers_cache",
            "tmr"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structk_itimer",
            "rcu"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *posix_timers_cache;\n\nstatic void k_itimer_rcu_free(struct rcu_head *head)\n{\n\tstruct k_itimer *tmr = container_of(head, struct k_itimer, rcu);\n\n\tkmem_cache_free(posix_timers_cache, tmr);\n}"
  },
  {
    "function_name": "alloc_posix_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "455-467",
    "snippet": "static struct k_itimer * alloc_posix_timer(void)\n{\n\tstruct k_itimer *tmr;\n\ttmr = kmem_cache_zalloc(posix_timers_cache, GFP_KERNEL);\n\tif (!tmr)\n\t\treturn tmr;\n\tif (unlikely(!(tmr->sigq = sigqueue_alloc()))) {\n\t\tkmem_cache_free(posix_timers_cache, tmr);\n\t\treturn NULL;\n\t}\n\tclear_siginfo(&tmr->sigq->info);\n\treturn tmr;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *posix_timers_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&tmr->sigq->info"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "posix_timers_cache",
            "tmr"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(tmr->sigq = sigqueue_alloc())"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigqueue_alloc",
          "args": [],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "sigqueue_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1920-1923",
          "snippet": "struct sigqueue *sigqueue_alloc(void)\n{\n\treturn __sigqueue_alloc(-1, current, GFP_KERNEL, 0, SIGQUEUE_PREALLOC);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sigqueue *sigqueue_alloc(void)\n{\n\treturn __sigqueue_alloc(-1, current, GFP_KERNEL, 0, SIGQUEUE_PREALLOC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "posix_timers_cache",
            "GFP_KERNEL"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *posix_timers_cache;\n\nstatic struct k_itimer * alloc_posix_timer(void)\n{\n\tstruct k_itimer *tmr;\n\ttmr = kmem_cache_zalloc(posix_timers_cache, GFP_KERNEL);\n\tif (!tmr)\n\t\treturn tmr;\n\tif (unlikely(!(tmr->sigq = sigqueue_alloc()))) {\n\t\tkmem_cache_free(posix_timers_cache, tmr);\n\t\treturn NULL;\n\t}\n\tclear_siginfo(&tmr->sigq->info);\n\treturn tmr;\n}"
  },
  {
    "function_name": "good_sigevent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "431-453",
    "snippet": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct pid *pid = task_tgid(current);\n\tstruct task_struct *rtn;\n\n\tswitch (event->sigev_notify) {\n\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n\t\tpid = find_vpid(event->sigev_notify_thread_id);\n\t\trtn = pid_task(pid, PIDTYPE_PID);\n\t\tif (!rtn || !same_thread_group(rtn, current))\n\t\t\treturn NULL;\n\t\tfallthrough;\n\tcase SIGEV_SIGNAL:\n\tcase SIGEV_THREAD:\n\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n\t\t\treturn NULL;\n\t\tfallthrough;\n\tcase SIGEV_NONE:\n\t\treturn pid;\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "rtn",
            "current"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vpid",
          "args": [
            "event->sigev_notify_thread_id"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "find_vpid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "315-318",
          "snippet": "struct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct pid *pid = task_tgid(current);\n\tstruct task_struct *rtn;\n\n\tswitch (event->sigev_notify) {\n\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n\t\tpid = find_vpid(event->sigev_notify_thread_id);\n\t\trtn = pid_task(pid, PIDTYPE_PID);\n\t\tif (!rtn || !same_thread_group(rtn, current))\n\t\t\treturn NULL;\n\t\tfallthrough;\n\tcase SIGEV_SIGNAL:\n\tcase SIGEV_THREAD:\n\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n\t\t\treturn NULL;\n\t\tfallthrough;\n\tcase SIGEV_NONE:\n\t\treturn pid;\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "posix_timer_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "366-429",
    "snippet": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\t/*\n\t\t * signal was not sent because of sig_ignor\n\t\t * we will not get a call back to restart it AND\n\t\t * it should be restarted.\n\t\t */\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n\t\t\t/*\n\t\t\t * FIXME: What we really want, is to stop this\n\t\t\t * timer completely and restart it in case the\n\t\t\t * SIG_IGN is removed. This is a non trivial\n\t\t\t * change which involves sighand locking\n\t\t\t * (sigh !), which we don't want to do late in\n\t\t\t * the release cycle.\n\t\t\t *\n\t\t\t * For now we just let timers with an interval\n\t\t\t * less than a jiffie expire every jiffie to\n\t\t\t * avoid softirq starvation in case of SIG_IGN\n\t\t\t * and a very small interval, which would put\n\t\t\t * the timer right back on the softirq pending\n\t\t\t * list. By moving now ahead of time we trick\n\t\t\t * hrtimer_forward() to expire the timer\n\t\t\t * later, while we still maintain the overrun\n\t\t\t * accuracy, but have some inconsistency in\n\t\t\t * the timer_gettime() case. This is at least\n\t\t\t * better than a starved softirq. A more\n\t\t\t * complex fix which solves also another related\n\t\t\t * inconsistency is already in the pipeline.\n\t\t\t */\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += hrtimer_forward(timer, now,\n\t\t\t\t\t\t\t    timr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_timer",
          "args": [
            "timr",
            "flags"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "164-167",
          "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "timer",
            "now",
            "timr->it_interval"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1037-1069",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "now",
            "kj"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cb_get_time",
          "args": [
            "timer"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_timer_event",
          "args": [
            "timr",
            "si_private"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "336-357",
          "snippet": "int posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&timr->it_lock",
            "flags"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structk_itimer",
            "it.real.timer"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\t/*\n\t\t * signal was not sent because of sig_ignor\n\t\t * we will not get a call back to restart it AND\n\t\t * it should be restarted.\n\t\t */\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n\t\t\t/*\n\t\t\t * FIXME: What we really want, is to stop this\n\t\t\t * timer completely and restart it in case the\n\t\t\t * SIG_IGN is removed. This is a non trivial\n\t\t\t * change which involves sighand locking\n\t\t\t * (sigh !), which we don't want to do late in\n\t\t\t * the release cycle.\n\t\t\t *\n\t\t\t * For now we just let timers with an interval\n\t\t\t * less than a jiffie expire every jiffie to\n\t\t\t * avoid softirq starvation in case of SIG_IGN\n\t\t\t * and a very small interval, which would put\n\t\t\t * the timer right back on the softirq pending\n\t\t\t * list. By moving now ahead of time we trick\n\t\t\t * hrtimer_forward() to expire the timer\n\t\t\t * later, while we still maintain the overrun\n\t\t\t * accuracy, but have some inconsistency in\n\t\t\t * the timer_gettime() case. This is at least\n\t\t\t * better than a starved softirq. A more\n\t\t\t * complex fix which solves also another related\n\t\t\t * inconsistency is already in the pipeline.\n\t\t\t */\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += hrtimer_forward(timer, now,\n\t\t\t\t\t\t\t    timr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "posix_timer_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "336-357",
    "snippet": "int posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sigqueue",
          "args": [
            "timr->sigq",
            "timr->it_pid",
            "type"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1950-1996",
          "snippet": "int send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}"
  },
  {
    "function_name": "posixtimer_rearm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "313-334",
    "snippet": "void posixtimer_rearm(struct kernel_siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\n\tif (timr->it_interval && timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1LL;\n\t\t++timr->it_requeue_pending;\n\n\t\tinfo->si_overrun = timer_overrun_to_int(timr, info->si_overrun);\n\t}\n\n\tunlock_timer(timr, flags);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_timer",
          "args": [
            "timr",
            "flags"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "164-167",
          "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_overrun_to_int",
          "args": [
            "timr",
            "info->si_overrun"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "timer_overrun_to_int",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "286-291",
          "snippet": "static inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timr->kclock->timer_rearm",
          "args": [
            "timr"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_timer",
          "args": [
            "info->si_tid",
            "&flags"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "614-638",
          "snippet": "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nvoid posixtimer_rearm(struct kernel_siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\n\tif (timr->it_interval && timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1LL;\n\t\t++timr->it_requeue_pending;\n\n\t\tinfo->si_overrun = timer_overrun_to_int(timr, info->si_overrun);\n\t}\n\n\tunlock_timer(timr, flags);\n}"
  },
  {
    "function_name": "common_hrtimer_rearm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "293-300",
    "snippet": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\ttimr->it_overrun += hrtimer_forward(timer, timer->base->get_time(),\n\t\t\t\t\t    timr->it_interval);\n\thrtimer_restart(timer);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_restart",
          "args": [
            "timer"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mux_hrtimer_restart",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "1175-1194",
          "snippet": "static int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED_HARD);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static __must_check struct",
            "static void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);",
            "static bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);",
            "static void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic __must_check struct;\nstatic void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);\nstatic void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);\n\nstatic int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED_HARD);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "timer",
            "timer->base->get_time()",
            "timr->it_interval"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1037-1069",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer->base->get_time",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\ttimr->it_overrun += hrtimer_forward(timer, timer->base->get_time(),\n\t\t\t\t\t    timr->it_interval);\n\thrtimer_restart(timer);\n}"
  },
  {
    "function_name": "timer_overrun_to_int",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "286-291",
    "snippet": "static inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}"
  },
  {
    "function_name": "init_posix_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "273-279",
    "snippet": "static __init int init_posix_timers(void)\n{\n\tposix_timers_cache = kmem_cache_create(\"posix_timers_cache\",\n\t\t\t\t\tsizeof(struct k_itimer), 0,\n\t\t\t\t\tSLAB_PANIC | SLAB_ACCOUNT, NULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *posix_timers_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"posix_timers_cache\"",
            "sizeof(struct k_itimer)",
            "0",
            "SLAB_PANIC | SLAB_ACCOUNT",
            "NULL"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *posix_timers_cache;\n\nstatic __init int init_posix_timers(void)\n{\n\tposix_timers_cache = kmem_cache_create(\"posix_timers_cache\",\n\t\t\t\t\tsizeof(struct k_itimer), 0,\n\t\t\t\t\tSLAB_PANIC | SLAB_ACCOUNT, NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_hrtimer_res",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "263-268",
    "snippet": "static int posix_get_hrtimer_res(clockid_t which_clock, struct timespec64 *tp)\n{\n\ttp->tv_sec = 0;\n\ttp->tv_nsec = hrtimer_resolution;\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_hrtimer_res(clockid_t which_clock, struct timespec64 *tp)\n{\n\ttp->tv_sec = 0;\n\ttp->tv_nsec = hrtimer_resolution;\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_tai_ktime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "258-261",
    "snippet": "static ktime_t posix_get_tai_ktime(clockid_t which_clock)\n{\n\treturn ktime_get_clocktai();\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_clocktai",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic ktime_t posix_get_tai_ktime(clockid_t which_clock)\n{\n\treturn ktime_get_clocktai();\n}"
  },
  {
    "function_name": "posix_get_tai_timespec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "252-256",
    "snippet": "static int posix_get_tai_timespec(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_clocktai_ts64(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_clocktai_ts64",
          "args": [
            "tp"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_tai_timespec(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_clocktai_ts64(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_boottime_ktime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "247-250",
    "snippet": "static ktime_t posix_get_boottime_ktime(const clockid_t which_clock)\n{\n\treturn ktime_get_boottime();\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_boottime",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic ktime_t posix_get_boottime_ktime(const clockid_t which_clock)\n{\n\treturn ktime_get_boottime();\n}"
  },
  {
    "function_name": "posix_get_boottime_timespec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "240-245",
    "snippet": "static int posix_get_boottime_timespec(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_boottime_ts64(tp);\n\ttimens_add_boottime(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timens_add_boottime",
          "args": [
            "tp"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_boottime_ts64",
          "args": [
            "tp"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_boottime_timespec(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_boottime_ts64(tp);\n\ttimens_add_boottime(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_coarse_res",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "234-238",
    "snippet": "static int posix_get_coarse_res(const clockid_t which_clock, struct timespec64 *tp)\n{\n\t*tp = ktime_to_timespec64(KTIME_LOW_RES);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "KTIME_LOW_RES"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_coarse_res(const clockid_t which_clock, struct timespec64 *tp)\n{\n\t*tp = ktime_to_timespec64(KTIME_LOW_RES);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_monotonic_coarse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "226-232",
    "snippet": "static int posix_get_monotonic_coarse(clockid_t which_clock,\n\t\t\t\t\t\tstruct timespec64 *tp)\n{\n\tktime_get_coarse_ts64(tp);\n\ttimens_add_monotonic(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timens_add_monotonic",
          "args": [
            "tp"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_coarse_ts64",
          "args": [
            "tp"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_coarse_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2247-2262",
          "snippet": "void ktime_get_coarse_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 now, mono;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tnow = tk_xtime(tk);\n\t\tmono = tk->wall_to_monotonic;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tset_normalized_timespec64(ts, now.tv_sec + mono.tv_sec,\n\t\t\t\tnow.tv_nsec + mono.tv_nsec);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 now, mono;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tnow = tk_xtime(tk);\n\t\tmono = tk->wall_to_monotonic;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tset_normalized_timespec64(ts, now.tv_sec + mono.tv_sec,\n\t\t\t\tnow.tv_nsec + mono.tv_nsec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_monotonic_coarse(clockid_t which_clock,\n\t\t\t\t\t\tstruct timespec64 *tp)\n{\n\tktime_get_coarse_ts64(tp);\n\ttimens_add_monotonic(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_realtime_coarse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "220-224",
    "snippet": "static int posix_get_realtime_coarse(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_coarse_real_ts64(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_coarse_real_ts64",
          "args": [
            "tp"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_coarse_real_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2234-2244",
          "snippet": "void ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_realtime_coarse(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_coarse_real_ts64(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_monotonic_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "212-217",
    "snippet": "static int posix_get_monotonic_raw(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_raw_ts64(tp);\n\ttimens_add_monotonic(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timens_add_monotonic",
          "args": [
            "tp"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_raw_ts64",
          "args": [
            "tp"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_raw_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1496-1511",
          "snippet": "void ktime_get_raw_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->raw_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_raw_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->raw_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_monotonic_raw(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_raw_ts64(tp);\n\ttimens_add_monotonic(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_monotonic_ktime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "204-207",
    "snippet": "static ktime_t posix_get_monotonic_ktime(clockid_t which_clock)\n{\n\treturn ktime_get();\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic ktime_t posix_get_monotonic_ktime(clockid_t which_clock)\n{\n\treturn ktime_get();\n}"
  },
  {
    "function_name": "posix_get_monotonic_timespec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "197-202",
    "snippet": "static int posix_get_monotonic_timespec(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_ts64(tp);\n\ttimens_add_monotonic(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timens_add_monotonic",
          "args": [
            "tp"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ts64",
          "args": [
            "tp"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "950-970",
          "snippet": "void ktime_get_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 tomono;\n\tunsigned int seq;\n\tu64 nsec;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsec = timekeeping_get_ns(&tk->tkr_mono);\n\t\ttomono = tk->wall_to_monotonic;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_sec += tomono.tv_sec;\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsec + tomono.tv_nsec);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 tomono;\n\tunsigned int seq;\n\tu64 nsec;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsec = timekeeping_get_ns(&tk->tkr_mono);\n\t\ttomono = tk->wall_to_monotonic;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_sec += tomono.tv_sec;\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsec + tomono.tv_nsec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_monotonic_timespec(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_ts64(tp);\n\ttimens_add_monotonic(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_clock_realtime_adj",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "188-192",
    "snippet": "static int posix_clock_realtime_adj(const clockid_t which_clock,\n\t\t\t\t    struct __kernel_timex *t)\n{\n\treturn do_adjtimex(t);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_adjtimex",
          "args": [
            "t"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "do_adjtimex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2387-2447",
          "snippet": "int do_adjtimex(struct __kernel_timex *txc)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct audit_ntp_data ad;\n\tbool clock_set = false;\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\ts32 orig_tai, tai;\n\tint ret;\n\n\t/* Validate the data before disabling interrupts */\n\tret = timekeeping_validate_timex(txc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\tstruct timespec64 delta;\n\t\tdelta.tv_sec  = txc->time.tv_sec;\n\t\tdelta.tv_nsec = txc->time.tv_usec;\n\t\tif (!(txc->modes & ADJ_NANO))\n\t\t\tdelta.tv_nsec *= 1000;\n\t\tret = timekeeping_inject_offset(&delta);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taudit_tk_injoffset(delta);\n\t}\n\n\taudit_ntp_init(&ad);\n\n\tktime_get_real_ts64(&ts);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\torig_tai = tai = tk->tai_offset;\n\tret = __do_adjtimex(txc, &ts, &tai, &ad);\n\n\tif (tai != orig_tai) {\n\t\t__timekeeping_set_tai_offset(tk, tai);\n\t\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\t\tclock_set = true;\n\t}\n\ttk_update_leap_state(tk);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\taudit_ntp_log(&ad);\n\n\t/* Update the multiplier immediately if frequency was set directly */\n\tif (txc->modes & (ADJ_FREQUENCY | ADJ_TICK))\n\t\tclock_set |= timekeeping_advance(TK_ADV_FREQ);\n\n\tif (clock_set)\n\t\tclock_was_set(CLOCK_REALTIME);\n\n\tntp_notify_cmos_timer();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n\nint do_adjtimex(struct __kernel_timex *txc)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct audit_ntp_data ad;\n\tbool clock_set = false;\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\ts32 orig_tai, tai;\n\tint ret;\n\n\t/* Validate the data before disabling interrupts */\n\tret = timekeeping_validate_timex(txc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\tstruct timespec64 delta;\n\t\tdelta.tv_sec  = txc->time.tv_sec;\n\t\tdelta.tv_nsec = txc->time.tv_usec;\n\t\tif (!(txc->modes & ADJ_NANO))\n\t\t\tdelta.tv_nsec *= 1000;\n\t\tret = timekeeping_inject_offset(&delta);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taudit_tk_injoffset(delta);\n\t}\n\n\taudit_ntp_init(&ad);\n\n\tktime_get_real_ts64(&ts);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\torig_tai = tai = tk->tai_offset;\n\tret = __do_adjtimex(txc, &ts, &tai, &ad);\n\n\tif (tai != orig_tai) {\n\t\t__timekeeping_set_tai_offset(tk, tai);\n\t\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\t\tclock_set = true;\n\t}\n\ttk_update_leap_state(tk);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\taudit_ntp_log(&ad);\n\n\t/* Update the multiplier immediately if frequency was set directly */\n\tif (txc->modes & (ADJ_FREQUENCY | ADJ_TICK))\n\t\tclock_set |= timekeeping_advance(TK_ADV_FREQ);\n\n\tif (clock_set)\n\t\tclock_was_set(CLOCK_REALTIME);\n\n\tntp_notify_cmos_timer();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_clock_realtime_adj(const clockid_t which_clock,\n\t\t\t\t    struct __kernel_timex *t)\n{\n\treturn do_adjtimex(t);\n}"
  },
  {
    "function_name": "posix_clock_realtime_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "182-186",
    "snippet": "static int posix_clock_realtime_set(const clockid_t which_clock,\n\t\t\t\t    const struct timespec64 *tp)\n{\n\treturn do_sys_settimeofday64(tp, NULL);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_sys_settimeofday64",
          "args": [
            "tp",
            "NULL"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "do_sys_settimeofday64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "169-197",
          "snippet": "int do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz)\n{\n\tstatic int firsttime = 1;\n\tint error = 0;\n\n\tif (tv && !timespec64_valid_settod(tv))\n\t\treturn -EINVAL;\n\n\terror = security_settime64(tv, tz);\n\tif (error)\n\t\treturn error;\n\n\tif (tz) {\n\t\t/* Verify we're within the +-15 hrs range */\n\t\tif (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)\n\t\t\treturn -EINVAL;\n\n\t\tsys_tz = *tz;\n\t\tupdate_vsyscall_tz();\n\t\tif (firsttime) {\n\t\t\tfirsttime = 0;\n\t\t\tif (!tv)\n\t\t\t\ttimekeeping_warp_clock();\n\t\t}\n\t}\n\tif (tv)\n\t\treturn do_settimeofday64(tv);\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct timezone sys_tz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timezone sys_tz;\n\nint do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz)\n{\n\tstatic int firsttime = 1;\n\tint error = 0;\n\n\tif (tv && !timespec64_valid_settod(tv))\n\t\treturn -EINVAL;\n\n\terror = security_settime64(tv, tz);\n\tif (error)\n\t\treturn error;\n\n\tif (tz) {\n\t\t/* Verify we're within the +-15 hrs range */\n\t\tif (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)\n\t\t\treturn -EINVAL;\n\n\t\tsys_tz = *tz;\n\t\tupdate_vsyscall_tz();\n\t\tif (firsttime) {\n\t\t\tfirsttime = 0;\n\t\t\tif (!tv)\n\t\t\t\ttimekeeping_warp_clock();\n\t\t}\n\t}\n\tif (tv)\n\t\treturn do_settimeofday64(tv);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_clock_realtime_set(const clockid_t which_clock,\n\t\t\t\t    const struct timespec64 *tp)\n{\n\treturn do_sys_settimeofday64(tp, NULL);\n}"
  },
  {
    "function_name": "posix_get_realtime_ktime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "176-179",
    "snippet": "static ktime_t posix_get_realtime_ktime(clockid_t which_clock)\n{\n\treturn ktime_get_real();\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_real",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic ktime_t posix_get_realtime_ktime(clockid_t which_clock)\n{\n\treturn ktime_get_real();\n}"
  },
  {
    "function_name": "posix_get_realtime_timespec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "170-174",
    "snippet": "static int posix_get_realtime_timespec(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_real_ts64(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_real_ts64",
          "args": [
            "tp"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "796-814",
          "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_realtime_timespec(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_real_ts64(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "unlock_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "164-167",
    "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&timr->it_lock",
            "flags"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
  },
  {
    "function_name": "posix_timer_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "140-162",
    "snippet": "static int posix_timer_add(struct k_itimer *timer)\n{\n\tstruct signal_struct *sig = current->signal;\n\tint first_free_id = sig->posix_timer_id;\n\tstruct hlist_head *head;\n\tint ret = -ENOENT;\n\n\tdo {\n\t\tspin_lock(&hash_lock);\n\t\thead = &posix_timers_hashtable[hash(sig, sig->posix_timer_id)];\n\t\tif (!__posix_timers_find(head, sig, sig->posix_timer_id)) {\n\t\t\thlist_add_head_rcu(&timer->t_hash, head);\n\t\t\tret = sig->posix_timer_id;\n\t\t}\n\t\tif (++sig->posix_timer_id < 0)\n\t\t\tsig->posix_timer_id = 0;\n\t\tif ((sig->posix_timer_id == first_free_id) && (ret == -ENOENT))\n\t\t\t/* Loop over all possible ids completed */\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&hash_lock);\n\t} while (ret == -ENOENT);\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);",
      "static DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&timer->t_hash",
            "head"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__posix_timers_find",
          "args": [
            "head",
            "sig",
            "sig->posix_timer_id"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__posix_timers_find",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "118-130",
          "snippet": "static struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash,\n\t\t\t\t lockdep_is_held(&hash_lock)) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(hash_lock);",
            "static const struct k_clock *clockid_to_kclock(const clockid_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(hash_lock);\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\n\nstatic struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash,\n\t\t\t\t lockdep_is_held(&hash_lock)) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sig",
            "sig->posix_timer_id"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "113-116",
          "snippet": "static int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\n\nstatic int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\nstatic DEFINE_SPINLOCK(hash_lock);\n\nstatic int posix_timer_add(struct k_itimer *timer)\n{\n\tstruct signal_struct *sig = current->signal;\n\tint first_free_id = sig->posix_timer_id;\n\tstruct hlist_head *head;\n\tint ret = -ENOENT;\n\n\tdo {\n\t\tspin_lock(&hash_lock);\n\t\thead = &posix_timers_hashtable[hash(sig, sig->posix_timer_id)];\n\t\tif (!__posix_timers_find(head, sig, sig->posix_timer_id)) {\n\t\t\thlist_add_head_rcu(&timer->t_hash, head);\n\t\t\tret = sig->posix_timer_id;\n\t\t}\n\t\tif (++sig->posix_timer_id < 0)\n\t\t\tsig->posix_timer_id = 0;\n\t\tif ((sig->posix_timer_id == first_free_id) && (ret == -ENOENT))\n\t\t\t/* Loop over all possible ids completed */\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&hash_lock);\n\t} while (ret == -ENOENT);\n\treturn ret;\n}"
  },
  {
    "function_name": "posix_timer_by_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "132-138",
    "snippet": "static struct k_itimer *posix_timer_by_id(timer_t id)\n{\n\tstruct signal_struct *sig = current->signal;\n\tstruct hlist_head *head = &posix_timers_hashtable[hash(sig, id)];\n\n\treturn __posix_timers_find(head, sig, id);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);",
      "static const struct k_clock *clockid_to_kclock(const clockid_t id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__posix_timers_find",
          "args": [
            "head",
            "sig",
            "id"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "__posix_timers_find",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "118-130",
          "snippet": "static struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash,\n\t\t\t\t lockdep_is_held(&hash_lock)) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(hash_lock);",
            "static const struct k_clock *clockid_to_kclock(const clockid_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(hash_lock);\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\n\nstatic struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash,\n\t\t\t\t lockdep_is_held(&hash_lock)) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sig",
            "id"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "113-116",
          "snippet": "static int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\n\nstatic int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\n\nstatic struct k_itimer *posix_timer_by_id(timer_t id)\n{\n\tstruct signal_struct *sig = current->signal;\n\tstruct hlist_head *head = &posix_timers_hashtable[hash(sig, id)];\n\n\treturn __posix_timers_find(head, sig, id);\n}"
  },
  {
    "function_name": "__posix_timers_find",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "118-130",
    "snippet": "static struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash,\n\t\t\t\t lockdep_is_held(&hash_lock)) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(hash_lock);",
      "static const struct k_clock *clockid_to_kclock(const clockid_t id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "timer",
            "head",
            "t_hash",
            "lockdep_is_held(&hash_lock)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&hash_lock"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(hash_lock);\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\n\nstatic struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash,\n\t\t\t\t lockdep_is_held(&hash_lock)) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "113-116",
    "snippet": "static int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "hash32_ptr(sig) ^ nr",
            "HASH_BITS(posix_timers_hashtable)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HASH_BITS",
          "args": [
            "posix_timers_hashtable"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash32_ptr",
          "args": [
            "sig"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\n\nstatic int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}"
  },
  {
    "function_name": "timer_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "577-589",
    "snippet": "SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,\n\t\tstruct sigevent __user *, timer_event_spec,\n\t\ttimer_t __user *, created_timer_id)\n{\n\tif (timer_event_spec) {\n\t\tsigevent_t event;\n\n\t\tif (copy_from_user(&event, timer_event_spec, sizeof (event)))\n\t\t\treturn -EFAULT;\n\t\treturn do_timer_create(which_clock, &event, created_timer_id);\n\t}\n\treturn do_timer_create(which_clock, NULL, created_timer_id);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,\n\t\tstruct sigevent __user *, timer_event_spec,\n\t\ttimer_t __user *, created_timer_id)\n{\n\tif (timer_event_spec) {\n\t\tsigevent_t event;\n\n\t\tif (copy_from_user(&event, timer_event_spec, sizeof (event)))\n\t\t\treturn -EFAULT;\n\t\treturn do_timer_create(which_clock, &event, created_timer_id);\n\t}\n\treturn do_timer_create(which_clock, NULL, created_timer_id);\n}"
  },
  {
    "function_name": "timer_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "592-604",
    "snippet": "SYSCALL_DEFINE3(timer_create, clockid_t, which_clock,\n\t\t       struct compat_sigevent __user *, timer_event_spec,\n\t\t       timer_t __user *, created_timer_id)\n{\n\tif (timer_event_spec) {\n\t\tsigevent_t event;\n\n\t\tif (get_compat_sigevent(&event, timer_event_spec))\n\t\t\treturn -EFAULT;\n\t\treturn do_timer_create(which_clock, &event, created_timer_id);\n\t}\n\treturn do_timer_create(which_clock, NULL, created_timer_id);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(timer_create, clockid_t, which_clock,\n\t\t       struct compat_sigevent __user *, timer_event_spec,\n\t\t       timer_t __user *, created_timer_id)\n{\n\tif (timer_event_spec) {\n\t\tsigevent_t event;\n\n\t\tif (get_compat_sigevent(&event, timer_event_spec))\n\t\t\treturn -EFAULT;\n\t\treturn do_timer_create(which_clock, &event, created_timer_id);\n\t}\n\treturn do_timer_create(which_clock, NULL, created_timer_id);\n}"
  },
  {
    "function_name": "timer_gettime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "738-749",
    "snippet": "SYSCALL_DEFINE2(timer_gettime, timer_t, timer_id,\n\t\tstruct __kernel_itimerspec __user *, setting)\n{\n\tstruct itimerspec64 cur_setting;\n\n\tint ret = do_timer_gettime(timer_id, &cur_setting);\n\tif (!ret) {\n\t\tif (put_itimerspec64(&cur_setting, setting))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(timer_gettime, timer_t, timer_id,\n\t\tstruct __kernel_itimerspec __user *, setting)\n{\n\tstruct itimerspec64 cur_setting;\n\n\tint ret = do_timer_gettime(timer_id, &cur_setting);\n\tif (!ret) {\n\t\tif (put_itimerspec64(&cur_setting, setting))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "timer_gettime32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "753-764",
    "snippet": "SYSCALL_DEFINE2(timer_gettime32, timer_t, timer_id,\n\t\tstruct old_itimerspec32 __user *, setting)\n{\n\tstruct itimerspec64 cur_setting;\n\n\tint ret = do_timer_gettime(timer_id, &cur_setting);\n\tif (!ret) {\n\t\tif (put_old_itimerspec32(&cur_setting, setting))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(timer_gettime32, timer_t, timer_id,\n\t\tstruct old_itimerspec32 __user *, setting)\n{\n\tstruct itimerspec64 cur_setting;\n\n\tint ret = do_timer_gettime(timer_id, &cur_setting);\n\tif (!ret) {\n\t\tif (put_old_itimerspec32(&cur_setting, setting))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "timer_getoverrun",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "777-791",
    "snippet": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\toverrun = timer_overrun_to_int(timr, 0);\n\tunlock_timer(timr, flags);\n\n\treturn overrun;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\toverrun = timer_overrun_to_int(timr, 0);\n\tunlock_timer(timr, flags);\n\n\treturn overrun;\n}"
  },
  {
    "function_name": "timer_settime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "938-958",
    "snippet": "SYSCALL_DEFINE4(timer_settime, timer_t, timer_id, int, flags,\n\t\tconst struct __kernel_itimerspec __user *, new_setting,\n\t\tstruct __kernel_itimerspec __user *, old_setting)\n{\n\tstruct itimerspec64 new_spec, old_spec;\n\tstruct itimerspec64 *rtn = old_setting ? &old_spec : NULL;\n\tint error = 0;\n\n\tif (!new_setting)\n\t\treturn -EINVAL;\n\n\tif (get_itimerspec64(&new_spec, new_setting))\n\t\treturn -EFAULT;\n\n\terror = do_timer_settime(timer_id, flags, &new_spec, rtn);\n\tif (!error && old_setting) {\n\t\tif (put_itimerspec64(&old_spec, old_setting))\n\t\t\terror = -EFAULT;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE4(timer_settime, timer_t, timer_id, int, flags,\n\t\tconst struct __kernel_itimerspec __user *, new_setting,\n\t\tstruct __kernel_itimerspec __user *, old_setting)\n{\n\tstruct itimerspec64 new_spec, old_spec;\n\tstruct itimerspec64 *rtn = old_setting ? &old_spec : NULL;\n\tint error = 0;\n\n\tif (!new_setting)\n\t\treturn -EINVAL;\n\n\tif (get_itimerspec64(&new_spec, new_setting))\n\t\treturn -EFAULT;\n\n\terror = do_timer_settime(timer_id, flags, &new_spec, rtn);\n\tif (!error && old_setting) {\n\t\tif (put_itimerspec64(&old_spec, old_setting))\n\t\t\terror = -EFAULT;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "timer_settime32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "961-980",
    "snippet": "SYSCALL_DEFINE4(timer_settime32, timer_t, timer_id, int, flags,\n\t\tstruct old_itimerspec32 __user *, new,\n\t\tstruct old_itimerspec32 __user *, old)\n{\n\tstruct itimerspec64 new_spec, old_spec;\n\tstruct itimerspec64 *rtn = old ? &old_spec : NULL;\n\tint error = 0;\n\n\tif (!new)\n\t\treturn -EINVAL;\n\tif (get_old_itimerspec32(&new_spec, new))\n\t\treturn -EFAULT;\n\n\terror = do_timer_settime(timer_id, flags, &new_spec, rtn);\n\tif (!error && old) {\n\t\tif (put_old_itimerspec32(&old_spec, old))\n\t\t\terror = -EFAULT;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE4(timer_settime32, timer_t, timer_id, int, flags,\n\t\tstruct old_itimerspec32 __user *, new,\n\t\tstruct old_itimerspec32 __user *, old)\n{\n\tstruct itimerspec64 new_spec, old_spec;\n\tstruct itimerspec64 *rtn = old ? &old_spec : NULL;\n\tint error = 0;\n\n\tif (!new)\n\t\treturn -EINVAL;\n\tif (get_old_itimerspec32(&new_spec, new))\n\t\treturn -EFAULT;\n\n\terror = do_timer_settime(timer_id, flags, &new_spec, rtn);\n\tif (!error && old) {\n\t\tif (put_old_itimerspec32(&old_spec, old))\n\t\t\terror = -EFAULT;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "timer_delete",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1004-1033",
    "snippet": "SYSCALL_DEFINE1(timer_delete, timer_t, timer_id)\n{\n\tstruct k_itimer *timer;\n\tunsigned long flags;\n\n\ttimer = lock_timer(timer_id, &flags);\n\nretry_delete:\n\tif (!timer)\n\t\treturn -EINVAL;\n\n\tif (unlikely(timer_delete_hook(timer) == TIMER_RETRY)) {\n\t\t/* Unlocks and relocks the timer if it still exists */\n\t\ttimer = timer_wait_running(timer, &flags);\n\t\tgoto retry_delete;\n\t}\n\n\tspin_lock(&current->sighand->siglock);\n\tlist_del(&timer->list);\n\tspin_unlock(&current->sighand->siglock);\n\t/*\n\t * This keeps any tasks waiting on the spin lock from thinking\n\t * they got something (see the lock code above).\n\t */\n\ttimer->it_signal = NULL;\n\n\tunlock_timer(timer, flags);\n\trelease_posix_timer(timer, IT_ID_SET);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define IT_ID_SET\t1"
    ],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\n#define IT_ID_SET\t1\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE1(timer_delete, timer_t, timer_id)\n{\n\tstruct k_itimer *timer;\n\tunsigned long flags;\n\n\ttimer = lock_timer(timer_id, &flags);\n\nretry_delete:\n\tif (!timer)\n\t\treturn -EINVAL;\n\n\tif (unlikely(timer_delete_hook(timer) == TIMER_RETRY)) {\n\t\t/* Unlocks and relocks the timer if it still exists */\n\t\ttimer = timer_wait_running(timer, &flags);\n\t\tgoto retry_delete;\n\t}\n\n\tspin_lock(&current->sighand->siglock);\n\tlist_del(&timer->list);\n\tspin_unlock(&current->sighand->siglock);\n\t/*\n\t * This keeps any tasks waiting on the spin lock from thinking\n\t * they got something (see the lock code above).\n\t */\n\ttimer->it_signal = NULL;\n\n\tunlock_timer(timer, flags);\n\trelease_posix_timer(timer, IT_ID_SET);\n\treturn 0;\n}"
  },
  {
    "function_name": "clock_settime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1067-1080",
    "snippet": "SYSCALL_DEFINE2(clock_settime, const clockid_t, which_clock,\n\t\tconst struct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 new_tp;\n\n\tif (!kc || !kc->clock_set)\n\t\treturn -EINVAL;\n\n\tif (get_timespec64(&new_tp, tp))\n\t\treturn -EFAULT;\n\n\treturn kc->clock_set(which_clock, &new_tp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_settime, const clockid_t, which_clock,\n\t\tconst struct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 new_tp;\n\n\tif (!kc || !kc->clock_set)\n\t\treturn -EINVAL;\n\n\tif (get_timespec64(&new_tp, tp))\n\t\treturn -EFAULT;\n\n\treturn kc->clock_set(which_clock, &new_tp);\n}"
  },
  {
    "function_name": "clock_gettime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1082-1098",
    "snippet": "SYSCALL_DEFINE2(clock_gettime, const clockid_t, which_clock,\n\t\tstruct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 kernel_tp;\n\tint error;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terror = kc->clock_get_timespec(which_clock, &kernel_tp);\n\n\tif (!error && put_timespec64(&kernel_tp, tp))\n\t\terror = -EFAULT;\n\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_gettime, const clockid_t, which_clock,\n\t\tstruct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 kernel_tp;\n\tint error;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terror = kc->clock_get_timespec(which_clock, &kernel_tp);\n\n\tif (!error && put_timespec64(&kernel_tp, tp))\n\t\terror = -EFAULT;\n\n\treturn error;\n}"
  },
  {
    "function_name": "clock_adjtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1112-1127",
    "snippet": "SYSCALL_DEFINE2(clock_adjtime, const clockid_t, which_clock,\n\t\tstruct __kernel_timex __user *, utx)\n{\n\tstruct __kernel_timex ktx;\n\tint err;\n\n\tif (copy_from_user(&ktx, utx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\n\terr = do_clock_adjtime(which_clock, &ktx);\n\n\tif (err >= 0 && copy_to_user(utx, &ktx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_adjtime, const clockid_t, which_clock,\n\t\tstruct __kernel_timex __user *, utx)\n{\n\tstruct __kernel_timex ktx;\n\tint err;\n\n\tif (copy_from_user(&ktx, utx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\n\terr = do_clock_adjtime(which_clock, &ktx);\n\n\tif (err >= 0 && copy_to_user(utx, &ktx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\n\treturn err;\n}"
  },
  {
    "function_name": "clock_getres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1129-1145",
    "snippet": "SYSCALL_DEFINE2(clock_getres, const clockid_t, which_clock,\n\t\tstruct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 rtn_tp;\n\tint error;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terror = kc->clock_getres(which_clock, &rtn_tp);\n\n\tif (!error && tp && put_timespec64(&rtn_tp, tp))\n\t\terror = -EFAULT;\n\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_getres, const clockid_t, which_clock,\n\t\tstruct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 rtn_tp;\n\tint error;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terror = kc->clock_getres(which_clock, &rtn_tp);\n\n\tif (!error && tp && put_timespec64(&rtn_tp, tp))\n\t\terror = -EFAULT;\n\n\treturn error;\n}"
  },
  {
    "function_name": "clock_settime32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1149-1162",
    "snippet": "SYSCALL_DEFINE2(clock_settime32, clockid_t, which_clock,\n\t\tstruct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\n\tif (!kc || !kc->clock_set)\n\t\treturn -EINVAL;\n\n\tif (get_old_timespec32(&ts, tp))\n\t\treturn -EFAULT;\n\n\treturn kc->clock_set(which_clock, &ts);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_settime32, clockid_t, which_clock,\n\t\tstruct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\n\tif (!kc || !kc->clock_set)\n\t\treturn -EINVAL;\n\n\tif (get_old_timespec32(&ts, tp))\n\t\treturn -EFAULT;\n\n\treturn kc->clock_set(which_clock, &ts);\n}"
  },
  {
    "function_name": "clock_gettime32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1164-1180",
    "snippet": "SYSCALL_DEFINE2(clock_gettime32, clockid_t, which_clock,\n\t\tstruct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terr = kc->clock_get_timespec(which_clock, &ts);\n\n\tif (!err && put_old_timespec32(&ts, tp))\n\t\terr = -EFAULT;\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_gettime32, clockid_t, which_clock,\n\t\tstruct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terr = kc->clock_get_timespec(which_clock, &ts);\n\n\tif (!err && put_old_timespec32(&ts, tp))\n\t\terr = -EFAULT;\n\n\treturn err;\n}"
  },
  {
    "function_name": "clock_adjtime32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1182-1198",
    "snippet": "SYSCALL_DEFINE2(clock_adjtime32, clockid_t, which_clock,\n\t\tstruct old_timex32 __user *, utp)\n{\n\tstruct __kernel_timex ktx;\n\tint err;\n\n\terr = get_old_timex32(&ktx, utp);\n\tif (err)\n\t\treturn err;\n\n\terr = do_clock_adjtime(which_clock, &ktx);\n\n\tif (err >= 0 && put_old_timex32(utp, &ktx))\n\t\treturn -EFAULT;\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_adjtime32, clockid_t, which_clock,\n\t\tstruct old_timex32 __user *, utp)\n{\n\tstruct __kernel_timex ktx;\n\tint err;\n\n\terr = get_old_timex32(&ktx, utp);\n\tif (err)\n\t\treturn err;\n\n\terr = do_clock_adjtime(which_clock, &ktx);\n\n\tif (err >= 0 && put_old_timex32(utp, &ktx))\n\t\treturn -EFAULT;\n\n\treturn err;\n}"
  },
  {
    "function_name": "clock_getres_time32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1200-1215",
    "snippet": "SYSCALL_DEFINE2(clock_getres_time32, clockid_t, which_clock,\n\t\tstruct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terr = kc->clock_getres(which_clock, &ts);\n\tif (!err && tp && put_old_timespec32(&ts, tp))\n\t\treturn -EFAULT;\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_getres_time32, clockid_t, which_clock,\n\t\tstruct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terr = kc->clock_getres(which_clock, &ts);\n\tif (!err && tp && put_old_timespec32(&ts, tp))\n\t\treturn -EFAULT;\n\n\treturn err;\n}"
  },
  {
    "function_name": "clock_nanosleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1245-1268",
    "snippet": "SYSCALL_DEFINE4(clock_nanosleep, const clockid_t, which_clock, int, flags,\n\t\tconst struct __kernel_timespec __user *, rqtp,\n\t\tstruct __kernel_timespec __user *, rmtp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 t;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->nsleep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (get_timespec64(&t, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&t))\n\t\treturn -EINVAL;\n\tif (flags & TIMER_ABSTIME)\n\t\trmtp = NULL;\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;\n\tcurrent->restart_block.nanosleep.rmtp = rmtp;\n\n\treturn kc->nsleep(which_clock, flags, &t);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE4(clock_nanosleep, const clockid_t, which_clock, int, flags,\n\t\tconst struct __kernel_timespec __user *, rqtp,\n\t\tstruct __kernel_timespec __user *, rmtp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 t;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->nsleep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (get_timespec64(&t, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&t))\n\t\treturn -EINVAL;\n\tif (flags & TIMER_ABSTIME)\n\t\trmtp = NULL;\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;\n\tcurrent->restart_block.nanosleep.rmtp = rmtp;\n\n\treturn kc->nsleep(which_clock, flags, &t);\n}"
  },
  {
    "function_name": "clock_nanosleep_time32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
    "lines": "1272-1295",
    "snippet": "SYSCALL_DEFINE4(clock_nanosleep_time32, clockid_t, which_clock, int, flags,\n\t\tstruct old_timespec32 __user *, rqtp,\n\t\tstruct old_timespec32 __user *, rmtp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 t;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->nsleep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (get_old_timespec32(&t, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&t))\n\t\treturn -EINVAL;\n\tif (flags & TIMER_ABSTIME)\n\t\trmtp = NULL;\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;\n\tcurrent->restart_block.nanosleep.compat_rmtp = rmtp;\n\n\treturn kc->nsleep(which_clock, flags, &t);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE4(clock_nanosleep_time32, clockid_t, which_clock, int, flags,\n\t\tstruct old_timespec32 __user *, rqtp,\n\t\tstruct old_timespec32 __user *, rmtp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 t;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->nsleep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (get_old_timespec32(&t, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&t))\n\t\treturn -EINVAL;\n\tif (flags & TIMER_ABSTIME)\n\t\trmtp = NULL;\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;\n\tcurrent->restart_block.nanosleep.compat_rmtp = rmtp;\n\n\treturn kc->nsleep(which_clock, flags, &t);\n}"
  }
]