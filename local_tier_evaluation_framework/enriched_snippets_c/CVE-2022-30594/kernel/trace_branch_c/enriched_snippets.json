[
  {
    "function_name": "all_annotated_branch_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "442-453",
    "snippet": "__init static int all_annotated_branch_stats(void)\n{\n\tint ret;\n\n\tret = register_stat_tracer(&all_branch_stats);\n\tif (!ret) {\n\t\tprintk(KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"all branches stats\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"all branches stats\\n\""
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_stat_tracer",
          "args": [
            "&all_branch_stats"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_stat_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "351-364",
          "snippet": "void unregister_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *node, *tmp;\n\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace) {\n\t\t\tlist_del(&node->session_list);\n\t\t\tdestroy_session(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&all_stat_sessions_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(all_stat_sessions);",
            "static DEFINE_MUTEX(all_stat_sessions_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(all_stat_sessions);\nstatic DEFINE_MUTEX(all_stat_sessions_mutex);\n\nvoid unregister_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *node, *tmp;\n\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace) {\n\t\t\tlist_del(&node->session_list);\n\t\t\tdestroy_session(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&all_stat_sessions_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\n__init static int all_annotated_branch_stats(void)\n{\n\tint ret;\n\n\tret = register_stat_tracer(&all_branch_stats);\n\tif (!ret) {\n\t\tprintk(KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"all branches stats\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "all_branch_stat_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "425-432",
    "snippet": "static int all_branch_stat_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_branch_data *p = v;\n\tconst char *f;\n\n\tf = branch_stat_process_file(p);\n\treturn branch_stat_show_normal(m, p, f);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "branch_stat_show_normal",
          "args": [
            "m",
            "p",
            "f"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "branch_stat_show_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
          "lines": "289-295",
          "snippet": "static int branch_stat_show_normal(struct seq_file *m,\n\t\t\t\t   struct ftrace_branch_data *p, const char *f)\n{\n\tseq_printf(m, \"%8lu %8lu \",  p->correct, p->incorrect);\n\tbranch_stat_show(m, p, f);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace_stat.h\"",
            "#include \"trace.h\"",
            "#include <asm/local.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic int branch_stat_show_normal(struct seq_file *m,\n\t\t\t\t   struct ftrace_branch_data *p, const char *f)\n{\n\tseq_printf(m, \"%8lu %8lu \",  p->correct, p->incorrect);\n\tbranch_stat_show(m, p, f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "branch_stat_process_file",
          "args": [
            "p"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "branch_stat_process_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
          "lines": "260-269",
          "snippet": "static const char *branch_stat_process_file(struct ftrace_branch_data *p)\n{\n\tconst char *f;\n\n\t/* Only print the file, not the path */\n\tf = p->file + strlen(p->file);\n\twhile (f >= p->file && *f != '/')\n\t\tf--;\n\treturn ++f;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace_stat.h\"",
            "#include \"trace.h\"",
            "#include <asm/local.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic const char *branch_stat_process_file(struct ftrace_branch_data *p)\n{\n\tconst char *f;\n\n\t/* Only print the file, not the path */\n\tf = p->file + strlen(p->file);\n\twhile (f >= p->file && *f != '/')\n\t\tf--;\n\treturn ++f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic int all_branch_stat_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_branch_data *p = v;\n\tconst char *f;\n\n\tf = branch_stat_process_file(p);\n\treturn branch_stat_show_normal(m, p, f);\n}"
  },
  {
    "function_name": "all_branch_stat_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "412-423",
    "snippet": "static void *\nall_branch_stat_next(void *v, int idx)\n{\n\tstruct ftrace_branch_data *p = v;\n\n\t++p;\n\n\tif ((void *)p >= (void *)__stop_branch_profile)\n\t\treturn NULL;\n\n\treturn p;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic void *\nall_branch_stat_next(void *v, int idx)\n{\n\tstruct ftrace_branch_data *p = v;\n\n\t++p;\n\n\tif ((void *)p >= (void *)__stop_branch_profile)\n\t\treturn NULL;\n\n\treturn p;\n}"
  },
  {
    "function_name": "all_branch_stat_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "407-410",
    "snippet": "static void *all_branch_stat_start(struct tracer_stat *trace)\n{\n\treturn __start_branch_profile;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic void *all_branch_stat_start(struct tracer_stat *trace)\n{\n\treturn __start_branch_profile;\n}"
  },
  {
    "function_name": "all_branch_stat_headers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "396-405",
    "snippet": "static int all_branch_stat_headers(struct seq_file *m)\n{\n\tseq_puts(m, \"   miss      hit    % \"\n\t\t    \"       Function                \"\n\t\t    \"  File              Line\\n\"\n\t\t    \" ------- ---------  - \"\n\t\t    \"       --------                \"\n\t\t    \"  ----              ----\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"   miss      hit    % \"\n\t\t    \"       Function                \"\n\t\t    \"  File              Line\\n\"\n\t\t    \" ------- ---------  - \"\n\t\t    \"       --------                \"\n\t\t    \"  ----              ----\\n\""
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic int all_branch_stat_headers(struct seq_file *m)\n{\n\tseq_puts(m, \"   miss      hit    % \"\n\t\t    \"       Function                \"\n\t\t    \"  File              Line\\n\"\n\t\t    \" ------- ---------  - \"\n\t\t    \"       --------                \"\n\t\t    \"  ----              ----\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "init_annotated_branch_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "377-388",
    "snippet": "__init static int init_annotated_branch_stats(void)\n{\n\tint ret;\n\n\tret = register_stat_tracer(&annotated_branch_stats);\n\tif (!ret) {\n\t\tprintk(KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"annotated branches stats\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tracer_stat annotated_branch_stats = {\n\t.name = \"branch_annotated\",\n\t.stat_start = annotated_branch_stat_start,\n\t.stat_next = annotated_branch_stat_next,\n\t.stat_cmp = annotated_branch_stat_cmp,\n\t.stat_headers = annotated_branch_stat_headers,\n\t.stat_show = annotate_branch_stat_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"annotated branches stats\\n\""
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_stat_tracer",
          "args": [
            "&annotated_branch_stats"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_stat_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "351-364",
          "snippet": "void unregister_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *node, *tmp;\n\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace) {\n\t\t\tlist_del(&node->session_list);\n\t\t\tdestroy_session(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&all_stat_sessions_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(all_stat_sessions);",
            "static DEFINE_MUTEX(all_stat_sessions_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(all_stat_sessions);\nstatic DEFINE_MUTEX(all_stat_sessions_mutex);\n\nvoid unregister_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *node, *tmp;\n\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace) {\n\t\t\tlist_del(&node->session_list);\n\t\t\tdestroy_session(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&all_stat_sessions_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic struct tracer_stat annotated_branch_stats = {\n\t.name = \"branch_annotated\",\n\t.stat_start = annotated_branch_stat_start,\n\t.stat_next = annotated_branch_stat_next,\n\t.stat_cmp = annotated_branch_stat_cmp,\n\t.stat_headers = annotated_branch_stat_headers,\n\t.stat_show = annotate_branch_stat_show\n};\n\n__init static int init_annotated_branch_stats(void)\n{\n\tint ret;\n\n\tret = register_stat_tracer(&annotated_branch_stats);\n\tif (!ret) {\n\t\tprintk(KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"annotated branches stats\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "annotated_branch_stat_cmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "335-366",
    "snippet": "static int annotated_branch_stat_cmp(const void *p1, const void *p2)\n{\n\tconst struct ftrace_branch_data *a = p1;\n\tconst struct ftrace_branch_data *b = p2;\n\n\tlong percent_a, percent_b;\n\n\tpercent_a = get_incorrect_percent(a);\n\tpercent_b = get_incorrect_percent(b);\n\n\tif (percent_a < percent_b)\n\t\treturn -1;\n\tif (percent_a > percent_b)\n\t\treturn 1;\n\n\tif (a->incorrect < b->incorrect)\n\t\treturn -1;\n\tif (a->incorrect > b->incorrect)\n\t\treturn 1;\n\n\t/*\n\t * Since the above shows worse (incorrect) cases\n\t * first, we continue that by showing best (correct)\n\t * cases last.\n\t */\n\tif (a->correct > b->correct)\n\t\treturn -1;\n\tif (a->correct < b->correct)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_incorrect_percent",
          "args": [
            "b"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "get_incorrect_percent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
          "lines": "247-258",
          "snippet": "static inline long get_incorrect_percent(const struct ftrace_branch_data *p)\n{\n\tlong percent;\n\n\tif (p->correct) {\n\t\tpercent = p->incorrect * 100;\n\t\tpercent /= p->correct + p->incorrect;\n\t} else\n\t\tpercent = p->incorrect ? 100 : -1;\n\n\treturn percent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace_stat.h\"",
            "#include \"trace.h\"",
            "#include <asm/local.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic inline long get_incorrect_percent(const struct ftrace_branch_data *p)\n{\n\tlong percent;\n\n\tif (p->correct) {\n\t\tpercent = p->incorrect * 100;\n\t\tpercent /= p->correct + p->incorrect;\n\t} else\n\t\tpercent = p->incorrect ? 100 : -1;\n\n\treturn percent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic int annotated_branch_stat_cmp(const void *p1, const void *p2)\n{\n\tconst struct ftrace_branch_data *a = p1;\n\tconst struct ftrace_branch_data *b = p2;\n\n\tlong percent_a, percent_b;\n\n\tpercent_a = get_incorrect_percent(a);\n\tpercent_b = get_incorrect_percent(b);\n\n\tif (percent_a < percent_b)\n\t\treturn -1;\n\tif (percent_a > percent_b)\n\t\treturn 1;\n\n\tif (a->incorrect < b->incorrect)\n\t\treturn -1;\n\tif (a->incorrect > b->incorrect)\n\t\treturn 1;\n\n\t/*\n\t * Since the above shows worse (incorrect) cases\n\t * first, we continue that by showing best (correct)\n\t * cases last.\n\t */\n\tif (a->correct > b->correct)\n\t\treturn -1;\n\tif (a->correct < b->correct)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "annotated_branch_stat_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "322-333",
    "snippet": "static void *\nannotated_branch_stat_next(void *v, int idx)\n{\n\tstruct ftrace_likely_data *p = v;\n\n\t++p;\n\n\tif ((void *)p >= (void *)__stop_annotated_branch_profile)\n\t\treturn NULL;\n\n\treturn p;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern unsigned long __stop_annotated_branch_profile[];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nextern unsigned long __stop_annotated_branch_profile[];\n\nstatic void *\nannotated_branch_stat_next(void *v, int idx)\n{\n\tstruct ftrace_likely_data *p = v;\n\n\t++p;\n\n\tif ((void *)p >= (void *)__stop_annotated_branch_profile)\n\t\treturn NULL;\n\n\treturn p;\n}"
  },
  {
    "function_name": "annotated_branch_stat_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "317-320",
    "snippet": "static void *annotated_branch_stat_start(struct tracer_stat *trace)\n{\n\treturn __start_annotated_branch_profile;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern unsigned long __start_annotated_branch_profile[];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nextern unsigned long __start_annotated_branch_profile[];\n\nstatic void *annotated_branch_stat_start(struct tracer_stat *trace)\n{\n\treturn __start_annotated_branch_profile;\n}"
  },
  {
    "function_name": "annotate_branch_stat_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "297-315",
    "snippet": "static int annotate_branch_stat_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_likely_data *p = v;\n\tconst char *f;\n\tint l;\n\n\tf = branch_stat_process_file(&p->data);\n\n\tif (!p->constant)\n\t\treturn branch_stat_show_normal(m, &p->data, f);\n\n\tl = snprintf(NULL, 0, \"/%lu\", p->constant);\n\tl = l > 8 ? 0 : 8 - l;\n\n\tseq_printf(m, \"%8lu/%lu %*lu \",\n\t\t   p->data.correct, p->constant, l, p->data.incorrect);\n\tbranch_stat_show(m, &p->data, f);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "branch_stat_show",
          "args": [
            "m",
            "&p->data",
            "f"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "branch_stat_show_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
          "lines": "289-295",
          "snippet": "static int branch_stat_show_normal(struct seq_file *m,\n\t\t\t\t   struct ftrace_branch_data *p, const char *f)\n{\n\tseq_printf(m, \"%8lu %8lu \",  p->correct, p->incorrect);\n\tbranch_stat_show(m, p, f);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace_stat.h\"",
            "#include \"trace.h\"",
            "#include <asm/local.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic int branch_stat_show_normal(struct seq_file *m,\n\t\t\t\t   struct ftrace_branch_data *p, const char *f)\n{\n\tseq_printf(m, \"%8lu %8lu \",  p->correct, p->incorrect);\n\tbranch_stat_show(m, p, f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%8lu/%lu %*lu \"",
            "p->data.correct",
            "p->constant",
            "l",
            "p->data.incorrect"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "NULL",
            "0",
            "\"/%lu\"",
            "p->constant"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "branch_stat_process_file",
          "args": [
            "&p->data"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "branch_stat_process_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
          "lines": "260-269",
          "snippet": "static const char *branch_stat_process_file(struct ftrace_branch_data *p)\n{\n\tconst char *f;\n\n\t/* Only print the file, not the path */\n\tf = p->file + strlen(p->file);\n\twhile (f >= p->file && *f != '/')\n\t\tf--;\n\treturn ++f;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace_stat.h\"",
            "#include \"trace.h\"",
            "#include <asm/local.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic const char *branch_stat_process_file(struct ftrace_branch_data *p)\n{\n\tconst char *f;\n\n\t/* Only print the file, not the path */\n\tf = p->file + strlen(p->file);\n\twhile (f >= p->file && *f != '/')\n\t\tf--;\n\treturn ++f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic int annotate_branch_stat_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_likely_data *p = v;\n\tconst char *f;\n\tint l;\n\n\tf = branch_stat_process_file(&p->data);\n\n\tif (!p->constant)\n\t\treturn branch_stat_show_normal(m, &p->data, f);\n\n\tl = snprintf(NULL, 0, \"/%lu\", p->constant);\n\tl = l > 8 ? 0 : 8 - l;\n\n\tseq_printf(m, \"%8lu/%lu %*lu \",\n\t\t   p->data.correct, p->constant, l, p->data.incorrect);\n\tbranch_stat_show(m, &p->data, f);\n\treturn 0;\n}"
  },
  {
    "function_name": "branch_stat_show_normal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "289-295",
    "snippet": "static int branch_stat_show_normal(struct seq_file *m,\n\t\t\t\t   struct ftrace_branch_data *p, const char *f)\n{\n\tseq_printf(m, \"%8lu %8lu \",  p->correct, p->incorrect);\n\tbranch_stat_show(m, p, f);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "branch_stat_show",
          "args": [
            "m",
            "p",
            "f"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "branch_stat_show_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
          "lines": "289-295",
          "snippet": "static int branch_stat_show_normal(struct seq_file *m,\n\t\t\t\t   struct ftrace_branch_data *p, const char *f)\n{\n\tseq_printf(m, \"%8lu %8lu \",  p->correct, p->incorrect);\n\tbranch_stat_show(m, p, f);\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%8lu %8lu \"",
            "p->correct",
            "p->incorrect"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic int branch_stat_show_normal(struct seq_file *m,\n\t\t\t\t   struct ftrace_branch_data *p, const char *f)\n{\n\tseq_printf(m, \"%8lu %8lu \",  p->correct, p->incorrect);\n\tbranch_stat_show(m, p, f);\n\treturn 0;\n}"
  },
  {
    "function_name": "branch_stat_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "271-287",
    "snippet": "static void branch_stat_show(struct seq_file *m,\n\t\t\t     struct ftrace_branch_data *p, const char *f)\n{\n\tlong percent;\n\n\t/*\n\t * The miss is overlayed on correct, and hit on incorrect.\n\t */\n\tpercent = get_incorrect_percent(p);\n\n\tif (percent < 0)\n\t\tseq_puts(m, \"  X \");\n\telse\n\t\tseq_printf(m, \"%3ld \", percent);\n\n\tseq_printf(m, \"%-30.30s %-20.20s %d\\n\", p->func, f, p->line);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%-30.30s %-20.20s %d\\n\"",
            "p->func",
            "f",
            "p->line"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"  X \""
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_incorrect_percent",
          "args": [
            "p"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "get_incorrect_percent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
          "lines": "247-258",
          "snippet": "static inline long get_incorrect_percent(const struct ftrace_branch_data *p)\n{\n\tlong percent;\n\n\tif (p->correct) {\n\t\tpercent = p->incorrect * 100;\n\t\tpercent /= p->correct + p->incorrect;\n\t} else\n\t\tpercent = p->incorrect ? 100 : -1;\n\n\treturn percent;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace_stat.h\"",
            "#include \"trace.h\"",
            "#include <asm/local.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic inline long get_incorrect_percent(const struct ftrace_branch_data *p)\n{\n\tlong percent;\n\n\tif (p->correct) {\n\t\tpercent = p->incorrect * 100;\n\t\tpercent /= p->correct + p->incorrect;\n\t} else\n\t\tpercent = p->incorrect ? 100 : -1;\n\n\treturn percent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic void branch_stat_show(struct seq_file *m,\n\t\t\t     struct ftrace_branch_data *p, const char *f)\n{\n\tlong percent;\n\n\t/*\n\t * The miss is overlayed on correct, and hit on incorrect.\n\t */\n\tpercent = get_incorrect_percent(p);\n\n\tif (percent < 0)\n\t\tseq_puts(m, \"  X \");\n\telse\n\t\tseq_printf(m, \"%3ld \", percent);\n\n\tseq_printf(m, \"%-30.30s %-20.20s %d\\n\", p->func, f, p->line);\n}"
  },
  {
    "function_name": "branch_stat_process_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "260-269",
    "snippet": "static const char *branch_stat_process_file(struct ftrace_branch_data *p)\n{\n\tconst char *f;\n\n\t/* Only print the file, not the path */\n\tf = p->file + strlen(p->file);\n\twhile (f >= p->file && *f != '/')\n\t\tf--;\n\treturn ++f;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p->file"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic const char *branch_stat_process_file(struct ftrace_branch_data *p)\n{\n\tconst char *f;\n\n\t/* Only print the file, not the path */\n\tf = p->file + strlen(p->file);\n\twhile (f >= p->file && *f != '/')\n\t\tf--;\n\treturn ++f;\n}"
  },
  {
    "function_name": "get_incorrect_percent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "247-258",
    "snippet": "static inline long get_incorrect_percent(const struct ftrace_branch_data *p)\n{\n\tlong percent;\n\n\tif (p->correct) {\n\t\tpercent = p->incorrect * 100;\n\t\tpercent /= p->correct + p->incorrect;\n\t} else\n\t\tpercent = p->incorrect ? 100 : -1;\n\n\treturn percent;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic inline long get_incorrect_percent(const struct ftrace_branch_data *p)\n{\n\tlong percent;\n\n\tif (p->correct) {\n\t\tpercent = p->incorrect * 100;\n\t\tpercent /= p->correct + p->incorrect;\n\t} else\n\t\tpercent = p->incorrect ? 100 : -1;\n\n\treturn percent;\n}"
  },
  {
    "function_name": "annotated_branch_stat_headers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "236-245",
    "snippet": "static int annotated_branch_stat_headers(struct seq_file *m)\n{\n\tseq_puts(m, \" correct incorrect  % \"\n\t\t    \"       Function                \"\n\t\t    \"  File              Line\\n\"\n\t\t    \" ------- ---------  - \"\n\t\t    \"       --------                \"\n\t\t    \"  ----              ----\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" correct incorrect  % \"\n\t\t    \"       Function                \"\n\t\t    \"  File              Line\\n\"\n\t\t    \" ------- ---------  - \"\n\t\t    \"       --------                \"\n\t\t    \"  ----              ----\\n\""
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic int annotated_branch_stat_headers(struct seq_file *m)\n{\n\tseq_puts(m, \" correct incorrect  % \"\n\t\t    \"       Function                \"\n\t\t    \"  File              Line\\n\"\n\t\t    \" ------- ---------  - \"\n\t\t    \"       --------                \"\n\t\t    \"  ----              ----\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_likely_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "205-230",
    "snippet": "void ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant)\n{\n\tunsigned long flags = user_access_save();\n\n\t/* A constant is always correct */\n\tif (is_constant) {\n\t\tf->constant++;\n\t\tval = expect;\n\t}\n\t/*\n\t * I would love to have a trace point here instead, but the\n\t * trace point code is so inundated with unlikely and likely\n\t * conditions that the recursive nightmare that exists is too\n\t * much to try to get working. At least for now.\n\t */\n\ttrace_likely_condition(f, val, expect);\n\n\t/* FIXME: Make this atomic! */\n\tif (val == expect)\n\t\tf->data.correct++;\n\telse\n\t\tf->data.incorrect++;\n\n\tuser_access_restore(flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_access_restore",
          "args": [
            "flags"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_likely_condition",
          "args": [
            "f",
            "val",
            "expect"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "trace_likely_condition",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
          "lines": "199-202",
          "snippet": "static inline\nvoid trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace_stat.h\"",
            "#include \"trace.h\"",
            "#include <asm/local.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic inline\nvoid trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_access_save",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant)\n{\n\tunsigned long flags = user_access_save();\n\n\t/* A constant is always correct */\n\tif (is_constant) {\n\t\tf->constant++;\n\t\tval = expect;\n\t}\n\t/*\n\t * I would love to have a trace point here instead, but the\n\t * trace point code is so inundated with unlikely and likely\n\t * conditions that the recursive nightmare that exists is too\n\t * much to try to get working. At least for now.\n\t */\n\ttrace_likely_condition(f, val, expect);\n\n\t/* FIXME: Make this atomic! */\n\tif (val == expect)\n\t\tf->data.correct++;\n\telse\n\t\tf->data.incorrect++;\n\n\tuser_access_restore(flags);\n}"
  },
  {
    "function_name": "trace_likely_condition",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "199-202",
    "snippet": "static inline\nvoid trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic inline\nvoid trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n}"
  },
  {
    "function_name": "init_branch_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "184-195",
    "snippet": "__init static int init_branch_tracer(void)\n{\n\tint ret;\n\n\tret = register_trace_event(&trace_branch_event);\n\tif (!ret) {\n\t\tprintk(KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"branch events\\n\");\n\t\treturn 1;\n\t}\n\treturn register_tracer(&branch_trace);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&branch_trace"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2037-2120",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"branch events\\n\""
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trace_event",
          "args": [
            "&trace_branch_event"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "826-833",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\n__init static int init_branch_tracer(void)\n{\n\tint ret;\n\n\tret = register_trace_event(&trace_branch_event);\n\tif (!ret) {\n\t\tprintk(KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"branch events\\n\");\n\t\treturn 1;\n\t}\n\treturn register_tracer(&branch_trace);\n}"
  },
  {
    "function_name": "branch_print_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "156-162",
    "snippet": "static void branch_print_header(struct seq_file *s)\n{\n\tseq_puts(s, \"#           TASK-PID    CPU#    TIMESTAMP  CORRECT\"\n\t\t    \"  FUNC:FILE:LINE\\n\"\n\t\t    \"#              | |       |          |         |   \"\n\t\t    \"    |\\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"#           TASK-PID    CPU#    TIMESTAMP  CORRECT\"\n\t\t    \"  FUNC:FILE:LINE\\n\"\n\t\t    \"#              | |       |          |         |   \"\n\t\t    \"    |\\n\""
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic void branch_print_header(struct seq_file *s)\n{\n\tseq_puts(s, \"#           TASK-PID    CPU#    TIMESTAMP  CORRECT\"\n\t\t    \"  FUNC:FILE:LINE\\n\"\n\t\t    \"#              | |       |          |         |   \"\n\t\t    \"    |\\n\");\n}"
  },
  {
    "function_name": "trace_branch_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "140-154",
    "snippet": "static enum print_line_t trace_branch_print(struct trace_iterator *iter,\n\t\t\t\t\t    int flags, struct trace_event *event)\n{\n\tstruct trace_branch *field;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"[%s] %s:%s:%d\\n\",\n\t\t\t field->correct ? \"  ok  \" : \" MISS \",\n\t\t\t field->func,\n\t\t\t field->file,\n\t\t\t field->line);\n\n\treturn trace_handle_return(&iter->seq);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "&iter->seq"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "&iter->seq",
            "\"[%s] %s:%s:%d\\n\"",
            "field->correct ? \"  ok  \" : \" MISS \"",
            "field->func",
            "field->file",
            "field->line"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "iter->ent"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic enum print_line_t trace_branch_print(struct trace_iterator *iter,\n\t\t\t\t\t    int flags, struct trace_event *event)\n{\n\tstruct trace_branch *field;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"[%s] %s:%s:%d\\n\",\n\t\t\t field->correct ? \"  ok  \" : \" MISS \",\n\t\t\t field->func,\n\t\t\t field->file,\n\t\t\t field->line);\n\n\treturn trace_handle_return(&iter->seq);\n}"
  },
  {
    "function_name": "branch_trace_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "135-138",
    "snippet": "static void branch_trace_reset(struct trace_array *tr)\n{\n\tdisable_branch_tracing();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_branch_tracing",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "disable_branch_tracing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
          "lines": "117-128",
          "snippet": "void disable_branch_tracing(void)\n{\n\tmutex_lock(&branch_tracing_mutex);\n\n\tif (!branch_tracing_enabled)\n\t\tgoto out_unlock;\n\n\tbranch_tracing_enabled--;\n\n out_unlock:\n\tmutex_unlock(&branch_tracing_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace_stat.h\"",
            "#include \"trace.h\"",
            "#include <asm/local.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nvoid disable_branch_tracing(void)\n{\n\tmutex_lock(&branch_tracing_mutex);\n\n\tif (!branch_tracing_enabled)\n\t\tgoto out_unlock;\n\n\tbranch_tracing_enabled--;\n\n out_unlock:\n\tmutex_unlock(&branch_tracing_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic void branch_trace_reset(struct trace_array *tr)\n{\n\tdisable_branch_tracing();\n}"
  },
  {
    "function_name": "branch_trace_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "130-133",
    "snippet": "static int branch_trace_init(struct trace_array *tr)\n{\n\treturn enable_branch_tracing(tr);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_branch_tracing",
          "args": [
            "tr"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "enable_branch_tracing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
          "lines": "102-115",
          "snippet": "int enable_branch_tracing(struct trace_array *tr)\n{\n\tmutex_lock(&branch_tracing_mutex);\n\tbranch_tracer = tr;\n\t/*\n\t * Must be seen before enabling. The reader is a condition\n\t * where we do not need a matching rmb()\n\t */\n\tsmp_wmb();\n\tbranch_tracing_enabled++;\n\tmutex_unlock(&branch_tracing_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace_stat.h\"",
            "#include \"trace.h\"",
            "#include <asm/local.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nint enable_branch_tracing(struct trace_array *tr)\n{\n\tmutex_lock(&branch_tracing_mutex);\n\tbranch_tracer = tr;\n\t/*\n\t * Must be seen before enabling. The reader is a condition\n\t * where we do not need a matching rmb()\n\t */\n\tsmp_wmb();\n\tbranch_tracing_enabled++;\n\tmutex_unlock(&branch_tracing_mutex);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic int branch_trace_init(struct trace_array *tr)\n{\n\treturn enable_branch_tracing(tr);\n}"
  },
  {
    "function_name": "disable_branch_tracing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "117-128",
    "snippet": "void disable_branch_tracing(void)\n{\n\tmutex_lock(&branch_tracing_mutex);\n\n\tif (!branch_tracing_enabled)\n\t\tgoto out_unlock;\n\n\tbranch_tracing_enabled--;\n\n out_unlock:\n\tmutex_unlock(&branch_tracing_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&branch_tracing_mutex"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&branch_tracing_mutex"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nvoid disable_branch_tracing(void)\n{\n\tmutex_lock(&branch_tracing_mutex);\n\n\tif (!branch_tracing_enabled)\n\t\tgoto out_unlock;\n\n\tbranch_tracing_enabled--;\n\n out_unlock:\n\tmutex_unlock(&branch_tracing_mutex);\n}"
  },
  {
    "function_name": "enable_branch_tracing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "102-115",
    "snippet": "int enable_branch_tracing(struct trace_array *tr)\n{\n\tmutex_lock(&branch_tracing_mutex);\n\tbranch_tracer = tr;\n\t/*\n\t * Must be seen before enabling. The reader is a condition\n\t * where we do not need a matching rmb()\n\t */\n\tsmp_wmb();\n\tbranch_tracing_enabled++;\n\tmutex_unlock(&branch_tracing_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&branch_tracing_mutex"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&branch_tracing_mutex"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nint enable_branch_tracing(struct trace_array *tr)\n{\n\tmutex_lock(&branch_tracing_mutex);\n\tbranch_tracer = tr;\n\t/*\n\t * Must be seen before enabling. The reader is a condition\n\t * where we do not need a matching rmb()\n\t */\n\tsmp_wmb();\n\tbranch_tracing_enabled++;\n\tmutex_unlock(&branch_tracing_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_likely_condition",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "93-100",
    "snippet": "static inline\nvoid trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n\tif (!branch_tracing_enabled)\n\t\treturn;\n\n\tprobe_likely_condition(f, val, expect);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "probe_likely_condition",
          "args": [
            "f",
            "val",
            "expect"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "probe_likely_condition",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
          "lines": "30-91",
          "snippet": "static void\nprobe_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n\tstruct trace_event_call *call = &event_branch;\n\tstruct trace_array *tr = branch_tracer;\n\tstruct trace_buffer *buffer;\n\tstruct trace_array_cpu *data;\n\tstruct ring_buffer_event *event;\n\tstruct trace_branch *entry;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tconst char *p;\n\n\tif (current->trace_recursion & TRACE_BRANCH_BIT)\n\t\treturn;\n\n\t/*\n\t * I would love to save just the ftrace_likely_data pointer, but\n\t * this code can also be used by modules. Ugly things can happen\n\t * if the module is unloaded, and then we go and read the\n\t * pointer.  This is slower, but much safer.\n\t */\n\n\tif (unlikely(!tr))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcurrent->trace_recursion |= TRACE_BRANCH_BIT;\n\tdata = this_cpu_ptr(tr->array_buffer.data);\n\tif (atomic_read(&data->disabled))\n\t\tgoto out;\n\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\tbuffer = tr->array_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_BRANCH,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\tgoto out;\n\n\tentry\t= ring_buffer_event_data(event);\n\n\t/* Strip off the path, only save the file */\n\tp = f->data.file + strlen(f->data.file);\n\twhile (p >= f->data.file && *p != '/')\n\t\tp--;\n\tp++;\n\n\tstrncpy(entry->func, f->data.func, TRACE_FUNC_SIZE);\n\tstrncpy(entry->file, p, TRACE_FILE_SIZE);\n\tentry->func[TRACE_FUNC_SIZE] = 0;\n\tentry->file[TRACE_FILE_SIZE] = 0;\n\tentry->constant = f->constant;\n\tentry->line = f->data.line;\n\tentry->correct = val == expect;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n out:\n\tcurrent->trace_recursion &= ~TRACE_BRANCH_BIT;\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace_stat.h\"",
            "#include \"trace.h\"",
            "#include <asm/local.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic void\nprobe_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n\tstruct trace_event_call *call = &event_branch;\n\tstruct trace_array *tr = branch_tracer;\n\tstruct trace_buffer *buffer;\n\tstruct trace_array_cpu *data;\n\tstruct ring_buffer_event *event;\n\tstruct trace_branch *entry;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tconst char *p;\n\n\tif (current->trace_recursion & TRACE_BRANCH_BIT)\n\t\treturn;\n\n\t/*\n\t * I would love to save just the ftrace_likely_data pointer, but\n\t * this code can also be used by modules. Ugly things can happen\n\t * if the module is unloaded, and then we go and read the\n\t * pointer.  This is slower, but much safer.\n\t */\n\n\tif (unlikely(!tr))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcurrent->trace_recursion |= TRACE_BRANCH_BIT;\n\tdata = this_cpu_ptr(tr->array_buffer.data);\n\tif (atomic_read(&data->disabled))\n\t\tgoto out;\n\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\tbuffer = tr->array_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_BRANCH,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\tgoto out;\n\n\tentry\t= ring_buffer_event_data(event);\n\n\t/* Strip off the path, only save the file */\n\tp = f->data.file + strlen(f->data.file);\n\twhile (p >= f->data.file && *p != '/')\n\t\tp--;\n\tp++;\n\n\tstrncpy(entry->func, f->data.func, TRACE_FUNC_SIZE);\n\tstrncpy(entry->file, p, TRACE_FILE_SIZE);\n\tentry->func[TRACE_FUNC_SIZE] = 0;\n\tentry->file[TRACE_FILE_SIZE] = 0;\n\tentry->constant = f->constant;\n\tentry->line = f->data.line;\n\tentry->correct = val == expect;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n out:\n\tcurrent->trace_recursion &= ~TRACE_BRANCH_BIT;\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic inline\nvoid trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n\tif (!branch_tracing_enabled)\n\t\treturn;\n\n\tprobe_likely_condition(f, val, expect);\n}"
  },
  {
    "function_name": "probe_likely_condition",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_branch.c",
    "lines": "30-91",
    "snippet": "static void\nprobe_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n\tstruct trace_event_call *call = &event_branch;\n\tstruct trace_array *tr = branch_tracer;\n\tstruct trace_buffer *buffer;\n\tstruct trace_array_cpu *data;\n\tstruct ring_buffer_event *event;\n\tstruct trace_branch *entry;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tconst char *p;\n\n\tif (current->trace_recursion & TRACE_BRANCH_BIT)\n\t\treturn;\n\n\t/*\n\t * I would love to save just the ftrace_likely_data pointer, but\n\t * this code can also be used by modules. Ugly things can happen\n\t * if the module is unloaded, and then we go and read the\n\t * pointer.  This is slower, but much safer.\n\t */\n\n\tif (unlikely(!tr))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcurrent->trace_recursion |= TRACE_BRANCH_BIT;\n\tdata = this_cpu_ptr(tr->array_buffer.data);\n\tif (atomic_read(&data->disabled))\n\t\tgoto out;\n\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\tbuffer = tr->array_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_BRANCH,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\tgoto out;\n\n\tentry\t= ring_buffer_event_data(event);\n\n\t/* Strip off the path, only save the file */\n\tp = f->data.file + strlen(f->data.file);\n\twhile (p >= f->data.file && *p != '/')\n\t\tp--;\n\tp++;\n\n\tstrncpy(entry->func, f->data.func, TRACE_FUNC_SIZE);\n\tstrncpy(entry->file, p, TRACE_FILE_SIZE);\n\tentry->func[TRACE_FUNC_SIZE] = 0;\n\tentry->file[TRACE_FILE_SIZE] = 0;\n\tentry->constant = f->constant;\n\tentry->line = f->data.line;\n\tentry->correct = val == expect;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n out:\n\tcurrent->trace_recursion &= ~TRACE_BRANCH_BIT;\n\traw_local_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace_stat.h\"",
      "#include \"trace.h\"",
      "#include <asm/local.h>",
      "#include <linux/fs.h>",
      "#include <linux/hash.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit_nostack",
          "args": [
            "buffer",
            "event"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit_nostack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2948-2953",
          "snippet": "void\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "502-513",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "entry->file",
            "p",
            "TRACE_FILE_SIZE"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "entry->func",
            "f->data.func",
            "TRACE_FUNC_SIZE"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "f->data.file"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_BRANCH",
            "sizeof(*entry)",
            "trace_ctx"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "flags"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->disabled"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "tr->array_buffer.data"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tr"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace_stat.h\"\n#include \"trace.h\"\n#include <asm/local.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic void\nprobe_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n\tstruct trace_event_call *call = &event_branch;\n\tstruct trace_array *tr = branch_tracer;\n\tstruct trace_buffer *buffer;\n\tstruct trace_array_cpu *data;\n\tstruct ring_buffer_event *event;\n\tstruct trace_branch *entry;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tconst char *p;\n\n\tif (current->trace_recursion & TRACE_BRANCH_BIT)\n\t\treturn;\n\n\t/*\n\t * I would love to save just the ftrace_likely_data pointer, but\n\t * this code can also be used by modules. Ugly things can happen\n\t * if the module is unloaded, and then we go and read the\n\t * pointer.  This is slower, but much safer.\n\t */\n\n\tif (unlikely(!tr))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcurrent->trace_recursion |= TRACE_BRANCH_BIT;\n\tdata = this_cpu_ptr(tr->array_buffer.data);\n\tif (atomic_read(&data->disabled))\n\t\tgoto out;\n\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\tbuffer = tr->array_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_BRANCH,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\tgoto out;\n\n\tentry\t= ring_buffer_event_data(event);\n\n\t/* Strip off the path, only save the file */\n\tp = f->data.file + strlen(f->data.file);\n\twhile (p >= f->data.file && *p != '/')\n\t\tp--;\n\tp++;\n\n\tstrncpy(entry->func, f->data.func, TRACE_FUNC_SIZE);\n\tstrncpy(entry->file, p, TRACE_FILE_SIZE);\n\tentry->func[TRACE_FUNC_SIZE] = 0;\n\tentry->file[TRACE_FILE_SIZE] = 0;\n\tentry->constant = f->constant;\n\tentry->line = f->data.line;\n\tentry->correct = val == expect;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n out:\n\tcurrent->trace_recursion &= ~TRACE_BRANCH_BIT;\n\traw_local_irq_restore(flags);\n}"
  }
]