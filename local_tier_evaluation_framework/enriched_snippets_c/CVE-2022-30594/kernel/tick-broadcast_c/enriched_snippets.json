[
  {
    "function_name": "tick_broadcast_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "1145-1155",
    "snippet": "void __init tick_broadcast_init(void)\n{\n\tzalloc_cpumask_var(&tick_broadcast_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_on, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tmpmask, GFP_NOWAIT);\n#ifdef CONFIG_TICK_ONESHOT\n\tzalloc_cpumask_var(&tick_broadcast_oneshot_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_pending_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_force_mask, GFP_NOWAIT);\n#endif\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t tick_broadcast_mask",
      "static cpumask_var_t tick_broadcast_on"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tick_broadcast_force_mask",
            "GFP_NOWAIT"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tick_broadcast_pending_mask",
            "GFP_NOWAIT"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tick_broadcast_oneshot_mask",
            "GFP_NOWAIT"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tmpmask",
            "GFP_NOWAIT"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tick_broadcast_on",
            "GFP_NOWAIT"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tick_broadcast_mask",
            "GFP_NOWAIT"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\nstatic cpumask_var_t tick_broadcast_on;\n\nvoid __init tick_broadcast_init(void)\n{\n\tzalloc_cpumask_var(&tick_broadcast_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_on, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tmpmask, GFP_NOWAIT);\n#ifdef CONFIG_TICK_ONESHOT\n\tzalloc_cpumask_var(&tick_broadcast_oneshot_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_pending_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_force_mask, GFP_NOWAIT);\n#endif\n}"
  },
  {
    "function_name": "__tick_broadcast_oneshot_control",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "1134-1142",
    "snippet": "int __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (!bc || (bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (!bc || (bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tick_broadcast_oneshot_available",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "1126-1131",
    "snippet": "bool tick_broadcast_oneshot_available(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\treturn bc ? bc->features & CLOCK_EVT_FEAT_ONESHOT : false;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nbool tick_broadcast_oneshot_available(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\treturn bc ? bc->features & CLOCK_EVT_FEAT_ONESHOT : false;\n}"
  },
  {
    "function_name": "tick_broadcast_oneshot_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "1118-1121",
    "snippet": "int tick_broadcast_oneshot_active(void)\n{\n\treturn tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_broadcast_oneshot_active(void)\n{\n\treturn tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;\n}"
  },
  {
    "function_name": "tick_broadcast_oneshot_offline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "1100-1112",
    "snippet": "static void tick_broadcast_oneshot_offline(unsigned int cpu)\n{\n\tif (tick_get_oneshot_wakeup_device(cpu))\n\t\ttick_set_oneshot_wakeup_device(NULL, cpu);\n\n\t/*\n\t * Clear the broadcast masks for the dead cpu, but do not stop\n\t * the broadcast device!\n\t */\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_force_mask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_force_mask"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_pending_mask"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_set_oneshot_wakeup_device",
          "args": [
            "NULL",
            "cpu"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "tick_set_oneshot_wakeup_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "152-156",
          "snippet": "static bool tick_set_oneshot_wakeup_device(struct clock_event_device *newdev,\n\t\t\t\t\t   int cpu)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic bool tick_set_oneshot_wakeup_device(struct clock_event_device *newdev,\n\t\t\t\t\t   int cpu)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_get_oneshot_wakeup_device",
          "args": [
            "cpu"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_oneshot_wakeup_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "147-150",
          "snippet": "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_oneshot_offline(unsigned int cpu)\n{\n\tif (tick_get_oneshot_wakeup_device(cpu))\n\t\ttick_set_oneshot_wakeup_device(NULL, cpu);\n\n\t/*\n\t * Clear the broadcast masks for the dead cpu, but do not stop\n\t * the broadcast device!\n\t */\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_force_mask);\n}"
  },
  {
    "function_name": "hotplug_cpu__broadcast_tick_pull",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "1082-1095",
    "snippet": "void hotplug_cpu__broadcast_tick_pull(int deadcpu)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc && broadcast_needs_cpu(bc, deadcpu)) {\n\t\t/* This moves the broadcast assignment to this CPU: */\n\t\tclockevents_program_event(bc, bc->next_event, 1);\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "bc",
            "bc->next_event",
            "1"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "303-337",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "broadcast_needs_cpu",
          "args": [
            "bc",
            "deadcpu"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "broadcast_needs_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "765-772",
          "snippet": "static int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid hotplug_cpu__broadcast_tick_pull(int deadcpu)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc && broadcast_needs_cpu(bc, deadcpu)) {\n\t\t/* This moves the broadcast assignment to this CPU: */\n\t\tclockevents_program_event(bc, bc->next_event, 1);\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "tick_broadcast_switch_to_oneshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "1066-1079",
    "snippet": "void tick_broadcast_switch_to_oneshot(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\ttick_broadcast_device.mode = TICKDEV_MODE_ONESHOT;\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\ttick_broadcast_setup_oneshot(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_setup_oneshot",
          "args": [
            "bc"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_setup_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "1019-1061",
          "snippet": "static void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tktime_t nextevt = tick_get_next_period();\n\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask, nextevt);\n\t\t\ttick_broadcast_set_event(bc, cpu, nextevt);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t tick_broadcast_mask",
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tktime_t nextevt = tick_get_next_period();\n\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask, nextevt);\n\t\t\ttick_broadcast_set_event(bc, cpu, nextevt);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_broadcast_switch_to_oneshot(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\ttick_broadcast_device.mode = TICKDEV_MODE_ONESHOT;\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\ttick_broadcast_setup_oneshot(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "tick_broadcast_setup_oneshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "1019-1061",
    "snippet": "static void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tktime_t nextevt = tick_get_next_period();\n\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask, nextevt);\n\t\t\ttick_broadcast_set_event(bc, cpu, nextevt);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t tick_broadcast_mask",
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_broadcast_clear_oneshot",
          "args": [
            "cpu"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_clear_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "981-985",
          "snippet": "static void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_set_event",
          "args": [
            "bc",
            "cpu",
            "nextevt"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_set_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "646-654",
          "snippet": "static void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_init_next_event",
          "args": [
            "tmpmask",
            "nextevt"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_init_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "987-998",
          "snippet": "static void tick_broadcast_init_next_event(struct cpumask *mask,\n\t\t\t\t\t   ktime_t expires)\n{\n\tstruct tick_device *td;\n\tint cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev)\n\t\t\ttd->evtdev->next_event = expires;\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_init_next_event(struct cpumask *mask,\n\t\t\t\t\t   ktime_t expires)\n{\n\tstruct tick_device *td;\n\tint cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev)\n\t\t\ttd->evtdev->next_event = expires;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "bc",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "147-165",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_get_next_period",
          "args": [],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_next_period",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "1000-1014",
          "snippet": "static inline ktime_t tick_get_next_period(void)\n{\n\tktime_t next;\n\n\t/*\n\t * Protect against concurrent updates (store /load tearing on\n\t * 32bit). It does not matter if the time is already in the\n\t * past. The broadcast device which is about to be programmed will\n\t * fire in any case.\n\t */\n\traw_spin_lock(&jiffies_lock);\n\tnext = tick_next_period;\n\traw_spin_unlock(&jiffies_lock);\n\treturn next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t tick_get_next_period(void)\n{\n\tktime_t next;\n\n\t/*\n\t * Protect against concurrent updates (store /load tearing on\n\t * 32bit). It does not matter if the time is already in the\n\t * past. The broadcast device which is about to be programmed will\n\t * fire in any case.\n\t */\n\traw_spin_lock(&jiffies_lock);\n\tnext = tick_next_period;\n\traw_spin_unlock(&jiffies_lock);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tmpmask"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "tick_broadcast_oneshot_mask",
            "tick_broadcast_oneshot_mask",
            "tmpmask"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tmpmask"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "tmpmask",
            "tick_broadcast_mask"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_periodic",
          "args": [
            "bc"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tktime_t nextevt = tick_get_next_period();\n\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask, nextevt);\n\t\t\ttick_broadcast_set_event(bc, cpu, nextevt);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}"
  },
  {
    "function_name": "tick_get_next_period",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "1000-1014",
    "snippet": "static inline ktime_t tick_get_next_period(void)\n{\n\tktime_t next;\n\n\t/*\n\t * Protect against concurrent updates (store /load tearing on\n\t * 32bit). It does not matter if the time is already in the\n\t * past. The broadcast device which is about to be programmed will\n\t * fire in any case.\n\t */\n\traw_spin_lock(&jiffies_lock);\n\tnext = tick_next_period;\n\traw_spin_unlock(&jiffies_lock);\n\treturn next;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t tick_get_next_period(void)\n{\n\tktime_t next;\n\n\t/*\n\t * Protect against concurrent updates (store /load tearing on\n\t * 32bit). It does not matter if the time is already in the\n\t * past. The broadcast device which is about to be programmed will\n\t * fire in any case.\n\t */\n\traw_spin_lock(&jiffies_lock);\n\tnext = tick_next_period;\n\traw_spin_unlock(&jiffies_lock);\n\treturn next;\n}"
  },
  {
    "function_name": "tick_broadcast_init_next_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "987-998",
    "snippet": "static void tick_broadcast_init_next_event(struct cpumask *mask,\n\t\t\t\t\t   ktime_t expires)\n{\n\tstruct tick_device *td;\n\tint cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev)\n\t\t\ttd->evtdev->next_event = expires;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_init_next_event(struct cpumask *mask,\n\t\t\t\t\t   ktime_t expires)\n{\n\tstruct tick_device *td;\n\tint cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev)\n\t\t\ttd->evtdev->next_event = expires;\n\t}\n}"
  },
  {
    "function_name": "tick_broadcast_clear_oneshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "981-985",
    "snippet": "static void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_pending_mask"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}"
  },
  {
    "function_name": "__tick_broadcast_oneshot_control",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "958-974",
    "snippet": "int __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tif (!tick_oneshot_wakeup_control(state, td, cpu))\n\t\treturn 0;\n\n\tif (tick_broadcast_device.evtdev)\n\t\treturn ___tick_broadcast_oneshot_control(state, td, cpu);\n\n\t/*\n\t * If there is no broadcast or wakeup device, tell the caller not\n\t * to go into deep idle.\n\t */\n\treturn -EBUSY;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "___tick_broadcast_oneshot_control",
          "args": [
            "state",
            "td",
            "cpu"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "___tick_broadcast_oneshot_control",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "791-927",
          "snippet": "static int ___tick_broadcast_oneshot_control(enum tick_broadcast_state state,\n\t\t\t\t\t     struct tick_device *td,\n\t\t\t\t\t     int cpu)\n{\n\tstruct clock_event_device *bc, *dev = td->evtdev;\n\tint ret = 0;\n\tktime_t now;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (state == TICK_BROADCAST_ENTER) {\n\t\t/*\n\t\t * If the current CPU owns the hrtimer broadcast\n\t\t * mechanism, it cannot go deep idle and we do not add\n\t\t * the CPU to the broadcast mask. We don't have to go\n\t\t * through the EXIT path as the local timer is not\n\t\t * shutdown.\n\t\t */\n\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * If the broadcast device is in periodic mode, we\n\t\t * return.\n\t\t */\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\t\t/* If it is a hrtimer based broadcast, return busy */\n\t\t\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER)\n\t\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tWARN_ON_ONCE(cpumask_test_cpu(cpu, tick_broadcast_pending_mask));\n\n\t\t\t/* Conditionally shut down the local timer. */\n\t\t\tbroadcast_shutdown_local(bc, dev);\n\n\t\t\t/*\n\t\t\t * We only reprogram the broadcast timer if we\n\t\t\t * did not mark ourself in the force mask and\n\t\t\t * if the cpu local event is earlier than the\n\t\t\t * broadcast event. If the current CPU is in\n\t\t\t * the force mask, then we are going to be\n\t\t\t * woken by the IPI right away; we return\n\t\t\t * busy, so the CPU does not try to go deep\n\t\t\t * idle.\n\t\t\t */\n\t\t\tif (cpumask_test_cpu(cpu, tick_broadcast_force_mask)) {\n\t\t\t\tret = -EBUSY;\n\t\t\t} else if (dev->next_event < bc->next_event) {\n\t\t\t\ttick_broadcast_set_event(bc, cpu, dev->next_event);\n\t\t\t\t/*\n\t\t\t\t * In case of hrtimer broadcasts the\n\t\t\t\t * programming might have moved the\n\t\t\t\t * timer to this cpu. If yes, remove\n\t\t\t\t * us from the broadcast mask and\n\t\t\t\t * return busy.\n\t\t\t\t */\n\t\t\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcpumask_clear_cpu(cpu,\n\t\t\t\t\t\ttick_broadcast_oneshot_mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t\t\t/*\n\t\t\t * The cpu which was handling the broadcast\n\t\t\t * timer marked this cpu in the broadcast\n\t\t\t * pending mask and fired the broadcast\n\t\t\t * IPI. So we are going to handle the expired\n\t\t\t * event anyway via the broadcast IPI\n\t\t\t * handler. No need to reprogram the timer\n\t\t\t * with an already expired event.\n\t\t\t */\n\t\t\tif (cpumask_test_and_clear_cpu(cpu,\n\t\t\t\t       tick_broadcast_pending_mask))\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Bail out if there is no next event.\n\t\t\t */\n\t\t\tif (dev->next_event == KTIME_MAX)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * If the pending bit is not set, then we are\n\t\t\t * either the CPU handling the broadcast\n\t\t\t * interrupt or we got woken by something else.\n\t\t\t *\n\t\t\t * We are no longer in the broadcast mask, so\n\t\t\t * if the cpu local expiry time is already\n\t\t\t * reached, we would reprogram the cpu local\n\t\t\t * timer with an already expired event.\n\t\t\t *\n\t\t\t * This can lead to a ping-pong when we return\n\t\t\t * to idle and therefore rearm the broadcast\n\t\t\t * timer before the cpu local timer was able\n\t\t\t * to fire. This happens because the forced\n\t\t\t * reprogramming makes sure that the event\n\t\t\t * will happen in the future and depending on\n\t\t\t * the min_delta setting this might be far\n\t\t\t * enough out that the ping-pong starts.\n\t\t\t *\n\t\t\t * If the cpu local next_event has expired\n\t\t\t * then we know that the broadcast timer\n\t\t\t * next_event has expired as well and\n\t\t\t * broadcast is about to be handled. So we\n\t\t\t * avoid reprogramming and enforce that the\n\t\t\t * broadcast handler, which did not run yet,\n\t\t\t * will invoke the cpu local handler.\n\t\t\t *\n\t\t\t * We cannot call the handler directly from\n\t\t\t * here, because we might be in a NOHZ phase\n\t\t\t * and we did not go through the irq_enter()\n\t\t\t * nohz fixups.\n\t\t\t */\n\t\t\tnow = ktime_get();\n\t\t\tif (dev->next_event <= now) {\n\t\t\t\tcpumask_set_cpu(cpu, tick_broadcast_force_mask);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We got woken by something else. Reprogram\n\t\t\t * the cpu local timer device.\n\t\t\t */\n\t\t\ttick_program_event(dev->next_event, 1);\n\t\t}\n\t}\nout:\n\traw_spin_unlock(&tick_broadcast_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);",
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic int ___tick_broadcast_oneshot_control(enum tick_broadcast_state state,\n\t\t\t\t\t     struct tick_device *td,\n\t\t\t\t\t     int cpu)\n{\n\tstruct clock_event_device *bc, *dev = td->evtdev;\n\tint ret = 0;\n\tktime_t now;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (state == TICK_BROADCAST_ENTER) {\n\t\t/*\n\t\t * If the current CPU owns the hrtimer broadcast\n\t\t * mechanism, it cannot go deep idle and we do not add\n\t\t * the CPU to the broadcast mask. We don't have to go\n\t\t * through the EXIT path as the local timer is not\n\t\t * shutdown.\n\t\t */\n\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * If the broadcast device is in periodic mode, we\n\t\t * return.\n\t\t */\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\t\t/* If it is a hrtimer based broadcast, return busy */\n\t\t\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER)\n\t\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tWARN_ON_ONCE(cpumask_test_cpu(cpu, tick_broadcast_pending_mask));\n\n\t\t\t/* Conditionally shut down the local timer. */\n\t\t\tbroadcast_shutdown_local(bc, dev);\n\n\t\t\t/*\n\t\t\t * We only reprogram the broadcast timer if we\n\t\t\t * did not mark ourself in the force mask and\n\t\t\t * if the cpu local event is earlier than the\n\t\t\t * broadcast event. If the current CPU is in\n\t\t\t * the force mask, then we are going to be\n\t\t\t * woken by the IPI right away; we return\n\t\t\t * busy, so the CPU does not try to go deep\n\t\t\t * idle.\n\t\t\t */\n\t\t\tif (cpumask_test_cpu(cpu, tick_broadcast_force_mask)) {\n\t\t\t\tret = -EBUSY;\n\t\t\t} else if (dev->next_event < bc->next_event) {\n\t\t\t\ttick_broadcast_set_event(bc, cpu, dev->next_event);\n\t\t\t\t/*\n\t\t\t\t * In case of hrtimer broadcasts the\n\t\t\t\t * programming might have moved the\n\t\t\t\t * timer to this cpu. If yes, remove\n\t\t\t\t * us from the broadcast mask and\n\t\t\t\t * return busy.\n\t\t\t\t */\n\t\t\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcpumask_clear_cpu(cpu,\n\t\t\t\t\t\ttick_broadcast_oneshot_mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t\t\t/*\n\t\t\t * The cpu which was handling the broadcast\n\t\t\t * timer marked this cpu in the broadcast\n\t\t\t * pending mask and fired the broadcast\n\t\t\t * IPI. So we are going to handle the expired\n\t\t\t * event anyway via the broadcast IPI\n\t\t\t * handler. No need to reprogram the timer\n\t\t\t * with an already expired event.\n\t\t\t */\n\t\t\tif (cpumask_test_and_clear_cpu(cpu,\n\t\t\t\t       tick_broadcast_pending_mask))\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Bail out if there is no next event.\n\t\t\t */\n\t\t\tif (dev->next_event == KTIME_MAX)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * If the pending bit is not set, then we are\n\t\t\t * either the CPU handling the broadcast\n\t\t\t * interrupt or we got woken by something else.\n\t\t\t *\n\t\t\t * We are no longer in the broadcast mask, so\n\t\t\t * if the cpu local expiry time is already\n\t\t\t * reached, we would reprogram the cpu local\n\t\t\t * timer with an already expired event.\n\t\t\t *\n\t\t\t * This can lead to a ping-pong when we return\n\t\t\t * to idle and therefore rearm the broadcast\n\t\t\t * timer before the cpu local timer was able\n\t\t\t * to fire. This happens because the forced\n\t\t\t * reprogramming makes sure that the event\n\t\t\t * will happen in the future and depending on\n\t\t\t * the min_delta setting this might be far\n\t\t\t * enough out that the ping-pong starts.\n\t\t\t *\n\t\t\t * If the cpu local next_event has expired\n\t\t\t * then we know that the broadcast timer\n\t\t\t * next_event has expired as well and\n\t\t\t * broadcast is about to be handled. So we\n\t\t\t * avoid reprogramming and enforce that the\n\t\t\t * broadcast handler, which did not run yet,\n\t\t\t * will invoke the cpu local handler.\n\t\t\t *\n\t\t\t * We cannot call the handler directly from\n\t\t\t * here, because we might be in a NOHZ phase\n\t\t\t * and we did not go through the irq_enter()\n\t\t\t * nohz fixups.\n\t\t\t */\n\t\t\tnow = ktime_get();\n\t\t\tif (dev->next_event <= now) {\n\t\t\t\tcpumask_set_cpu(cpu, tick_broadcast_force_mask);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We got woken by something else. Reprogram\n\t\t\t * the cpu local timer device.\n\t\t\t */\n\t\t\ttick_program_event(dev->next_event, 1);\n\t\t}\n\t}\nout:\n\traw_spin_unlock(&tick_broadcast_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_oneshot_wakeup_control",
          "args": [
            "state",
            "td",
            "cpu"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "tick_oneshot_wakeup_control",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "929-956",
          "snippet": "static int tick_oneshot_wakeup_control(enum tick_broadcast_state state,\n\t\t\t\t       struct tick_device *td,\n\t\t\t\t       int cpu)\n{\n\tstruct clock_event_device *dev, *wd;\n\n\tdev = td->evtdev;\n\tif (td->mode != TICKDEV_MODE_ONESHOT)\n\t\treturn -EINVAL;\n\n\twd = tick_get_oneshot_wakeup_device(cpu);\n\tif (!wd)\n\t\treturn -ENODEV;\n\n\tswitch (state) {\n\tcase TICK_BROADCAST_ENTER:\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tclockevents_switch_state(wd, CLOCK_EVT_STATE_ONESHOT);\n\t\tclockevents_program_event(wd, dev->next_event, 1);\n\t\tbreak;\n\tcase TICK_BROADCAST_EXIT:\n\t\t/* We may have transitioned to oneshot mode while idle */\n\t\tif (clockevent_get_state(wd) != CLOCK_EVT_STATE_ONESHOT)\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic int tick_oneshot_wakeup_control(enum tick_broadcast_state state,\n\t\t\t\t       struct tick_device *td,\n\t\t\t\t       int cpu)\n{\n\tstruct clock_event_device *dev, *wd;\n\n\tdev = td->evtdev;\n\tif (td->mode != TICKDEV_MODE_ONESHOT)\n\t\treturn -EINVAL;\n\n\twd = tick_get_oneshot_wakeup_device(cpu);\n\tif (!wd)\n\t\treturn -ENODEV;\n\n\tswitch (state) {\n\tcase TICK_BROADCAST_ENTER:\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tclockevents_switch_state(wd, CLOCK_EVT_STATE_ONESHOT);\n\t\tclockevents_program_event(wd, dev->next_event, 1);\n\t\tbreak;\n\tcase TICK_BROADCAST_EXIT:\n\t\t/* We may have transitioned to oneshot mode while idle */\n\t\tif (clockevent_get_state(wd) != CLOCK_EVT_STATE_ONESHOT)\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nint __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tif (!tick_oneshot_wakeup_control(state, td, cpu))\n\t\treturn 0;\n\n\tif (tick_broadcast_device.evtdev)\n\t\treturn ___tick_broadcast_oneshot_control(state, td, cpu);\n\n\t/*\n\t * If there is no broadcast or wakeup device, tell the caller not\n\t * to go into deep idle.\n\t */\n\treturn -EBUSY;\n}"
  },
  {
    "function_name": "tick_oneshot_wakeup_control",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "929-956",
    "snippet": "static int tick_oneshot_wakeup_control(enum tick_broadcast_state state,\n\t\t\t\t       struct tick_device *td,\n\t\t\t\t       int cpu)\n{\n\tstruct clock_event_device *dev, *wd;\n\n\tdev = td->evtdev;\n\tif (td->mode != TICKDEV_MODE_ONESHOT)\n\t\treturn -EINVAL;\n\n\twd = tick_get_oneshot_wakeup_device(cpu);\n\tif (!wd)\n\t\treturn -ENODEV;\n\n\tswitch (state) {\n\tcase TICK_BROADCAST_ENTER:\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tclockevents_switch_state(wd, CLOCK_EVT_STATE_ONESHOT);\n\t\tclockevents_program_event(wd, dev->next_event, 1);\n\t\tbreak;\n\tcase TICK_BROADCAST_EXIT:\n\t\t/* We may have transitioned to oneshot mode while idle */\n\t\tif (clockevent_get_state(wd) != CLOCK_EVT_STATE_ONESHOT)\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevent_get_state",
          "args": [
            "wd"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_get_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-internal.h",
          "lines": "39-42",
          "snippet": "static inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "wd",
            "dev->next_event",
            "1"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "303-337",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "wd",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "147-165",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_get_oneshot_wakeup_device",
          "args": [
            "cpu"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_oneshot_wakeup_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "147-150",
          "snippet": "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic int tick_oneshot_wakeup_control(enum tick_broadcast_state state,\n\t\t\t\t       struct tick_device *td,\n\t\t\t\t       int cpu)\n{\n\tstruct clock_event_device *dev, *wd;\n\n\tdev = td->evtdev;\n\tif (td->mode != TICKDEV_MODE_ONESHOT)\n\t\treturn -EINVAL;\n\n\twd = tick_get_oneshot_wakeup_device(cpu);\n\tif (!wd)\n\t\treturn -ENODEV;\n\n\tswitch (state) {\n\tcase TICK_BROADCAST_ENTER:\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tclockevents_switch_state(wd, CLOCK_EVT_STATE_ONESHOT);\n\t\tclockevents_program_event(wd, dev->next_event, 1);\n\t\tbreak;\n\tcase TICK_BROADCAST_EXIT:\n\t\t/* We may have transitioned to oneshot mode while idle */\n\t\tif (clockevent_get_state(wd) != CLOCK_EVT_STATE_ONESHOT)\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "___tick_broadcast_oneshot_control",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "791-927",
    "snippet": "static int ___tick_broadcast_oneshot_control(enum tick_broadcast_state state,\n\t\t\t\t\t     struct tick_device *td,\n\t\t\t\t\t     int cpu)\n{\n\tstruct clock_event_device *bc, *dev = td->evtdev;\n\tint ret = 0;\n\tktime_t now;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (state == TICK_BROADCAST_ENTER) {\n\t\t/*\n\t\t * If the current CPU owns the hrtimer broadcast\n\t\t * mechanism, it cannot go deep idle and we do not add\n\t\t * the CPU to the broadcast mask. We don't have to go\n\t\t * through the EXIT path as the local timer is not\n\t\t * shutdown.\n\t\t */\n\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * If the broadcast device is in periodic mode, we\n\t\t * return.\n\t\t */\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\t\t/* If it is a hrtimer based broadcast, return busy */\n\t\t\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER)\n\t\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tWARN_ON_ONCE(cpumask_test_cpu(cpu, tick_broadcast_pending_mask));\n\n\t\t\t/* Conditionally shut down the local timer. */\n\t\t\tbroadcast_shutdown_local(bc, dev);\n\n\t\t\t/*\n\t\t\t * We only reprogram the broadcast timer if we\n\t\t\t * did not mark ourself in the force mask and\n\t\t\t * if the cpu local event is earlier than the\n\t\t\t * broadcast event. If the current CPU is in\n\t\t\t * the force mask, then we are going to be\n\t\t\t * woken by the IPI right away; we return\n\t\t\t * busy, so the CPU does not try to go deep\n\t\t\t * idle.\n\t\t\t */\n\t\t\tif (cpumask_test_cpu(cpu, tick_broadcast_force_mask)) {\n\t\t\t\tret = -EBUSY;\n\t\t\t} else if (dev->next_event < bc->next_event) {\n\t\t\t\ttick_broadcast_set_event(bc, cpu, dev->next_event);\n\t\t\t\t/*\n\t\t\t\t * In case of hrtimer broadcasts the\n\t\t\t\t * programming might have moved the\n\t\t\t\t * timer to this cpu. If yes, remove\n\t\t\t\t * us from the broadcast mask and\n\t\t\t\t * return busy.\n\t\t\t\t */\n\t\t\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcpumask_clear_cpu(cpu,\n\t\t\t\t\t\ttick_broadcast_oneshot_mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t\t\t/*\n\t\t\t * The cpu which was handling the broadcast\n\t\t\t * timer marked this cpu in the broadcast\n\t\t\t * pending mask and fired the broadcast\n\t\t\t * IPI. So we are going to handle the expired\n\t\t\t * event anyway via the broadcast IPI\n\t\t\t * handler. No need to reprogram the timer\n\t\t\t * with an already expired event.\n\t\t\t */\n\t\t\tif (cpumask_test_and_clear_cpu(cpu,\n\t\t\t\t       tick_broadcast_pending_mask))\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Bail out if there is no next event.\n\t\t\t */\n\t\t\tif (dev->next_event == KTIME_MAX)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * If the pending bit is not set, then we are\n\t\t\t * either the CPU handling the broadcast\n\t\t\t * interrupt or we got woken by something else.\n\t\t\t *\n\t\t\t * We are no longer in the broadcast mask, so\n\t\t\t * if the cpu local expiry time is already\n\t\t\t * reached, we would reprogram the cpu local\n\t\t\t * timer with an already expired event.\n\t\t\t *\n\t\t\t * This can lead to a ping-pong when we return\n\t\t\t * to idle and therefore rearm the broadcast\n\t\t\t * timer before the cpu local timer was able\n\t\t\t * to fire. This happens because the forced\n\t\t\t * reprogramming makes sure that the event\n\t\t\t * will happen in the future and depending on\n\t\t\t * the min_delta setting this might be far\n\t\t\t * enough out that the ping-pong starts.\n\t\t\t *\n\t\t\t * If the cpu local next_event has expired\n\t\t\t * then we know that the broadcast timer\n\t\t\t * next_event has expired as well and\n\t\t\t * broadcast is about to be handled. So we\n\t\t\t * avoid reprogramming and enforce that the\n\t\t\t * broadcast handler, which did not run yet,\n\t\t\t * will invoke the cpu local handler.\n\t\t\t *\n\t\t\t * We cannot call the handler directly from\n\t\t\t * here, because we might be in a NOHZ phase\n\t\t\t * and we did not go through the irq_enter()\n\t\t\t * nohz fixups.\n\t\t\t */\n\t\t\tnow = ktime_get();\n\t\t\tif (dev->next_event <= now) {\n\t\t\t\tcpumask_set_cpu(cpu, tick_broadcast_force_mask);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We got woken by something else. Reprogram\n\t\t\t * the cpu local timer device.\n\t\t\t */\n\t\t\ttick_program_event(dev->next_event, 1);\n\t\t}\n\t}\nout:\n\traw_spin_unlock(&tick_broadcast_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);",
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "dev->next_event",
            "1"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "23-45",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_force_mask"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_pending_mask"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "147-165",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "broadcast_needs_cpu",
          "args": [
            "bc",
            "cpu"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "broadcast_needs_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "765-772",
          "snippet": "static int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_set_event",
          "args": [
            "bc",
            "cpu",
            "dev->next_event"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_set_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "646-654",
          "snippet": "static void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "tick_broadcast_force_mask"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "broadcast_shutdown_local",
          "args": [
            "bc",
            "dev"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "broadcast_shutdown_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "774-789",
          "snippet": "static void broadcast_shutdown_local(struct clock_event_device *bc,\n\t\t\t\t     struct clock_event_device *dev)\n{\n\t/*\n\t * For hrtimer based broadcasting we cannot shutdown the cpu\n\t * local device if our own event is the first one to expire or\n\t * if we own the broadcast timer.\n\t */\n\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER) {\n\t\tif (broadcast_needs_cpu(bc, smp_processor_id()))\n\t\t\treturn;\n\t\tif (dev->next_event < bc->next_event)\n\t\t\treturn;\n\t}\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void broadcast_shutdown_local(struct clock_event_device *bc,\n\t\t\t\t     struct clock_event_device *dev)\n{\n\t/*\n\t * For hrtimer based broadcasting we cannot shutdown the cpu\n\t * local device if our own event is the first one to expire or\n\t * if we own the broadcast timer.\n\t */\n\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER) {\n\t\tif (broadcast_needs_cpu(bc, smp_processor_id()))\n\t\t\treturn;\n\t\tif (dev->next_event < bc->next_event)\n\t\t\treturn;\n\t}\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpumask_test_cpu(cpu, tick_broadcast_pending_mask)"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "tick_broadcast_pending_mask"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic int ___tick_broadcast_oneshot_control(enum tick_broadcast_state state,\n\t\t\t\t\t     struct tick_device *td,\n\t\t\t\t\t     int cpu)\n{\n\tstruct clock_event_device *bc, *dev = td->evtdev;\n\tint ret = 0;\n\tktime_t now;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (state == TICK_BROADCAST_ENTER) {\n\t\t/*\n\t\t * If the current CPU owns the hrtimer broadcast\n\t\t * mechanism, it cannot go deep idle and we do not add\n\t\t * the CPU to the broadcast mask. We don't have to go\n\t\t * through the EXIT path as the local timer is not\n\t\t * shutdown.\n\t\t */\n\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * If the broadcast device is in periodic mode, we\n\t\t * return.\n\t\t */\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\t\t/* If it is a hrtimer based broadcast, return busy */\n\t\t\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER)\n\t\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tWARN_ON_ONCE(cpumask_test_cpu(cpu, tick_broadcast_pending_mask));\n\n\t\t\t/* Conditionally shut down the local timer. */\n\t\t\tbroadcast_shutdown_local(bc, dev);\n\n\t\t\t/*\n\t\t\t * We only reprogram the broadcast timer if we\n\t\t\t * did not mark ourself in the force mask and\n\t\t\t * if the cpu local event is earlier than the\n\t\t\t * broadcast event. If the current CPU is in\n\t\t\t * the force mask, then we are going to be\n\t\t\t * woken by the IPI right away; we return\n\t\t\t * busy, so the CPU does not try to go deep\n\t\t\t * idle.\n\t\t\t */\n\t\t\tif (cpumask_test_cpu(cpu, tick_broadcast_force_mask)) {\n\t\t\t\tret = -EBUSY;\n\t\t\t} else if (dev->next_event < bc->next_event) {\n\t\t\t\ttick_broadcast_set_event(bc, cpu, dev->next_event);\n\t\t\t\t/*\n\t\t\t\t * In case of hrtimer broadcasts the\n\t\t\t\t * programming might have moved the\n\t\t\t\t * timer to this cpu. If yes, remove\n\t\t\t\t * us from the broadcast mask and\n\t\t\t\t * return busy.\n\t\t\t\t */\n\t\t\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcpumask_clear_cpu(cpu,\n\t\t\t\t\t\ttick_broadcast_oneshot_mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t\t\t/*\n\t\t\t * The cpu which was handling the broadcast\n\t\t\t * timer marked this cpu in the broadcast\n\t\t\t * pending mask and fired the broadcast\n\t\t\t * IPI. So we are going to handle the expired\n\t\t\t * event anyway via the broadcast IPI\n\t\t\t * handler. No need to reprogram the timer\n\t\t\t * with an already expired event.\n\t\t\t */\n\t\t\tif (cpumask_test_and_clear_cpu(cpu,\n\t\t\t\t       tick_broadcast_pending_mask))\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Bail out if there is no next event.\n\t\t\t */\n\t\t\tif (dev->next_event == KTIME_MAX)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * If the pending bit is not set, then we are\n\t\t\t * either the CPU handling the broadcast\n\t\t\t * interrupt or we got woken by something else.\n\t\t\t *\n\t\t\t * We are no longer in the broadcast mask, so\n\t\t\t * if the cpu local expiry time is already\n\t\t\t * reached, we would reprogram the cpu local\n\t\t\t * timer with an already expired event.\n\t\t\t *\n\t\t\t * This can lead to a ping-pong when we return\n\t\t\t * to idle and therefore rearm the broadcast\n\t\t\t * timer before the cpu local timer was able\n\t\t\t * to fire. This happens because the forced\n\t\t\t * reprogramming makes sure that the event\n\t\t\t * will happen in the future and depending on\n\t\t\t * the min_delta setting this might be far\n\t\t\t * enough out that the ping-pong starts.\n\t\t\t *\n\t\t\t * If the cpu local next_event has expired\n\t\t\t * then we know that the broadcast timer\n\t\t\t * next_event has expired as well and\n\t\t\t * broadcast is about to be handled. So we\n\t\t\t * avoid reprogramming and enforce that the\n\t\t\t * broadcast handler, which did not run yet,\n\t\t\t * will invoke the cpu local handler.\n\t\t\t *\n\t\t\t * We cannot call the handler directly from\n\t\t\t * here, because we might be in a NOHZ phase\n\t\t\t * and we did not go through the irq_enter()\n\t\t\t * nohz fixups.\n\t\t\t */\n\t\t\tnow = ktime_get();\n\t\t\tif (dev->next_event <= now) {\n\t\t\t\tcpumask_set_cpu(cpu, tick_broadcast_force_mask);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We got woken by something else. Reprogram\n\t\t\t * the cpu local timer device.\n\t\t\t */\n\t\t\ttick_program_event(dev->next_event, 1);\n\t\t}\n\t}\nout:\n\traw_spin_unlock(&tick_broadcast_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "broadcast_shutdown_local",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "774-789",
    "snippet": "static void broadcast_shutdown_local(struct clock_event_device *bc,\n\t\t\t\t     struct clock_event_device *dev)\n{\n\t/*\n\t * For hrtimer based broadcasting we cannot shutdown the cpu\n\t * local device if our own event is the first one to expire or\n\t * if we own the broadcast timer.\n\t */\n\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER) {\n\t\tif (broadcast_needs_cpu(bc, smp_processor_id()))\n\t\t\treturn;\n\t\tif (dev->next_event < bc->next_event)\n\t\t\treturn;\n\t}\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_SHUTDOWN"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "147-165",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "broadcast_needs_cpu",
          "args": [
            "bc",
            "smp_processor_id()"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "broadcast_needs_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "765-772",
          "snippet": "static int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void broadcast_shutdown_local(struct clock_event_device *bc,\n\t\t\t\t     struct clock_event_device *dev)\n{\n\t/*\n\t * For hrtimer based broadcasting we cannot shutdown the cpu\n\t * local device if our own event is the first one to expire or\n\t * if we own the broadcast timer.\n\t */\n\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER) {\n\t\tif (broadcast_needs_cpu(bc, smp_processor_id()))\n\t\t\treturn;\n\t\tif (dev->next_event < bc->next_event)\n\t\t\treturn;\n\t}\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n}"
  },
  {
    "function_name": "broadcast_needs_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "765-772",
    "snippet": "static int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}"
  },
  {
    "function_name": "tick_handle_oneshot_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "685-763",
    "snippet": "static void tick_handle_oneshot_broadcast(struct clock_event_device *dev)\n{\n\tstruct tick_device *td;\n\tktime_t now, next_event;\n\tint cpu, next_cpu = 0;\n\tbool bc_local;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\tdev->next_event = KTIME_MAX;\n\tnext_event = KTIME_MAX;\n\tcpumask_clear(tmpmask);\n\tnow = ktime_get();\n\t/* Find all expired events */\n\tfor_each_cpu(cpu, tick_broadcast_oneshot_mask) {\n\t\t/*\n\t\t * Required for !SMP because for_each_cpu() reports\n\t\t * unconditionally CPU0 as set on UP kernels.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_SMP) &&\n\t\t    cpumask_empty(tick_broadcast_oneshot_mask))\n\t\t\tbreak;\n\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev->next_event <= now) {\n\t\t\tcpumask_set_cpu(cpu, tmpmask);\n\t\t\t/*\n\t\t\t * Mark the remote cpu in the pending mask, so\n\t\t\t * it can avoid reprogramming the cpu local\n\t\t\t * timer in tick_broadcast_oneshot_control().\n\t\t\t */\n\t\t\tcpumask_set_cpu(cpu, tick_broadcast_pending_mask);\n\t\t} else if (td->evtdev->next_event < next_event) {\n\t\t\tnext_event = td->evtdev->next_event;\n\t\t\tnext_cpu = cpu;\n\t\t}\n\t}\n\n\t/*\n\t * Remove the current cpu from the pending mask. The event is\n\t * delivered immediately in tick_do_broadcast() !\n\t */\n\tcpumask_clear_cpu(smp_processor_id(), tick_broadcast_pending_mask);\n\n\t/* Take care of enforced broadcast requests */\n\tcpumask_or(tmpmask, tmpmask, tick_broadcast_force_mask);\n\tcpumask_clear(tick_broadcast_force_mask);\n\n\t/*\n\t * Sanity check. Catch the case where we try to broadcast to\n\t * offline cpus.\n\t */\n\tif (WARN_ON_ONCE(!cpumask_subset(tmpmask, cpu_online_mask)))\n\t\tcpumask_and(tmpmask, tmpmask, cpu_online_mask);\n\n\t/*\n\t * Wakeup the cpus which have an expired event.\n\t */\n\tbc_local = tick_do_broadcast(tmpmask);\n\n\t/*\n\t * Two reasons for reprogram:\n\t *\n\t * - The global event did not expire any CPU local\n\t * events. This happens in dyntick mode, as the maximum PIT\n\t * delta is quite small.\n\t *\n\t * - There are pending events on sleeping CPUs which were not\n\t * in the event mask\n\t */\n\tif (next_event != KTIME_MAX)\n\t\ttick_broadcast_set_event(dev, next_cpu, next_event);\n\n\traw_spin_unlock(&tick_broadcast_lock);\n\n\tif (bc_local) {\n\t\ttd = this_cpu_ptr(&tick_cpu_device);\n\t\ttd->evtdev->event_handler(td->evtdev);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);",
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "td->evtdev->event_handler",
          "args": [
            "td->evtdev"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_set_event",
          "args": [
            "dev",
            "next_cpu",
            "next_event"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_set_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "646-654",
          "snippet": "static void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_do_broadcast",
          "args": [
            "tmpmask"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_broadcast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "345-384",
          "snippet": "static bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "tmpmask",
            "tmpmask",
            "cpu_online_mask"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!cpumask_subset(tmpmask, cpu_online_mask)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "tmpmask",
            "cpu_online_mask"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "tick_broadcast_force_mask"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "tmpmask",
            "tmpmask",
            "tick_broadcast_force_mask"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "smp_processor_id()",
            "tick_broadcast_pending_mask"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_pending_mask"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tmpmask"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_oneshot_mask"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SMP"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "tmpmask"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_handle_oneshot_broadcast(struct clock_event_device *dev)\n{\n\tstruct tick_device *td;\n\tktime_t now, next_event;\n\tint cpu, next_cpu = 0;\n\tbool bc_local;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\tdev->next_event = KTIME_MAX;\n\tnext_event = KTIME_MAX;\n\tcpumask_clear(tmpmask);\n\tnow = ktime_get();\n\t/* Find all expired events */\n\tfor_each_cpu(cpu, tick_broadcast_oneshot_mask) {\n\t\t/*\n\t\t * Required for !SMP because for_each_cpu() reports\n\t\t * unconditionally CPU0 as set on UP kernels.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_SMP) &&\n\t\t    cpumask_empty(tick_broadcast_oneshot_mask))\n\t\t\tbreak;\n\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev->next_event <= now) {\n\t\t\tcpumask_set_cpu(cpu, tmpmask);\n\t\t\t/*\n\t\t\t * Mark the remote cpu in the pending mask, so\n\t\t\t * it can avoid reprogramming the cpu local\n\t\t\t * timer in tick_broadcast_oneshot_control().\n\t\t\t */\n\t\t\tcpumask_set_cpu(cpu, tick_broadcast_pending_mask);\n\t\t} else if (td->evtdev->next_event < next_event) {\n\t\t\tnext_event = td->evtdev->next_event;\n\t\t\tnext_cpu = cpu;\n\t\t}\n\t}\n\n\t/*\n\t * Remove the current cpu from the pending mask. The event is\n\t * delivered immediately in tick_do_broadcast() !\n\t */\n\tcpumask_clear_cpu(smp_processor_id(), tick_broadcast_pending_mask);\n\n\t/* Take care of enforced broadcast requests */\n\tcpumask_or(tmpmask, tmpmask, tick_broadcast_force_mask);\n\tcpumask_clear(tick_broadcast_force_mask);\n\n\t/*\n\t * Sanity check. Catch the case where we try to broadcast to\n\t * offline cpus.\n\t */\n\tif (WARN_ON_ONCE(!cpumask_subset(tmpmask, cpu_online_mask)))\n\t\tcpumask_and(tmpmask, tmpmask, cpu_online_mask);\n\n\t/*\n\t * Wakeup the cpus which have an expired event.\n\t */\n\tbc_local = tick_do_broadcast(tmpmask);\n\n\t/*\n\t * Two reasons for reprogram:\n\t *\n\t * - The global event did not expire any CPU local\n\t * events. This happens in dyntick mode, as the maximum PIT\n\t * delta is quite small.\n\t *\n\t * - There are pending events on sleeping CPUs which were not\n\t * in the event mask\n\t */\n\tif (next_event != KTIME_MAX)\n\t\ttick_broadcast_set_event(dev, next_cpu, next_event);\n\n\traw_spin_unlock(&tick_broadcast_lock);\n\n\tif (bc_local) {\n\t\ttd = this_cpu_ptr(&tick_cpu_device);\n\t\ttd->evtdev->event_handler(td->evtdev);\n\t}\n}"
  },
  {
    "function_name": "tick_check_oneshot_broadcast_this_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "665-680",
    "snippet": "void tick_check_oneshot_broadcast_this_cpu(void)\n{\n\tif (cpumask_test_cpu(smp_processor_id(), tick_broadcast_oneshot_mask)) {\n\t\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\t\t/*\n\t\t * We might be in the middle of switching over from\n\t\t * periodic to oneshot. If the CPU has not yet\n\t\t * switched over, leave the device alone.\n\t\t */\n\t\tif (td->mode == TICKDEV_MODE_ONESHOT) {\n\t\t\tclockevents_switch_state(td->evtdev,\n\t\t\t\t\t      CLOCK_EVT_STATE_ONESHOT);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "td->evtdev",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "147-165",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "smp_processor_id()",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_check_oneshot_broadcast_this_cpu(void)\n{\n\tif (cpumask_test_cpu(smp_processor_id(), tick_broadcast_oneshot_mask)) {\n\t\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\t\t/*\n\t\t * We might be in the middle of switching over from\n\t\t * periodic to oneshot. If the CPU has not yet\n\t\t * switched over, leave the device alone.\n\t\t */\n\t\tif (td->mode == TICKDEV_MODE_ONESHOT) {\n\t\t\tclockevents_switch_state(td->evtdev,\n\t\t\t\t\t      CLOCK_EVT_STATE_ONESHOT);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "tick_resume_broadcast_oneshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "656-659",
    "snippet": "static void tick_resume_broadcast_oneshot(struct clock_event_device *bc)\n{\n\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "bc",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "147-165",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_resume_broadcast_oneshot(struct clock_event_device *bc)\n{\n\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n}"
  },
  {
    "function_name": "tick_broadcast_set_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "646-654",
    "snippet": "static void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_broadcast_set_affinity",
          "args": [
            "bc",
            "cpumask_of(cpu)"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_set_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "633-644",
          "snippet": "static void tick_broadcast_set_affinity(struct clock_event_device *bc,\n\t\t\t\t\tconst struct cpumask *cpumask)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_DYNIRQ))\n\t\treturn;\n\n\tif (cpumask_equal(bc->cpumask, cpumask))\n\t\treturn;\n\n\tbc->cpumask = cpumask;\n\tirq_set_affinity(bc->irq, bc->cpumask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_set_affinity(struct clock_event_device *bc,\n\t\t\t\t\tconst struct cpumask *cpumask)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_DYNIRQ))\n\t\treturn;\n\n\tif (cpumask_equal(bc->cpumask, cpumask))\n\t\treturn;\n\n\tbc->cpumask = cpumask;\n\tirq_set_affinity(bc->irq, bc->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "bc",
            "expires",
            "1"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "303-337",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "bc",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "147-165",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "bc"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}"
  },
  {
    "function_name": "tick_broadcast_set_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "633-644",
    "snippet": "static void tick_broadcast_set_affinity(struct clock_event_device *bc,\n\t\t\t\t\tconst struct cpumask *cpumask)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_DYNIRQ))\n\t\treturn;\n\n\tif (cpumask_equal(bc->cpumask, cpumask))\n\t\treturn;\n\n\tbc->cpumask = cpumask;\n\tirq_set_affinity(bc->irq, bc->cpumask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_set_affinity",
          "args": [
            "bc->irq",
            "bc->cpumask"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_affinity_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "541-575",
          "snippet": "int\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc || desc->istate & IRQS_NMI)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify) {\n\t\tif (cancel_work_sync(&old_notify->work)) {\n\t\t\t/* Pending work had a ref, put that one too */\n\t\t\tkref_put(&old_notify->kref, old_notify->release);\n\t\t}\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc || desc->istate & IRQS_NMI)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify) {\n\t\tif (cancel_work_sync(&old_notify->work)) {\n\t\t\t/* Pending work had a ref, put that one too */\n\t\t\tkref_put(&old_notify->kref, old_notify->release);\n\t\t}\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "bc->cpumask",
            "cpumask"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_set_affinity(struct clock_event_device *bc,\n\t\t\t\t\tconst struct cpumask *cpumask)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_DYNIRQ))\n\t\treturn;\n\n\tif (cpumask_equal(bc->cpumask, cpumask))\n\t\treturn;\n\n\tbc->cpumask = cpumask;\n\tirq_set_affinity(bc->irq, bc->cpumask);\n}"
  },
  {
    "function_name": "tick_check_broadcast_expired",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "625-628",
    "snippet": "int tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "smp_processor_id()",
            "tick_broadcast_force_mask"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}"
  },
  {
    "function_name": "tick_get_broadcast_oneshot_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "613-616",
    "snippet": "struct cpumask *tick_get_broadcast_oneshot_mask(void)\n{\n\treturn tick_broadcast_oneshot_mask;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct cpumask *tick_get_broadcast_oneshot_mask(void)\n{\n\treturn tick_broadcast_oneshot_mask;\n}"
  },
  {
    "function_name": "tick_resume_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "578-602",
    "snippet": "void tick_resume_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc) {\n\t\tclockevents_tick_resume(bc);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\tbreak;\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_resume_broadcast_oneshot(bc);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_resume_broadcast_oneshot",
          "args": [
            "bc"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_broadcast_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "656-659",
          "snippet": "static void tick_resume_broadcast_oneshot(struct clock_event_device *bc)\n{\n\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_resume_broadcast_oneshot(struct clock_event_device *bc)\n{\n\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_broadcast_start_periodic",
          "args": [
            "bc"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_start_periodic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "76-80",
          "snippet": "static void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_tick_resume",
          "args": [
            "bc"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_tick_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "181-189",
          "snippet": "int clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_resume_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc) {\n\t\tclockevents_tick_resume(bc);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\tbreak;\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_resume_broadcast_oneshot(bc);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "tick_resume_check_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "570-576",
    "snippet": "bool tick_resume_check_broadcast(void)\n{\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT)\n\t\treturn false;\n\telse\n\t\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_mask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "smp_processor_id()",
            "tick_broadcast_mask"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\n\nbool tick_resume_check_broadcast(void)\n{\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT)\n\t\treturn false;\n\telse\n\t\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_mask);\n}"
  },
  {
    "function_name": "tick_suspend_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "548-560",
    "snippet": "void tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "bc"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "171-175",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "tick_broadcast_offline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "536-544",
    "snippet": "void tick_broadcast_offline(unsigned int cpu)\n{\n\traw_spin_lock(&tick_broadcast_lock);\n\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_on);\n\ttick_broadcast_oneshot_offline(cpu);\n\ttick_shutdown_broadcast();\n\traw_spin_unlock(&tick_broadcast_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t tick_broadcast_mask",
      "static cpumask_var_t tick_broadcast_on",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);",
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_shutdown_broadcast",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "tick_shutdown_broadcast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "523-531",
          "snippet": "static void tick_shutdown_broadcast(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\tif (bc && cpumask_empty(tick_broadcast_mask))\n\t\t\tclockevents_shutdown(bc);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static cpumask_var_t tick_broadcast_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\n\nstatic void tick_shutdown_broadcast(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\tif (bc && cpumask_empty(tick_broadcast_mask))\n\t\t\tclockevents_shutdown(bc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_oneshot_offline",
          "args": [
            "cpu"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_oneshot_offline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "1100-1112",
          "snippet": "static void tick_broadcast_oneshot_offline(unsigned int cpu)\n{\n\tif (tick_get_oneshot_wakeup_device(cpu))\n\t\ttick_set_oneshot_wakeup_device(NULL, cpu);\n\n\t/*\n\t * Clear the broadcast masks for the dead cpu, but do not stop\n\t * the broadcast device!\n\t */\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_force_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_oneshot_offline(unsigned int cpu)\n{\n\tif (tick_get_oneshot_wakeup_device(cpu))\n\t\ttick_set_oneshot_wakeup_device(NULL, cpu);\n\n\t/*\n\t * Clear the broadcast masks for the dead cpu, but do not stop\n\t * the broadcast device!\n\t */\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_force_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_on"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\nstatic cpumask_var_t tick_broadcast_on;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nvoid tick_broadcast_offline(unsigned int cpu)\n{\n\traw_spin_lock(&tick_broadcast_lock);\n\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_on);\n\ttick_broadcast_oneshot_offline(cpu);\n\ttick_shutdown_broadcast();\n\traw_spin_unlock(&tick_broadcast_lock);\n}"
  },
  {
    "function_name": "tick_shutdown_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "523-531",
    "snippet": "static void tick_shutdown_broadcast(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\tif (bc && cpumask_empty(tick_broadcast_mask))\n\t\t\tclockevents_shutdown(bc);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "bc"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "171-175",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\n\nstatic void tick_shutdown_broadcast(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\tif (bc && cpumask_empty(tick_broadcast_mask))\n\t\t\tclockevents_shutdown(bc);\n\t}\n}"
  },
  {
    "function_name": "tick_set_periodic_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "514-520",
    "snippet": "void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)\n{\n\tif (!broadcast)\n\t\tdev->event_handler = tick_handle_periodic;\n\telse\n\t\tdev->event_handler = tick_handle_periodic_broadcast;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)\n{\n\tif (!broadcast)\n\t\tdev->event_handler = tick_handle_periodic;\n\telse\n\t\tdev->event_handler = tick_handle_periodic_broadcast;\n}"
  },
  {
    "function_name": "tick_broadcast_control",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "437-508",
    "snippet": "void tick_broadcast_control(enum tick_broadcast_mode mode)\n{\n\tstruct clock_event_device *bc, *dev;\n\tstruct tick_device *td;\n\tint cpu, bc_stopped;\n\tunsigned long flags;\n\n\t/* Protects also the local clockevent device. */\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\ttd = this_cpu_ptr(&tick_cpu_device);\n\tdev = td->evtdev;\n\n\t/*\n\t * Is the device not affected by the powerstate ?\n\t */\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\tgoto out;\n\n\tif (!tick_device_is_functional(dev))\n\t\tgoto out;\n\n\tcpu = smp_processor_id();\n\tbc = tick_broadcast_device.evtdev;\n\tbc_stopped = cpumask_empty(tick_broadcast_mask);\n\n\tswitch (mode) {\n\tcase TICK_BROADCAST_FORCE:\n\t\ttick_broadcast_forced = 1;\n\t\tfallthrough;\n\tcase TICK_BROADCAST_ON:\n\t\tcpumask_set_cpu(cpu, tick_broadcast_on);\n\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_mask)) {\n\t\t\t/*\n\t\t\t * Only shutdown the cpu local device, if:\n\t\t\t *\n\t\t\t * - the broadcast device exists\n\t\t\t * - the broadcast device is not a hrtimer based one\n\t\t\t * - the broadcast device is in periodic mode to\n\t\t\t *   avoid a hiccup during switch to oneshot mode\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER) &&\n\t\t\t    tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\t\tclockevents_shutdown(dev);\n\t\t}\n\t\tbreak;\n\n\tcase TICK_BROADCAST_OFF:\n\t\tif (tick_broadcast_forced)\n\t\t\tbreak;\n\t\tcpumask_clear_cpu(cpu, tick_broadcast_on);\n\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_mask)) {\n\t\t\tif (tick_broadcast_device.mode ==\n\t\t\t    TICKDEV_MODE_PERIODIC)\n\t\t\t\ttick_setup_periodic(dev, 0);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (bc) {\n\t\tif (cpumask_empty(tick_broadcast_mask)) {\n\t\t\tif (!bc_stopped)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t} else if (bc_stopped) {\n\t\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\telse\n\t\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\t}\n\t}\nout:\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask",
      "static cpumask_var_t tick_broadcast_on",
      "static int tick_broadcast_forced;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);",
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_setup_oneshot",
          "args": [
            "bc"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_setup_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "1019-1061",
          "snippet": "static void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tktime_t nextevt = tick_get_next_period();\n\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask, nextevt);\n\t\t\ttick_broadcast_set_event(bc, cpu, nextevt);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t tick_broadcast_mask",
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tktime_t nextevt = tick_get_next_period();\n\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask, nextevt);\n\t\t\ttick_broadcast_set_event(bc, cpu, nextevt);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_start_periodic",
          "args": [
            "bc"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_start_periodic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "76-80",
          "snippet": "static void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "bc"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "171-175",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_setup_periodic",
          "args": [
            "dev",
            "0"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_periodic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "152-180",
          "snippet": "void tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned int seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned int seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_on"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_on"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_device_is_functional",
          "args": [
            "dev"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "tick_device_is_functional",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-internal.h",
          "lines": "34-37",
          "snippet": "static inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic cpumask_var_t tick_broadcast_on;\nstatic int tick_broadcast_forced;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nvoid tick_broadcast_control(enum tick_broadcast_mode mode)\n{\n\tstruct clock_event_device *bc, *dev;\n\tstruct tick_device *td;\n\tint cpu, bc_stopped;\n\tunsigned long flags;\n\n\t/* Protects also the local clockevent device. */\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\ttd = this_cpu_ptr(&tick_cpu_device);\n\tdev = td->evtdev;\n\n\t/*\n\t * Is the device not affected by the powerstate ?\n\t */\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\tgoto out;\n\n\tif (!tick_device_is_functional(dev))\n\t\tgoto out;\n\n\tcpu = smp_processor_id();\n\tbc = tick_broadcast_device.evtdev;\n\tbc_stopped = cpumask_empty(tick_broadcast_mask);\n\n\tswitch (mode) {\n\tcase TICK_BROADCAST_FORCE:\n\t\ttick_broadcast_forced = 1;\n\t\tfallthrough;\n\tcase TICK_BROADCAST_ON:\n\t\tcpumask_set_cpu(cpu, tick_broadcast_on);\n\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_mask)) {\n\t\t\t/*\n\t\t\t * Only shutdown the cpu local device, if:\n\t\t\t *\n\t\t\t * - the broadcast device exists\n\t\t\t * - the broadcast device is not a hrtimer based one\n\t\t\t * - the broadcast device is in periodic mode to\n\t\t\t *   avoid a hiccup during switch to oneshot mode\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER) &&\n\t\t\t    tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\t\tclockevents_shutdown(dev);\n\t\t}\n\t\tbreak;\n\n\tcase TICK_BROADCAST_OFF:\n\t\tif (tick_broadcast_forced)\n\t\t\tbreak;\n\t\tcpumask_clear_cpu(cpu, tick_broadcast_on);\n\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_mask)) {\n\t\t\tif (tick_broadcast_device.mode ==\n\t\t\t    TICKDEV_MODE_PERIODIC)\n\t\t\t\ttick_setup_periodic(dev, 0);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (bc) {\n\t\tif (cpumask_empty(tick_broadcast_mask)) {\n\t\t\tif (!bc_stopped)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t} else if (bc_stopped) {\n\t\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\telse\n\t\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\t}\n\t}\nout:\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "tick_handle_periodic_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "399-428",
    "snippet": "static void tick_handle_periodic_broadcast(struct clock_event_device *dev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool bc_local;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\n\t/* Handle spurious interrupts gracefully */\n\tif (clockevent_state_shutdown(tick_broadcast_device.evtdev)) {\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t\treturn;\n\t}\n\n\tbc_local = tick_do_periodic_broadcast();\n\n\tif (clockevent_state_oneshot(dev)) {\n\t\tktime_t next = ktime_add_ns(dev->next_event, TICK_NSEC);\n\n\t\tclockevents_program_event(dev, next, true);\n\t}\n\traw_spin_unlock(&tick_broadcast_lock);\n\n\t/*\n\t * We run the handler of the local cpu after dropping\n\t * tick_broadcast_lock because the handler might deadlock when\n\t * trying to switch to oneshot mode.\n\t */\n\tif (bc_local)\n\t\ttd->evtdev->event_handler(td->evtdev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);",
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "td->evtdev->event_handler",
          "args": [
            "td->evtdev"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "dev",
            "next",
            "true"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "303-337",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "dev->next_event",
            "TICK_NSEC"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_do_periodic_broadcast",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_periodic_broadcast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "390-394",
          "snippet": "static bool tick_do_periodic_broadcast(void)\n{\n\tcpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);\n\treturn tick_do_broadcast(tmpmask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t tick_broadcast_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstatic bool tick_do_periodic_broadcast(void)\n{\n\tcpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);\n\treturn tick_do_broadcast(tmpmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_shutdown",
          "args": [
            "tick_broadcast_device.evtdev"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_handle_periodic_broadcast(struct clock_event_device *dev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool bc_local;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\n\t/* Handle spurious interrupts gracefully */\n\tif (clockevent_state_shutdown(tick_broadcast_device.evtdev)) {\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t\treturn;\n\t}\n\n\tbc_local = tick_do_periodic_broadcast();\n\n\tif (clockevent_state_oneshot(dev)) {\n\t\tktime_t next = ktime_add_ns(dev->next_event, TICK_NSEC);\n\n\t\tclockevents_program_event(dev, next, true);\n\t}\n\traw_spin_unlock(&tick_broadcast_lock);\n\n\t/*\n\t * We run the handler of the local cpu after dropping\n\t * tick_broadcast_lock because the handler might deadlock when\n\t * trying to switch to oneshot mode.\n\t */\n\tif (bc_local)\n\t\ttd->evtdev->event_handler(td->evtdev);\n}"
  },
  {
    "function_name": "tick_do_periodic_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "390-394",
    "snippet": "static bool tick_do_periodic_broadcast(void)\n{\n\tcpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);\n\treturn tick_do_broadcast(tmpmask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t tick_broadcast_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_do_broadcast",
          "args": [
            "tmpmask"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_broadcast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "345-384",
          "snippet": "static bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "tmpmask",
            "cpu_online_mask",
            "tick_broadcast_mask"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstatic bool tick_do_periodic_broadcast(void)\n{\n\tcpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);\n\treturn tick_do_broadcast(tmpmask);\n}"
  },
  {
    "function_name": "tick_do_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "345-384",
    "snippet": "static bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "td->evtdev->broadcast",
          "args": [
            "mask"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpumask_first(mask)"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "mask"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "mask"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}"
  },
  {
    "function_name": "tick_receive_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "327-340",
    "snippet": "int tick_receive_broadcast(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tstruct clock_event_device *evt = td->evtdev;\n\n\tif (!evt)\n\t\treturn -ENODEV;\n\n\tif (!evt->event_handler)\n\t\treturn -EINVAL;\n\n\tevt->event_handler(evt);\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evt->event_handler",
          "args": [
            "evt"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_receive_broadcast(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tstruct clock_event_device *evt = td->evtdev;\n\n\tif (!evt)\n\t\treturn -ENODEV;\n\n\tif (!evt->event_handler)\n\t\treturn -EINVAL;\n\n\tevt->event_handler(evt);\n\treturn 0;\n}"
  },
  {
    "function_name": "tick_device_uses_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "246-325",
    "snippet": "int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Devices might be registered with both periodic and oneshot\n\t * mode disabled. This signals, that the device needs to be\n\t * operated from the broadcast device and is a placeholder for\n\t * the cpu local device.\n\t */\n\tif (!tick_device_is_functional(dev)) {\n\t\tdev->event_handler = tick_handle_periodic;\n\t\ttick_device_setup_broadcast_func(dev);\n\t\tcpumask_set_cpu(cpu, tick_broadcast_mask);\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_broadcast_start_periodic(bc);\n\t\telse\n\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\tret = 1;\n\t} else {\n\t\t/*\n\t\t * Clear the broadcast bit for this cpu if the\n\t\t * device is not power state affected.\n\t\t */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\t\telse\n\t\t\ttick_device_setup_broadcast_func(dev);\n\n\t\t/*\n\t\t * Clear the broadcast bit if the CPU is not in\n\t\t * periodic broadcast on state.\n\t\t */\n\t\tif (!cpumask_test_cpu(cpu, tick_broadcast_on))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\t/*\n\t\t\t * If the system is in oneshot mode we can\n\t\t\t * unconditionally clear the oneshot mask bit,\n\t\t\t * because the CPU is running and therefore\n\t\t\t * not in an idle state which causes the power\n\t\t\t * state affected device to stop. Let the\n\t\t\t * caller initialize the device.\n\t\t\t */\n\t\t\ttick_broadcast_clear_oneshot(cpu);\n\t\t\tret = 0;\n\t\t\tbreak;\n\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\t/*\n\t\t\t * If the system is in periodic mode, check\n\t\t\t * whether the broadcast device can be\n\t\t\t * switched off now.\n\t\t\t */\n\t\t\tif (cpumask_empty(tick_broadcast_mask) && bc)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t\t/*\n\t\t\t * If we kept the cpu in the broadcast mask,\n\t\t\t * tell the caller to leave the per cpu device\n\t\t\t * in shutdown state. The periodic interrupt\n\t\t\t * is delivered by the broadcast device, if\n\t\t\t * the broadcast device exists and is not\n\t\t\t * hrtimer based.\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\t\t\tret = cpumask_test_cpu(cpu, tick_broadcast_mask);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask",
      "static cpumask_var_t tick_broadcast_on",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);",
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "bc"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "171-175",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_broadcast_clear_oneshot",
          "args": [
            "cpu"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_clear_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "981-985",
          "snippet": "static void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "tick_broadcast_on"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_device_setup_broadcast_func",
          "args": [
            "dev"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "tick_device_setup_broadcast_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "231-240",
          "snippet": "static void tick_device_setup_broadcast_func(struct clock_event_device *dev)\n{\n\tif (!dev->broadcast)\n\t\tdev->broadcast = tick_broadcast;\n\tif (!dev->broadcast) {\n\t\tpr_warn_once(\"%s depends on broadcast, but no broadcast function available\\n\",\n\t\t\t     dev->name);\n\t\tdev->broadcast = err_broadcast;\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_device_setup_broadcast_func(struct clock_event_device *dev)\n{\n\tif (!dev->broadcast)\n\t\tdev->broadcast = tick_broadcast;\n\tif (!dev->broadcast) {\n\t\tpr_warn_once(\"%s depends on broadcast, but no broadcast function available\\n\",\n\t\t\t     dev->name);\n\t\tdev->broadcast = err_broadcast;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_broadcast_setup_oneshot",
          "args": [
            "bc"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_setup_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "1019-1061",
          "snippet": "static void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tktime_t nextevt = tick_get_next_period();\n\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask, nextevt);\n\t\t\ttick_broadcast_set_event(bc, cpu, nextevt);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t tick_broadcast_mask",
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tktime_t nextevt = tick_get_next_period();\n\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask, nextevt);\n\t\t\ttick_broadcast_set_event(bc, cpu, nextevt);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_start_periodic",
          "args": [
            "bc"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_start_periodic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "76-80",
          "snippet": "static void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_device_is_functional",
          "args": [
            "dev"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "tick_device_is_functional",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-internal.h",
          "lines": "34-37",
          "snippet": "static inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic cpumask_var_t tick_broadcast_on;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nint tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Devices might be registered with both periodic and oneshot\n\t * mode disabled. This signals, that the device needs to be\n\t * operated from the broadcast device and is a placeholder for\n\t * the cpu local device.\n\t */\n\tif (!tick_device_is_functional(dev)) {\n\t\tdev->event_handler = tick_handle_periodic;\n\t\ttick_device_setup_broadcast_func(dev);\n\t\tcpumask_set_cpu(cpu, tick_broadcast_mask);\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_broadcast_start_periodic(bc);\n\t\telse\n\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\tret = 1;\n\t} else {\n\t\t/*\n\t\t * Clear the broadcast bit for this cpu if the\n\t\t * device is not power state affected.\n\t\t */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\t\telse\n\t\t\ttick_device_setup_broadcast_func(dev);\n\n\t\t/*\n\t\t * Clear the broadcast bit if the CPU is not in\n\t\t * periodic broadcast on state.\n\t\t */\n\t\tif (!cpumask_test_cpu(cpu, tick_broadcast_on))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\t/*\n\t\t\t * If the system is in oneshot mode we can\n\t\t\t * unconditionally clear the oneshot mask bit,\n\t\t\t * because the CPU is running and therefore\n\t\t\t * not in an idle state which causes the power\n\t\t\t * state affected device to stop. Let the\n\t\t\t * caller initialize the device.\n\t\t\t */\n\t\t\ttick_broadcast_clear_oneshot(cpu);\n\t\t\tret = 0;\n\t\t\tbreak;\n\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\t/*\n\t\t\t * If the system is in periodic mode, check\n\t\t\t * whether the broadcast device can be\n\t\t\t * switched off now.\n\t\t\t */\n\t\t\tif (cpumask_empty(tick_broadcast_mask) && bc)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t\t/*\n\t\t\t * If we kept the cpu in the broadcast mask,\n\t\t\t * tell the caller to leave the per cpu device\n\t\t\t * in shutdown state. The periodic interrupt\n\t\t\t * is delivered by the broadcast device, if\n\t\t\t * the broadcast device exists and is not\n\t\t\t * hrtimer based.\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\t\t\tret = cpumask_test_cpu(cpu, tick_broadcast_mask);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "tick_device_setup_broadcast_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "231-240",
    "snippet": "static void tick_device_setup_broadcast_func(struct clock_event_device *dev)\n{\n\tif (!dev->broadcast)\n\t\tdev->broadcast = tick_broadcast;\n\tif (!dev->broadcast) {\n\t\tpr_warn_once(\"%s depends on broadcast, but no broadcast function available\\n\",\n\t\t\t     dev->name);\n\t\tdev->broadcast = err_broadcast;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"%s depends on broadcast, but no broadcast function available\\n\"",
            "dev->name"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_device_setup_broadcast_func(struct clock_event_device *dev)\n{\n\tif (!dev->broadcast)\n\t\tdev->broadcast = tick_broadcast;\n\tif (!dev->broadcast) {\n\t\tpr_warn_once(\"%s depends on broadcast, but no broadcast function available\\n\",\n\t\t\t     dev->name);\n\t\tdev->broadcast = err_broadcast;\n\t}\n}"
  },
  {
    "function_name": "err_broadcast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "226-229",
    "snippet": "static void err_broadcast(const struct cpumask *mask)\n{\n\tpr_crit_once(\"Failed to broadcast timer tick. Some CPUs may be unresponsive.\\n\");\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_crit_once",
          "args": [
            "\"Failed to broadcast timer tick. Some CPUs may be unresponsive.\\n\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void err_broadcast(const struct cpumask *mask)\n{\n\tpr_crit_once(\"Failed to broadcast timer tick. Some CPUs may be unresponsive.\\n\");\n}"
  },
  {
    "function_name": "tick_broadcast_update_freq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "213-223",
    "snippet": "int tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tint ret = -ENODEV;\n\n\tif (tick_is_broadcast_device(dev)) {\n\t\traw_spin_lock(&tick_broadcast_lock);\n\t\tret = __clockevents_update_freq(dev, freq);\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clockevents_update_freq",
          "args": [
            "dev",
            "freq"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_update_freq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "515-526",
          "snippet": "int __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_is_broadcast_device",
          "args": [
            "dev"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "tick_is_broadcast_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "208-211",
          "snippet": "int tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nint tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tint ret = -ENODEV;\n\n\tif (tick_is_broadcast_device(dev)) {\n\t\traw_spin_lock(&tick_broadcast_lock);\n\t\tret = __clockevents_update_freq(dev, freq);\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "tick_is_broadcast_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "208-211",
    "snippet": "int tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}"
  },
  {
    "function_name": "tick_install_broadcast_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "162-203",
    "snippet": "void tick_install_broadcast_device(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *cur = tick_broadcast_device.evtdev;\n\n\tif (tick_set_oneshot_wakeup_device(dev, cpu))\n\t\treturn;\n\n\tif (!tick_check_broadcast_device(cur, dev))\n\t\treturn;\n\n\tif (!try_module_get(dev->owner))\n\t\treturn;\n\n\tclockevents_exchange_device(cur, dev);\n\tif (cur)\n\t\tcur->event_handler = clockevents_handle_noop;\n\ttick_broadcast_device.evtdev = dev;\n\tif (!cpumask_empty(tick_broadcast_mask))\n\t\ttick_broadcast_start_periodic(dev);\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * If the system already runs in oneshot mode, switch the newly\n\t * registered broadcast device to oneshot mode explicitly.\n\t */\n\tif (tick_broadcast_oneshot_active()) {\n\t\ttick_broadcast_switch_to_oneshot();\n\t\treturn;\n\t}\n\n\t/*\n\t * Inform all cpus about this. We might be in a situation\n\t * where we did not switch to oneshot mode because the per cpu\n\t * devices are affected by CLOCK_EVT_FEAT_C3STOP and the lack\n\t * of a oneshot capable broadcast device. Without that\n\t * notification the systems stays stuck in periodic mode\n\t * forever.\n\t */\n\ttick_clock_notify();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask",
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_clock_notify",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "tick_clock_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1499-1505",
          "snippet": "void tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_switch_to_oneshot",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_switch_to_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "1066-1079",
          "snippet": "void tick_broadcast_switch_to_oneshot(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\ttick_broadcast_device.mode = TICKDEV_MODE_ONESHOT;\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\ttick_broadcast_setup_oneshot(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_broadcast_switch_to_oneshot(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\ttick_broadcast_device.mode = TICKDEV_MODE_ONESHOT;\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\ttick_broadcast_setup_oneshot(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_oneshot_active",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_oneshot_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "1118-1121",
          "snippet": "int tick_broadcast_oneshot_active(void)\n{\n\treturn tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_broadcast_oneshot_active(void)\n{\n\treturn tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_start_periodic",
          "args": [
            "dev"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_start_periodic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "76-80",
          "snippet": "static void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_exchange_device",
          "args": [
            "cur",
            "dev"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_exchange_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "568-585",
          "snippet": "void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevents_released);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevents_released);\n\nvoid clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "dev->owner"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_broadcast_device",
          "args": [
            "cur",
            "dev"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_broadcast_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "85-98",
          "snippet": "static bool tick_check_broadcast_device(struct clock_event_device *curdev,\n\t\t\t\t\tstruct clock_event_device *newdev)\n{\n\tif ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_PERCPU) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn false;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT &&\n\t    !(newdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn false;\n\n\treturn !curdev || newdev->rating > curdev->rating;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstatic bool tick_check_broadcast_device(struct clock_event_device *curdev,\n\t\t\t\t\tstruct clock_event_device *newdev)\n{\n\tif ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_PERCPU) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn false;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT &&\n\t    !(newdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn false;\n\n\treturn !curdev || newdev->rating > curdev->rating;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_set_oneshot_wakeup_device",
          "args": [
            "dev",
            "cpu"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "tick_set_oneshot_wakeup_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "152-156",
          "snippet": "static bool tick_set_oneshot_wakeup_device(struct clock_event_device *newdev,\n\t\t\t\t\t   int cpu)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic bool tick_set_oneshot_wakeup_device(struct clock_event_device *newdev,\n\t\t\t\t\t   int cpu)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nvoid tick_install_broadcast_device(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *cur = tick_broadcast_device.evtdev;\n\n\tif (tick_set_oneshot_wakeup_device(dev, cpu))\n\t\treturn;\n\n\tif (!tick_check_broadcast_device(cur, dev))\n\t\treturn;\n\n\tif (!try_module_get(dev->owner))\n\t\treturn;\n\n\tclockevents_exchange_device(cur, dev);\n\tif (cur)\n\t\tcur->event_handler = clockevents_handle_noop;\n\ttick_broadcast_device.evtdev = dev;\n\tif (!cpumask_empty(tick_broadcast_mask))\n\t\ttick_broadcast_start_periodic(dev);\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * If the system already runs in oneshot mode, switch the newly\n\t * registered broadcast device to oneshot mode explicitly.\n\t */\n\tif (tick_broadcast_oneshot_active()) {\n\t\ttick_broadcast_switch_to_oneshot();\n\t\treturn;\n\t}\n\n\t/*\n\t * Inform all cpus about this. We might be in a situation\n\t * where we did not switch to oneshot mode because the per cpu\n\t * devices are affected by CLOCK_EVT_FEAT_C3STOP and the lack\n\t * of a oneshot capable broadcast device. Without that\n\t * notification the systems stays stuck in periodic mode\n\t * forever.\n\t */\n\ttick_clock_notify();\n}"
  },
  {
    "function_name": "tick_set_oneshot_wakeup_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "152-156",
    "snippet": "static bool tick_set_oneshot_wakeup_device(struct clock_event_device *newdev,\n\t\t\t\t\t   int cpu)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic bool tick_set_oneshot_wakeup_device(struct clock_event_device *newdev,\n\t\t\t\t\t   int cpu)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "tick_get_oneshot_wakeup_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "147-150",
    "snippet": "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "tick_set_oneshot_wakeup_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "115-145",
    "snippet": "static bool tick_set_oneshot_wakeup_device(struct clock_event_device *newdev,\n\t\t\t\t\t   int cpu)\n{\n\tstruct clock_event_device *curdev = tick_get_oneshot_wakeup_device(cpu);\n\n\tif (!newdev)\n\t\tgoto set_device;\n\n\tif ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\t return false;\n\n\tif (!(newdev->features & CLOCK_EVT_FEAT_PERCPU) ||\n\t    !(newdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn false;\n\n\tif (!cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\n\tif (curdev && newdev->rating <= curdev->rating)\n\t\treturn false;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn false;\n\n\tnewdev->event_handler = tick_oneshot_wakeup_handler;\nset_device:\n\tclockevents_exchange_device(curdev, newdev);\n\tper_cpu(tick_oneshot_wakeup_device, cpu) = newdev;\n\treturn true;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_oneshot_wakeup_device",
            "cpu"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_exchange_device",
          "args": [
            "curdev",
            "newdev"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_exchange_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "568-585",
          "snippet": "void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevents_released);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevents_released);\n\nvoid clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "newdev->owner"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "newdev->cpumask",
            "cpumask_of(cpu)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_get_oneshot_wakeup_device",
          "args": [
            "cpu"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_oneshot_wakeup_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "147-150",
          "snippet": "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic bool tick_set_oneshot_wakeup_device(struct clock_event_device *newdev,\n\t\t\t\t\t   int cpu)\n{\n\tstruct clock_event_device *curdev = tick_get_oneshot_wakeup_device(cpu);\n\n\tif (!newdev)\n\t\tgoto set_device;\n\n\tif ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\t return false;\n\n\tif (!(newdev->features & CLOCK_EVT_FEAT_PERCPU) ||\n\t    !(newdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn false;\n\n\tif (!cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\n\tif (curdev && newdev->rating <= curdev->rating)\n\t\treturn false;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn false;\n\n\tnewdev->event_handler = tick_oneshot_wakeup_handler;\nset_device:\n\tclockevents_exchange_device(curdev, newdev);\n\tper_cpu(tick_oneshot_wakeup_device, cpu) = newdev;\n\treturn true;\n}"
  },
  {
    "function_name": "tick_oneshot_wakeup_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "106-113",
    "snippet": "static void tick_oneshot_wakeup_handler(struct clock_event_device *wd)\n{\n\t/*\n\t * If we woke up early and the tick was reprogrammed in the\n\t * meantime then this may be spurious but harmless.\n\t */\n\ttick_receive_broadcast();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_receive_broadcast",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "tick_receive_broadcast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "327-340",
          "snippet": "int tick_receive_broadcast(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tstruct clock_event_device *evt = td->evtdev;\n\n\tif (!evt)\n\t\treturn -ENODEV;\n\n\tif (!evt->event_handler)\n\t\treturn -EINVAL;\n\n\tevt->event_handler(evt);\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_receive_broadcast(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tstruct clock_event_device *evt = td->evtdev;\n\n\tif (!evt)\n\t\treturn -ENODEV;\n\n\tif (!evt->event_handler)\n\t\treturn -EINVAL;\n\n\tevt->event_handler(evt);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_oneshot_wakeup_handler(struct clock_event_device *wd)\n{\n\t/*\n\t * If we woke up early and the tick was reprogrammed in the\n\t * meantime then this may be spurious but harmless.\n\t */\n\ttick_receive_broadcast();\n}"
  },
  {
    "function_name": "tick_get_oneshot_wakeup_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "101-104",
    "snippet": "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn per_cpu(tick_oneshot_wakeup_device, cpu);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_oneshot_wakeup_device",
            "cpu"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn per_cpu(tick_oneshot_wakeup_device, cpu);\n}"
  },
  {
    "function_name": "tick_check_broadcast_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "85-98",
    "snippet": "static bool tick_check_broadcast_device(struct clock_event_device *curdev,\n\t\t\t\t\tstruct clock_event_device *newdev)\n{\n\tif ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_PERCPU) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn false;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT &&\n\t    !(newdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn false;\n\n\treturn !curdev || newdev->rating > curdev->rating;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstatic bool tick_check_broadcast_device(struct clock_event_device *curdev,\n\t\t\t\t\tstruct clock_event_device *newdev)\n{\n\tif ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_PERCPU) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn false;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT &&\n\t    !(newdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn false;\n\n\treturn !curdev || newdev->rating > curdev->rating;\n}"
  },
  {
    "function_name": "tick_broadcast_start_periodic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "76-80",
    "snippet": "static void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_setup_periodic",
          "args": [
            "bc",
            "1"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_periodic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "152-180",
          "snippet": "void tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned int seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned int seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}"
  },
  {
    "function_name": "tick_get_wakeup_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "68-71",
    "snippet": "const struct clock_event_device *tick_get_wakeup_device(int cpu)\n{\n\treturn tick_get_oneshot_wakeup_device(cpu);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_get_oneshot_wakeup_device",
          "args": [
            "cpu"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_oneshot_wakeup_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "147-150",
          "snippet": "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nconst struct clock_event_device *tick_get_wakeup_device(int cpu)\n{\n\treturn tick_get_oneshot_wakeup_device(cpu);\n}"
  },
  {
    "function_name": "tick_get_broadcast_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "61-64",
    "snippet": "struct cpumask *tick_get_broadcast_mask(void)\n{\n\treturn tick_broadcast_mask;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t tick_broadcast_mask"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstruct cpumask *tick_get_broadcast_mask(void)\n{\n\treturn tick_broadcast_mask;\n}"
  },
  {
    "function_name": "tick_get_broadcast_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "56-59",
    "snippet": "struct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstruct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}"
  },
  {
    "function_name": "tick_broadcast_oneshot_offline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "49-49",
    "snippet": "static inline void tick_broadcast_oneshot_offline(unsigned int cpu) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic inline void tick_broadcast_oneshot_offline(unsigned int cpu) { }"
  },
  {
    "function_name": "tick_resume_broadcast_oneshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "47-47",
    "snippet": "static inline void tick_resume_broadcast_oneshot(struct clock_event_device *bc) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_resume_broadcast_oneshot(struct clock_event_device *bc) { }"
  },
  {
    "function_name": "tick_broadcast_clear_oneshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "46-46",
    "snippet": "static inline void tick_broadcast_clear_oneshot(int cpu) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nstatic inline void tick_broadcast_clear_oneshot(int cpu) { }"
  },
  {
    "function_name": "tick_broadcast_setup_oneshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
    "lines": "45-45",
    "snippet": "static inline void tick_broadcast_setup_oneshot(struct clock_event_device *bc) { BUG(); }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_broadcast_setup_oneshot(struct clock_event_device *bc) { BUG(); }"
  }
]