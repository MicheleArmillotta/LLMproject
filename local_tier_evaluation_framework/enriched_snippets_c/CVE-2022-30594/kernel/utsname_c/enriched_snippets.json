[
  {
    "function_name": "uts_ns_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "169-177",
    "snippet": "void __init uts_ns_init(void)\n{\n\tuts_ns_cache = kmem_cache_create_usercopy(\n\t\t\t\"uts_namespace\", sizeof(struct uts_namespace), 0,\n\t\t\tSLAB_PANIC|SLAB_ACCOUNT,\n\t\t\toffsetof(struct uts_namespace, name),\n\t\t\tsizeof_field(struct uts_namespace, name),\n\t\t\tNULL);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *uts_ns_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create_usercopy",
          "args": [
            "\"uts_namespace\"",
            "sizeof(struct uts_namespace)",
            "0",
            "SLAB_PANIC|SLAB_ACCOUNT",
            "offsetof(struct uts_namespace, name)",
            "sizeof_field(struct uts_namespace, name)",
            "NULL"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeof_field",
          "args": [
            "structuts_namespace",
            "name"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *uts_ns_cache;\n\nvoid __init uts_ns_init(void)\n{\n\tuts_ns_cache = kmem_cache_create_usercopy(\n\t\t\t\"uts_namespace\", sizeof(struct uts_namespace), 0,\n\t\t\tSLAB_PANIC|SLAB_ACCOUNT,\n\t\t\toffsetof(struct uts_namespace, name),\n\t\t\tsizeof_field(struct uts_namespace, name),\n\t\t\tNULL);\n}"
  },
  {
    "function_name": "utsns_owner",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "155-158",
    "snippet": "static struct user_namespace *utsns_owner(struct ns_common *ns)\n{\n\treturn to_uts_ns(ns)->user_ns;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_uts_ns",
          "args": [
            "ns"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "to_uts_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
          "lines": "114-117",
          "snippet": "static inline struct uts_namespace *to_uts_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct uts_namespace, ns);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic inline struct uts_namespace *to_uts_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct uts_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct user_namespace *utsns_owner(struct ns_common *ns)\n{\n\treturn to_uts_ns(ns)->user_ns;\n}"
  },
  {
    "function_name": "utsns_install",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "140-153",
    "snippet": "static int utsns_install(struct nsset *nsset, struct ns_common *new)\n{\n\tstruct nsproxy *nsproxy = nsset->nsproxy;\n\tstruct uts_namespace *ns = to_uts_ns(new);\n\n\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tget_uts_ns(ns);\n\tput_uts_ns(nsproxy->uts_ns);\n\tnsproxy->uts_ns = ns;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uts_ns",
          "args": [
            "nsproxy->uts_ns"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uts_ns",
          "args": [
            "ns"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "nsset->cred->user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_setid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "431-434",
          "snippet": "bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_uts_ns",
          "args": [
            "new"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "to_uts_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
          "lines": "114-117",
          "snippet": "static inline struct uts_namespace *to_uts_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct uts_namespace, ns);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic inline struct uts_namespace *to_uts_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct uts_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic int utsns_install(struct nsset *nsset, struct ns_common *new)\n{\n\tstruct nsproxy *nsproxy = nsset->nsproxy;\n\tstruct uts_namespace *ns = to_uts_ns(new);\n\n\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tget_uts_ns(ns);\n\tput_uts_ns(nsproxy->uts_ns);\n\tnsproxy->uts_ns = ns;\n\treturn 0;\n}"
  },
  {
    "function_name": "utsns_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "135-138",
    "snippet": "static void utsns_put(struct ns_common *ns)\n{\n\tput_uts_ns(to_uts_ns(ns));\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uts_ns",
          "args": [
            "to_uts_ns(ns)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_uts_ns",
          "args": [
            "ns"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "to_uts_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
          "lines": "114-117",
          "snippet": "static inline struct uts_namespace *to_uts_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct uts_namespace, ns);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic inline struct uts_namespace *to_uts_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct uts_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic void utsns_put(struct ns_common *ns)\n{\n\tput_uts_ns(to_uts_ns(ns));\n}"
  },
  {
    "function_name": "utsns_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "119-133",
    "snippet": "static struct ns_common *utsns_get(struct task_struct *task)\n{\n\tstruct uts_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->uts_ns;\n\t\tget_uts_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\treturn ns ? &ns->ns : NULL;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uts_ns",
          "args": [
            "ns"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct ns_common *utsns_get(struct task_struct *task)\n{\n\tstruct uts_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->uts_ns;\n\t\tget_uts_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\treturn ns ? &ns->ns : NULL;\n}"
  },
  {
    "function_name": "to_uts_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "114-117",
    "snippet": "static inline struct uts_namespace *to_uts_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct uts_namespace, ns);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ns",
            "structuts_namespace",
            "ns"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic inline struct uts_namespace *to_uts_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct uts_namespace, ns);\n}"
  },
  {
    "function_name": "free_uts_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "106-112",
    "snippet": "void free_uts_ns(struct uts_namespace *ns)\n{\n\tdec_uts_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\tns_free_inum(&ns->ns);\n\tkmem_cache_free(uts_ns_cache, ns);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *uts_ns_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "uts_ns_cache",
            "ns"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_free_inum",
          "args": [
            "&ns->ns"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "ns->user_ns"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__put_user_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "208-211",
          "snippet": "void __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_user_ns(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void free_user_ns(struct work_struct *work);\n\nvoid __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_uts_namespaces",
          "args": [
            "ns->ucounts"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "dec_uts_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
          "lines": "25-28",
          "snippet": "static void dec_uts_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_UTS_NAMESPACES);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic void dec_uts_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_UTS_NAMESPACES);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *uts_ns_cache;\n\nvoid free_uts_ns(struct uts_namespace *ns)\n{\n\tdec_uts_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\tns_free_inum(&ns->ns);\n\tkmem_cache_free(uts_ns_cache, ns);\n}"
  },
  {
    "function_name": "copy_utsname",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "89-104",
    "snippet": "struct uts_namespace *copy_utsname(unsigned long flags,\n\tstruct user_namespace *user_ns, struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *new_ns;\n\n\tBUG_ON(!old_ns);\n\tget_uts_ns(old_ns);\n\n\tif (!(flags & CLONE_NEWUTS))\n\t\treturn old_ns;\n\n\tnew_ns = clone_uts_ns(user_ns, old_ns);\n\n\tput_uts_ns(old_ns);\n\treturn new_ns;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uts_ns",
          "args": [
            "old_ns"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone_uts_ns",
          "args": [
            "user_ns",
            "old_ns"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "clone_uts_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
          "lines": "45-81",
          "snippet": "static struct uts_namespace *clone_uts_ns(struct user_namespace *user_ns,\n\t\t\t\t\t  struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *ns;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -ENOSPC;\n\tucounts = inc_uts_namespaces(user_ns);\n\tif (!ucounts)\n\t\tgoto fail;\n\n\terr = -ENOMEM;\n\tns = create_uts_ns();\n\tif (!ns)\n\t\tgoto fail_dec;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto fail_free;\n\n\tns->ucounts = ucounts;\n\tns->ns.ops = &utsns_operations;\n\n\tdown_read(&uts_sem);\n\tmemcpy(&ns->name, &old_ns->name, sizeof(ns->name));\n\tns->user_ns = get_user_ns(user_ns);\n\tup_read(&uts_sem);\n\treturn ns;\n\nfail_free:\n\tkmem_cache_free(uts_ns_cache, ns);\nfail_dec:\n\tdec_uts_namespaces(ucounts);\nfail:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *uts_ns_cache",
            "const struct proc_ns_operations utsns_operations = {\n\t.name\t\t= \"uts\",\n\t.type\t\t= CLONE_NEWUTS,\n\t.get\t\t= utsns_get,\n\t.put\t\t= utsns_put,\n\t.install\t= utsns_install,\n\t.owner\t\t= utsns_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *uts_ns_cache;\nconst struct proc_ns_operations utsns_operations = {\n\t.name\t\t= \"uts\",\n\t.type\t\t= CLONE_NEWUTS,\n\t.get\t\t= utsns_get,\n\t.put\t\t= utsns_put,\n\t.install\t= utsns_install,\n\t.owner\t\t= utsns_owner,\n};\n\nstatic struct uts_namespace *clone_uts_ns(struct user_namespace *user_ns,\n\t\t\t\t\t  struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *ns;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -ENOSPC;\n\tucounts = inc_uts_namespaces(user_ns);\n\tif (!ucounts)\n\t\tgoto fail;\n\n\terr = -ENOMEM;\n\tns = create_uts_ns();\n\tif (!ns)\n\t\tgoto fail_dec;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto fail_free;\n\n\tns->ucounts = ucounts;\n\tns->ns.ops = &utsns_operations;\n\n\tdown_read(&uts_sem);\n\tmemcpy(&ns->name, &old_ns->name, sizeof(ns->name));\n\tns->user_ns = get_user_ns(user_ns);\n\tup_read(&uts_sem);\n\treturn ns;\n\nfail_free:\n\tkmem_cache_free(uts_ns_cache, ns);\nfail_dec:\n\tdec_uts_namespaces(ucounts);\nfail:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_uts_ns",
          "args": [
            "old_ns"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!old_ns"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstruct uts_namespace *copy_utsname(unsigned long flags,\n\tstruct user_namespace *user_ns, struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *new_ns;\n\n\tBUG_ON(!old_ns);\n\tget_uts_ns(old_ns);\n\n\tif (!(flags & CLONE_NEWUTS))\n\t\treturn old_ns;\n\n\tnew_ns = clone_uts_ns(user_ns, old_ns);\n\n\tput_uts_ns(old_ns);\n\treturn new_ns;\n}"
  },
  {
    "function_name": "clone_uts_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "45-81",
    "snippet": "static struct uts_namespace *clone_uts_ns(struct user_namespace *user_ns,\n\t\t\t\t\t  struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *ns;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -ENOSPC;\n\tucounts = inc_uts_namespaces(user_ns);\n\tif (!ucounts)\n\t\tgoto fail;\n\n\terr = -ENOMEM;\n\tns = create_uts_ns();\n\tif (!ns)\n\t\tgoto fail_dec;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto fail_free;\n\n\tns->ucounts = ucounts;\n\tns->ns.ops = &utsns_operations;\n\n\tdown_read(&uts_sem);\n\tmemcpy(&ns->name, &old_ns->name, sizeof(ns->name));\n\tns->user_ns = get_user_ns(user_ns);\n\tup_read(&uts_sem);\n\treturn ns;\n\nfail_free:\n\tkmem_cache_free(uts_ns_cache, ns);\nfail_dec:\n\tdec_uts_namespaces(ucounts);\nfail:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *uts_ns_cache",
      "const struct proc_ns_operations utsns_operations = {\n\t.name\t\t= \"uts\",\n\t.type\t\t= CLONE_NEWUTS,\n\t.get\t\t= utsns_get,\n\t.put\t\t= utsns_put,\n\t.install\t= utsns_install,\n\t.owner\t\t= utsns_owner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_uts_namespaces",
          "args": [
            "ucounts"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "dec_uts_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
          "lines": "25-28",
          "snippet": "static void dec_uts_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_UTS_NAMESPACES);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic void dec_uts_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_UTS_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "uts_ns_cache",
            "ns"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&uts_sem"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "user_ns"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ns->name",
            "&old_ns->name",
            "sizeof(ns->name)"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&uts_sem"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_alloc_inum",
          "args": [
            "&ns->ns"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_uts_ns",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "create_uts_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
          "lines": "30-38",
          "snippet": "static struct uts_namespace *create_uts_ns(void)\n{\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = kmem_cache_alloc(uts_ns_cache, GFP_KERNEL);\n\tif (uts_ns)\n\t\trefcount_set(&uts_ns->ns.count, 1);\n\treturn uts_ns;\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *uts_ns_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *uts_ns_cache;\n\nstatic struct uts_namespace *create_uts_ns(void)\n{\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = kmem_cache_alloc(uts_ns_cache, GFP_KERNEL);\n\tif (uts_ns)\n\t\trefcount_set(&uts_ns->ns.count, 1);\n\treturn uts_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_uts_namespaces",
          "args": [
            "user_ns"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "inc_uts_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
          "lines": "20-23",
          "snippet": "static struct ucounts *inc_uts_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_UTS_NAMESPACES);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct ucounts *inc_uts_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_UTS_NAMESPACES);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *uts_ns_cache;\nconst struct proc_ns_operations utsns_operations = {\n\t.name\t\t= \"uts\",\n\t.type\t\t= CLONE_NEWUTS,\n\t.get\t\t= utsns_get,\n\t.put\t\t= utsns_put,\n\t.install\t= utsns_install,\n\t.owner\t\t= utsns_owner,\n};\n\nstatic struct uts_namespace *clone_uts_ns(struct user_namespace *user_ns,\n\t\t\t\t\t  struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *ns;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -ENOSPC;\n\tucounts = inc_uts_namespaces(user_ns);\n\tif (!ucounts)\n\t\tgoto fail;\n\n\terr = -ENOMEM;\n\tns = create_uts_ns();\n\tif (!ns)\n\t\tgoto fail_dec;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto fail_free;\n\n\tns->ucounts = ucounts;\n\tns->ns.ops = &utsns_operations;\n\n\tdown_read(&uts_sem);\n\tmemcpy(&ns->name, &old_ns->name, sizeof(ns->name));\n\tns->user_ns = get_user_ns(user_ns);\n\tup_read(&uts_sem);\n\treturn ns;\n\nfail_free:\n\tkmem_cache_free(uts_ns_cache, ns);\nfail_dec:\n\tdec_uts_namespaces(ucounts);\nfail:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "create_uts_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "30-38",
    "snippet": "static struct uts_namespace *create_uts_ns(void)\n{\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = kmem_cache_alloc(uts_ns_cache, GFP_KERNEL);\n\tif (uts_ns)\n\t\trefcount_set(&uts_ns->ns.count, 1);\n\treturn uts_ns;\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *uts_ns_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&uts_ns->ns.count",
            "1"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "uts_ns_cache",
            "GFP_KERNEL"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *uts_ns_cache;\n\nstatic struct uts_namespace *create_uts_ns(void)\n{\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = kmem_cache_alloc(uts_ns_cache, GFP_KERNEL);\n\tif (uts_ns)\n\t\trefcount_set(&uts_ns->ns.count, 1);\n\treturn uts_ns;\n}"
  },
  {
    "function_name": "dec_uts_namespaces",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "25-28",
    "snippet": "static void dec_uts_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_UTS_NAMESPACES);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_ucount",
          "args": [
            "ucounts",
            "UCOUNT_UTS_NAMESPACES"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "dec_ucount",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "254-262",
          "snippet": "void dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic void dec_uts_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_UTS_NAMESPACES);\n}"
  },
  {
    "function_name": "inc_uts_namespaces",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
    "lines": "20-23",
    "snippet": "static struct ucounts *inc_uts_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_UTS_NAMESPACES);\n}",
    "includes": [
      "#include <linux/sched/task.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_ucount",
          "args": [
            "ns",
            "current_euid()",
            "UCOUNT_UTS_NAMESPACES"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "inc_ucount",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "231-252",
          "snippet": "struct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = alloc_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tlong max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_long_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_long_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = alloc_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tlong max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_long_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_long_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct ucounts *inc_uts_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_UTS_NAMESPACES);\n}"
  }
]