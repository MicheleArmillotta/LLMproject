[
  {
    "function_name": "trace_preempt_off",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
    "lines": "127-132",
    "snippet": "void trace_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_disable_rcuidle(a0, a1);\n\ttracer_preempt_off(a0, a1);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracer_preempt_off",
          "args": [
            "a0",
            "a1"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_preempt_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "662-666",
          "snippet": "void tracer_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (preempt_trace(preempt_count()) && !irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (preempt_trace(preempt_count()) && !irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_preempt_disable_rcuidle",
          "args": [
            "a0",
            "a1"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_disable_rcuidle(a0, a1);\n\ttracer_preempt_off(a0, a1);\n}"
  },
  {
    "function_name": "trace_preempt_on",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
    "lines": "120-125",
    "snippet": "void trace_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_enable_rcuidle(a0, a1);\n\ttracer_preempt_on(a0, a1);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracer_preempt_on",
          "args": [
            "a0",
            "a1"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_preempt_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "656-660",
          "snippet": "void tracer_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (preempt_trace(preempt_count()) && !irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (preempt_trace(preempt_count()) && !irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_preempt_enable_rcuidle",
          "args": [
            "a0",
            "a1"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_enable_rcuidle(a0, a1);\n\ttracer_preempt_on(a0, a1);\n}"
  },
  {
    "function_name": "trace_hardirqs_off_caller",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
    "lines": "103-113",
    "snippet": "__visible void trace_hardirqs_off_caller(unsigned long caller_addr)\n{\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, caller_addr);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable_rcuidle(CALLER_ADDR0, caller_addr);\n\t}\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_disable_rcuidle",
          "args": [
            "CALLER_ADDR0",
            "caller_addr"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_hardirqs_off",
          "args": [
            "CALLER_ADDR0",
            "caller_addr"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_hardirqs_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "615-619",
          "snippet": "void tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tracing_irq_cpu",
            "1"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tracing_irq_cpu"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_off",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4364-4400",
          "snippet": "void noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n__visible void trace_hardirqs_off_caller(unsigned long caller_addr)\n{\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, caller_addr);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable_rcuidle(CALLER_ADDR0, caller_addr);\n\t}\n}"
  },
  {
    "function_name": "trace_hardirqs_on_caller",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
    "lines": "88-99",
    "snippet": "__visible void trace_hardirqs_on_caller(unsigned long caller_addr)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable_rcuidle(CALLER_ADDR0, caller_addr);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, caller_addr);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4297-4358",
          "snippet": "void noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on_prepare",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4244-4294",
          "snippet": "void lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tracing_irq_cpu",
            "0"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_hardirqs_on",
          "args": [
            "CALLER_ADDR0",
            "caller_addr"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_hardirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "608-612",
          "snippet": "void tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_irq_enable_rcuidle",
          "args": [
            "CALLER_ADDR0",
            "caller_addr"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tracing_irq_cpu"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n__visible void trace_hardirqs_on_caller(unsigned long caller_addr)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable_rcuidle(CALLER_ADDR0, caller_addr);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, caller_addr);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}"
  },
  {
    "function_name": "trace_hardirqs_off",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
    "lines": "74-84",
    "snippet": "void trace_hardirqs_off(void)\n{\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable_rcuidle(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_disable_rcuidle",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_hardirqs_off",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_hardirqs_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "615-619",
          "snippet": "void tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tracing_irq_cpu",
            "1"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tracing_irq_cpu"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_off",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4364-4400",
          "snippet": "void noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_off(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * Matching lockdep_hardirqs_on(), allow NMIs in the middle of lockdep;\n\t * they will restore the software state. This ensures the software\n\t * state is consistent inside NMIs as well.\n\t */\n\tif (in_nmi()) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\t} else if (__this_cpu_read(lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\t__this_cpu_write(hardirqs_enabled, 0);\n\t\ttrace->hardirq_disable_ip = ip;\n\t\ttrace->hardirq_disable_event = ++trace->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else {\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_off(void)\n{\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable_rcuidle(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n}"
  },
  {
    "function_name": "trace_hardirqs_off_finish",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
    "lines": "61-70",
    "snippet": "void trace_hardirqs_off_finish(void)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_disable",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_hardirqs_off",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_hardirqs_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "615-619",
          "snippet": "void tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tracing_irq_cpu",
            "1"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tracing_irq_cpu"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_off_finish(void)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n\n}"
  },
  {
    "function_name": "trace_hardirqs_on",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
    "lines": "40-51",
    "snippet": "void trace_hardirqs_on(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable_rcuidle(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4297-4358",
          "snippet": "void noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid noinstr lockdep_hardirqs_on(unsigned long ip)\n{\n\tstruct irqtrace_events *trace = &current->irqtrace;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs can happen in the middle of local_irq_{en,dis}able() where the\n\t * tracking state and hardware state are out of sync.\n\t *\n\t * NMIs must save lockdep_hardirqs_enabled() to restore IRQ state from,\n\t * and not rely on hardware state like normal interrupts.\n\t */\n\tif (unlikely(in_nmi())) {\n\t\tif (!IS_ENABLED(CONFIG_TRACE_IRQFLAGS_NMI))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Skip:\n\t\t *  - recursion check, because NMI can hit lockdep;\n\t\t *  - hardware state check, because above;\n\t\t *  - chain_key check, see lockdep_hardirqs_on_prepare().\n\t\t */\n\t\tgoto skip_checks;\n\t}\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (lockdep_hardirqs_enabled()) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * Ensure the lock stack remained unchanged between\n\t * lockdep_hardirqs_on_prepare() and lockdep_hardirqs_on().\n\t */\n\tDEBUG_LOCKS_WARN_ON(current->hardirq_chain_key !=\n\t\t\t    current->curr_chain_key);\n\nskip_checks:\n\t/* we'll do an OFF -> ON transition: */\n\t__this_cpu_write(hardirqs_enabled, 1);\n\ttrace->hardirq_enable_ip = ip;\n\ttrace->hardirq_enable_event = ++trace->irq_events;\n\tdebug_atomic_inc(hardirqs_on_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on_prepare",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4244-4294",
          "snippet": "void lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_on_prepare(unsigned long ip)\n{\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\t/*\n\t * NMIs do not (and cannot) track lock dependencies, nothing to do.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\tif (unlikely(this_cpu_read(lockdep_recursion)))\n\t\treturn;\n\n\tif (unlikely(lockdep_hardirqs_enabled())) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(early_boot_irqs_disabled))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(lockdep_hardirq_context()))\n\t\treturn;\n\n\tcurrent->hardirq_chain_key = current->curr_chain_key;\n\n\tlockdep_recursion_inc();\n\t__trace_hardirqs_on_caller();\n\tlockdep_recursion_finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tracing_irq_cpu",
            "0"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_hardirqs_on",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_hardirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "608-612",
          "snippet": "void tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_irq_enable_rcuidle",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tracing_irq_cpu"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_on(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable_rcuidle(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n\n\tlockdep_hardirqs_on_prepare(CALLER_ADDR0);\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}"
  },
  {
    "function_name": "trace_hardirqs_on_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_preemptirq.c",
    "lines": "28-36",
    "snippet": "void trace_hardirqs_on_prepare(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tracing_irq_cpu",
            "0"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_hardirqs_on",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_hardirqs_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "608-612",
          "snippet": "void tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_irq_enable",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tracing_irq_cpu"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_on_prepare(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n}"
  }
]