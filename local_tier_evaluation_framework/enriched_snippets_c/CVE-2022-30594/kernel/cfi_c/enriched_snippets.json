[
  {
    "function_name": "cfi_failure_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "325-328",
    "snippet": "void cfi_failure_handler(void *data, void *ptr, void *vtable)\n{\n\thandle_cfi_failure(ptr);\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [
      "#define cfi_failure_handler\t__ubsan_handle_cfi_check_fail_abort",
      "#define cfi_failure_handler\t__ubsan_handle_cfi_check_fail"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_cfi_failure",
          "args": [
            "ptr"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "handle_cfi_failure",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "26-32",
          "snippet": "static inline void handle_cfi_failure(void *ptr)\n{\n\tif (IS_ENABLED(CONFIG_CFI_PERMISSIVE))\n\t\tWARN_RATELIMIT(1, \"CFI failure (target: %pS):\\n\", ptr);\n\telse\n\t\tpanic(\"CFI failure (target: %pS)\\n\", ptr);\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline void handle_cfi_failure(void *ptr)\n{\n\tif (IS_ENABLED(CONFIG_CFI_PERMISSIVE))\n\t\tWARN_RATELIMIT(1, \"CFI failure (target: %pS):\\n\", ptr);\n\telse\n\t\tpanic(\"CFI failure (target: %pS)\\n\", ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define cfi_failure_handler\t__ubsan_handle_cfi_check_fail_abort\n#define cfi_failure_handler\t__ubsan_handle_cfi_check_fail\n\nvoid cfi_failure_handler(void *data, void *ptr, void *vtable)\n{\n\thandle_cfi_failure(ptr);\n}"
  },
  {
    "function_name": "__cfi_slowpath_diag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "317-320",
    "snippet": "void __cfi_slowpath_diag(uint64_t id, void *ptr, void *diag)\n{\n\thandle_cfi_failure(ptr); /* No modules */\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_cfi_failure",
          "args": [
            "ptr"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "handle_cfi_failure",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "26-32",
          "snippet": "static inline void handle_cfi_failure(void *ptr)\n{\n\tif (IS_ENABLED(CONFIG_CFI_PERMISSIVE))\n\t\tWARN_RATELIMIT(1, \"CFI failure (target: %pS):\\n\", ptr);\n\telse\n\t\tpanic(\"CFI failure (target: %pS)\\n\", ptr);\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline void handle_cfi_failure(void *ptr)\n{\n\tif (IS_ENABLED(CONFIG_CFI_PERMISSIVE))\n\t\tWARN_RATELIMIT(1, \"CFI failure (target: %pS):\\n\", ptr);\n\telse\n\t\tpanic(\"CFI failure (target: %pS)\\n\", ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nvoid __cfi_slowpath_diag(uint64_t id, void *ptr, void *diag)\n{\n\thandle_cfi_failure(ptr); /* No modules */\n}"
  },
  {
    "function_name": "__cfi_slowpath_diag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "304-312",
    "snippet": "void __cfi_slowpath_diag(uint64_t id, void *ptr, void *diag)\n{\n\tcfi_check_fn fn = find_check_fn((unsigned long)ptr);\n\n\tif (likely(fn))\n\t\tfn(id, ptr, diag);\n\telse /* Don't allow unchecked modules */\n\t\thandle_cfi_failure(ptr);\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_cfi_failure",
          "args": [
            "ptr"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "handle_cfi_failure",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "26-32",
          "snippet": "static inline void handle_cfi_failure(void *ptr)\n{\n\tif (IS_ENABLED(CONFIG_CFI_PERMISSIVE))\n\t\tWARN_RATELIMIT(1, \"CFI failure (target: %pS):\\n\", ptr);\n\telse\n\t\tpanic(\"CFI failure (target: %pS)\\n\", ptr);\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline void handle_cfi_failure(void *ptr)\n{\n\tif (IS_ENABLED(CONFIG_CFI_PERMISSIVE))\n\t\tWARN_RATELIMIT(1, \"CFI failure (target: %pS):\\n\", ptr);\n\telse\n\t\tpanic(\"CFI failure (target: %pS)\\n\", ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "id",
            "ptr",
            "diag"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "fnpid_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7541-7551",
          "snippet": "static void *fnpid_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list = rcu_dereference_sched(tr->function_no_pids);\n\n\tif (v == FTRACE_NO_PIDS) {\n\t\t(*pos)++;\n\t\treturn NULL;\n\t}\n\treturn trace_pid_next(pid_list, v, pos);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_NO_PIDS\t\t(void *)(PID_MAX_LIMIT + 1)\n\nstatic void *fnpid_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list = rcu_dereference_sched(tr->function_no_pids);\n\n\tif (v == FTRACE_NO_PIDS) {\n\t\t(*pos)++;\n\t\treturn NULL;\n\t}\n\treturn trace_pid_next(pid_list, v, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "fn"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_check_fn",
          "args": [
            "(unsigned long)ptr"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "find_check_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "281-302",
          "snippet": "static inline cfi_check_fn find_check_fn(unsigned long ptr)\n{\n\tcfi_check_fn fn = NULL;\n\n\tif (is_kernel_text(ptr))\n\t\treturn __cfi_check;\n\n\t/*\n\t * Indirect call checks can happen when RCU is not watching. Both\n\t * the shadow and __module_address use RCU, so we need to wake it\n\t * up if necessary.\n\t */\n\tRCU_NONIDLE({\n\t\tif (IS_ENABLED(CONFIG_CFI_CLANG_SHADOW))\n\t\t\tfn = find_shadow_check_fn(ptr);\n\n\t\tif (!fn)\n\t\t\tfn = find_module_check_fn(ptr);\n\t});\n\n\treturn fn;\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline cfi_check_fn find_check_fn(unsigned long ptr)\n{\n\tcfi_check_fn fn = NULL;\n\n\tif (is_kernel_text(ptr))\n\t\treturn __cfi_check;\n\n\t/*\n\t * Indirect call checks can happen when RCU is not watching. Both\n\t * the shadow and __module_address use RCU, so we need to wake it\n\t * up if necessary.\n\t */\n\tRCU_NONIDLE({\n\t\tif (IS_ENABLED(CONFIG_CFI_CLANG_SHADOW))\n\t\t\tfn = find_shadow_check_fn(ptr);\n\n\t\tif (!fn)\n\t\t\tfn = find_module_check_fn(ptr);\n\t});\n\n\treturn fn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nvoid __cfi_slowpath_diag(uint64_t id, void *ptr, void *diag)\n{\n\tcfi_check_fn fn = find_check_fn((unsigned long)ptr);\n\n\tif (likely(fn))\n\t\tfn(id, ptr, diag);\n\telse /* Don't allow unchecked modules */\n\t\thandle_cfi_failure(ptr);\n}"
  },
  {
    "function_name": "find_check_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "281-302",
    "snippet": "static inline cfi_check_fn find_check_fn(unsigned long ptr)\n{\n\tcfi_check_fn fn = NULL;\n\n\tif (is_kernel_text(ptr))\n\t\treturn __cfi_check;\n\n\t/*\n\t * Indirect call checks can happen when RCU is not watching. Both\n\t * the shadow and __module_address use RCU, so we need to wake it\n\t * up if necessary.\n\t */\n\tRCU_NONIDLE({\n\t\tif (IS_ENABLED(CONFIG_CFI_CLANG_SHADOW))\n\t\t\tfn = find_shadow_check_fn(ptr);\n\n\t\tif (!fn)\n\t\t\tfn = find_module_check_fn(ptr);\n\t});\n\n\treturn fn;\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RCU_NONIDLE",
          "args": [
            "{\n\t\tif (IS_ENABLED(CONFIG_CFI_CLANG_SHADOW))\n\t\t\tfn = find_shadow_check_fn(ptr);\n\n\t\tif (!fn)\n\t\t\tfn = find_module_check_fn(ptr);\n\t}"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_module_check_fn",
          "args": [
            "ptr"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "find_module_check_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "267-279",
          "snippet": "static inline cfi_check_fn find_module_check_fn(unsigned long ptr)\n{\n\tcfi_check_fn fn = NULL;\n\tstruct module *mod;\n\n\trcu_read_lock_sched_notrace();\n\tmod = __module_address(ptr);\n\tif (mod)\n\t\tfn = mod->cfi_check;\n\trcu_read_unlock_sched_notrace();\n\n\treturn fn;\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline cfi_check_fn find_module_check_fn(unsigned long ptr)\n{\n\tcfi_check_fn fn = NULL;\n\tstruct module *mod;\n\n\trcu_read_lock_sched_notrace();\n\tmod = __module_address(ptr);\n\tif (mod)\n\t\tfn = mod->cfi_check;\n\trcu_read_unlock_sched_notrace();\n\n\treturn fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_shadow_check_fn",
          "args": [
            "ptr"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "find_shadow_check_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "260-263",
          "snippet": "static inline cfi_check_fn find_shadow_check_fn(unsigned long ptr)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline cfi_check_fn find_shadow_check_fn(unsigned long ptr)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CFI_CLANG_SHADOW"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_kernel_text",
          "args": [
            "ptr"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "func_ptr_is_kernel_text",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/extable.c",
          "lines": "141-148",
          "snippet": "int func_ptr_is_kernel_text(void *ptr)\n{\n\tunsigned long addr;\n\taddr = (unsigned long) dereference_function_descriptor(ptr);\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\treturn is_module_text_address(addr);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/sections.h>",
            "#include <linux/filter.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/extable.h>",
            "#include <linux/memory.h>",
            "#include <linux/ftrace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/sections.h>\n#include <linux/filter.h>\n#include <linux/kprobes.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/extable.h>\n#include <linux/memory.h>\n#include <linux/ftrace.h>\n\nint func_ptr_is_kernel_text(void *ptr)\n{\n\tunsigned long addr;\n\taddr = (unsigned long) dereference_function_descriptor(ptr);\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\treturn is_module_text_address(addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline cfi_check_fn find_check_fn(unsigned long ptr)\n{\n\tcfi_check_fn fn = NULL;\n\n\tif (is_kernel_text(ptr))\n\t\treturn __cfi_check;\n\n\t/*\n\t * Indirect call checks can happen when RCU is not watching. Both\n\t * the shadow and __module_address use RCU, so we need to wake it\n\t * up if necessary.\n\t */\n\tRCU_NONIDLE({\n\t\tif (IS_ENABLED(CONFIG_CFI_CLANG_SHADOW))\n\t\t\tfn = find_shadow_check_fn(ptr);\n\n\t\tif (!fn)\n\t\t\tfn = find_module_check_fn(ptr);\n\t});\n\n\treturn fn;\n}"
  },
  {
    "function_name": "find_module_check_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "267-279",
    "snippet": "static inline cfi_check_fn find_module_check_fn(unsigned long ptr)\n{\n\tcfi_check_fn fn = NULL;\n\tstruct module *mod;\n\n\trcu_read_lock_sched_notrace();\n\tmod = __module_address(ptr);\n\tif (mod)\n\t\tfn = mod->cfi_check;\n\trcu_read_unlock_sched_notrace();\n\n\treturn fn;\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched_notrace",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__module_address",
          "args": [
            "ptr"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "__module_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4736-4752",
          "snippet": "struct module *__module_address(unsigned long addr)\n{\n\tstruct module *mod;\n\n\tif (addr < module_addr_min || addr > module_addr_max)\n\t\treturn NULL;\n\n\tmodule_assert_mutex_or_preempt();\n\n\tmod = mod_find(addr);\n\tif (mod) {\n\t\tBUG_ON(!within_module(addr, mod));\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define module_addr_max mod_tree.addr_max",
            "#define module_addr_min mod_tree.addr_min"
          ],
          "globals_used": [
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\n#define module_addr_max mod_tree.addr_max\n#define module_addr_min mod_tree.addr_min\n\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nstruct module *__module_address(unsigned long addr)\n{\n\tstruct module *mod;\n\n\tif (addr < module_addr_min || addr > module_addr_max)\n\t\treturn NULL;\n\n\tmodule_assert_mutex_or_preempt();\n\n\tmod = mod_find(addr);\n\tif (mod) {\n\t\tBUG_ON(!within_module(addr, mod));\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched_notrace",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline cfi_check_fn find_module_check_fn(unsigned long ptr)\n{\n\tcfi_check_fn fn = NULL;\n\tstruct module *mod;\n\n\trcu_read_lock_sched_notrace();\n\tmod = __module_address(ptr);\n\tif (mod)\n\t\tfn = mod->cfi_check;\n\trcu_read_unlock_sched_notrace();\n\n\treturn fn;\n}"
  },
  {
    "function_name": "find_shadow_check_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "260-263",
    "snippet": "static inline cfi_check_fn find_shadow_check_fn(unsigned long ptr)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline cfi_check_fn find_shadow_check_fn(unsigned long ptr)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_shadow_check_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "247-256",
    "snippet": "static inline cfi_check_fn find_shadow_check_fn(unsigned long ptr)\n{\n\tcfi_check_fn fn;\n\n\trcu_read_lock_sched_notrace();\n\tfn = ptr_to_check_fn(rcu_dereference_sched(cfi_shadow), ptr);\n\trcu_read_unlock_sched_notrace();\n\n\treturn fn;\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched_notrace",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_check_fn",
          "args": [
            "rcu_dereference_sched(cfi_shadow)",
            "ptr"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ptr_to_check_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "232-245",
          "snippet": "static inline cfi_check_fn ptr_to_check_fn(const struct cfi_shadow __rcu *s,\n\tunsigned long ptr)\n{\n\tint index;\n\n\tif (unlikely(!s))\n\t\treturn NULL; /* No shadow available */\n\n\tindex = ptr_to_shadow(s, ptr);\n\tif (index < 0)\n\t\treturn NULL; /* Cannot be addressed with shadow */\n\n\treturn (cfi_check_fn)shadow_to_check_fn(s, index);\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline cfi_check_fn ptr_to_check_fn(const struct cfi_shadow __rcu *s,\n\tunsigned long ptr)\n{\n\tint index;\n\n\tif (unlikely(!s))\n\t\treturn NULL; /* No shadow available */\n\n\tindex = ptr_to_shadow(s, ptr);\n\tif (index < 0)\n\t\treturn NULL; /* Cannot be addressed with shadow */\n\n\treturn (cfi_check_fn)shadow_to_check_fn(s, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "cfi_shadow"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched_notrace",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline cfi_check_fn find_shadow_check_fn(unsigned long ptr)\n{\n\tcfi_check_fn fn;\n\n\trcu_read_lock_sched_notrace();\n\tfn = ptr_to_check_fn(rcu_dereference_sched(cfi_shadow), ptr);\n\trcu_read_unlock_sched_notrace();\n\n\treturn fn;\n}"
  },
  {
    "function_name": "ptr_to_check_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "232-245",
    "snippet": "static inline cfi_check_fn ptr_to_check_fn(const struct cfi_shadow __rcu *s,\n\tunsigned long ptr)\n{\n\tint index;\n\n\tif (unlikely(!s))\n\t\treturn NULL; /* No shadow available */\n\n\tindex = ptr_to_shadow(s, ptr);\n\tif (index < 0)\n\t\treturn NULL; /* Cannot be addressed with shadow */\n\n\treturn (cfi_check_fn)shadow_to_check_fn(s, index);\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shadow_to_check_fn",
          "args": [
            "s",
            "index"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_to_check_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "96-107",
          "snippet": "static inline unsigned long shadow_to_check_fn(const struct cfi_shadow *s,\n\tint index)\n{\n\tif (unlikely(index < 0 || index >= SHADOW_ARR_SLOTS))\n\t\treturn 0;\n\n\tif (unlikely(s->shadow[index] == SHADOW_INVALID))\n\t\treturn 0;\n\n\t/* __cfi_check is always page aligned */\n\treturn (s->base + s->shadow[index]) << PAGE_SHIFT;\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [
            "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))",
            "#define SHADOW_INVALID\t\t((shadow_t)~0UL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n#define SHADOW_INVALID\t\t((shadow_t)~0UL)\n\nstatic inline unsigned long shadow_to_check_fn(const struct cfi_shadow *s,\n\tint index)\n{\n\tif (unlikely(index < 0 || index >= SHADOW_ARR_SLOTS))\n\t\treturn 0;\n\n\tif (unlikely(s->shadow[index] == SHADOW_INVALID))\n\t\treturn 0;\n\n\t/* __cfi_check is always page aligned */\n\treturn (s->base + s->shadow[index]) << PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_to_shadow",
          "args": [
            "s",
            "ptr"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ptr_to_shadow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "69-83",
          "snippet": "static inline int ptr_to_shadow(const struct cfi_shadow *s, unsigned long ptr)\n{\n\tunsigned long index;\n\tunsigned long page = ptr >> PAGE_SHIFT;\n\n\tif (unlikely(page < s->base))\n\t\treturn -1; /* Outside of module area */\n\n\tindex = page - s->base;\n\n\tif (index >= SHADOW_ARR_SLOTS)\n\t\treturn -1; /* Cannot be addressed with shadow */\n\n\treturn (int)index;\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [
            "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n\nstatic inline int ptr_to_shadow(const struct cfi_shadow *s, unsigned long ptr)\n{\n\tunsigned long index;\n\tunsigned long page = ptr >> PAGE_SHIFT;\n\n\tif (unlikely(page < s->base))\n\t\treturn -1; /* Outside of module area */\n\n\tindex = page - s->base;\n\n\tif (index >= SHADOW_ARR_SLOTS)\n\t\treturn -1; /* Cannot be addressed with shadow */\n\n\treturn (int)index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!s"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline cfi_check_fn ptr_to_check_fn(const struct cfi_shadow __rcu *s,\n\tunsigned long ptr)\n{\n\tint index;\n\n\tif (unlikely(!s))\n\t\treturn NULL; /* No shadow available */\n\n\tindex = ptr_to_shadow(s, ptr);\n\tif (index < 0)\n\t\treturn NULL; /* Cannot be addressed with shadow */\n\n\treturn (cfi_check_fn)shadow_to_check_fn(s, index);\n}"
  },
  {
    "function_name": "cfi_module_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "227-230",
    "snippet": "void cfi_module_remove(struct module *mod, unsigned long base_addr)\n{\n\tupdate_shadow(mod, base_addr, remove_module_from_shadow);\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_shadow",
          "args": [
            "mod",
            "base_addr",
            "remove_module_from_shadow"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "update_shadow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "188-220",
          "snippet": "static void update_shadow(struct module *mod, unsigned long base_addr,\n\t\tupdate_shadow_fn fn)\n{\n\tstruct cfi_shadow *prev;\n\tstruct cfi_shadow *next;\n\tunsigned long min_addr, max_addr;\n\n\tnext = vmalloc(SHADOW_SIZE);\n\n\tmutex_lock(&shadow_update_lock);\n\tprev = rcu_dereference_protected(cfi_shadow,\n\t\t\t\t\t mutex_is_locked(&shadow_update_lock));\n\n\tif (next) {\n\t\tnext->base = base_addr >> PAGE_SHIFT;\n\t\tprepare_next_shadow(prev, next);\n\n\t\tmin_addr = (unsigned long)mod->core_layout.base;\n\t\tmax_addr = min_addr + mod->core_layout.text_size;\n\t\tfn(next, mod, min_addr & PAGE_MASK, max_addr & PAGE_MASK);\n\n\t\tset_memory_ro((unsigned long)next, SHADOW_PAGES);\n\t}\n\n\trcu_assign_pointer(cfi_shadow, next);\n\tmutex_unlock(&shadow_update_lock);\n\tsynchronize_rcu();\n\n\tif (prev) {\n\t\tset_memory_rw((unsigned long)prev, SHADOW_PAGES);\n\t\tvfree(prev);\n\t}\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [
            "#define SHADOW_SIZE\t\t(SHADOW_PAGES << PAGE_SHIFT)",
            "#define SHADOW_PAGES\t\tmax(1UL, __SHADOW_PAGES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_SIZE\t\t(SHADOW_PAGES << PAGE_SHIFT)\n#define SHADOW_PAGES\t\tmax(1UL, __SHADOW_PAGES)\n\nstatic void update_shadow(struct module *mod, unsigned long base_addr,\n\t\tupdate_shadow_fn fn)\n{\n\tstruct cfi_shadow *prev;\n\tstruct cfi_shadow *next;\n\tunsigned long min_addr, max_addr;\n\n\tnext = vmalloc(SHADOW_SIZE);\n\n\tmutex_lock(&shadow_update_lock);\n\tprev = rcu_dereference_protected(cfi_shadow,\n\t\t\t\t\t mutex_is_locked(&shadow_update_lock));\n\n\tif (next) {\n\t\tnext->base = base_addr >> PAGE_SHIFT;\n\t\tprepare_next_shadow(prev, next);\n\n\t\tmin_addr = (unsigned long)mod->core_layout.base;\n\t\tmax_addr = min_addr + mod->core_layout.text_size;\n\t\tfn(next, mod, min_addr & PAGE_MASK, max_addr & PAGE_MASK);\n\n\t\tset_memory_ro((unsigned long)next, SHADOW_PAGES);\n\t}\n\n\trcu_assign_pointer(cfi_shadow, next);\n\tmutex_unlock(&shadow_update_lock);\n\tsynchronize_rcu();\n\n\tif (prev) {\n\t\tset_memory_rw((unsigned long)prev, SHADOW_PAGES);\n\t\tvfree(prev);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nvoid cfi_module_remove(struct module *mod, unsigned long base_addr)\n{\n\tupdate_shadow(mod, base_addr, remove_module_from_shadow);\n}"
  },
  {
    "function_name": "cfi_module_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "222-225",
    "snippet": "void cfi_module_add(struct module *mod, unsigned long base_addr)\n{\n\tupdate_shadow(mod, base_addr, add_module_to_shadow);\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_shadow",
          "args": [
            "mod",
            "base_addr",
            "add_module_to_shadow"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "update_shadow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "188-220",
          "snippet": "static void update_shadow(struct module *mod, unsigned long base_addr,\n\t\tupdate_shadow_fn fn)\n{\n\tstruct cfi_shadow *prev;\n\tstruct cfi_shadow *next;\n\tunsigned long min_addr, max_addr;\n\n\tnext = vmalloc(SHADOW_SIZE);\n\n\tmutex_lock(&shadow_update_lock);\n\tprev = rcu_dereference_protected(cfi_shadow,\n\t\t\t\t\t mutex_is_locked(&shadow_update_lock));\n\n\tif (next) {\n\t\tnext->base = base_addr >> PAGE_SHIFT;\n\t\tprepare_next_shadow(prev, next);\n\n\t\tmin_addr = (unsigned long)mod->core_layout.base;\n\t\tmax_addr = min_addr + mod->core_layout.text_size;\n\t\tfn(next, mod, min_addr & PAGE_MASK, max_addr & PAGE_MASK);\n\n\t\tset_memory_ro((unsigned long)next, SHADOW_PAGES);\n\t}\n\n\trcu_assign_pointer(cfi_shadow, next);\n\tmutex_unlock(&shadow_update_lock);\n\tsynchronize_rcu();\n\n\tif (prev) {\n\t\tset_memory_rw((unsigned long)prev, SHADOW_PAGES);\n\t\tvfree(prev);\n\t}\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [
            "#define SHADOW_SIZE\t\t(SHADOW_PAGES << PAGE_SHIFT)",
            "#define SHADOW_PAGES\t\tmax(1UL, __SHADOW_PAGES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_SIZE\t\t(SHADOW_PAGES << PAGE_SHIFT)\n#define SHADOW_PAGES\t\tmax(1UL, __SHADOW_PAGES)\n\nstatic void update_shadow(struct module *mod, unsigned long base_addr,\n\t\tupdate_shadow_fn fn)\n{\n\tstruct cfi_shadow *prev;\n\tstruct cfi_shadow *next;\n\tunsigned long min_addr, max_addr;\n\n\tnext = vmalloc(SHADOW_SIZE);\n\n\tmutex_lock(&shadow_update_lock);\n\tprev = rcu_dereference_protected(cfi_shadow,\n\t\t\t\t\t mutex_is_locked(&shadow_update_lock));\n\n\tif (next) {\n\t\tnext->base = base_addr >> PAGE_SHIFT;\n\t\tprepare_next_shadow(prev, next);\n\n\t\tmin_addr = (unsigned long)mod->core_layout.base;\n\t\tmax_addr = min_addr + mod->core_layout.text_size;\n\t\tfn(next, mod, min_addr & PAGE_MASK, max_addr & PAGE_MASK);\n\n\t\tset_memory_ro((unsigned long)next, SHADOW_PAGES);\n\t}\n\n\trcu_assign_pointer(cfi_shadow, next);\n\tmutex_unlock(&shadow_update_lock);\n\tsynchronize_rcu();\n\n\tif (prev) {\n\t\tset_memory_rw((unsigned long)prev, SHADOW_PAGES);\n\t\tvfree(prev);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nvoid cfi_module_add(struct module *mod, unsigned long base_addr)\n{\n\tupdate_shadow(mod, base_addr, add_module_to_shadow);\n}"
  },
  {
    "function_name": "update_shadow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "188-220",
    "snippet": "static void update_shadow(struct module *mod, unsigned long base_addr,\n\t\tupdate_shadow_fn fn)\n{\n\tstruct cfi_shadow *prev;\n\tstruct cfi_shadow *next;\n\tunsigned long min_addr, max_addr;\n\n\tnext = vmalloc(SHADOW_SIZE);\n\n\tmutex_lock(&shadow_update_lock);\n\tprev = rcu_dereference_protected(cfi_shadow,\n\t\t\t\t\t mutex_is_locked(&shadow_update_lock));\n\n\tif (next) {\n\t\tnext->base = base_addr >> PAGE_SHIFT;\n\t\tprepare_next_shadow(prev, next);\n\n\t\tmin_addr = (unsigned long)mod->core_layout.base;\n\t\tmax_addr = min_addr + mod->core_layout.text_size;\n\t\tfn(next, mod, min_addr & PAGE_MASK, max_addr & PAGE_MASK);\n\n\t\tset_memory_ro((unsigned long)next, SHADOW_PAGES);\n\t}\n\n\trcu_assign_pointer(cfi_shadow, next);\n\tmutex_unlock(&shadow_update_lock);\n\tsynchronize_rcu();\n\n\tif (prev) {\n\t\tset_memory_rw((unsigned long)prev, SHADOW_PAGES);\n\t\tvfree(prev);\n\t}\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [
      "#define SHADOW_SIZE\t\t(SHADOW_PAGES << PAGE_SHIFT)",
      "#define SHADOW_PAGES\t\tmax(1UL, __SHADOW_PAGES)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "prev"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_rw",
          "args": [
            "(unsigned long)prev",
            "SHADOW_PAGES"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&shadow_update_lock"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "cfi_shadow",
            "next"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_ro",
          "args": [
            "(unsigned long)next",
            "SHADOW_PAGES"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "next",
            "mod",
            "min_addr & PAGE_MASK",
            "max_addr & PAGE_MASK"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "cwt_wakefn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3123-3130",
          "snippet": "static int cwt_wakefn(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct cwt_wait *cwait = container_of(wait, struct cwt_wait, wait);\n\n\tif (cwait->work != key)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int cwt_wakefn(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct cwt_wait *cwait = container_of(wait, struct cwt_wait, wait);\n\n\tif (cwait->work != key)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_next_shadow",
          "args": [
            "prev",
            "next"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_next_shadow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "109-142",
          "snippet": "static void prepare_next_shadow(const struct cfi_shadow __rcu *prev,\n\t\tstruct cfi_shadow *next)\n{\n\tint i, index, check;\n\n\t/* Mark everything invalid */\n\tmemset(next->shadow, 0xFF, SHADOW_ARR_SIZE);\n\n\tif (!prev)\n\t\treturn; /* No previous shadow */\n\n\t/* If the base address didn't change, an update is not needed */\n\tif (prev->base == next->base) {\n\t\tmemcpy(next->shadow, prev->shadow, SHADOW_ARR_SIZE);\n\t\treturn;\n\t}\n\n\t/* Convert the previous shadow to the new address range */\n\tfor (i = 0; i < SHADOW_ARR_SLOTS; ++i) {\n\t\tif (prev->shadow[i] == SHADOW_INVALID)\n\t\t\tcontinue;\n\n\t\tindex = ptr_to_shadow(next, shadow_to_ptr(prev, i));\n\t\tif (index < 0)\n\t\t\tcontinue;\n\n\t\tcheck = ptr_to_shadow(next,\n\t\t\t\tshadow_to_check_fn(prev, prev->shadow[i]));\n\t\tif (check < 0)\n\t\t\tcontinue;\n\n\t\tnext->shadow[index] = (shadow_t)check;\n\t}\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [
            "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))",
            "#define SHADOW_ARR_SIZE\t\t(SHADOW_SIZE - offsetof(struct cfi_shadow, shadow))",
            "#define SHADOW_INVALID\t\t((shadow_t)~0UL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n#define SHADOW_ARR_SIZE\t\t(SHADOW_SIZE - offsetof(struct cfi_shadow, shadow))\n#define SHADOW_INVALID\t\t((shadow_t)~0UL)\n\nstatic void prepare_next_shadow(const struct cfi_shadow __rcu *prev,\n\t\tstruct cfi_shadow *next)\n{\n\tint i, index, check;\n\n\t/* Mark everything invalid */\n\tmemset(next->shadow, 0xFF, SHADOW_ARR_SIZE);\n\n\tif (!prev)\n\t\treturn; /* No previous shadow */\n\n\t/* If the base address didn't change, an update is not needed */\n\tif (prev->base == next->base) {\n\t\tmemcpy(next->shadow, prev->shadow, SHADOW_ARR_SIZE);\n\t\treturn;\n\t}\n\n\t/* Convert the previous shadow to the new address range */\n\tfor (i = 0; i < SHADOW_ARR_SLOTS; ++i) {\n\t\tif (prev->shadow[i] == SHADOW_INVALID)\n\t\t\tcontinue;\n\n\t\tindex = ptr_to_shadow(next, shadow_to_ptr(prev, i));\n\t\tif (index < 0)\n\t\t\tcontinue;\n\n\t\tcheck = ptr_to_shadow(next,\n\t\t\t\tshadow_to_check_fn(prev, prev->shadow[i]));\n\t\tif (check < 0)\n\t\t\tcontinue;\n\n\t\tnext->shadow[index] = (shadow_t)check;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "cfi_shadow",
            "mutex_is_locked(&shadow_update_lock)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&shadow_update_lock"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&shadow_update_lock"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "SHADOW_SIZE"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "array_map_vmalloc_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "379-382",
          "snippet": "static void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_SIZE\t\t(SHADOW_PAGES << PAGE_SHIFT)\n#define SHADOW_PAGES\t\tmax(1UL, __SHADOW_PAGES)\n\nstatic void update_shadow(struct module *mod, unsigned long base_addr,\n\t\tupdate_shadow_fn fn)\n{\n\tstruct cfi_shadow *prev;\n\tstruct cfi_shadow *next;\n\tunsigned long min_addr, max_addr;\n\n\tnext = vmalloc(SHADOW_SIZE);\n\n\tmutex_lock(&shadow_update_lock);\n\tprev = rcu_dereference_protected(cfi_shadow,\n\t\t\t\t\t mutex_is_locked(&shadow_update_lock));\n\n\tif (next) {\n\t\tnext->base = base_addr >> PAGE_SHIFT;\n\t\tprepare_next_shadow(prev, next);\n\n\t\tmin_addr = (unsigned long)mod->core_layout.base;\n\t\tmax_addr = min_addr + mod->core_layout.text_size;\n\t\tfn(next, mod, min_addr & PAGE_MASK, max_addr & PAGE_MASK);\n\n\t\tset_memory_ro((unsigned long)next, SHADOW_PAGES);\n\t}\n\n\trcu_assign_pointer(cfi_shadow, next);\n\tmutex_unlock(&shadow_update_lock);\n\tsynchronize_rcu();\n\n\tif (prev) {\n\t\tset_memory_rw((unsigned long)prev, SHADOW_PAGES);\n\t\tvfree(prev);\n\t}\n}"
  },
  {
    "function_name": "remove_module_from_shadow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "172-183",
    "snippet": "static void remove_module_from_shadow(struct cfi_shadow *s, struct module *mod,\n\t\tunsigned long min_addr, unsigned long max_addr)\n{\n\tunsigned long ptr;\n\n\tfor (ptr = min_addr; ptr <= max_addr; ptr += PAGE_SIZE) {\n\t\tint index = ptr_to_shadow(s, ptr);\n\n\t\tif (index >= 0)\n\t\t\ts->shadow[index] = SHADOW_INVALID;\n\t}\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [
      "#define SHADOW_INVALID\t\t((shadow_t)~0UL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr_to_shadow",
          "args": [
            "s",
            "ptr"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "ptr_to_shadow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "69-83",
          "snippet": "static inline int ptr_to_shadow(const struct cfi_shadow *s, unsigned long ptr)\n{\n\tunsigned long index;\n\tunsigned long page = ptr >> PAGE_SHIFT;\n\n\tif (unlikely(page < s->base))\n\t\treturn -1; /* Outside of module area */\n\n\tindex = page - s->base;\n\n\tif (index >= SHADOW_ARR_SLOTS)\n\t\treturn -1; /* Cannot be addressed with shadow */\n\n\treturn (int)index;\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [
            "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n\nstatic inline int ptr_to_shadow(const struct cfi_shadow *s, unsigned long ptr)\n{\n\tunsigned long index;\n\tunsigned long page = ptr >> PAGE_SHIFT;\n\n\tif (unlikely(page < s->base))\n\t\treturn -1; /* Outside of module area */\n\n\tindex = page - s->base;\n\n\tif (index >= SHADOW_ARR_SLOTS)\n\t\treturn -1; /* Cannot be addressed with shadow */\n\n\treturn (int)index;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_INVALID\t\t((shadow_t)~0UL)\n\nstatic void remove_module_from_shadow(struct cfi_shadow *s, struct module *mod,\n\t\tunsigned long min_addr, unsigned long max_addr)\n{\n\tunsigned long ptr;\n\n\tfor (ptr = min_addr; ptr <= max_addr; ptr += PAGE_SIZE) {\n\t\tint index = ptr_to_shadow(s, ptr);\n\n\t\tif (index >= 0)\n\t\t\ts->shadow[index] = SHADOW_INVALID;\n\t}\n}"
  },
  {
    "function_name": "add_module_to_shadow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "144-170",
    "snippet": "static void add_module_to_shadow(struct cfi_shadow *s, struct module *mod,\n\t\t\tunsigned long min_addr, unsigned long max_addr)\n{\n\tint check_index;\n\tunsigned long check = (unsigned long)mod->cfi_check;\n\tunsigned long ptr;\n\n\tif (unlikely(!PAGE_ALIGNED(check))) {\n\t\tpr_warn(\"cfi: not using shadow for module %s\\n\", mod->name);\n\t\treturn;\n\t}\n\n\tcheck_index = ptr_to_shadow(s, check);\n\tif (check_index < 0)\n\t\treturn; /* Module not addressable with shadow */\n\n\t/* For each page, store the check function index in the shadow */\n\tfor (ptr = min_addr; ptr <= max_addr; ptr += PAGE_SIZE) {\n\t\tint index = ptr_to_shadow(s, ptr);\n\n\t\tif (index >= 0) {\n\t\t\t/* Each page must only contain one module */\n\t\t\tWARN_ON_ONCE(s->shadow[index] != SHADOW_INVALID);\n\t\t\ts->shadow[index] = (shadow_t)check_index;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [
      "#define SHADOW_INVALID\t\t((shadow_t)~0UL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "s->shadow[index] != SHADOW_INVALID"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_shadow",
          "args": [
            "s",
            "ptr"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "ptr_to_shadow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "69-83",
          "snippet": "static inline int ptr_to_shadow(const struct cfi_shadow *s, unsigned long ptr)\n{\n\tunsigned long index;\n\tunsigned long page = ptr >> PAGE_SHIFT;\n\n\tif (unlikely(page < s->base))\n\t\treturn -1; /* Outside of module area */\n\n\tindex = page - s->base;\n\n\tif (index >= SHADOW_ARR_SLOTS)\n\t\treturn -1; /* Cannot be addressed with shadow */\n\n\treturn (int)index;\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [
            "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n\nstatic inline int ptr_to_shadow(const struct cfi_shadow *s, unsigned long ptr)\n{\n\tunsigned long index;\n\tunsigned long page = ptr >> PAGE_SHIFT;\n\n\tif (unlikely(page < s->base))\n\t\treturn -1; /* Outside of module area */\n\n\tindex = page - s->base;\n\n\tif (index >= SHADOW_ARR_SLOTS)\n\t\treturn -1; /* Cannot be addressed with shadow */\n\n\treturn (int)index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"cfi: not using shadow for module %s\\n\"",
            "mod->name"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PAGE_ALIGNED(check)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGNED",
          "args": [
            "check"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_INVALID\t\t((shadow_t)~0UL)\n\nstatic void add_module_to_shadow(struct cfi_shadow *s, struct module *mod,\n\t\t\tunsigned long min_addr, unsigned long max_addr)\n{\n\tint check_index;\n\tunsigned long check = (unsigned long)mod->cfi_check;\n\tunsigned long ptr;\n\n\tif (unlikely(!PAGE_ALIGNED(check))) {\n\t\tpr_warn(\"cfi: not using shadow for module %s\\n\", mod->name);\n\t\treturn;\n\t}\n\n\tcheck_index = ptr_to_shadow(s, check);\n\tif (check_index < 0)\n\t\treturn; /* Module not addressable with shadow */\n\n\t/* For each page, store the check function index in the shadow */\n\tfor (ptr = min_addr; ptr <= max_addr; ptr += PAGE_SIZE) {\n\t\tint index = ptr_to_shadow(s, ptr);\n\n\t\tif (index >= 0) {\n\t\t\t/* Each page must only contain one module */\n\t\t\tWARN_ON_ONCE(s->shadow[index] != SHADOW_INVALID);\n\t\t\ts->shadow[index] = (shadow_t)check_index;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "prepare_next_shadow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "109-142",
    "snippet": "static void prepare_next_shadow(const struct cfi_shadow __rcu *prev,\n\t\tstruct cfi_shadow *next)\n{\n\tint i, index, check;\n\n\t/* Mark everything invalid */\n\tmemset(next->shadow, 0xFF, SHADOW_ARR_SIZE);\n\n\tif (!prev)\n\t\treturn; /* No previous shadow */\n\n\t/* If the base address didn't change, an update is not needed */\n\tif (prev->base == next->base) {\n\t\tmemcpy(next->shadow, prev->shadow, SHADOW_ARR_SIZE);\n\t\treturn;\n\t}\n\n\t/* Convert the previous shadow to the new address range */\n\tfor (i = 0; i < SHADOW_ARR_SLOTS; ++i) {\n\t\tif (prev->shadow[i] == SHADOW_INVALID)\n\t\t\tcontinue;\n\n\t\tindex = ptr_to_shadow(next, shadow_to_ptr(prev, i));\n\t\tif (index < 0)\n\t\t\tcontinue;\n\n\t\tcheck = ptr_to_shadow(next,\n\t\t\t\tshadow_to_check_fn(prev, prev->shadow[i]));\n\t\tif (check < 0)\n\t\t\tcontinue;\n\n\t\tnext->shadow[index] = (shadow_t)check;\n\t}\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [
      "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))",
      "#define SHADOW_ARR_SIZE\t\t(SHADOW_SIZE - offsetof(struct cfi_shadow, shadow))",
      "#define SHADOW_INVALID\t\t((shadow_t)~0UL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr_to_shadow",
          "args": [
            "next",
            "shadow_to_check_fn(prev, prev->shadow[i])"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ptr_to_shadow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "69-83",
          "snippet": "static inline int ptr_to_shadow(const struct cfi_shadow *s, unsigned long ptr)\n{\n\tunsigned long index;\n\tunsigned long page = ptr >> PAGE_SHIFT;\n\n\tif (unlikely(page < s->base))\n\t\treturn -1; /* Outside of module area */\n\n\tindex = page - s->base;\n\n\tif (index >= SHADOW_ARR_SLOTS)\n\t\treturn -1; /* Cannot be addressed with shadow */\n\n\treturn (int)index;\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [
            "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n\nstatic inline int ptr_to_shadow(const struct cfi_shadow *s, unsigned long ptr)\n{\n\tunsigned long index;\n\tunsigned long page = ptr >> PAGE_SHIFT;\n\n\tif (unlikely(page < s->base))\n\t\treturn -1; /* Outside of module area */\n\n\tindex = page - s->base;\n\n\tif (index >= SHADOW_ARR_SLOTS)\n\t\treturn -1; /* Cannot be addressed with shadow */\n\n\treturn (int)index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shadow_to_check_fn",
          "args": [
            "prev",
            "prev->shadow[i]"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_to_check_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "96-107",
          "snippet": "static inline unsigned long shadow_to_check_fn(const struct cfi_shadow *s,\n\tint index)\n{\n\tif (unlikely(index < 0 || index >= SHADOW_ARR_SLOTS))\n\t\treturn 0;\n\n\tif (unlikely(s->shadow[index] == SHADOW_INVALID))\n\t\treturn 0;\n\n\t/* __cfi_check is always page aligned */\n\treturn (s->base + s->shadow[index]) << PAGE_SHIFT;\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [
            "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))",
            "#define SHADOW_INVALID\t\t((shadow_t)~0UL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n#define SHADOW_INVALID\t\t((shadow_t)~0UL)\n\nstatic inline unsigned long shadow_to_check_fn(const struct cfi_shadow *s,\n\tint index)\n{\n\tif (unlikely(index < 0 || index >= SHADOW_ARR_SLOTS))\n\t\treturn 0;\n\n\tif (unlikely(s->shadow[index] == SHADOW_INVALID))\n\t\treturn 0;\n\n\t/* __cfi_check is always page aligned */\n\treturn (s->base + s->shadow[index]) << PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shadow_to_ptr",
          "args": [
            "prev",
            "i"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_to_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
          "lines": "86-93",
          "snippet": "static inline unsigned long shadow_to_ptr(const struct cfi_shadow *s,\n\tint index)\n{\n\tif (unlikely(index < 0 || index >= SHADOW_ARR_SLOTS))\n\t\treturn 0;\n\n\treturn (s->base + index) << PAGE_SHIFT;\n}",
          "includes": [
            "#include <asm/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/printk.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [
            "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n\nstatic inline unsigned long shadow_to_ptr(const struct cfi_shadow *s,\n\tint index)\n{\n\tif (unlikely(index < 0 || index >= SHADOW_ARR_SLOTS))\n\t\treturn 0;\n\n\treturn (s->base + index) << PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "next->shadow",
            "prev->shadow",
            "SHADOW_ARR_SIZE"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "next->shadow",
            "0xFF",
            "SHADOW_ARR_SIZE"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n#define SHADOW_ARR_SIZE\t\t(SHADOW_SIZE - offsetof(struct cfi_shadow, shadow))\n#define SHADOW_INVALID\t\t((shadow_t)~0UL)\n\nstatic void prepare_next_shadow(const struct cfi_shadow __rcu *prev,\n\t\tstruct cfi_shadow *next)\n{\n\tint i, index, check;\n\n\t/* Mark everything invalid */\n\tmemset(next->shadow, 0xFF, SHADOW_ARR_SIZE);\n\n\tif (!prev)\n\t\treturn; /* No previous shadow */\n\n\t/* If the base address didn't change, an update is not needed */\n\tif (prev->base == next->base) {\n\t\tmemcpy(next->shadow, prev->shadow, SHADOW_ARR_SIZE);\n\t\treturn;\n\t}\n\n\t/* Convert the previous shadow to the new address range */\n\tfor (i = 0; i < SHADOW_ARR_SLOTS; ++i) {\n\t\tif (prev->shadow[i] == SHADOW_INVALID)\n\t\t\tcontinue;\n\n\t\tindex = ptr_to_shadow(next, shadow_to_ptr(prev, i));\n\t\tif (index < 0)\n\t\t\tcontinue;\n\n\t\tcheck = ptr_to_shadow(next,\n\t\t\t\tshadow_to_check_fn(prev, prev->shadow[i]));\n\t\tif (check < 0)\n\t\t\tcontinue;\n\n\t\tnext->shadow[index] = (shadow_t)check;\n\t}\n}"
  },
  {
    "function_name": "shadow_to_check_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "96-107",
    "snippet": "static inline unsigned long shadow_to_check_fn(const struct cfi_shadow *s,\n\tint index)\n{\n\tif (unlikely(index < 0 || index >= SHADOW_ARR_SLOTS))\n\t\treturn 0;\n\n\tif (unlikely(s->shadow[index] == SHADOW_INVALID))\n\t\treturn 0;\n\n\t/* __cfi_check is always page aligned */\n\treturn (s->base + s->shadow[index]) << PAGE_SHIFT;\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [
      "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))",
      "#define SHADOW_INVALID\t\t((shadow_t)~0UL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "s->shadow[index] == SHADOW_INVALID"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index < 0 || index >= SHADOW_ARR_SLOTS"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n#define SHADOW_INVALID\t\t((shadow_t)~0UL)\n\nstatic inline unsigned long shadow_to_check_fn(const struct cfi_shadow *s,\n\tint index)\n{\n\tif (unlikely(index < 0 || index >= SHADOW_ARR_SLOTS))\n\t\treturn 0;\n\n\tif (unlikely(s->shadow[index] == SHADOW_INVALID))\n\t\treturn 0;\n\n\t/* __cfi_check is always page aligned */\n\treturn (s->base + s->shadow[index]) << PAGE_SHIFT;\n}"
  },
  {
    "function_name": "shadow_to_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "86-93",
    "snippet": "static inline unsigned long shadow_to_ptr(const struct cfi_shadow *s,\n\tint index)\n{\n\tif (unlikely(index < 0 || index >= SHADOW_ARR_SLOTS))\n\t\treturn 0;\n\n\treturn (s->base + index) << PAGE_SHIFT;\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [
      "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index < 0 || index >= SHADOW_ARR_SLOTS"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n\nstatic inline unsigned long shadow_to_ptr(const struct cfi_shadow *s,\n\tint index)\n{\n\tif (unlikely(index < 0 || index >= SHADOW_ARR_SLOTS))\n\t\treturn 0;\n\n\treturn (s->base + index) << PAGE_SHIFT;\n}"
  },
  {
    "function_name": "ptr_to_shadow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "69-83",
    "snippet": "static inline int ptr_to_shadow(const struct cfi_shadow *s, unsigned long ptr)\n{\n\tunsigned long index;\n\tunsigned long page = ptr >> PAGE_SHIFT;\n\n\tif (unlikely(page < s->base))\n\t\treturn -1; /* Outside of module area */\n\n\tindex = page - s->base;\n\n\tif (index >= SHADOW_ARR_SLOTS)\n\t\treturn -1; /* Cannot be addressed with shadow */\n\n\treturn (int)index;\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [
      "#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page < s->base"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\n#define SHADOW_ARR_SLOTS\t(SHADOW_ARR_SIZE / sizeof(shadow_t))\n\nstatic inline int ptr_to_shadow(const struct cfi_shadow *s, unsigned long ptr)\n{\n\tunsigned long index;\n\tunsigned long page = ptr >> PAGE_SHIFT;\n\n\tif (unlikely(page < s->base))\n\t\treturn -1; /* Outside of module area */\n\n\tindex = page - s->base;\n\n\tif (index >= SHADOW_ARR_SLOTS)\n\t\treturn -1; /* Cannot be addressed with shadow */\n\n\treturn (int)index;\n}"
  },
  {
    "function_name": "handle_cfi_failure",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cfi.c",
    "lines": "26-32",
    "snippet": "static inline void handle_cfi_failure(void *ptr)\n{\n\tif (IS_ENABLED(CONFIG_CFI_PERMISSIVE))\n\t\tWARN_RATELIMIT(1, \"CFI failure (target: %pS):\\n\", ptr);\n\telse\n\t\tpanic(\"CFI failure (target: %pS)\\n\", ptr);\n}",
    "includes": [
      "#include <asm/set_memory.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/printk.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"CFI failure (target: %pS)\\n\"",
            "ptr"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "179-361",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_RATELIMIT",
          "args": [
            "1",
            "\"CFI failure (target: %pS):\\n\"",
            "ptr"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CFI_PERMISSIVE"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/hardirq.h>\n\nstatic inline void handle_cfi_failure(void *ptr)\n{\n\tif (IS_ENABLED(CONFIG_CFI_PERMISSIVE))\n\t\tWARN_RATELIMIT(1, \"CFI failure (target: %pS):\\n\", ptr);\n\telse\n\t\tpanic(\"CFI failure (target: %pS)\\n\", ptr);\n}"
  }
]