[
  {
    "function_name": "in_egroup_p",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "226-234",
    "snippet": "int in_egroup_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->egid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "groups_search",
          "args": [
            "cred->group_info",
            "grp"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "groups_search",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
          "lines": "92-111",
          "snippet": "int groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sort.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "grp",
            "cred->egid"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint in_egroup_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->egid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}"
  },
  {
    "function_name": "in_group_p",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "214-222",
    "snippet": "int in_group_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->fsgid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "groups_search",
          "args": [
            "cred->group_info",
            "grp"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "groups_search",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
          "lines": "92-111",
          "snippet": "int groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sort.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "grp",
            "cred->fsgid"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint in_group_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->fsgid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}"
  },
  {
    "function_name": "may_setgroups",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "172-178",
    "snippet": "bool may_setgroups(void)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\treturn ns_capable_setid(user_ns, CAP_SETGID) &&\n\t\tuserns_may_setgroups(user_ns);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "userns_may_setgroups",
          "args": [
            "user_ns"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "userns_may_setgroups",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "1263-1277",
          "snippet": "bool userns_may_setgroups(const struct user_namespace *ns)\n{\n\tbool allowed;\n\n\tmutex_lock(&userns_state_mutex);\n\t/* It is not safe to use setgroups until a gid mapping in\n\t * the user namespace has been established.\n\t */\n\tallowed = ns->gid_map.nr_extents != 0;\n\t/* Is setgroups allowed? */\n\tallowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);\n\tmutex_unlock(&userns_state_mutex);\n\n\treturn allowed;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(userns_state_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(userns_state_mutex);\n\nbool userns_may_setgroups(const struct user_namespace *ns)\n{\n\tbool allowed;\n\n\tmutex_lock(&userns_state_mutex);\n\t/* It is not safe to use setgroups until a gid mapping in\n\t * the user namespace has been established.\n\t */\n\tallowed = ns->gid_map.nr_extents != 0;\n\t/* Is setgroups allowed? */\n\tallowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);\n\tmutex_unlock(&userns_state_mutex);\n\n\treturn allowed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable_setid",
          "args": [
            "user_ns",
            "CAP_SETGID"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_setid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "431-434",
          "snippet": "bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nbool may_setgroups(void)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\treturn ns_capable_setid(user_ns, CAP_SETGID) &&\n\t\tuserns_may_setgroups(user_ns);\n}"
  },
  {
    "function_name": "set_current_groups",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "134-144",
    "snippet": "int set_current_groups(struct group_info *group_info)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tset_groups(new, group_info);\n\treturn commit_creds(new);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "commit_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "447-523",
          "snippet": "int commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\t/*\n\t\t * If a task drops privileges and becomes nondumpable,\n\t\t * the dumpability change must become visible before\n\t\t * the credential change; otherwise, a __ptrace_may_access()\n\t\t * racing with this change may be able to attach to a task it\n\t\t * shouldn't be able to attach to (as if the task had dropped\n\t\t * privileges without becoming nondumpable).\n\t\t * Pairs with a read barrier in __ptrace_may_access().\n\t\t */\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(new);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(new);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tinc_rlimit_ucounts(new->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tdec_rlimit_ucounts(old->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\t/*\n\t\t * If a task drops privileges and becomes nondumpable,\n\t\t * the dumpability change must become visible before\n\t\t * the credential change; otherwise, a __ptrace_may_access()\n\t\t * racing with this change may be able to attach to a task it\n\t\t * shouldn't be able to attach to (as if the task had dropped\n\t\t * privileges without becoming nondumpable).\n\t\t * Pairs with a read barrier in __ptrace_may_access().\n\t\t */\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(new);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(new);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tinc_rlimit_ucounts(new->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tdec_rlimit_ucounts(old->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_groups",
          "args": [
            "new",
            "group_info"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "set_groups",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
          "lines": "118-123",
          "snippet": "void set_groups(struct cred *new, struct group_info *group_info)\n{\n\tput_group_info(new->group_info);\n\tget_group_info(group_info);\n\tnew->group_info = group_info;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sort.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nvoid set_groups(struct cred *new, struct group_info *group_info)\n{\n\tput_group_info(new->group_info);\n\tget_group_info(group_info);\n\tnew->group_info = group_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "252-300",
          "snippet": "struct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cred_jar;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint set_current_groups(struct group_info *group_info)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tset_groups(new, group_info);\n\treturn commit_creds(new);\n}"
  },
  {
    "function_name": "set_groups",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "118-123",
    "snippet": "void set_groups(struct cred *new, struct group_info *group_info)\n{\n\tput_group_info(new->group_info);\n\tget_group_info(group_info);\n\tnew->group_info = group_info;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_group_info",
          "args": [
            "group_info"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_group_info",
          "args": [
            "new->group_info"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nvoid set_groups(struct cred *new, struct group_info *group_info)\n{\n\tput_group_info(new->group_info);\n\tget_group_info(group_info);\n\tnew->group_info = group_info;\n}"
  },
  {
    "function_name": "groups_search",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "92-111",
    "snippet": "int groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_lt",
          "args": [
            "grp",
            "group_info->gid[mid]"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_gt",
          "args": [
            "grp",
            "group_info->gid[mid]"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "groups_sort",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "84-88",
    "snippet": "void groups_sort(struct group_info *group_info)\n{\n\tsort(group_info->gid, group_info->ngroups, sizeof(*group_info->gid),\n\t     gid_cmp, NULL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "group_info->gid",
            "group_info->ngroups",
            "sizeof(*group_info->gid)",
            "gid_cmp",
            "NULL"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nvoid groups_sort(struct group_info *group_info)\n{\n\tsort(group_info->gid, group_info->ngroups, sizeof(*group_info->gid),\n\t     gid_cmp, NULL);\n}"
  },
  {
    "function_name": "gid_cmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "76-82",
    "snippet": "static int gid_cmp(const void *_a, const void *_b)\n{\n\tkgid_t a = *(kgid_t *)_a;\n\tkgid_t b = *(kgid_t *)_b;\n\n\treturn gid_gt(a, b) - gid_lt(a, b);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_lt",
          "args": [
            "a",
            "b"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_gt",
          "args": [
            "a",
            "b"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nstatic int gid_cmp(const void *_a, const void *_b)\n{\n\tkgid_t a = *(kgid_t *)_a;\n\tkgid_t b = *(kgid_t *)_b;\n\n\treturn gid_gt(a, b) - gid_lt(a, b);\n}"
  },
  {
    "function_name": "groups_from_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "54-74",
    "snippet": "static int groups_from_user(struct group_info *group_info,\n    gid_t __user *grouplist)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tkgid_t kgid;\n\t\tif (get_user(gid, grouplist+i))\n\t\t\treturn -EFAULT;\n\n\t\tkgid = make_kgid(user_ns, gid);\n\t\tif (!gid_valid(kgid))\n\t\t\treturn -EINVAL;\n\n\t\tgroup_info->gid[i] = kgid;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "kgid"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "user_ns",
            "gid"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "make_kgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "459-463",
          "snippet": "kgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "gid",
            "grouplist+i"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "530-557",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nstatic int groups_from_user(struct group_info *group_info,\n    gid_t __user *grouplist)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tkgid_t kgid;\n\t\tif (get_user(gid, grouplist+i))\n\t\t\treturn -EFAULT;\n\n\t\tkgid = make_kgid(user_ns, gid);\n\t\tif (!gid_valid(kgid))\n\t\t\treturn -EINVAL;\n\n\t\tgroup_info->gid[i] = kgid;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "groups_to_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "37-51",
    "snippet": "static int groups_to_user(gid_t __user *grouplist,\n\t\t\t  const struct group_info *group_info)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tgid = from_kgid_munged(user_ns, group_info->gid[i]);\n\t\tif (put_user(gid, grouplist+i))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "gid",
            "grouplist+i"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "user_ns",
            "group_info->gid[i]"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "502-510",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nstatic int groups_to_user(gid_t __user *grouplist,\n\t\t\t  const struct group_info *group_info)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tgid = from_kgid_munged(user_ns, group_info->gid[i]);\n\t\tif (put_user(gid, grouplist+i))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "groups_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "29-32",
    "snippet": "void groups_free(struct group_info *group_info)\n{\n\tkvfree(group_info);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "group_info"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nvoid groups_free(struct group_info *group_info)\n{\n\tkvfree(group_info);\n}"
  },
  {
    "function_name": "groups_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "15-25",
    "snippet": "struct group_info *groups_alloc(int gidsetsize)\n{\n\tstruct group_info *gi;\n\tgi = kvmalloc(struct_size(gi, gid, gidsetsize), GFP_KERNEL_ACCOUNT);\n\tif (!gi)\n\t\treturn NULL;\n\n\tatomic_set(&gi->usage, 1);\n\tgi->ngroups = gidsetsize;\n\treturn gi;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&gi->usage",
            "1"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "struct_size(gi, gid, gidsetsize)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "gi",
            "gid",
            "gidsetsize"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nstruct group_info *groups_alloc(int gidsetsize)\n{\n\tstruct group_info *gi;\n\tgi = kvmalloc(struct_size(gi, gid, gidsetsize), GFP_KERNEL_ACCOUNT);\n\tif (!gi)\n\t\treturn NULL;\n\n\tatomic_set(&gi->usage, 1);\n\tgi->ngroups = gidsetsize;\n\treturn gi;\n}"
  },
  {
    "function_name": "getgroups",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "148-170",
    "snippet": "SYSCALL_DEFINE2(getgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tconst struct cred *cred = current_cred();\n\tint i;\n\n\tif (gidsetsize < 0)\n\t\treturn -EINVAL;\n\n\t/* no need to grab task_lock here; it cannot change */\n\ti = cred->group_info->ngroups;\n\tif (gidsetsize) {\n\t\tif (i > gidsetsize) {\n\t\t\ti = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (groups_to_user(grouplist, cred->group_info)) {\n\t\t\ti = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn i;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nSYSCALL_DEFINE2(getgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tconst struct cred *cred = current_cred();\n\tint i;\n\n\tif (gidsetsize < 0)\n\t\treturn -EINVAL;\n\n\t/* no need to grab task_lock here; it cannot change */\n\ti = cred->group_info->ngroups;\n\tif (gidsetsize) {\n\t\tif (i > gidsetsize) {\n\t\t\ti = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (groups_to_user(grouplist, cred->group_info)) {\n\t\t\ti = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn i;\n}"
  },
  {
    "function_name": "setgroups",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
    "lines": "185-209",
    "snippet": "SYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tstruct group_info *group_info;\n\tint retval;\n\n\tif (!may_setgroups())\n\t\treturn -EPERM;\n\tif ((unsigned)gidsetsize > NGROUPS_MAX)\n\t\treturn -EINVAL;\n\n\tgroup_info = groups_alloc(gidsetsize);\n\tif (!group_info)\n\t\treturn -ENOMEM;\n\tretval = groups_from_user(group_info, grouplist);\n\tif (retval) {\n\t\tput_group_info(group_info);\n\t\treturn retval;\n\t}\n\n\tgroups_sort(group_info);\n\tretval = set_current_groups(group_info);\n\tput_group_info(group_info);\n\n\treturn retval;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sort.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nSYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tstruct group_info *group_info;\n\tint retval;\n\n\tif (!may_setgroups())\n\t\treturn -EPERM;\n\tif ((unsigned)gidsetsize > NGROUPS_MAX)\n\t\treturn -EINVAL;\n\n\tgroup_info = groups_alloc(gidsetsize);\n\tif (!group_info)\n\t\treturn -ENOMEM;\n\tretval = groups_from_user(group_info, grouplist);\n\tif (retval) {\n\t\tput_group_info(group_info);\n\t\treturn retval;\n\t}\n\n\tgroups_sort(group_info);\n\tretval = set_current_groups(group_info);\n\tput_group_info(group_info);\n\n\treturn retval;\n}"
  }
]