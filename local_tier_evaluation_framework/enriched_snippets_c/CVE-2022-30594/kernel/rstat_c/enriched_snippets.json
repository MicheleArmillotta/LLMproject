[
  {
    "function_name": "cgroup_base_stat_cputime_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "436-463",
    "snippet": "void cgroup_base_stat_cputime_show(struct seq_file *seq)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tu64 usage, utime, stime;\n\tstruct task_cputime cputime;\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcgroup_rstat_flush_hold(cgrp);\n\t\tusage = cgrp->bstat.cputime.sum_exec_runtime;\n\t\tcputime_adjust(&cgrp->bstat.cputime, &cgrp->prev_cputime,\n\t\t\t       &utime, &stime);\n\t\tcgroup_rstat_flush_release();\n\t} else {\n\t\troot_cgroup_cputime(&cputime);\n\t\tusage = cputime.sum_exec_runtime;\n\t\tutime = cputime.utime;\n\t\tstime = cputime.stime;\n\t}\n\n\tdo_div(usage, NSEC_PER_USEC);\n\tdo_div(utime, NSEC_PER_USEC);\n\tdo_div(stime, NSEC_PER_USEC);\n\n\tseq_printf(seq, \"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\",\n\t\t   usage, utime, stime);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\"",
            "usage",
            "utime",
            "stime"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stime",
            "NSEC_PER_USEC"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "utime",
            "NSEC_PER_USEC"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "usage",
            "NSEC_PER_USEC"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root_cgroup_cputime",
          "args": [
            "&cputime"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "root_cgroup_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "406-434",
          "snippet": "static void root_cgroup_cputime(struct task_cputime *cputime)\n{\n\tint i;\n\n\tcputime->stime = 0;\n\tcputime->utime = 0;\n\tcputime->sum_exec_runtime = 0;\n\tfor_each_possible_cpu(i) {\n\t\tstruct kernel_cpustat kcpustat;\n\t\tu64 *cpustat = kcpustat.cpustat;\n\t\tu64 user = 0;\n\t\tu64 sys = 0;\n\n\t\tkcpustat_cpu_fetch(&kcpustat, i);\n\n\t\tuser += cpustat[CPUTIME_USER];\n\t\tuser += cpustat[CPUTIME_NICE];\n\t\tcputime->utime += user;\n\n\t\tsys += cpustat[CPUTIME_SYSTEM];\n\t\tsys += cpustat[CPUTIME_IRQ];\n\t\tsys += cpustat[CPUTIME_SOFTIRQ];\n\t\tcputime->stime += sys;\n\n\t\tcputime->sum_exec_runtime += user;\n\t\tcputime->sum_exec_runtime += sys;\n\t\tcputime->sum_exec_runtime += cpustat[CPUTIME_STEAL];\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void root_cgroup_cputime(struct task_cputime *cputime)\n{\n\tint i;\n\n\tcputime->stime = 0;\n\tcputime->utime = 0;\n\tcputime->sum_exec_runtime = 0;\n\tfor_each_possible_cpu(i) {\n\t\tstruct kernel_cpustat kcpustat;\n\t\tu64 *cpustat = kcpustat.cpustat;\n\t\tu64 user = 0;\n\t\tu64 sys = 0;\n\n\t\tkcpustat_cpu_fetch(&kcpustat, i);\n\n\t\tuser += cpustat[CPUTIME_USER];\n\t\tuser += cpustat[CPUTIME_NICE];\n\t\tcputime->utime += user;\n\n\t\tsys += cpustat[CPUTIME_SYSTEM];\n\t\tsys += cpustat[CPUTIME_IRQ];\n\t\tsys += cpustat[CPUTIME_SOFTIRQ];\n\t\tcputime->stime += sys;\n\n\t\tcputime->sum_exec_runtime += user;\n\t\tcputime->sum_exec_runtime += sys;\n\t\tcputime->sum_exec_runtime += cpustat[CPUTIME_STEAL];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_release",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "239-243",
          "snippet": "void cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cputime_adjust",
          "args": [
            "&cgrp->bstat.cputime",
            "&cgrp->prev_cputime",
            "&utime",
            "&stime"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "cputime_adjust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "540-610",
          "snippet": "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicity code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = mul_u64_u64_div_u64(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicity code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = mul_u64_u64_div_u64(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_hold",
          "args": [
            "cgrp"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_hold",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "228-234",
          "snippet": "void cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_base_stat_cputime_show(struct seq_file *seq)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tu64 usage, utime, stime;\n\tstruct task_cputime cputime;\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcgroup_rstat_flush_hold(cgrp);\n\t\tusage = cgrp->bstat.cputime.sum_exec_runtime;\n\t\tcputime_adjust(&cgrp->bstat.cputime, &cgrp->prev_cputime,\n\t\t\t       &utime, &stime);\n\t\tcgroup_rstat_flush_release();\n\t} else {\n\t\troot_cgroup_cputime(&cputime);\n\t\tusage = cputime.sum_exec_runtime;\n\t\tutime = cputime.utime;\n\t\tstime = cputime.stime;\n\t}\n\n\tdo_div(usage, NSEC_PER_USEC);\n\tdo_div(utime, NSEC_PER_USEC);\n\tdo_div(stime, NSEC_PER_USEC);\n\n\tseq_printf(seq, \"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\",\n\t\t   usage, utime, stime);\n}"
  },
  {
    "function_name": "root_cgroup_cputime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "406-434",
    "snippet": "static void root_cgroup_cputime(struct task_cputime *cputime)\n{\n\tint i;\n\n\tcputime->stime = 0;\n\tcputime->utime = 0;\n\tcputime->sum_exec_runtime = 0;\n\tfor_each_possible_cpu(i) {\n\t\tstruct kernel_cpustat kcpustat;\n\t\tu64 *cpustat = kcpustat.cpustat;\n\t\tu64 user = 0;\n\t\tu64 sys = 0;\n\n\t\tkcpustat_cpu_fetch(&kcpustat, i);\n\n\t\tuser += cpustat[CPUTIME_USER];\n\t\tuser += cpustat[CPUTIME_NICE];\n\t\tcputime->utime += user;\n\n\t\tsys += cpustat[CPUTIME_SYSTEM];\n\t\tsys += cpustat[CPUTIME_IRQ];\n\t\tsys += cpustat[CPUTIME_SOFTIRQ];\n\t\tcputime->stime += sys;\n\n\t\tcputime->sum_exec_runtime += user;\n\t\tcputime->sum_exec_runtime += sys;\n\t\tcputime->sum_exec_runtime += cpustat[CPUTIME_STEAL];\n\t}\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcpustat_cpu_fetch",
          "args": [
            "&kcpustat",
            "i"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "kcpustat_cpu_fetch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "1049-1081",
          "snippet": "void kcpustat_cpu_fetch(struct kernel_cpustat *dst, int cpu)\n{\n\tconst struct kernel_cpustat *src = &kcpustat_cpu(cpu);\n\tstruct rq *rq;\n\tint err;\n\n\tif (!vtime_accounting_enabled_cpu(cpu)) {\n\t\t*dst = *src;\n\t\treturn;\n\t}\n\n\trq = cpu_rq(cpu);\n\n\tfor (;;) {\n\t\tstruct task_struct *curr;\n\n\t\trcu_read_lock();\n\t\tcurr = rcu_dereference(rq->curr);\n\t\tif (WARN_ON_ONCE(!curr)) {\n\t\t\trcu_read_unlock();\n\t\t\t*dst = *src;\n\t\t\treturn;\n\t\t}\n\n\t\terr = kcpustat_cpu_fetch_vtime(dst, src, curr, cpu);\n\t\trcu_read_unlock();\n\n\t\tif (!err)\n\t\t\treturn;\n\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid kcpustat_cpu_fetch(struct kernel_cpustat *dst, int cpu)\n{\n\tconst struct kernel_cpustat *src = &kcpustat_cpu(cpu);\n\tstruct rq *rq;\n\tint err;\n\n\tif (!vtime_accounting_enabled_cpu(cpu)) {\n\t\t*dst = *src;\n\t\treturn;\n\t}\n\n\trq = cpu_rq(cpu);\n\n\tfor (;;) {\n\t\tstruct task_struct *curr;\n\n\t\trcu_read_lock();\n\t\tcurr = rcu_dereference(rq->curr);\n\t\tif (WARN_ON_ONCE(!curr)) {\n\t\t\trcu_read_unlock();\n\t\t\t*dst = *src;\n\t\t\treturn;\n\t\t}\n\n\t\terr = kcpustat_cpu_fetch_vtime(dst, src, curr, cpu);\n\t\trcu_read_unlock();\n\n\t\tif (!err)\n\t\t\treturn;\n\n\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void root_cgroup_cputime(struct task_cputime *cputime)\n{\n\tint i;\n\n\tcputime->stime = 0;\n\tcputime->utime = 0;\n\tcputime->sum_exec_runtime = 0;\n\tfor_each_possible_cpu(i) {\n\t\tstruct kernel_cpustat kcpustat;\n\t\tu64 *cpustat = kcpustat.cpustat;\n\t\tu64 user = 0;\n\t\tu64 sys = 0;\n\n\t\tkcpustat_cpu_fetch(&kcpustat, i);\n\n\t\tuser += cpustat[CPUTIME_USER];\n\t\tuser += cpustat[CPUTIME_NICE];\n\t\tcputime->utime += user;\n\n\t\tsys += cpustat[CPUTIME_SYSTEM];\n\t\tsys += cpustat[CPUTIME_IRQ];\n\t\tsys += cpustat[CPUTIME_SOFTIRQ];\n\t\tcputime->stime += sys;\n\n\t\tcputime->sum_exec_runtime += user;\n\t\tcputime->sum_exec_runtime += sys;\n\t\tcputime->sum_exec_runtime += cpustat[CPUTIME_STEAL];\n\t}\n}"
  },
  {
    "function_name": "__cgroup_account_cputime_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "375-398",
    "snippet": "void __cgroup_account_cputime_field(struct cgroup *cgrp,\n\t\t\t\t    enum cpu_usage_stat index, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\n\tswitch (index) {\n\tcase CPUTIME_USER:\n\tcase CPUTIME_NICE:\n\t\trstatc->bstat.cputime.utime += delta_exec;\n\t\tbreak;\n\tcase CPUTIME_SYSTEM:\n\tcase CPUTIME_IRQ:\n\tcase CPUTIME_SOFTIRQ:\n\t\trstatc->bstat.cputime.stime += delta_exec;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_end",
          "args": [
            "cgrp",
            "rstatc",
            "flags"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "356-363",
          "snippet": "static void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_begin",
          "args": [
            "cgrp",
            "&flags"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "346-354",
          "snippet": "static struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid __cgroup_account_cputime_field(struct cgroup *cgrp,\n\t\t\t\t    enum cpu_usage_stat index, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\n\tswitch (index) {\n\tcase CPUTIME_USER:\n\tcase CPUTIME_NICE:\n\t\trstatc->bstat.cputime.utime += delta_exec;\n\t\tbreak;\n\tcase CPUTIME_SYSTEM:\n\tcase CPUTIME_IRQ:\n\tcase CPUTIME_SOFTIRQ:\n\t\trstatc->bstat.cputime.stime += delta_exec;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}"
  },
  {
    "function_name": "__cgroup_account_cputime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "365-373",
    "snippet": "void __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\trstatc->bstat.cputime.sum_exec_runtime += delta_exec;\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_end",
          "args": [
            "cgrp",
            "rstatc",
            "flags"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "356-363",
          "snippet": "static void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_begin",
          "args": [
            "cgrp",
            "&flags"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "346-354",
          "snippet": "static struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\trstatc->bstat.cputime.sum_exec_runtime += delta_exec;\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}"
  },
  {
    "function_name": "cgroup_base_stat_cputime_account_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "356-363",
    "snippet": "static void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_ptr",
          "args": [
            "rstatc"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_updated",
          "args": [
            "cgrp",
            "smp_processor_id()"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_updated",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "25-70",
          "snippet": "void cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tunsigned long flags;\n\n\t/*\n\t * Speculative already-on-list test. This may race leading to\n\t * temporary inaccuracies, which is fine.\n\t *\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (data_race(cgroup_rstat_cpu(cgrp, cpu)->updated_next))\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\twhile (true) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup *parent = cgroup_parent(cgrp);\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\t/* Root has no parent to link it to, but mark it busy */\n\t\tif (!parent) {\n\t\t\trstatc->updated_next = cgrp;\n\t\t\tbreak;\n\t\t}\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\n\t\tcgrp = parent;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tunsigned long flags;\n\n\t/*\n\t * Speculative already-on-list test. This may race leading to\n\t * temporary inaccuracies, which is fine.\n\t *\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (data_race(cgroup_rstat_cpu(cgrp, cpu)->updated_next))\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\twhile (true) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup *parent = cgroup_parent(cgrp);\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\t/* Root has no parent to link it to, but mark it busy */\n\t\tif (!parent) {\n\t\t\trstatc->updated_next = cgrp;\n\t\t\tbreak;\n\t\t}\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\n\t\tcgrp = parent;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_update_end_irqrestore",
          "args": [
            "&rstatc->bsync",
            "flags"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}"
  },
  {
    "function_name": "cgroup_base_stat_cputime_account_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "346-354",
    "snippet": "static struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_stats_update_begin_irqsave",
          "args": [
            "&rstatc->bsync"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_ptr",
          "args": [
            "cgrp->rstat_cpu"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}"
  },
  {
    "function_name": "cgroup_base_stat_flush",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "314-344",
    "snippet": "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_base_stat cur, delta;\n\tunsigned seq;\n\n\t/* Root-level stats are sourced from system-wide CPU stats */\n\tif (!parent)\n\t\treturn;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcur.cputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* propagate percpu delta to global */\n\tdelta = cur;\n\tcgroup_base_stat_sub(&delta, &rstatc->last_bstat);\n\tcgroup_base_stat_add(&cgrp->bstat, &delta);\n\tcgroup_base_stat_add(&rstatc->last_bstat, &delta);\n\n\t/* propagate global delta to parent (unless that's root) */\n\tif (cgroup_parent(parent)) {\n\t\tdelta = cgrp->bstat;\n\t\tcgroup_base_stat_sub(&delta, &cgrp->last_bstat);\n\t\tcgroup_base_stat_add(&parent->bstat, &delta);\n\t\tcgroup_base_stat_add(&cgrp->last_bstat, &delta);\n\t}\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_stat_add",
          "args": [
            "&cgrp->last_bstat",
            "&delta"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "298-304",
          "snippet": "static void cgroup_base_stat_add(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_add(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_sub",
          "args": [
            "&delta",
            "&cgrp->last_bstat"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_sub",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "306-312",
          "snippet": "static void cgroup_base_stat_sub(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime -= src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime -= src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime -= src_bstat->cputime.sum_exec_runtime;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_sub(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime -= src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime -= src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime -= src_bstat->cputime.sum_exec_runtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "parent"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__u64_stats_fetch_retry",
          "args": [
            "&rstatc->bsync",
            "seq"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__u64_stats_fetch_begin",
          "args": [
            "&rstatc->bsync"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "cgrp",
            "cpu"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "11-14",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_base_stat cur, delta;\n\tunsigned seq;\n\n\t/* Root-level stats are sourced from system-wide CPU stats */\n\tif (!parent)\n\t\treturn;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcur.cputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* propagate percpu delta to global */\n\tdelta = cur;\n\tcgroup_base_stat_sub(&delta, &rstatc->last_bstat);\n\tcgroup_base_stat_add(&cgrp->bstat, &delta);\n\tcgroup_base_stat_add(&rstatc->last_bstat, &delta);\n\n\t/* propagate global delta to parent (unless that's root) */\n\tif (cgroup_parent(parent)) {\n\t\tdelta = cgrp->bstat;\n\t\tcgroup_base_stat_sub(&delta, &cgrp->last_bstat);\n\t\tcgroup_base_stat_add(&parent->bstat, &delta);\n\t\tcgroup_base_stat_add(&cgrp->last_bstat, &delta);\n\t}\n}"
  },
  {
    "function_name": "cgroup_base_stat_sub",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "306-312",
    "snippet": "static void cgroup_base_stat_sub(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime -= src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime -= src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime -= src_bstat->cputime.sum_exec_runtime;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_sub(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime -= src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime -= src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime -= src_bstat->cputime.sum_exec_runtime;\n}"
  },
  {
    "function_name": "cgroup_base_stat_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "298-304",
    "snippet": "static void cgroup_base_stat_add(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_add(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}"
  },
  {
    "function_name": "cgroup_rstat_boot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "286-292",
    "snippet": "void __init cgroup_rstat_boot(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu));\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid __init cgroup_rstat_boot(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu));\n}"
  },
  {
    "function_name": "cgroup_rstat_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "267-284",
    "snippet": "void cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "cgrp->rstat_cpu"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rstatc->updated_next"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rstatc->updated_children != cgrp"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "cgrp",
            "cpu"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "11-14",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush",
          "args": [
            "cgrp"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_hold",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "228-234",
          "snippet": "void cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}"
  },
  {
    "function_name": "cgroup_rstat_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "245-265",
    "snippet": "int cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_stats_init",
          "args": [
            "&rstatc->bsync"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "cgrp",
            "cpu"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "11-14",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structcgroup_rstat_cpu"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nint cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "239-243",
    "snippet": "void cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_hold",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "228-234",
    "snippet": "void cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_locked",
          "args": [
            "cgrp",
            "true"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "145-180",
          "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_irqsafe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "210-217",
    "snippet": "void cgroup_rstat_flush_irqsafe(struct cgroup *cgrp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_rstat_lock, flags);\n\tcgroup_rstat_flush_locked(cgrp, false);\n\tspin_unlock_irqrestore(&cgroup_rstat_lock, flags);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&cgroup_rstat_lock",
            "flags"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_locked",
          "args": [
            "cgrp",
            "false"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "145-180",
          "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&cgroup_rstat_lock",
            "flags"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_irqsafe(struct cgroup *cgrp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_rstat_lock, flags);\n\tcgroup_rstat_flush_locked(cgrp, false);\n\tspin_unlock_irqrestore(&cgroup_rstat_lock, flags);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "195-202",
    "snippet": "void cgroup_rstat_flush(struct cgroup *cgrp)\n{\n\tmight_sleep();\n\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_locked",
          "args": [
            "cgrp",
            "true"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "145-180",
          "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush(struct cgroup *cgrp)\n{\n\tmight_sleep();\n\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "145-180",
    "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
      "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "cpu_lock"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "css",
            "cpu"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "css",
            "&pos->rstat_css_list",
            "rstat_css_node"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_flush",
          "args": [
            "pos",
            "cpu"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_flush",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "314-344",
          "snippet": "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_base_stat cur, delta;\n\tunsigned seq;\n\n\t/* Root-level stats are sourced from system-wide CPU stats */\n\tif (!parent)\n\t\treturn;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcur.cputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* propagate percpu delta to global */\n\tdelta = cur;\n\tcgroup_base_stat_sub(&delta, &rstatc->last_bstat);\n\tcgroup_base_stat_add(&cgrp->bstat, &delta);\n\tcgroup_base_stat_add(&rstatc->last_bstat, &delta);\n\n\t/* propagate global delta to parent (unless that's root) */\n\tif (cgroup_parent(parent)) {\n\t\tdelta = cgrp->bstat;\n\t\tcgroup_base_stat_sub(&delta, &cgrp->last_bstat);\n\t\tcgroup_base_stat_add(&parent->bstat, &delta);\n\t\tcgroup_base_stat_add(&cgrp->last_bstat, &delta);\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_base_stat cur, delta;\n\tunsigned seq;\n\n\t/* Root-level stats are sourced from system-wide CPU stats */\n\tif (!parent)\n\t\treturn;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcur.cputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* propagate percpu delta to global */\n\tdelta = cur;\n\tcgroup_base_stat_sub(&delta, &rstatc->last_bstat);\n\tcgroup_base_stat_add(&cgrp->bstat, &delta);\n\tcgroup_base_stat_add(&rstatc->last_bstat, &delta);\n\n\t/* propagate global delta to parent (unless that's root) */\n\tif (cgroup_parent(parent)) {\n\t\tdelta = cgrp->bstat;\n\t\tcgroup_base_stat_sub(&delta, &cgrp->last_bstat);\n\t\tcgroup_base_stat_add(&parent->bstat, &delta);\n\t\tcgroup_base_stat_add(&cgrp->last_bstat, &delta);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu_pop_updated",
          "args": [
            "pos",
            "cgrp",
            "cpu"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu_pop_updated",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "87-142",
          "snippet": "static struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos) {\n\t\tpos = root;\n\t\t/* return NULL if this subtree is not on-list */\n\t\tif (!cgroup_rstat_cpu(pos, cpu)->updated_next)\n\t\t\treturn NULL;\n\t} else {\n\t\tpos = cgroup_parent(pos);\n\t}\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent) {\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (*nextp != pos) {\n\t\t\tstruct cgroup_rstat_cpu *nrstatc;\n\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\t\t*nextp = rstatc->updated_next;\n\t}\n\n\trstatc->updated_next = NULL;\n\treturn pos;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos) {\n\t\tpos = root;\n\t\t/* return NULL if this subtree is not on-list */\n\t\tif (!cgroup_rstat_cpu(pos, cpu)->updated_next)\n\t\t\treturn NULL;\n\t} else {\n\t\tpos = cgroup_parent(pos);\n\t}\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent) {\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (*nextp != pos) {\n\t\t\tstruct cgroup_rstat_cpu *nrstatc;\n\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\t\t*nextp = rstatc->updated_next;\n\t}\n\n\trstatc->updated_next = NULL;\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "cpu_lock"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cgroup_rstat_cpu_lock",
            "cpu"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cgroup_rstat_cpu_pop_updated",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "87-142",
    "snippet": "static struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos) {\n\t\tpos = root;\n\t\t/* return NULL if this subtree is not on-list */\n\t\tif (!cgroup_rstat_cpu(pos, cpu)->updated_next)\n\t\t\treturn NULL;\n\t} else {\n\t\tpos = cgroup_parent(pos);\n\t}\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent) {\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (*nextp != pos) {\n\t\t\tstruct cgroup_rstat_cpu *nrstatc;\n\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\t\t*nextp = rstatc->updated_next;\n\t}\n\n\trstatc->updated_next = NULL;\n\treturn pos;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "*nextp == parent"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "*nextp",
            "cpu"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "11-14",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "pos"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "pos"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos) {\n\t\tpos = root;\n\t\t/* return NULL if this subtree is not on-list */\n\t\tif (!cgroup_rstat_cpu(pos, cpu)->updated_next)\n\t\t\treturn NULL;\n\t} else {\n\t\tpos = cgroup_parent(pos);\n\t}\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent) {\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (*nextp != pos) {\n\t\t\tstruct cgroup_rstat_cpu *nrstatc;\n\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\t\t*nextp = rstatc->updated_next;\n\t}\n\n\trstatc->updated_next = NULL;\n\treturn pos;\n}"
  },
  {
    "function_name": "cgroup_rstat_updated",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "25-70",
    "snippet": "void cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tunsigned long flags;\n\n\t/*\n\t * Speculative already-on-list test. This may race leading to\n\t * temporary inaccuracies, which is fine.\n\t *\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (data_race(cgroup_rstat_cpu(cgrp, cpu)->updated_next))\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\twhile (true) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup *parent = cgroup_parent(cgrp);\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\t/* Root has no parent to link it to, but mark it busy */\n\t\tif (!parent) {\n\t\t\trstatc->updated_next = cgrp;\n\t\t\tbreak;\n\t\t}\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\n\t\tcgrp = parent;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "cpu_lock",
            "flags"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "parent",
            "cpu"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "11-14",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "cpu_lock",
            "flags"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "cgroup_rstat_cpu(cgrp, cpu)->updated_next"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cgroup_rstat_cpu_lock",
            "cpu"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tunsigned long flags;\n\n\t/*\n\t * Speculative already-on-list test. This may race leading to\n\t * temporary inaccuracies, which is fine.\n\t *\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (data_race(cgroup_rstat_cpu(cgrp, cpu)->updated_next))\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\twhile (true) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup *parent = cgroup_parent(cgrp);\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\t/* Root has no parent to link it to, but mark it busy */\n\t\tif (!parent) {\n\t\t\trstatc->updated_next = cgrp;\n\t\t\tbreak;\n\t\t}\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\n\t\tcgrp = parent;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}"
  },
  {
    "function_name": "cgroup_rstat_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
    "lines": "11-14",
    "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cgrp->rstat_cpu",
            "cpu"
          ],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
  }
]