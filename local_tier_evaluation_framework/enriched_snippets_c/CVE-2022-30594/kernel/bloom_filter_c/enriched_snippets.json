[
  {
    "function_name": "bloom_map_check_btf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
    "lines": "186-193",
    "snippet": "static int bloom_map_check_btf(const struct bpf_map *map,\n\t\t\t       const struct btf *btf,\n\t\t\t       const struct btf_type *key_type,\n\t\t\t       const struct btf_type *value_type)\n{\n\t/* Bloom filter maps are keyless */\n\treturn btf_type_is_void(key_type) ? 0 : -EINVAL;\n}",
    "includes": [
      "#include <linux/random.h>",
      "#include <linux/jhash.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_void",
          "args": [
            "key_type"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_void",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "430-433",
          "snippet": "bool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btf_type btf_void;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nbool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic int bloom_map_check_btf(const struct bpf_map *map,\n\t\t\t       const struct btf *btf,\n\t\t\t       const struct btf_type *key_type,\n\t\t\t       const struct btf_type *value_type)\n{\n\t/* Bloom filter maps are keyless */\n\treturn btf_type_is_void(key_type) ? 0 : -EINVAL;\n}"
  },
  {
    "function_name": "bloom_map_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
    "lines": "179-184",
    "snippet": "static int bloom_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t void *value, u64 flags)\n{\n\t/* The eBPF program should use map_push_elem instead */\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/random.h>",
      "#include <linux/jhash.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic int bloom_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t void *value, u64 flags)\n{\n\t/* The eBPF program should use map_push_elem instead */\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "bloom_map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
    "lines": "173-177",
    "snippet": "static void *bloom_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\t/* The eBPF program should use map_peek_elem instead */\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include <linux/random.h>",
      "#include <linux/jhash.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic void *bloom_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\t/* The eBPF program should use map_peek_elem instead */\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "bloom_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
    "lines": "165-171",
    "snippet": "static void bloom_map_free(struct bpf_map *map)\n{\n\tstruct bpf_bloom_filter *bloom =\n\t\tcontainer_of(map, struct bpf_bloom_filter, map);\n\n\tbpf_map_area_free(bloom);\n}",
    "includes": [
      "#include <linux/random.h>",
      "#include <linux/jhash.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "bloom"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "344-347",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_bloom_filter",
            "map"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic void bloom_map_free(struct bpf_map *map)\n{\n\tstruct bpf_bloom_filter *bloom =\n\t\tcontainer_of(map, struct bpf_bloom_filter, map);\n\n\tbpf_map_area_free(bloom);\n}"
  },
  {
    "function_name": "bloom_map_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
    "lines": "90-163",
    "snippet": "static struct bpf_map *bloom_map_alloc(union bpf_attr *attr)\n{\n\tu32 bitset_bytes, bitset_mask, nr_hash_funcs, nr_bits;\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_bloom_filter *bloom;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\tif (attr->key_size != 0 || attr->value_size == 0 ||\n\t    attr->max_entries == 0 ||\n\t    attr->map_flags & ~BLOOM_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags) ||\n\t    /* The lower 4 bits of map_extra (0xF) specify the number\n\t     * of hash functions\n\t     */\n\t    (attr->map_extra & ~0xF))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_hash_funcs = attr->map_extra;\n\tif (nr_hash_funcs == 0)\n\t\t/* Default to using 5 hash functions if unspecified */\n\t\tnr_hash_funcs = 5;\n\n\t/* For the bloom filter, the optimal bit array size that minimizes the\n\t * false positive probability is n * k / ln(2) where n is the number of\n\t * expected entries in the bloom filter and k is the number of hash\n\t * functions. We use 7 / 5 to approximate 1 / ln(2).\n\t *\n\t * We round this up to the nearest power of two to enable more efficient\n\t * hashing using bitmasks. The bitmask will be the bit array size - 1.\n\t *\n\t * If this overflows a u32, the bit array size will have 2^32 (4\n\t * GB) bits.\n\t */\n\tif (check_mul_overflow(attr->max_entries, nr_hash_funcs, &nr_bits) ||\n\t    check_mul_overflow(nr_bits / 5, (u32)7, &nr_bits) ||\n\t    nr_bits > (1UL << 31)) {\n\t\t/* The bit array size is 2^32 bits but to avoid overflowing the\n\t\t * u32, we use U32_MAX, which will round up to the equivalent\n\t\t * number of bytes\n\t\t */\n\t\tbitset_bytes = BITS_TO_BYTES(U32_MAX);\n\t\tbitset_mask = U32_MAX;\n\t} else {\n\t\tif (nr_bits <= BITS_PER_LONG)\n\t\t\tnr_bits = BITS_PER_LONG;\n\t\telse\n\t\t\tnr_bits = roundup_pow_of_two(nr_bits);\n\t\tbitset_bytes = BITS_TO_BYTES(nr_bits);\n\t\tbitset_mask = nr_bits - 1;\n\t}\n\n\tbitset_bytes = roundup(bitset_bytes, sizeof(unsigned long));\n\tbloom = bpf_map_area_alloc(sizeof(*bloom) + bitset_bytes, numa_node);\n\n\tif (!bloom)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&bloom->map, attr);\n\n\tbloom->nr_hash_funcs = nr_hash_funcs;\n\tbloom->bitset_mask = bitset_mask;\n\n\t/* Check whether the value size is u32-aligned */\n\tif ((attr->value_size & (sizeof(u32) - 1)) == 0)\n\t\tbloom->aligned_u32_count =\n\t\t\tattr->value_size / sizeof(u32);\n\n\tif (!(attr->map_flags & BPF_F_ZERO_SEED))\n\t\tbloom->hash_seed = get_random_int();\n\n\treturn &bloom->map;\n}",
    "includes": [
      "#include <linux/random.h>",
      "#include <linux/jhash.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [
      "#define BLOOM_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_ZERO_SEED | BPF_F_ACCESS_MASK)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&bloom->map",
            "attr"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "361-370",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "sizeof(*bloom) + bitset_bytes",
            "numa_node"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "334-337",
          "snippet": "void *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "bitset_bytes",
            "sizeof(unsigned long)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_BYTES",
          "args": [
            "nr_bits"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "nr_bits"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_BYTES",
          "args": [
            "U32_MAX"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_mul_overflow",
          "args": [
            "nr_bits / 5",
            "(u32)7",
            "&nr_bits"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_mul_overflow",
          "args": [
            "attr->max_entries",
            "nr_hash_funcs",
            "&nr_bits"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_flags_access_ok",
          "args": [
            "attr->map_flags"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\n#define BLOOM_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_ZERO_SEED | BPF_F_ACCESS_MASK)\n\nstatic struct bpf_map *bloom_map_alloc(union bpf_attr *attr)\n{\n\tu32 bitset_bytes, bitset_mask, nr_hash_funcs, nr_bits;\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_bloom_filter *bloom;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\tif (attr->key_size != 0 || attr->value_size == 0 ||\n\t    attr->max_entries == 0 ||\n\t    attr->map_flags & ~BLOOM_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags) ||\n\t    /* The lower 4 bits of map_extra (0xF) specify the number\n\t     * of hash functions\n\t     */\n\t    (attr->map_extra & ~0xF))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_hash_funcs = attr->map_extra;\n\tif (nr_hash_funcs == 0)\n\t\t/* Default to using 5 hash functions if unspecified */\n\t\tnr_hash_funcs = 5;\n\n\t/* For the bloom filter, the optimal bit array size that minimizes the\n\t * false positive probability is n * k / ln(2) where n is the number of\n\t * expected entries in the bloom filter and k is the number of hash\n\t * functions. We use 7 / 5 to approximate 1 / ln(2).\n\t *\n\t * We round this up to the nearest power of two to enable more efficient\n\t * hashing using bitmasks. The bitmask will be the bit array size - 1.\n\t *\n\t * If this overflows a u32, the bit array size will have 2^32 (4\n\t * GB) bits.\n\t */\n\tif (check_mul_overflow(attr->max_entries, nr_hash_funcs, &nr_bits) ||\n\t    check_mul_overflow(nr_bits / 5, (u32)7, &nr_bits) ||\n\t    nr_bits > (1UL << 31)) {\n\t\t/* The bit array size is 2^32 bits but to avoid overflowing the\n\t\t * u32, we use U32_MAX, which will round up to the equivalent\n\t\t * number of bytes\n\t\t */\n\t\tbitset_bytes = BITS_TO_BYTES(U32_MAX);\n\t\tbitset_mask = U32_MAX;\n\t} else {\n\t\tif (nr_bits <= BITS_PER_LONG)\n\t\t\tnr_bits = BITS_PER_LONG;\n\t\telse\n\t\t\tnr_bits = roundup_pow_of_two(nr_bits);\n\t\tbitset_bytes = BITS_TO_BYTES(nr_bits);\n\t\tbitset_mask = nr_bits - 1;\n\t}\n\n\tbitset_bytes = roundup(bitset_bytes, sizeof(unsigned long));\n\tbloom = bpf_map_area_alloc(sizeof(*bloom) + bitset_bytes, numa_node);\n\n\tif (!bloom)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&bloom->map, attr);\n\n\tbloom->nr_hash_funcs = nr_hash_funcs;\n\tbloom->bitset_mask = bitset_mask;\n\n\t/* Check whether the value size is u32-aligned */\n\tif ((attr->value_size & (sizeof(u32) - 1)) == 0)\n\t\tbloom->aligned_u32_count =\n\t\t\tattr->value_size / sizeof(u32);\n\n\tif (!(attr->map_flags & BPF_F_ZERO_SEED))\n\t\tbloom->hash_seed = get_random_int();\n\n\treturn &bloom->map;\n}"
  },
  {
    "function_name": "bloom_map_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
    "lines": "85-88",
    "snippet": "static int bloom_map_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include <linux/random.h>",
      "#include <linux/jhash.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic int bloom_map_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "bloom_map_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
    "lines": "80-83",
    "snippet": "static int bloom_map_delete_elem(struct bpf_map *map, void *value)\n{\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include <linux/random.h>",
      "#include <linux/jhash.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic int bloom_map_delete_elem(struct bpf_map *map, void *value)\n{\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "bloom_map_pop_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
    "lines": "75-78",
    "snippet": "static int bloom_map_pop_elem(struct bpf_map *map, void *value)\n{\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include <linux/random.h>",
      "#include <linux/jhash.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic int bloom_map_pop_elem(struct bpf_map *map, void *value)\n{\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "bloom_map_push_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
    "lines": "58-73",
    "snippet": "static int bloom_map_push_elem(struct bpf_map *map, void *value, u64 flags)\n{\n\tstruct bpf_bloom_filter *bloom =\n\t\tcontainer_of(map, struct bpf_bloom_filter, map);\n\tu32 i, h;\n\n\tif (flags != BPF_ANY)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {\n\t\th = hash(bloom, value, map->value_size, i);\n\t\tset_bit(h, bloom->bitset);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/random.h>",
      "#include <linux/jhash.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "h",
            "bloom->bitset"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "bloom",
            "value",
            "map->value_size",
            "i"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
          "lines": "29-41",
          "snippet": "static u32 hash(struct bpf_bloom_filter *bloom, void *value,\n\t\tu32 value_size, u32 index)\n{\n\tu32 h;\n\n\tif (bloom->aligned_u32_count)\n\t\th = jhash2(value, bloom->aligned_u32_count,\n\t\t\t   bloom->hash_seed + index);\n\telse\n\t\th = jhash(value, value_size, bloom->hash_seed + index);\n\n\treturn h & bloom->bitset_mask;\n}",
          "includes": [
            "#include <linux/random.h>",
            "#include <linux/jhash.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic u32 hash(struct bpf_bloom_filter *bloom, void *value,\n\t\tu32 value_size, u32 index)\n{\n\tu32 h;\n\n\tif (bloom->aligned_u32_count)\n\t\th = jhash2(value, bloom->aligned_u32_count,\n\t\t\t   bloom->hash_seed + index);\n\telse\n\t\th = jhash(value, value_size, bloom->hash_seed + index);\n\n\treturn h & bloom->bitset_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_bloom_filter",
            "map"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic int bloom_map_push_elem(struct bpf_map *map, void *value, u64 flags)\n{\n\tstruct bpf_bloom_filter *bloom =\n\t\tcontainer_of(map, struct bpf_bloom_filter, map);\n\tu32 i, h;\n\n\tif (flags != BPF_ANY)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {\n\t\th = hash(bloom, value, map->value_size, i);\n\t\tset_bit(h, bloom->bitset);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bloom_map_peek_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
    "lines": "43-56",
    "snippet": "static int bloom_map_peek_elem(struct bpf_map *map, void *value)\n{\n\tstruct bpf_bloom_filter *bloom =\n\t\tcontainer_of(map, struct bpf_bloom_filter, map);\n\tu32 i, h;\n\n\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {\n\t\th = hash(bloom, value, map->value_size, i);\n\t\tif (!test_bit(h, bloom->bitset))\n\t\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/random.h>",
      "#include <linux/jhash.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "h",
            "bloom->bitset"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "bloom",
            "value",
            "map->value_size",
            "i"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
          "lines": "29-41",
          "snippet": "static u32 hash(struct bpf_bloom_filter *bloom, void *value,\n\t\tu32 value_size, u32 index)\n{\n\tu32 h;\n\n\tif (bloom->aligned_u32_count)\n\t\th = jhash2(value, bloom->aligned_u32_count,\n\t\t\t   bloom->hash_seed + index);\n\telse\n\t\th = jhash(value, value_size, bloom->hash_seed + index);\n\n\treturn h & bloom->bitset_mask;\n}",
          "includes": [
            "#include <linux/random.h>",
            "#include <linux/jhash.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic u32 hash(struct bpf_bloom_filter *bloom, void *value,\n\t\tu32 value_size, u32 index)\n{\n\tu32 h;\n\n\tif (bloom->aligned_u32_count)\n\t\th = jhash2(value, bloom->aligned_u32_count,\n\t\t\t   bloom->hash_seed + index);\n\telse\n\t\th = jhash(value, value_size, bloom->hash_seed + index);\n\n\treturn h & bloom->bitset_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_bloom_filter",
            "map"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic int bloom_map_peek_elem(struct bpf_map *map, void *value)\n{\n\tstruct bpf_bloom_filter *bloom =\n\t\tcontainer_of(map, struct bpf_bloom_filter, map);\n\tu32 i, h;\n\n\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {\n\t\th = hash(bloom, value, map->value_size, i);\n\t\tif (!test_bit(h, bloom->bitset))\n\t\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bloom_filter.c",
    "lines": "29-41",
    "snippet": "static u32 hash(struct bpf_bloom_filter *bloom, void *value,\n\t\tu32 value_size, u32 index)\n{\n\tu32 h;\n\n\tif (bloom->aligned_u32_count)\n\t\th = jhash2(value, bloom->aligned_u32_count,\n\t\t\t   bloom->hash_seed + index);\n\telse\n\t\th = jhash(value, value_size, bloom->hash_seed + index);\n\n\treturn h & bloom->bitset_mask;\n}",
    "includes": [
      "#include <linux/random.h>",
      "#include <linux/jhash.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bitmap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "value",
            "value_size",
            "bloom->hash_seed + index"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhash2",
          "args": [
            "value",
            "bloom->aligned_u32_count",
            "bloom->hash_seed + index"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/bitmap.h>\n\nstatic u32 hash(struct bpf_bloom_filter *bloom, void *value,\n\t\tu32 value_size, u32 index)\n{\n\tu32 h;\n\n\tif (bloom->aligned_u32_count)\n\t\th = jhash2(value, bloom->aligned_u32_count,\n\t\t\t   bloom->hash_seed + index);\n\telse\n\t\th = jhash(value, value_size, bloom->hash_seed + index);\n\n\treturn h & bloom->bitset_mask;\n}"
  }
]