[
  {
    "function_name": "validate_creds_for_do_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "922-930",
    "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__validate_process_creds",
          "args": [
            "tsk",
            "__FILE__",
            "__LINE__"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "__validate_process_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "890-916",
          "snippet": "void __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(KERN_ERR \"CRED: Invalid process credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"Real\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"Effective\", tsk);\n\telse\n\t\tprintk(KERN_ERR \"CRED: Effective creds == Real creds\\n\");\n\tBUG();\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(KERN_ERR \"CRED: Invalid process credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"Real\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"Effective\", tsk);\n\telse\n\t\tprintk(KERN_ERR \"CRED: Effective creds == Real creds\\n\");\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"validate_creds_for_do_exit(%p,%p{%d,%d})\"",
            "tsk->real_cred",
            "tsk->cred",
            "atomic_read(&tsk->cred->usage)",
            "read_cred_subscribers(tsk->cred)"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "tsk->cred"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "73-80",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tsk->cred->usage"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
  },
  {
    "function_name": "__validate_process_creds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "890-916",
    "snippet": "void __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(KERN_ERR \"CRED: Invalid process credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"Real\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"Effective\", tsk);\n\telse\n\t\tprintk(KERN_ERR \"CRED: Effective creds == Real creds\\n\");\n\tBUG();\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CRED: Effective creds == Real creds\\n\""
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_invalid_creds",
          "args": [
            "tsk->cred",
            "\"Effective\"",
            "tsk"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "dump_invalid_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "841-873",
          "snippet": "static void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n\t.ucounts\t\t= &init_ucounts,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n\t.ucounts\t\t= &init_ucounts,\n};\n\nstatic void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CRED: At %s:%u\\n\"",
            "file",
            "line"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "creds_are_invalid",
          "args": [
            "tsk->cred"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "creds_are_invalid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "830-835",
          "snippet": "bool creds_are_invalid(const struct cred *cred)\n{\n\tif (cred->magic != CRED_MAGIC)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nbool creds_are_invalid(const struct cred *cred)\n{\n\tif (cred->magic != CRED_MAGIC)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "tsk->cred"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "73-80",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(KERN_ERR \"CRED: Invalid process credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"Real\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"Effective\", tsk);\n\telse\n\t\tprintk(KERN_ERR \"CRED: Effective creds == Real creds\\n\");\n\tBUG();\n}"
  },
  {
    "function_name": "__invalid_creds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "878-884",
    "snippet": "void __invalid_creds(const struct cred *cred, const char *file, unsigned line)\n{\n\tprintk(KERN_ERR \"CRED: Invalid credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\tdump_invalid_creds(cred, \"Specified\", current);\n\tBUG();\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_invalid_creds",
          "args": [
            "cred",
            "\"Specified\"",
            "current"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "dump_invalid_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "841-873",
          "snippet": "static void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n\t.ucounts\t\t= &init_ucounts,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n\t.ucounts\t\t= &init_ucounts,\n};\n\nstatic void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CRED: At %s:%u\\n\"",
            "file",
            "line"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CRED: Invalid credentials\\n\""
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __invalid_creds(const struct cred *cred, const char *file, unsigned line)\n{\n\tprintk(KERN_ERR \"CRED: Invalid credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\tdump_invalid_creds(cred, \"Specified\", current);\n\tBUG();\n}"
  },
  {
    "function_name": "dump_invalid_creds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "841-873",
    "snippet": "static void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n\t.ucounts\t\t= &init_ucounts,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CRED: ->security {%x, %x}\\n\"",
            "((u32*)cred->security)[0]",
            "((u32*)cred->security)[1]"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "cred->fsgid"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "502-510",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "cred->fsuid"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "cred"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "73-80",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n\t.ucounts\t\t= &init_ucounts,\n};\n\nstatic void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}"
  },
  {
    "function_name": "creds_are_invalid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "830-835",
    "snippet": "bool creds_are_invalid(const struct cred *cred)\n{\n\tif (cred->magic != CRED_MAGIC)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nbool creds_are_invalid(const struct cred *cred)\n{\n\tif (cred->magic != CRED_MAGIC)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "set_create_files_as",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "818-825",
    "snippet": "int set_create_files_as(struct cred *new, struct inode *inode)\n{\n\tif (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))\n\t\treturn -EINVAL;\n\tnew->fsuid = inode->i_uid;\n\tnew->fsgid = inode->i_gid;\n\treturn security_kernel_create_files_as(new, inode);\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_kernel_create_files_as",
          "args": [
            "new",
            "inode"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "inode->i_gid"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "inode->i_uid"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint set_create_files_as(struct cred *new, struct inode *inode)\n{\n\tif (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))\n\t\treturn -EINVAL;\n\tnew->fsuid = inode->i_uid;\n\tnew->fsgid = inode->i_gid;\n\treturn security_kernel_create_files_as(new, inode);\n}"
  },
  {
    "function_name": "set_security_override_from_ctx",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "796-806",
    "snippet": "int set_security_override_from_ctx(struct cred *new, const char *secctx)\n{\n\tu32 secid;\n\tint ret;\n\n\tret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn set_security_override(new, secid);\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_security_override",
          "args": [
            "new",
            "secid"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "set_security_override_from_ctx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "796-806",
          "snippet": "int set_security_override_from_ctx(struct cred *new, const char *secctx)\n{\n\tu32 secid;\n\tint ret;\n\n\tret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn set_security_override(new, secid);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "security_secctx_to_secid",
          "args": [
            "secctx",
            "strlen(secctx)",
            "&secid"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "secctx"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint set_security_override_from_ctx(struct cred *new, const char *secctx)\n{\n\tu32 secid;\n\tint ret;\n\n\tret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn set_security_override(new, secid);\n}"
  },
  {
    "function_name": "set_security_override",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "780-783",
    "snippet": "int set_security_override(struct cred *new, u32 secid)\n{\n\treturn security_kernel_act_as(new, secid);\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_kernel_act_as",
          "args": [
            "new",
            "secid"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint set_security_override(struct cred *new, u32 secid)\n{\n\treturn security_kernel_act_as(new, secid);\n}"
  },
  {
    "function_name": "prepare_kernel_cred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "717-769",
    "snippet": "struct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_kernel_cred() alloc %p\", new);\n\n\tif (daemon)\n\t\told = get_task_cred(daemon);\n\telse\n\t\told = get_cred(&init_cred);\n\n\tvalidate_creds(old);\n\n\t*new = *old;\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\tget_group_info(new->group_info);\n\n#ifdef CONFIG_KEYS\n\tnew->session_keyring = NULL;\n\tnew->process_keyring = NULL;\n\tnew->thread_keyring = NULL;\n\tnew->request_key_auth = NULL;\n\tnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cred_jar;",
      "struct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n\t.ucounts\t\t= &init_ucounts,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "old"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "135-154",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "new"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "922-930",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_prepare_creds",
          "args": [
            "new",
            "old",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ucounts",
          "args": [
            "new->ucounts"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "get_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "159-166",
          "snippet": "struct ucounts *get_ucounts(struct ucounts *ucounts)\n{\n\tif (!get_ucounts_or_wrap(ucounts)) {\n\t\tput_ucounts(ucounts);\n\t\tucounts = NULL;\n\t}\n\treturn ucounts;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstruct ucounts *get_ucounts(struct ucounts *ucounts)\n{\n\tif (!get_ucounts_or_wrap(ucounts)) {\n\t\tput_ucounts(ucounts);\n\t\tucounts = NULL;\n\t}\n\treturn ucounts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_group_info",
          "args": [
            "new->group_info"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "new->user_ns"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uid",
          "args": [
            "new->user"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cred_subscribers",
          "args": [
            "new",
            "0"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "set_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "66-71",
          "snippet": "static inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->usage",
            "1"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cred",
          "args": [
            "&init_cred"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_cred",
          "args": [
            "daemon"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "196-209",
          "snippet": "const struct cred *get_task_cred(struct task_struct *task)\n{\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcred = __task_cred((task));\n\t\tBUG_ON(!cred);\n\t} while (!get_cred_rcu(cred));\n\n\trcu_read_unlock();\n\treturn cred;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nconst struct cred *get_task_cred(struct task_struct *task)\n{\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcred = __task_cred((task));\n\t\tBUG_ON(!cred);\n\t} while (!get_cred_rcu(cred));\n\n\trcu_read_unlock();\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"prepare_kernel_cred() alloc %p\"",
            "new"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "cred_jar",
            "GFP_KERNEL"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n\t.ucounts\t\t= &init_ucounts,\n};\n\nstruct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_kernel_cred() alloc %p\", new);\n\n\tif (daemon)\n\t\told = get_task_cred(daemon);\n\telse\n\t\told = get_cred(&init_cred);\n\n\tvalidate_creds(old);\n\n\t*new = *old;\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\tget_group_info(new->group_info);\n\n#ifdef CONFIG_KEYS\n\tnew->session_keyring = NULL;\n\tnew->process_keyring = NULL;\n\tnew->thread_keyring = NULL;\n\tnew->request_key_auth = NULL;\n\tnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cred_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "694-699",
    "snippet": "void __init cred_init(void)\n{\n\t/* allocate a slab in which we can store credentials */\n\tcred_jar = kmem_cache_create(\"cred_jar\", sizeof(struct cred), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cred_jar;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"cred_jar\"",
            "sizeof(struct cred)",
            "0",
            "SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT",
            "NULL"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nvoid __init cred_init(void)\n{\n\t/* allocate a slab in which we can store credentials */\n\tcred_jar = kmem_cache_create(\"cred_jar\", sizeof(struct cred), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);\n}"
  },
  {
    "function_name": "set_cred_ucounts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "666-689",
    "snippet": "int set_cred_ucounts(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\tstruct ucounts *new_ucounts, *old_ucounts = new->ucounts;\n\n\tif (new->user == old->user && new->user_ns == old->user_ns)\n\t\treturn 0;\n\n\t/*\n\t * This optimization is needed because alloc_ucounts() uses locks\n\t * for table lookups.\n\t */\n\tif (old_ucounts->ns == new->user_ns && uid_eq(old_ucounts->uid, new->euid))\n\t\treturn 0;\n\n\tif (!(new_ucounts = alloc_ucounts(new->user_ns, new->euid)))\n\t\treturn -EAGAIN;\n\n\tnew->ucounts = new_ucounts;\n\tput_ucounts(old_ucounts);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_ucounts",
          "args": [
            "old_ucounts"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "put_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "206-215",
          "snippet": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nvoid put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_ucounts",
          "args": [
            "new->user_ns",
            "new->euid"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "168-204",
          "snippet": "struct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nstruct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old_ucounts->uid",
            "new->euid"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint set_cred_ucounts(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\tstruct ucounts *new_ucounts, *old_ucounts = new->ucounts;\n\n\tif (new->user == old->user && new->user_ns == old->user_ns)\n\t\treturn 0;\n\n\t/*\n\t * This optimization is needed because alloc_ucounts() uses locks\n\t * for table lookups.\n\t */\n\tif (old_ucounts->ns == new->user_ns && uid_eq(old_ucounts->uid, new->euid))\n\t\treturn 0;\n\n\tif (!(new_ucounts = alloc_ucounts(new->user_ns, new->euid)))\n\t\treturn -EAGAIN;\n\n\tnew->ucounts = new_ucounts;\n\tput_ucounts(old_ucounts);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cred_fscmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "626-663",
    "snippet": "int cred_fscmp(const struct cred *a, const struct cred *b)\n{\n\tstruct group_info *ga, *gb;\n\tint g;\n\n\tif (a == b)\n\t\treturn 0;\n\tif (uid_lt(a->fsuid, b->fsuid))\n\t\treturn -1;\n\tif (uid_gt(a->fsuid, b->fsuid))\n\t\treturn 1;\n\n\tif (gid_lt(a->fsgid, b->fsgid))\n\t\treturn -1;\n\tif (gid_gt(a->fsgid, b->fsgid))\n\t\treturn 1;\n\n\tga = a->group_info;\n\tgb = b->group_info;\n\tif (ga == gb)\n\t\treturn 0;\n\tif (ga == NULL)\n\t\treturn -1;\n\tif (gb == NULL)\n\t\treturn 1;\n\tif (ga->ngroups < gb->ngroups)\n\t\treturn -1;\n\tif (ga->ngroups > gb->ngroups)\n\t\treturn 1;\n\n\tfor (g = 0; g < ga->ngroups; g++) {\n\t\tif (gid_lt(ga->gid[g], gb->gid[g]))\n\t\t\treturn -1;\n\t\tif (gid_gt(ga->gid[g], gb->gid[g]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_gt",
          "args": [
            "ga->gid[g]",
            "gb->gid[g]"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_lt",
          "args": [
            "ga->gid[g]",
            "gb->gid[g]"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_gt",
          "args": [
            "a->fsgid",
            "b->fsgid"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_lt",
          "args": [
            "a->fsgid",
            "b->fsgid"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_gt",
          "args": [
            "a->fsuid",
            "b->fsuid"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_lt",
          "args": [
            "a->fsuid",
            "b->fsuid"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint cred_fscmp(const struct cred *a, const struct cred *b)\n{\n\tstruct group_info *ga, *gb;\n\tint g;\n\n\tif (a == b)\n\t\treturn 0;\n\tif (uid_lt(a->fsuid, b->fsuid))\n\t\treturn -1;\n\tif (uid_gt(a->fsuid, b->fsuid))\n\t\treturn 1;\n\n\tif (gid_lt(a->fsgid, b->fsgid))\n\t\treturn -1;\n\tif (gid_gt(a->fsgid, b->fsgid))\n\t\treturn 1;\n\n\tga = a->group_info;\n\tgb = b->group_info;\n\tif (ga == gb)\n\t\treturn 0;\n\tif (ga == NULL)\n\t\treturn -1;\n\tif (gb == NULL)\n\t\treturn 1;\n\tif (ga->ngroups < gb->ngroups)\n\t\treturn -1;\n\tif (ga->ngroups > gb->ngroups)\n\t\treturn 1;\n\n\tfor (g = 0; g < ga->ngroups; g++) {\n\t\tif (gid_lt(ga->gid[g], gb->gid[g]))\n\t\t\treturn -1;\n\t\tif (gid_gt(ga->gid[g], gb->gid[g]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "revert_creds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "595-609",
    "snippet": "void revert_creds(const struct cred *old)\n{\n\tconst struct cred *override = current->cred;\n\n\tkdebug(\"revert_creds(%p{%d,%d})\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\n\tvalidate_creds(old);\n\tvalidate_creds(override);\n\talter_cred_subscribers(old, 1);\n\trcu_assign_pointer(current->cred, old);\n\talter_cred_subscribers(override, -1);\n\tput_cred(override);\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "override"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "135-154",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alter_cred_subscribers",
          "args": [
            "override",
            "-1"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "alter_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "82-89",
          "snippet": "static inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "current->cred",
            "old"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "override"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "922-930",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"revert_creds(%p{%d,%d})\"",
            "old",
            "atomic_read(&old->usage)",
            "read_cred_subscribers(old)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "old"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "73-80",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&old->usage"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid revert_creds(const struct cred *old)\n{\n\tconst struct cred *override = current->cred;\n\n\tkdebug(\"revert_creds(%p{%d,%d})\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\n\tvalidate_creds(old);\n\tvalidate_creds(override);\n\talter_cred_subscribers(old, 1);\n\trcu_assign_pointer(current->cred, old);\n\talter_cred_subscribers(override, -1);\n\tput_cred(override);\n}"
  },
  {
    "function_name": "override_creds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "554-585",
    "snippet": "const struct cred *override_creds(const struct cred *new)\n{\n\tconst struct cred *old = current->cred;\n\n\tkdebug(\"override_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n\n\t/*\n\t * NOTE! This uses 'get_new_cred()' rather than 'get_cred()'.\n\t *\n\t * That means that we do not clear the 'non_rcu' flag, since\n\t * we are only installing the cred into the thread-synchronous\n\t * '->cred' pointer, not the '->real_cred' pointer that is\n\t * visible to other threads under RCU.\n\t *\n\t * Also note that we did validate_creds() manually, not depending\n\t * on the validation in 'get_cred()'.\n\t */\n\tget_new_cred((struct cred *)new);\n\talter_cred_subscribers(new, 1);\n\trcu_assign_pointer(current->cred, new);\n\talter_cred_subscribers(old, -1);\n\n\tkdebug(\"override_creds() = %p{%d,%d}\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\treturn old;\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"override_creds() = %p{%d,%d}\"",
            "old",
            "atomic_read(&old->usage)",
            "read_cred_subscribers(old)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "old"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "73-80",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&old->usage"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alter_cred_subscribers",
          "args": [
            "old",
            "-1"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "alter_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "82-89",
          "snippet": "static inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "current->cred",
            "new"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_new_cred",
          "args": [
            "(struct cred *)new"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "new"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "922-930",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"override_creds(%p{%d,%d})\"",
            "new",
            "atomic_read(&new->usage)",
            "read_cred_subscribers(new)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&new->usage"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nconst struct cred *override_creds(const struct cred *new)\n{\n\tconst struct cred *old = current->cred;\n\n\tkdebug(\"override_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n\n\t/*\n\t * NOTE! This uses 'get_new_cred()' rather than 'get_cred()'.\n\t *\n\t * That means that we do not clear the 'non_rcu' flag, since\n\t * we are only installing the cred into the thread-synchronous\n\t * '->cred' pointer, not the '->real_cred' pointer that is\n\t * visible to other threads under RCU.\n\t *\n\t * Also note that we did validate_creds() manually, not depending\n\t * on the validation in 'get_cred()'.\n\t */\n\tget_new_cred((struct cred *)new);\n\talter_cred_subscribers(new, 1);\n\trcu_assign_pointer(current->cred, new);\n\talter_cred_subscribers(old, -1);\n\n\tkdebug(\"override_creds() = %p{%d,%d}\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\treturn old;\n}"
  },
  {
    "function_name": "abort_creds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "533-544",
    "snippet": "void abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "new"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "135-154",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&new->usage) < 1"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&new->usage"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "read_cred_subscribers(new) != 0"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "new"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "73-80",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"abort_creds(%p{%d,%d})\"",
            "new",
            "atomic_read(&new->usage)",
            "read_cred_subscribers(new)"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&new->usage"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}"
  },
  {
    "function_name": "commit_creds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "447-523",
    "snippet": "int commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\t/*\n\t\t * If a task drops privileges and becomes nondumpable,\n\t\t * the dumpability change must become visible before\n\t\t * the credential change; otherwise, a __ptrace_may_access()\n\t\t * racing with this change may be able to attach to a task it\n\t\t * shouldn't be able to attach to (as if the task had dropped\n\t\t * privileges without becoming nondumpable).\n\t\t * Pairs with a read barrier in __ptrace_may_access().\n\t\t */\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(new);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(new);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tinc_rlimit_ucounts(new->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tdec_rlimit_ucounts(old->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "old"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "135-154",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_id_connector",
          "args": [
            "task",
            "PROC_EVENT_GID"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "new->fsgid",
            "old->fsgid"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "new->sgid",
            "old->sgid"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "new->egid",
            "old->egid"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "new->gid",
            "old->gid"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_id_connector",
          "args": [
            "task",
            "PROC_EVENT_UID"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->fsuid",
            "old->fsuid"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->suid",
            "old->suid"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->euid",
            "old->euid"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->uid",
            "old->uid"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alter_cred_subscribers",
          "args": [
            "old",
            "-2"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "alter_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "82-89",
          "snippet": "static inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_rlimit_ucounts",
          "args": [
            "old->ucounts",
            "UCOUNT_RLIMIT_NPROC",
            "1"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "dec_rlimit_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "281-292",
          "snippet": "bool dec_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong new = -1; /* Silence compiler warning */\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_sub_return(v, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tif (iter == ucounts)\n\t\t\tnew = dec;\n\t}\n\treturn (new == 0);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nbool dec_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong new = -1; /* Silence compiler warning */\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_sub_return(v, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tif (iter == ucounts)\n\t\t\tnew = dec;\n\t}\n\treturn (new == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "task->cred",
            "new"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "task->real_cred",
            "new"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_rlimit_ucounts",
          "args": [
            "new->ucounts",
            "UCOUNT_RLIMIT_NPROC",
            "1"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rlimit_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "264-279",
          "snippet": "long inc_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong max = LONG_MAX;\n\tlong ret = 0;\n\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong new = atomic_long_add_return(v, &iter->ucount[type]);\n\t\tif (new < 0 || new > max)\n\t\t\tret = LONG_MAX;\n\t\telse if (iter == ucounts)\n\t\t\tret = new;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nlong inc_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong max = LONG_MAX;\n\tlong ret = 0;\n\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong new = atomic_long_add_return(v, &iter->ucount[type]);\n\t\tif (new < 0 || new > max)\n\t\t\tret = LONG_MAX;\n\t\telse if (iter == ucounts)\n\t\t\tret = new;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_fsgid_changed",
          "args": [
            "new"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "new->fsgid",
            "old->fsgid"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_fsuid_changed",
          "args": [
            "new"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->fsuid",
            "old->fsuid"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dumpable",
          "args": [
            "task->mm",
            "suid_dumpable"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cred_cap_issubset",
          "args": [
            "old",
            "new"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "cred_cap_issubset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "408-431",
          "snippet": "static bool cred_cap_issubset(const struct cred *set, const struct cred *subset)\n{\n\tconst struct user_namespace *set_ns = set->user_ns;\n\tconst struct user_namespace *subset_ns = subset->user_ns;\n\n\t/* If the two credentials are in the same user namespace see if\n\t * the capabilities of subset are a subset of set.\n\t */\n\tif (set_ns == subset_ns)\n\t\treturn cap_issubset(subset->cap_permitted, set->cap_permitted);\n\n\t/* The credentials are in a different user namespaces\n\t * therefore one is a subset of the other only if a set is an\n\t * ancestor of subset and set->euid is owner of subset or one\n\t * of subsets ancestors.\n\t */\n\tfor (;subset_ns != &init_user_ns; subset_ns = subset_ns->parent) {\n\t\tif ((set_ns == subset_ns->parent)  &&\n\t\t    uid_eq(subset_ns->owner, set->euid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic bool cred_cap_issubset(const struct cred *set, const struct cred *subset)\n{\n\tconst struct user_namespace *set_ns = set->user_ns;\n\tconst struct user_namespace *subset_ns = subset->user_ns;\n\n\t/* If the two credentials are in the same user namespace see if\n\t * the capabilities of subset are a subset of set.\n\t */\n\tif (set_ns == subset_ns)\n\t\treturn cap_issubset(subset->cap_permitted, set->cap_permitted);\n\n\t/* The credentials are in a different user namespaces\n\t * therefore one is a subset of the other only if a set is an\n\t * ancestor of subset and set->euid is owner of subset or one\n\t * of subsets ancestors.\n\t */\n\tfor (;subset_ns != &init_user_ns; subset_ns = subset_ns->parent) {\n\t\tif ((set_ns == subset_ns->parent)  &&\n\t\t    uid_eq(subset_ns->owner, set->euid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "old->fsgid",
            "new->fsgid"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->fsuid",
            "new->fsuid"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "old->egid",
            "new->egid"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->euid",
            "new->euid"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cred",
          "args": [
            "new"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&new->usage) < 1"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&new->usage"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "new"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "922-930",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "read_cred_subscribers(old) < 2"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "old"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "73-80",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "task->cred != old"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"commit_creds(%p{%d,%d})\"",
            "new",
            "atomic_read(&new->usage)",
            "read_cred_subscribers(new)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&new->usage"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\t/*\n\t\t * If a task drops privileges and becomes nondumpable,\n\t\t * the dumpability change must become visible before\n\t\t * the credential change; otherwise, a __ptrace_may_access()\n\t\t * racing with this change may be able to attach to a task it\n\t\t * shouldn't be able to attach to (as if the task had dropped\n\t\t * privileges without becoming nondumpable).\n\t\t * Pairs with a read barrier in __ptrace_may_access().\n\t\t */\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(new);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(new);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tinc_rlimit_ucounts(new->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tdec_rlimit_ucounts(old->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}"
  },
  {
    "function_name": "cred_cap_issubset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "408-431",
    "snippet": "static bool cred_cap_issubset(const struct cred *set, const struct cred *subset)\n{\n\tconst struct user_namespace *set_ns = set->user_ns;\n\tconst struct user_namespace *subset_ns = subset->user_ns;\n\n\t/* If the two credentials are in the same user namespace see if\n\t * the capabilities of subset are a subset of set.\n\t */\n\tif (set_ns == subset_ns)\n\t\treturn cap_issubset(subset->cap_permitted, set->cap_permitted);\n\n\t/* The credentials are in a different user namespaces\n\t * therefore one is a subset of the other only if a set is an\n\t * ancestor of subset and set->euid is owner of subset or one\n\t * of subsets ancestors.\n\t */\n\tfor (;subset_ns != &init_user_ns; subset_ns = subset_ns->parent) {\n\t\tif ((set_ns == subset_ns->parent)  &&\n\t\t    uid_eq(subset_ns->owner, set->euid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "subset_ns->owner",
            "set->euid"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_issubset",
          "args": [
            "subset->cap_permitted",
            "set->cap_permitted"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "cred_cap_issubset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "408-431",
          "snippet": "static bool cred_cap_issubset(const struct cred *set, const struct cred *subset)\n{\n\tconst struct user_namespace *set_ns = set->user_ns;\n\tconst struct user_namespace *subset_ns = subset->user_ns;\n\n\t/* If the two credentials are in the same user namespace see if\n\t * the capabilities of subset are a subset of set.\n\t */\n\tif (set_ns == subset_ns)\n\t\treturn cap_issubset(subset->cap_permitted, set->cap_permitted);\n\n\t/* The credentials are in a different user namespaces\n\t * therefore one is a subset of the other only if a set is an\n\t * ancestor of subset and set->euid is owner of subset or one\n\t * of subsets ancestors.\n\t */\n\tfor (;subset_ns != &init_user_ns; subset_ns = subset_ns->parent) {\n\t\tif ((set_ns == subset_ns->parent)  &&\n\t\t    uid_eq(subset_ns->owner, set->euid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic bool cred_cap_issubset(const struct cred *set, const struct cred *subset)\n{\n\tconst struct user_namespace *set_ns = set->user_ns;\n\tconst struct user_namespace *subset_ns = subset->user_ns;\n\n\t/* If the two credentials are in the same user namespace see if\n\t * the capabilities of subset are a subset of set.\n\t */\n\tif (set_ns == subset_ns)\n\t\treturn cap_issubset(subset->cap_permitted, set->cap_permitted);\n\n\t/* The credentials are in a different user namespaces\n\t * therefore one is a subset of the other only if a set is an\n\t * ancestor of subset and set->euid is owner of subset or one\n\t * of subsets ancestors.\n\t */\n\tfor (;subset_ns != &init_user_ns; subset_ns = subset_ns->parent) {\n\t\tif ((set_ns == subset_ns->parent)  &&\n\t\t    uid_eq(subset_ns->owner, set->euid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "prepare_exec_creds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "307-329",
    "snippet": "struct cred *prepare_exec_creds(void)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn new;\n\n#ifdef CONFIG_KEYS\n\t/* newly exec'd tasks don't get a thread keyring */\n\tkey_put(new->thread_keyring);\n\tnew->thread_keyring = NULL;\n\n\t/* inherit the session keyring; new process keyring */\n\tkey_put(new->process_keyring);\n\tnew->process_keyring = NULL;\n#endif\n\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\n\treturn new;\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "new->process_keyring"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "new->thread_keyring"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "252-300",
          "snippet": "struct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cred_jar;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstruct cred *prepare_exec_creds(void)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn new;\n\n#ifdef CONFIG_KEYS\n\t/* newly exec'd tasks don't get a thread keyring */\n\tkey_put(new->thread_keyring);\n\tnew->thread_keyring = NULL;\n\n\t/* inherit the session keyring; new process keyring */\n\tkey_put(new->process_keyring);\n\tnew->process_keyring = NULL;\n#endif\n\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\n\treturn new;\n}"
  },
  {
    "function_name": "prepare_creds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "252-300",
    "snippet": "struct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cred_jar;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "new"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "abort_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "533-544",
          "snippet": "void abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "new"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "922-930",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_prepare_creds",
          "args": [
            "new",
            "old",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ucounts",
          "args": [
            "new->ucounts"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "get_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "159-166",
          "snippet": "struct ucounts *get_ucounts(struct ucounts *ucounts)\n{\n\tif (!get_ucounts_or_wrap(ucounts)) {\n\t\tput_ucounts(ucounts);\n\t\tucounts = NULL;\n\t}\n\treturn ucounts;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstruct ucounts *get_ucounts(struct ucounts *ucounts)\n{\n\tif (!get_ucounts_or_wrap(ucounts)) {\n\t\tput_ucounts(ucounts);\n\t\tucounts = NULL;\n\t}\n\treturn ucounts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "new->request_key_auth"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "new->thread_keyring"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "new->process_keyring"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "new->session_keyring"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "new->user_ns"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uid",
          "args": [
            "new->user"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_group_info",
          "args": [
            "new->group_info"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cred_subscribers",
          "args": [
            "new",
            "0"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "set_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "66-71",
          "snippet": "static inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->usage",
            "1"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new",
            "old",
            "sizeof(struct cred)"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"prepare_creds() alloc %p\"",
            "new"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "cred_jar",
            "GFP_KERNEL"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_process_creds",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cred_alloc_blank",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "216-236",
    "snippet": "struct cred *cred_alloc_blank(void)\n{\n\tstruct cred *new;\n\n\tnew = kmem_cache_zalloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tatomic_set(&new->usage, 1);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tnew->magic = CRED_MAGIC;\n#endif\n\tif (security_cred_alloc_blank(new, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cred_jar;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "new"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "abort_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "533-544",
          "snippet": "void abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_cred_alloc_blank",
          "args": [
            "new",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->usage",
            "1"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "cred_jar",
            "GFP_KERNEL"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstruct cred *cred_alloc_blank(void)\n{\n\tstruct cred *new;\n\n\tnew = kmem_cache_zalloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tatomic_set(&new->usage, 1);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tnew->magic = CRED_MAGIC;\n#endif\n\tif (security_cred_alloc_blank(new, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_task_cred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "196-209",
    "snippet": "const struct cred *get_task_cred(struct task_struct *task)\n{\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcred = __task_cred((task));\n\t\tBUG_ON(!cred);\n\t} while (!get_cred_rcu(cred));\n\n\trcu_read_unlock();\n\treturn cred;\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cred_rcu",
          "args": [
            "cred"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cred"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "(task)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nconst struct cred *get_task_cred(struct task_struct *task)\n{\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcred = __task_cred((task));\n\t\tBUG_ON(!cred);\n\t} while (!get_cred_rcu(cred));\n\n\trcu_read_unlock();\n\treturn cred;\n}"
  },
  {
    "function_name": "exit_creds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "160-184",
    "snippet": "void exit_creds(struct task_struct *tsk)\n{\n\tstruct cred *cred;\n\n\tkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", tsk->pid, tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\tcred = (struct cred *) tsk->real_cred;\n\ttsk->real_cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->cred;\n\ttsk->cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n#ifdef CONFIG_KEYS_REQUEST_CACHE\n\tkey_put(tsk->cached_requested_key);\n\ttsk->cached_requested_key = NULL;\n#endif\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "tsk->cached_requested_key"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "cred"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "135-154",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alter_cred_subscribers",
          "args": [
            "cred",
            "-1"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "alter_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "82-89",
          "snippet": "static inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "cred"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "922-930",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"exit_creds(%u,%p,%p,{%d,%d})\"",
            "tsk->pid",
            "tsk->real_cred",
            "tsk->cred",
            "atomic_read(&tsk->cred->usage)",
            "read_cred_subscribers(tsk->cred)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "tsk->cred"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "73-80",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tsk->cred->usage"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid exit_creds(struct task_struct *tsk)\n{\n\tstruct cred *cred;\n\n\tkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", tsk->pid, tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\tcred = (struct cred *) tsk->real_cred;\n\ttsk->real_cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->cred;\n\ttsk->cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n#ifdef CONFIG_KEYS_REQUEST_CACHE\n\tkey_put(tsk->cached_requested_key);\n\ttsk->cached_requested_key = NULL;\n#endif\n}"
  },
  {
    "function_name": "__put_cred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "135-154",
    "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&cred->rcu",
            "put_cred_rcu"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cred_rcu",
          "args": [
            "&cred->rcu"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "put_cred_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "94-127",
          "snippet": "static void put_cred_rcu(struct rcu_head *rcu)\n{\n\tstruct cred *cred = container_of(rcu, struct cred, rcu);\n\n\tkdebug(\"put_cred_rcu(%p)\", cred);\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tif (cred->magic != CRED_MAGIC_DEAD ||\n\t    atomic_read(&cred->usage) != 0 ||\n\t    read_cred_subscribers(cred) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with\"\n\t\t      \" mag %x, put %p, usage %d, subscr %d\\n\",\n\t\t      cred, cred->magic, cred->put_addr,\n\t\t      atomic_read(&cred->usage),\n\t\t      read_cred_subscribers(cred));\n#else\n\tif (atomic_read(&cred->usage) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with usage %d\\n\",\n\t\t      cred, atomic_read(&cred->usage));\n#endif\n\n\tsecurity_cred_free(cred);\n\tkey_put(cred->session_keyring);\n\tkey_put(cred->process_keyring);\n\tkey_put(cred->thread_keyring);\n\tkey_put(cred->request_key_auth);\n\tif (cred->group_info)\n\t\tput_group_info(cred->group_info);\n\tfree_uid(cred->user);\n\tif (cred->ucounts)\n\t\tput_ucounts(cred->ucounts);\n\tput_user_ns(cred->user_ns);\n\tkmem_cache_free(cred_jar, cred);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cred_jar;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstatic void put_cred_rcu(struct rcu_head *rcu)\n{\n\tstruct cred *cred = container_of(rcu, struct cred, rcu);\n\n\tkdebug(\"put_cred_rcu(%p)\", cred);\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tif (cred->magic != CRED_MAGIC_DEAD ||\n\t    atomic_read(&cred->usage) != 0 ||\n\t    read_cred_subscribers(cred) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with\"\n\t\t      \" mag %x, put %p, usage %d, subscr %d\\n\",\n\t\t      cred, cred->magic, cred->put_addr,\n\t\t      atomic_read(&cred->usage),\n\t\t      read_cred_subscribers(cred));\n#else\n\tif (atomic_read(&cred->usage) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with usage %d\\n\",\n\t\t      cred, atomic_read(&cred->usage));\n#endif\n\n\tsecurity_cred_free(cred);\n\tkey_put(cred->session_keyring);\n\tkey_put(cred->process_keyring);\n\tkey_put(cred->thread_keyring);\n\tkey_put(cred->request_key_auth);\n\tif (cred->group_info)\n\t\tput_group_info(cred->group_info);\n\tfree_uid(cred->user);\n\tif (cred->ucounts)\n\t\tput_ucounts(cred->ucounts);\n\tput_user_ns(cred->user_ns);\n\tkmem_cache_free(cred_jar, cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cred == current->real_cred"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cred == current->cred"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "read_cred_subscribers(cred) != 0"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "cred"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "73-80",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&cred->usage) != 0"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"__put_cred(%p{%d,%d})\"",
            "cred",
            "atomic_read(&cred->usage)",
            "read_cred_subscribers(cred)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
  },
  {
    "function_name": "put_cred_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "94-127",
    "snippet": "static void put_cred_rcu(struct rcu_head *rcu)\n{\n\tstruct cred *cred = container_of(rcu, struct cred, rcu);\n\n\tkdebug(\"put_cred_rcu(%p)\", cred);\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tif (cred->magic != CRED_MAGIC_DEAD ||\n\t    atomic_read(&cred->usage) != 0 ||\n\t    read_cred_subscribers(cred) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with\"\n\t\t      \" mag %x, put %p, usage %d, subscr %d\\n\",\n\t\t      cred, cred->magic, cred->put_addr,\n\t\t      atomic_read(&cred->usage),\n\t\t      read_cred_subscribers(cred));\n#else\n\tif (atomic_read(&cred->usage) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with usage %d\\n\",\n\t\t      cred, atomic_read(&cred->usage));\n#endif\n\n\tsecurity_cred_free(cred);\n\tkey_put(cred->session_keyring);\n\tkey_put(cred->process_keyring);\n\tkey_put(cred->thread_keyring);\n\tkey_put(cred->request_key_auth);\n\tif (cred->group_info)\n\t\tput_group_info(cred->group_info);\n\tfree_uid(cred->user);\n\tif (cred->ucounts)\n\t\tput_ucounts(cred->ucounts);\n\tput_user_ns(cred->user_ns);\n\tkmem_cache_free(cred_jar, cred);\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cred_jar;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "cred_jar",
            "cred"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "cred->user_ns"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__put_user_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "208-211",
          "snippet": "void __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_user_ns(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void free_user_ns(struct work_struct *work);\n\nvoid __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ucounts",
          "args": [
            "cred->ucounts"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "put_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "206-215",
          "snippet": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(ucounts_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstatic DEFINE_SPINLOCK(ucounts_lock);\n\nvoid put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "cred->user"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "free_uid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user.c",
          "lines": "178-187",
          "snippet": "void free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/key.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uidhash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/sched/user.h>\n#include <linux/key.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(uidhash_lock);\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_group_info",
          "args": [
            "cred->group_info"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "cred->request_key_auth"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "cred->thread_keyring"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "cred->process_keyring"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "cred->session_keyring"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_cred_free",
          "args": [
            "cred"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"CRED: put_cred_rcu() sees %p with usage %d\\n\"",
            "cred",
            "atomic_read(&cred->usage)"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "179-361",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "cred"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "73-80",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"put_cred_rcu(%p)\"",
            "cred"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structcred",
            "rcu"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstatic void put_cred_rcu(struct rcu_head *rcu)\n{\n\tstruct cred *cred = container_of(rcu, struct cred, rcu);\n\n\tkdebug(\"put_cred_rcu(%p)\", cred);\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tif (cred->magic != CRED_MAGIC_DEAD ||\n\t    atomic_read(&cred->usage) != 0 ||\n\t    read_cred_subscribers(cred) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with\"\n\t\t      \" mag %x, put %p, usage %d, subscr %d\\n\",\n\t\t      cred, cred->magic, cred->put_addr,\n\t\t      atomic_read(&cred->usage),\n\t\t      read_cred_subscribers(cred));\n#else\n\tif (atomic_read(&cred->usage) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with usage %d\\n\",\n\t\t      cred, atomic_read(&cred->usage));\n#endif\n\n\tsecurity_cred_free(cred);\n\tkey_put(cred->session_keyring);\n\tkey_put(cred->process_keyring);\n\tkey_put(cred->thread_keyring);\n\tkey_put(cred->request_key_auth);\n\tif (cred->group_info)\n\t\tput_group_info(cred->group_info);\n\tfree_uid(cred->user);\n\tif (cred->ucounts)\n\t\tput_ucounts(cred->ucounts);\n\tput_user_ns(cred->user_ns);\n\tkmem_cache_free(cred_jar, cred);\n}"
  },
  {
    "function_name": "alter_cred_subscribers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "82-89",
    "snippet": "static inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "n",
            "&cred->subscribers"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}"
  },
  {
    "function_name": "read_cred_subscribers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "73-80",
    "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->subscribers"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "set_cred_subscribers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
    "lines": "66-71",
    "snippet": "static inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}",
    "includes": [
      "#include <linux/uidgid.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cred->subscribers",
            "n"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}"
  }
]