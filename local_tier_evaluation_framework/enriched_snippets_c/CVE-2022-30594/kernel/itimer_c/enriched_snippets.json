[
  {
    "function_name": "get_old_itimerval32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "359-376",
    "snippet": "static int get_old_itimerval32(struct itimerspec64 *o, const struct old_itimerval32 __user *i)\n{\n\tstruct old_itimerval32 v32;\n\n\tif (copy_from_user(&v32, i, sizeof(struct old_itimerval32)))\n\t\treturn -EFAULT;\n\n\t/* Validate the timevals in value.  */\n\tif (!timeval_valid(&v32.it_value) ||\n\t    !timeval_valid(&v32.it_interval))\n\t\treturn -EINVAL;\n\n\to->it_interval.tv_sec = v32.it_interval.tv_sec;\n\to->it_interval.tv_nsec = v32.it_interval.tv_usec * NSEC_PER_USEC;\n\to->it_value.tv_sec = v32.it_value.tv_sec;\n\to->it_value.tv_nsec = v32.it_value.tv_usec * NSEC_PER_USEC;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeval_valid",
          "args": [
            "&v32.it_interval"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeval_valid",
          "args": [
            "&v32.it_value"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&v32",
            "i",
            "sizeof(struct old_itimerval32)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int get_old_itimerval32(struct itimerspec64 *o, const struct old_itimerval32 __user *i)\n{\n\tstruct old_itimerval32 v32;\n\n\tif (copy_from_user(&v32, i, sizeof(struct old_itimerval32)))\n\t\treturn -EFAULT;\n\n\t/* Validate the timevals in value.  */\n\tif (!timeval_valid(&v32.it_value) ||\n\t    !timeval_valid(&v32.it_interval))\n\t\treturn -EINVAL;\n\n\to->it_interval.tv_sec = v32.it_interval.tv_sec;\n\to->it_interval.tv_nsec = v32.it_interval.tv_usec * NSEC_PER_USEC;\n\to->it_value.tv_sec = v32.it_value.tv_sec;\n\to->it_value.tv_nsec = v32.it_value.tv_usec * NSEC_PER_USEC;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_itimerval",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "313-330",
    "snippet": "static int get_itimerval(struct itimerspec64 *o, const struct __kernel_old_itimerval __user *i)\n{\n\tstruct __kernel_old_itimerval v;\n\n\tif (copy_from_user(&v, i, sizeof(struct __kernel_old_itimerval)))\n\t\treturn -EFAULT;\n\n\t/* Validate the timevals in value. */\n\tif (!timeval_valid(&v.it_value) ||\n\t    !timeval_valid(&v.it_interval))\n\t\treturn -EINVAL;\n\n\to->it_interval.tv_sec = v.it_interval.tv_sec;\n\to->it_interval.tv_nsec = v.it_interval.tv_usec * NSEC_PER_USEC;\n\to->it_value.tv_sec = v.it_value.tv_sec;\n\to->it_value.tv_nsec = v.it_value.tv_usec * NSEC_PER_USEC;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeval_valid",
          "args": [
            "&v.it_interval"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeval_valid",
          "args": [
            "&v.it_value"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&v",
            "i",
            "sizeof(struct __kernel_old_itimerval)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int get_itimerval(struct itimerspec64 *o, const struct __kernel_old_itimerval __user *i)\n{\n\tstruct __kernel_old_itimerval v;\n\n\tif (copy_from_user(&v, i, sizeof(struct __kernel_old_itimerval)))\n\t\treturn -EFAULT;\n\n\t/* Validate the timevals in value. */\n\tif (!timeval_valid(&v.it_value) ||\n\t    !timeval_valid(&v.it_interval))\n\t\treturn -EINVAL;\n\n\to->it_interval.tv_sec = v.it_interval.tv_sec;\n\to->it_interval.tv_nsec = v.it_interval.tv_usec * NSEC_PER_USEC;\n\to->it_value.tv_sec = v.it_value.tv_sec;\n\to->it_value.tv_nsec = v.it_value.tv_usec * NSEC_PER_USEC;\n\treturn 0;\n}"
  },
  {
    "function_name": "alarm_setitimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "277-300",
    "snippet": "static unsigned int alarm_setitimer(unsigned int seconds)\n{\n\tstruct itimerspec64 it_new, it_old;\n\n#if BITS_PER_LONG < 64\n\tif (seconds > INT_MAX)\n\t\tseconds = INT_MAX;\n#endif\n\tit_new.it_value.tv_sec = seconds;\n\tit_new.it_value.tv_nsec = 0;\n\tit_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = 0;\n\n\tdo_setitimer(ITIMER_REAL, &it_new, &it_old);\n\n\t/*\n\t * We can't return 0 if we have an alarm pending ...  And we'd\n\t * better return too much than too little anyway\n\t */\n\tif ((!it_old.it_value.tv_sec && it_old.it_value.tv_nsec) ||\n\t      it_old.it_value.tv_nsec >= (NSEC_PER_SEC / 2))\n\t\tit_old.it_value.tv_sec++;\n\n\treturn it_old.it_value.tv_sec;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_setitimer",
          "args": [
            "ITIMER_REAL",
            "&it_new",
            "&it_old"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "do_setitimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
          "lines": "206-250",
          "snippet": "static int do_setitimer(int which, struct itimerspec64 *value,\n\t\t\tstruct itimerspec64 *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\nagain:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\ttimer = &tsk->signal->real_timer;\n\t\tif (ovalue) {\n\t\t\tovalue->it_value = itimer_get_remtime(timer);\n\t\t\tovalue->it_interval\n\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);\n\t\t}\n\t\t/* We are sharing ->siglock with it_real_fn() */\n\t\tif (hrtimer_try_to_cancel(timer) < 0) {\n\t\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t\thrtimer_cancel_wait_running(timer);\n\t\t\tgoto again;\n\t\t}\n\t\texpires = timespec64_to_ktime(value->it_value);\n\t\tif (expires != 0) {\n\t\t\ttsk->signal->it_real_incr =\n\t\t\t\ttimespec64_to_ktime(value->it_interval);\n\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);\n\t\t} else\n\t\t\ttsk->signal->it_real_incr = 0;\n\n\t\ttrace_itimer_state(ITIMER_REAL, value, 0);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int do_setitimer(int which, struct itimerspec64 *value,\n\t\t\tstruct itimerspec64 *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\nagain:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\ttimer = &tsk->signal->real_timer;\n\t\tif (ovalue) {\n\t\t\tovalue->it_value = itimer_get_remtime(timer);\n\t\t\tovalue->it_interval\n\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);\n\t\t}\n\t\t/* We are sharing ->siglock with it_real_fn() */\n\t\tif (hrtimer_try_to_cancel(timer) < 0) {\n\t\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t\thrtimer_cancel_wait_running(timer);\n\t\t\tgoto again;\n\t\t}\n\t\texpires = timespec64_to_ktime(value->it_value);\n\t\tif (expires != 0) {\n\t\t\ttsk->signal->it_real_incr =\n\t\t\t\ttimespec64_to_ktime(value->it_interval);\n\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);\n\t\t} else\n\t\t\ttsk->signal->it_real_incr = 0;\n\n\t\ttrace_itimer_state(ITIMER_REAL, value, 0);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic unsigned int alarm_setitimer(unsigned int seconds)\n{\n\tstruct itimerspec64 it_new, it_old;\n\n#if BITS_PER_LONG < 64\n\tif (seconds > INT_MAX)\n\t\tseconds = INT_MAX;\n#endif\n\tit_new.it_value.tv_sec = seconds;\n\tit_new.it_value.tv_nsec = 0;\n\tit_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = 0;\n\n\tdo_setitimer(ITIMER_REAL, &it_new, &it_old);\n\n\t/*\n\t * We can't return 0 if we have an alarm pending ...  And we'd\n\t * better return too much than too little anyway\n\t */\n\tif ((!it_old.it_value.tv_sec && it_old.it_value.tv_nsec) ||\n\t      it_old.it_value.tv_nsec >= (NSEC_PER_SEC / 2))\n\t\tit_old.it_value.tv_sec++;\n\n\treturn it_old.it_value.tv_sec;\n}"
  },
  {
    "function_name": "clear_itimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "253-260",
    "snippet": "void clear_itimer(void)\n{\n\tstruct itimerspec64 v = {};\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t\tdo_setitimer(i, &v, NULL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_setitimer",
          "args": [
            "i",
            "&v",
            "NULL"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "do_setitimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
          "lines": "206-250",
          "snippet": "static int do_setitimer(int which, struct itimerspec64 *value,\n\t\t\tstruct itimerspec64 *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\nagain:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\ttimer = &tsk->signal->real_timer;\n\t\tif (ovalue) {\n\t\t\tovalue->it_value = itimer_get_remtime(timer);\n\t\t\tovalue->it_interval\n\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);\n\t\t}\n\t\t/* We are sharing ->siglock with it_real_fn() */\n\t\tif (hrtimer_try_to_cancel(timer) < 0) {\n\t\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t\thrtimer_cancel_wait_running(timer);\n\t\t\tgoto again;\n\t\t}\n\t\texpires = timespec64_to_ktime(value->it_value);\n\t\tif (expires != 0) {\n\t\t\ttsk->signal->it_real_incr =\n\t\t\t\ttimespec64_to_ktime(value->it_interval);\n\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);\n\t\t} else\n\t\t\ttsk->signal->it_real_incr = 0;\n\n\t\ttrace_itimer_state(ITIMER_REAL, value, 0);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int do_setitimer(int which, struct itimerspec64 *value,\n\t\t\tstruct itimerspec64 *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\nagain:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\ttimer = &tsk->signal->real_timer;\n\t\tif (ovalue) {\n\t\t\tovalue->it_value = itimer_get_remtime(timer);\n\t\t\tovalue->it_interval\n\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);\n\t\t}\n\t\t/* We are sharing ->siglock with it_real_fn() */\n\t\tif (hrtimer_try_to_cancel(timer) < 0) {\n\t\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t\thrtimer_cancel_wait_running(timer);\n\t\t\tgoto again;\n\t\t}\n\t\texpires = timespec64_to_ktime(value->it_value);\n\t\tif (expires != 0) {\n\t\t\ttsk->signal->it_real_incr =\n\t\t\t\ttimespec64_to_ktime(value->it_interval);\n\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);\n\t\t} else\n\t\t\ttsk->signal->it_real_incr = 0;\n\n\t\ttrace_itimer_state(ITIMER_REAL, value, 0);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nvoid clear_itimer(void)\n{\n\tstruct itimerspec64 v = {};\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t\tdo_setitimer(i, &v, NULL);\n}"
  },
  {
    "function_name": "do_setitimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "206-250",
    "snippet": "static int do_setitimer(int which, struct itimerspec64 *value,\n\t\t\tstruct itimerspec64 *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\nagain:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\ttimer = &tsk->signal->real_timer;\n\t\tif (ovalue) {\n\t\t\tovalue->it_value = itimer_get_remtime(timer);\n\t\t\tovalue->it_interval\n\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);\n\t\t}\n\t\t/* We are sharing ->siglock with it_real_fn() */\n\t\tif (hrtimer_try_to_cancel(timer) < 0) {\n\t\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t\thrtimer_cancel_wait_running(timer);\n\t\t\tgoto again;\n\t\t}\n\t\texpires = timespec64_to_ktime(value->it_value);\n\t\tif (expires != 0) {\n\t\t\ttsk->signal->it_real_incr =\n\t\t\t\ttimespec64_to_ktime(value->it_interval);\n\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);\n\t\t} else\n\t\t\ttsk->signal->it_real_incr = 0;\n\n\t\ttrace_itimer_state(ITIMER_REAL, value, 0);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpu_itimer",
          "args": [
            "tsk",
            "CPUCLOCK_PROF",
            "value",
            "ovalue"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_itimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
          "lines": "168-198",
          "snippet": "static void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   const struct itimerspec64 *const value,\n\t\t\t   struct itimerspec64 *const ovalue)\n{\n\tu64 oval, nval, ointerval, ninterval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tnval = timespec64_to_ns(&value->it_value);\n\tninterval = timespec64_to_ns(&value->it_interval);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\toval = it->expires;\n\tointerval = it->incr;\n\tif (oval || nval) {\n\t\tif (nval > 0)\n\t\t\tnval += TICK_NSEC;\n\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);\n\t}\n\tit->expires = nval;\n\tit->incr = ninterval;\n\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?\n\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (ovalue) {\n\t\tovalue->it_value = ns_to_timespec64(oval);\n\t\tovalue->it_interval = ns_to_timespec64(ointerval);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   const struct itimerspec64 *const value,\n\t\t\t   struct itimerspec64 *const ovalue)\n{\n\tu64 oval, nval, ointerval, ninterval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tnval = timespec64_to_ns(&value->it_value);\n\tninterval = timespec64_to_ns(&value->it_interval);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\toval = it->expires;\n\tointerval = it->incr;\n\tif (oval || nval) {\n\t\tif (nval > 0)\n\t\t\tnval += TICK_NSEC;\n\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);\n\t}\n\tit->expires = nval;\n\tit->incr = ninterval;\n\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?\n\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (ovalue) {\n\t\tovalue->it_value = ns_to_timespec64(oval);\n\t\tovalue->it_interval = ns_to_timespec64(ointerval);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_itimer_state",
          "args": [
            "ITIMER_REAL",
            "value",
            "0"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "timer",
            "expires",
            "HRTIMER_MODE_REL"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "value->it_interval"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "value->it_value"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel_wait_running",
          "args": [
            "timer"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel_wait_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1393-1418",
          "snippet": "void hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "timer"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "823-826",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "tsk->signal->it_real_incr"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "itimer_get_remtime",
          "args": [
            "timer"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "itimer_get_remtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
          "lines": "29-45",
          "snippet": "static struct timespec64 itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timespec64(rem);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct timespec64 itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timespec64(rem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int do_setitimer(int which, struct itimerspec64 *value,\n\t\t\tstruct itimerspec64 *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\nagain:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\ttimer = &tsk->signal->real_timer;\n\t\tif (ovalue) {\n\t\t\tovalue->it_value = itimer_get_remtime(timer);\n\t\t\tovalue->it_interval\n\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);\n\t\t}\n\t\t/* We are sharing ->siglock with it_real_fn() */\n\t\tif (hrtimer_try_to_cancel(timer) < 0) {\n\t\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t\thrtimer_cancel_wait_running(timer);\n\t\t\tgoto again;\n\t\t}\n\t\texpires = timespec64_to_ktime(value->it_value);\n\t\tif (expires != 0) {\n\t\t\ttsk->signal->it_real_incr =\n\t\t\t\ttimespec64_to_ktime(value->it_interval);\n\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);\n\t\t} else\n\t\t\ttsk->signal->it_real_incr = 0;\n\n\t\ttrace_itimer_state(ITIMER_REAL, value, 0);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "set_cpu_itimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "168-198",
    "snippet": "static void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   const struct itimerspec64 *const value,\n\t\t\t   struct itimerspec64 *const ovalue)\n{\n\tu64 oval, nval, ointerval, ninterval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tnval = timespec64_to_ns(&value->it_value);\n\tninterval = timespec64_to_ns(&value->it_interval);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\toval = it->expires;\n\tointerval = it->incr;\n\tif (oval || nval) {\n\t\tif (nval > 0)\n\t\t\tnval += TICK_NSEC;\n\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);\n\t}\n\tit->expires = nval;\n\tit->incr = ninterval;\n\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?\n\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (ovalue) {\n\t\tovalue->it_value = ns_to_timespec64(oval);\n\t\tovalue->it_interval = ns_to_timespec64(ointerval);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "ointerval"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "506-525",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_itimer_state",
          "args": [
            "clock_id == CPUCLOCK_VIRT ?\n\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF",
            "value",
            "nval"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_process_cpu_timer",
          "args": [
            "tsk",
            "clock_id",
            "&nval",
            "&oval"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "set_process_cpu_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1397-1435",
          "snippet": "void set_process_cpu_timer(struct task_struct *tsk, unsigned int clkid,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now, *nextevt;\n\n\tif (WARN_ON_ONCE(clkid >= CPUCLOCK_SCHED))\n\t\treturn;\n\n\tnextevt = &tsk->signal->posix_cputimers.bases[clkid].nextevt;\n\tnow = cpu_clock_sample_group(clkid, tsk, true);\n\n\tif (oldval) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (*newval)\n\t\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if this is the earliest timer. CPUCLOCK_PROF\n\t * expiry cache is also used by RLIMIT_CPU!.\n\t */\n\tif (*newval < *nextevt)\n\t\t*nextevt = *newval;\n\n\ttick_dep_set_signal(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nvoid set_process_cpu_timer(struct task_struct *tsk, unsigned int clkid,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now, *nextevt;\n\n\tif (WARN_ON_ONCE(clkid >= CPUCLOCK_SCHED))\n\t\treturn;\n\n\tnextevt = &tsk->signal->posix_cputimers.bases[clkid].nextevt;\n\tnow = cpu_clock_sample_group(clkid, tsk, true);\n\n\tif (oldval) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (*newval)\n\t\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if this is the earliest timer. CPUCLOCK_PROF\n\t * expiry cache is also used by RLIMIT_CPU!.\n\t */\n\tif (*newval < *nextevt)\n\t\t*nextevt = *newval;\n\n\ttick_dep_set_signal(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_ns",
          "args": [
            "&value->it_interval"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ns",
          "args": [
            "&value->it_value"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   const struct itimerspec64 *const value,\n\t\t\t   struct itimerspec64 *const ovalue)\n{\n\tu64 oval, nval, ointerval, ninterval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tnval = timespec64_to_ns(&value->it_value);\n\tninterval = timespec64_to_ns(&value->it_interval);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\toval = it->expires;\n\tointerval = it->incr;\n\tif (oval || nval) {\n\t\tif (nval > 0)\n\t\t\tnval += TICK_NSEC;\n\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);\n\t}\n\tit->expires = nval;\n\tit->incr = ninterval;\n\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?\n\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (ovalue) {\n\t\tovalue->it_value = ns_to_timespec64(oval);\n\t\tovalue->it_interval = ns_to_timespec64(ointerval);\n\t}\n}"
  },
  {
    "function_name": "it_real_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "156-166",
    "snippet": "enum hrtimer_restart it_real_fn(struct hrtimer *timer)\n{\n\tstruct signal_struct *sig =\n\t\tcontainer_of(timer, struct signal_struct, real_timer);\n\tstruct pid *leader_pid = sig->pids[PIDTYPE_TGID];\n\n\ttrace_itimer_expire(ITIMER_REAL, leader_pid, 0);\n\tkill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_pid_info",
          "args": [
            "SIGALRM",
            "SEND_SIG_PRIV",
            "leader_pid"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "kill_pid_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1469-1489",
          "snippet": "int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_itimer_expire",
          "args": [
            "ITIMER_REAL",
            "leader_pid",
            "0"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structsignal_struct",
            "real_timer"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nenum hrtimer_restart it_real_fn(struct hrtimer *timer)\n{\n\tstruct signal_struct *sig =\n\t\tcontainer_of(timer, struct signal_struct, real_timer);\n\tstruct pid *leader_pid = sig->pids[PIDTYPE_TGID];\n\n\ttrace_itimer_expire(ITIMER_REAL, leader_pid, 0);\n\tkill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "put_old_itimerval32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "129-139",
    "snippet": "static int put_old_itimerval32(struct old_itimerval32 __user *o,\n\t\t\t       const struct itimerspec64 *i)\n{\n\tstruct old_itimerval32 v32;\n\n\tv32.it_interval.tv_sec = i->it_interval.tv_sec;\n\tv32.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;\n\tv32.it_value.tv_sec = i->it_value.tv_sec;\n\tv32.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;\n\treturn copy_to_user(o, &v32, sizeof(struct old_itimerval32)) ? -EFAULT : 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "o",
            "&v32",
            "sizeof(struct old_itimerval32)"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int put_old_itimerval32(struct old_itimerval32 __user *o,\n\t\t\t       const struct itimerspec64 *i)\n{\n\tstruct old_itimerval32 v32;\n\n\tv32.it_interval.tv_sec = i->it_interval.tv_sec;\n\tv32.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;\n\tv32.it_value.tv_sec = i->it_value.tv_sec;\n\tv32.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;\n\treturn copy_to_user(o, &v32, sizeof(struct old_itimerval32)) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "put_itimerval",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "100-110",
    "snippet": "static int put_itimerval(struct __kernel_old_itimerval __user *o,\n\t\t\t const struct itimerspec64 *i)\n{\n\tstruct __kernel_old_itimerval v;\n\n\tv.it_interval.tv_sec = i->it_interval.tv_sec;\n\tv.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;\n\tv.it_value.tv_sec = i->it_value.tv_sec;\n\tv.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;\n\treturn copy_to_user(o, &v, sizeof(struct __kernel_old_itimerval)) ? -EFAULT : 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "o",
            "&v",
            "sizeof(struct __kernel_old_itimerval)"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int put_itimerval(struct __kernel_old_itimerval __user *o,\n\t\t\t const struct itimerspec64 *i)\n{\n\tstruct __kernel_old_itimerval v;\n\n\tv.it_interval.tv_sec = i->it_interval.tv_sec;\n\tv.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;\n\tv.it_value.tv_sec = i->it_value.tv_sec;\n\tv.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;\n\treturn copy_to_user(o, &v, sizeof(struct __kernel_old_itimerval)) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "do_getitimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "76-98",
    "snippet": "static int do_getitimer(int which, struct itimerspec64 *value)\n{\n\tstruct task_struct *tsk = current;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\tvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);\n\t\tvalue->it_interval =\n\t\t\tktime_to_timespec64(tsk->signal->it_real_incr);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tget_cpu_itimer(tsk, CPUCLOCK_PROF, value);\n\t\tbreak;\n\tdefault:\n\t\treturn(-EINVAL);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_cpu_itimer",
          "args": [
            "tsk",
            "CPUCLOCK_PROF",
            "value"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_itimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
          "lines": "47-74",
          "snippet": "static void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   struct itimerspec64 *const value)\n{\n\tu64 val, interval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\tval = it->expires;\n\tinterval = it->incr;\n\tif (val) {\n\t\tu64 t, samples[CPUCLOCK_MAX];\n\n\t\tthread_group_sample_cputime(tsk, samples);\n\t\tt = samples[clock_id];\n\n\t\tif (val < t)\n\t\t\t/* about to fire */\n\t\t\tval = TICK_NSEC;\n\t\telse\n\t\t\tval -= t;\n\t}\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tvalue->it_value = ns_to_timespec64(val);\n\tvalue->it_interval = ns_to_timespec64(interval);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   struct itimerspec64 *const value)\n{\n\tu64 val, interval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\tval = it->expires;\n\tinterval = it->incr;\n\tif (val) {\n\t\tu64 t, samples[CPUCLOCK_MAX];\n\n\t\tthread_group_sample_cputime(tsk, samples);\n\t\tt = samples[clock_id];\n\n\t\tif (val < t)\n\t\t\t/* about to fire */\n\t\t\tval = TICK_NSEC;\n\t\telse\n\t\t\tval -= t;\n\t}\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tvalue->it_value = ns_to_timespec64(val);\n\tvalue->it_interval = ns_to_timespec64(interval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "tsk->signal->it_real_incr"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "itimer_get_remtime",
          "args": [
            "&tsk->signal->real_timer"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "itimer_get_remtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
          "lines": "29-45",
          "snippet": "static struct timespec64 itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timespec64(rem);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct timespec64 itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timespec64(rem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int do_getitimer(int which, struct itimerspec64 *value)\n{\n\tstruct task_struct *tsk = current;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\tvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);\n\t\tvalue->it_interval =\n\t\t\tktime_to_timespec64(tsk->signal->it_real_incr);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tget_cpu_itimer(tsk, CPUCLOCK_PROF, value);\n\t\tbreak;\n\tdefault:\n\t\treturn(-EINVAL);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "get_cpu_itimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "47-74",
    "snippet": "static void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   struct itimerspec64 *const value)\n{\n\tu64 val, interval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\tval = it->expires;\n\tinterval = it->incr;\n\tif (val) {\n\t\tu64 t, samples[CPUCLOCK_MAX];\n\n\t\tthread_group_sample_cputime(tsk, samples);\n\t\tt = samples[clock_id];\n\n\t\tif (val < t)\n\t\t\t/* about to fire */\n\t\t\tval = TICK_NSEC;\n\t\telse\n\t\t\tval -= t;\n\t}\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tvalue->it_value = ns_to_timespec64(val);\n\tvalue->it_interval = ns_to_timespec64(interval);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "interval"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "506-525",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_sample_cputime",
          "args": [
            "tsk",
            "samples"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_sample_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "268-276",
          "snippet": "void thread_group_sample_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct posix_cputimers *pct = &tsk->signal->posix_cputimers;\n\n\tWARN_ON_ONCE(!pct->timers_active);\n\n\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nvoid thread_group_sample_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct posix_cputimers *pct = &tsk->signal->posix_cputimers;\n\n\tWARN_ON_ONCE(!pct->timers_active);\n\n\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   struct itimerspec64 *const value)\n{\n\tu64 val, interval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\tval = it->expires;\n\tinterval = it->incr;\n\tif (val) {\n\t\tu64 t, samples[CPUCLOCK_MAX];\n\n\t\tthread_group_sample_cputime(tsk, samples);\n\t\tt = samples[clock_id];\n\n\t\tif (val < t)\n\t\t\t/* about to fire */\n\t\t\tval = TICK_NSEC;\n\t\telse\n\t\t\tval -= t;\n\t}\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tvalue->it_value = ns_to_timespec64(val);\n\tvalue->it_interval = ns_to_timespec64(interval);\n}"
  },
  {
    "function_name": "itimer_get_remtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "29-45",
    "snippet": "static struct timespec64 itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timespec64(rem);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "rem"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_active",
          "args": [
            "timer"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1604-1621",
          "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_get_remaining",
          "args": [
            "timer",
            "true"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_get_remaining",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1457-1470",
          "snippet": "ktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust)\n{\n\tunsigned long flags;\n\tktime_t rem;\n\n\tlock_hrtimer_base(timer, &flags);\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES) && adjust)\n\t\trem = hrtimer_expires_remaining_adjusted(timer);\n\telse\n\t\trem = hrtimer_expires_remaining(timer);\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn rem;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust)\n{\n\tunsigned long flags;\n\tktime_t rem;\n\n\tlock_hrtimer_base(timer, &flags);\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES) && adjust)\n\t\trem = hrtimer_expires_remaining_adjusted(timer);\n\telse\n\t\trem = hrtimer_expires_remaining(timer);\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn rem;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct timespec64 itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timespec64(rem);\n}"
  },
  {
    "function_name": "getitimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "113-121",
    "snippet": "SYSCALL_DEFINE2(getitimer, int, which, struct __kernel_old_itimerval __user *, value)\n{\n\tstruct itimerspec64 get_buffer;\n\tint error = do_getitimer(which, &get_buffer);\n\n\tif (!error && put_itimerval(value, &get_buffer))\n\t\terror = -EFAULT;\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(getitimer, int, which, struct __kernel_old_itimerval __user *, value)\n{\n\tstruct itimerspec64 get_buffer;\n\tint error = do_getitimer(which, &get_buffer);\n\n\tif (!error && put_itimerval(value, &get_buffer))\n\t\terror = -EFAULT;\n\treturn error;\n}"
  },
  {
    "function_name": "getitimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "141-150",
    "snippet": "SYSCALL_DEFINE2(getitimer, int, which,\n\t\t       struct old_itimerval32 __user *, value)\n{\n\tstruct itimerspec64 get_buffer;\n\tint error = do_getitimer(which, &get_buffer);\n\n\tif (!error && put_old_itimerval32(value, &get_buffer))\n\t\terror = -EFAULT;\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(getitimer, int, which,\n\t\t       struct old_itimerval32 __user *, value)\n{\n\tstruct itimerspec64 get_buffer;\n\tint error = do_getitimer(which, &get_buffer);\n\n\tif (!error && put_old_itimerval32(value, &get_buffer))\n\t\terror = -EFAULT;\n\treturn error;\n}"
  },
  {
    "function_name": "alarm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "306-309",
    "snippet": "SYSCALL_DEFINE1(alarm, unsigned int, seconds)\n{\n\treturn alarm_setitimer(seconds);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE1(alarm, unsigned int, seconds)\n{\n\treturn alarm_setitimer(seconds);\n}"
  },
  {
    "function_name": "setitimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "332-356",
    "snippet": "SYSCALL_DEFINE3(setitimer, int, which, struct __kernel_old_itimerval __user *, value,\n\t\tstruct __kernel_old_itimerval __user *, ovalue)\n{\n\tstruct itimerspec64 set_buffer, get_buffer;\n\tint error;\n\n\tif (value) {\n\t\terror = get_itimerval(&set_buffer, value);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tmemset(&set_buffer, 0, sizeof(set_buffer));\n\t\tprintk_once(KERN_WARNING \"%s calls setitimer() with new_value NULL pointer.\"\n\t\t\t    \" Misfeature support will be removed\\n\",\n\t\t\t    current->comm);\n\t}\n\n\terror = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);\n\tif (error || !ovalue)\n\t\treturn error;\n\n\tif (put_itimerval(ovalue, &get_buffer))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(setitimer, int, which, struct __kernel_old_itimerval __user *, value,\n\t\tstruct __kernel_old_itimerval __user *, ovalue)\n{\n\tstruct itimerspec64 set_buffer, get_buffer;\n\tint error;\n\n\tif (value) {\n\t\terror = get_itimerval(&set_buffer, value);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tmemset(&set_buffer, 0, sizeof(set_buffer));\n\t\tprintk_once(KERN_WARNING \"%s calls setitimer() with new_value NULL pointer.\"\n\t\t\t    \" Misfeature support will be removed\\n\",\n\t\t\t    current->comm);\n\t}\n\n\terror = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);\n\tif (error || !ovalue)\n\t\treturn error;\n\n\tif (put_itimerval(ovalue, &get_buffer))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "setitimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/itimer.c",
    "lines": "378-402",
    "snippet": "SYSCALL_DEFINE3(setitimer, int, which,\n\t\t       struct old_itimerval32 __user *, value,\n\t\t       struct old_itimerval32 __user *, ovalue)\n{\n\tstruct itimerspec64 set_buffer, get_buffer;\n\tint error;\n\n\tif (value) {\n\t\terror = get_old_itimerval32(&set_buffer, value);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tmemset(&set_buffer, 0, sizeof(set_buffer));\n\t\tprintk_once(KERN_WARNING \"%s calls setitimer() with new_value NULL pointer.\"\n\t\t\t    \" Misfeature support will be removed\\n\",\n\t\t\t    current->comm);\n\t}\n\n\terror = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);\n\tif (error || !ovalue)\n\t\treturn error;\n\tif (put_old_itimerval32(ovalue, &get_buffer))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(setitimer, int, which,\n\t\t       struct old_itimerval32 __user *, value,\n\t\t       struct old_itimerval32 __user *, ovalue)\n{\n\tstruct itimerspec64 set_buffer, get_buffer;\n\tint error;\n\n\tif (value) {\n\t\terror = get_old_itimerval32(&set_buffer, value);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tmemset(&set_buffer, 0, sizeof(set_buffer));\n\t\tprintk_once(KERN_WARNING \"%s calls setitimer() with new_value NULL pointer.\"\n\t\t\t    \" Misfeature support will be removed\\n\",\n\t\t\t    current->comm);\n\t}\n\n\terror = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);\n\tif (error || !ovalue)\n\t\treturn error;\n\tif (put_old_itimerval32(ovalue, &get_buffer))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  }
]