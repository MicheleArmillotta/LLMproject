[
  {
    "function_name": "sched_clock_syscore_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "291-296",
    "snippet": "static int __init sched_clock_syscore_init(void)\n{\n\tregister_syscore_ops(&sched_clock_ops);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct syscore_ops sched_clock_ops = {\n\t.suspend\t= sched_clock_suspend,\n\t.resume\t\t= sched_clock_resume,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_syscore_ops",
          "args": [
            "&sched_clock_ops"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct syscore_ops sched_clock_ops = {\n\t.suspend\t= sched_clock_suspend,\n\t.resume\t\t= sched_clock_resume,\n};\n\nstatic int __init sched_clock_syscore_init(void)\n{\n\tregister_syscore_ops(&sched_clock_ops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_clock_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "277-284",
    "snippet": "void sched_clock_resume(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\trd->epoch_cyc = cd.actual_read_sched_clock();\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);\n\trd->read_sched_clock = cd.actual_read_sched_clock;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer sched_clock_timer;",
      "notrace struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&sched_clock_timer",
            "cd.wrap_kt",
            "HRTIMER_MODE_REL_HARD"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd.actual_read_sched_clock",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\nnotrace struct;\n\nvoid sched_clock_resume(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\trd->epoch_cyc = cd.actual_read_sched_clock();\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);\n\trd->read_sched_clock = cd.actual_read_sched_clock;\n}"
  },
  {
    "function_name": "sched_clock_suspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "266-275",
    "snippet": "int sched_clock_suspend(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\tupdate_sched_clock();\n\thrtimer_cancel(&sched_clock_timer);\n\trd->read_sched_clock = suspended_sched_clock_read;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer sched_clock_timer;",
      "notrace struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&sched_clock_timer"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_sched_clock",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "update_sched_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "127-142",
          "snippet": "static void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "notrace struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nnotrace struct;\n\nstatic void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\nnotrace struct;\n\nint sched_clock_suspend(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\tupdate_sched_clock();\n\thrtimer_cancel(&sched_clock_timer);\n\trd->read_sched_clock = suspended_sched_clock_read;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "suspended_sched_clock_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "259-264",
    "snippet": "static u64 notrace suspended_sched_clock_read(void)\n{\n\tunsigned int seq = raw_read_seqcount_latch(&cd.seq);\n\n\treturn cd.read_data[seq & 1].epoch_cyc;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_read_seqcount_latch",
          "args": [
            "&cd.seq"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic u64 notrace suspended_sched_clock_read(void)\n{\n\tunsigned int seq = raw_read_seqcount_latch(&cd.seq);\n\n\treturn cd.read_data[seq & 1].epoch_cyc;\n}"
  },
  {
    "function_name": "generic_sched_clock_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "228-246",
    "snippet": "void __init generic_sched_clock_init(void)\n{\n\t/*\n\t * If no sched_clock() function has been provided at that point,\n\t * make it the final one.\n\t */\n\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)\n\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);\n\n\tupdate_sched_clock();\n\n\t/*\n\t * Start the timer to keep sched_clock() properly updated and\n\t * sets the initial epoch.\n\t */\n\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\tsched_clock_timer.function = sched_clock_poll;\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer sched_clock_timer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&sched_clock_timer",
            "cd.wrap_kt",
            "HRTIMER_MODE_REL_HARD"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&sched_clock_timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL_HARD"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_sched_clock",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "update_sched_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "127-142",
          "snippet": "static void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "notrace struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nnotrace struct;\n\nstatic void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_register",
          "args": [
            "jiffy_sched_clock_read",
            "BITS_PER_LONG",
            "HZ"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "152-226",
          "snippet": "void __init\nsched_clock_register(u64 (*read)(void), int bits, unsigned long rate)\n{\n\tu64 res, wrap, new_mask, new_epoch, cyc, ns;\n\tu32 new_mult, new_shift;\n\tunsigned long r, flags;\n\tchar r_unit;\n\tstruct clock_read_data rd;\n\n\tif (cd.rate > rate)\n\t\treturn;\n\n\t/* Cannot register a sched_clock with interrupts on */\n\tlocal_irq_save(flags);\n\n\t/* Calculate the mult/shift to convert counter ticks to ns. */\n\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);\n\n\tnew_mask = CLOCKSOURCE_MASK(bits);\n\tcd.rate = rate;\n\n\t/* Calculate how many nanosecs until we risk wrapping */\n\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);\n\tcd.wrap_kt = ns_to_ktime(wrap);\n\n\trd = cd.read_data[0];\n\n\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/\n\tnew_epoch = read();\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\tcd.actual_read_sched_clock = read;\n\n\trd.read_sched_clock\t= read;\n\trd.sched_clock_mask\t= new_mask;\n\trd.mult\t\t\t= new_mult;\n\trd.shift\t\t= new_shift;\n\trd.epoch_cyc\t\t= new_epoch;\n\trd.epoch_ns\t\t= ns;\n\n\tupdate_clock_read_data(&rd);\n\n\tif (sched_clock_timer.function != NULL) {\n\t\t/* update timeout for clock wrap */\n\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt,\n\t\t\t      HRTIMER_MODE_REL_HARD);\n\t}\n\n\tr = rate;\n\tif (r >= 4000000) {\n\t\tr /= 1000000;\n\t\tr_unit = 'M';\n\t} else {\n\t\tif (r >= 1000) {\n\t\t\tr /= 1000;\n\t\t\tr_unit = 'k';\n\t\t} else {\n\t\t\tr_unit = ' ';\n\t\t}\n\t}\n\n\t/* Calculate the ns resolution of this counter */\n\tres = cyc_to_ns(1ULL, new_mult, new_shift);\n\n\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",\n\t\tbits, r, r_unit, res, wrap);\n\n\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */\n\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))\n\t\tenable_sched_clock_irqtime();\n\n\tlocal_irq_restore(flags);\n\n\tpr_debug(\"Registered %pS as sched_clock source\\n\", read);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hrtimer sched_clock_timer;",
            "static int irqtime = -1;",
            "notrace struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\nstatic int irqtime = -1;\nnotrace struct;\n\nvoid __init\nsched_clock_register(u64 (*read)(void), int bits, unsigned long rate)\n{\n\tu64 res, wrap, new_mask, new_epoch, cyc, ns;\n\tu32 new_mult, new_shift;\n\tunsigned long r, flags;\n\tchar r_unit;\n\tstruct clock_read_data rd;\n\n\tif (cd.rate > rate)\n\t\treturn;\n\n\t/* Cannot register a sched_clock with interrupts on */\n\tlocal_irq_save(flags);\n\n\t/* Calculate the mult/shift to convert counter ticks to ns. */\n\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);\n\n\tnew_mask = CLOCKSOURCE_MASK(bits);\n\tcd.rate = rate;\n\n\t/* Calculate how many nanosecs until we risk wrapping */\n\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);\n\tcd.wrap_kt = ns_to_ktime(wrap);\n\n\trd = cd.read_data[0];\n\n\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/\n\tnew_epoch = read();\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\tcd.actual_read_sched_clock = read;\n\n\trd.read_sched_clock\t= read;\n\trd.sched_clock_mask\t= new_mask;\n\trd.mult\t\t\t= new_mult;\n\trd.shift\t\t= new_shift;\n\trd.epoch_cyc\t\t= new_epoch;\n\trd.epoch_ns\t\t= ns;\n\n\tupdate_clock_read_data(&rd);\n\n\tif (sched_clock_timer.function != NULL) {\n\t\t/* update timeout for clock wrap */\n\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt,\n\t\t\t      HRTIMER_MODE_REL_HARD);\n\t}\n\n\tr = rate;\n\tif (r >= 4000000) {\n\t\tr /= 1000000;\n\t\tr_unit = 'M';\n\t} else {\n\t\tif (r >= 1000) {\n\t\t\tr /= 1000;\n\t\t\tr_unit = 'k';\n\t\t} else {\n\t\t\tr_unit = ' ';\n\t\t}\n\t}\n\n\t/* Calculate the ns resolution of this counter */\n\tres = cyc_to_ns(1ULL, new_mult, new_shift);\n\n\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",\n\t\tbits, r, r_unit, res, wrap);\n\n\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */\n\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))\n\t\tenable_sched_clock_irqtime();\n\n\tlocal_irq_restore(flags);\n\n\tpr_debug(\"Registered %pS as sched_clock source\\n\", read);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\n\nvoid __init generic_sched_clock_init(void)\n{\n\t/*\n\t * If no sched_clock() function has been provided at that point,\n\t * make it the final one.\n\t */\n\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)\n\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);\n\n\tupdate_sched_clock();\n\n\t/*\n\t * Start the timer to keep sched_clock() properly updated and\n\t * sets the initial epoch.\n\t */\n\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\tsched_clock_timer.function = sched_clock_poll;\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);\n}"
  },
  {
    "function_name": "sched_clock_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "152-226",
    "snippet": "void __init\nsched_clock_register(u64 (*read)(void), int bits, unsigned long rate)\n{\n\tu64 res, wrap, new_mask, new_epoch, cyc, ns;\n\tu32 new_mult, new_shift;\n\tunsigned long r, flags;\n\tchar r_unit;\n\tstruct clock_read_data rd;\n\n\tif (cd.rate > rate)\n\t\treturn;\n\n\t/* Cannot register a sched_clock with interrupts on */\n\tlocal_irq_save(flags);\n\n\t/* Calculate the mult/shift to convert counter ticks to ns. */\n\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);\n\n\tnew_mask = CLOCKSOURCE_MASK(bits);\n\tcd.rate = rate;\n\n\t/* Calculate how many nanosecs until we risk wrapping */\n\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);\n\tcd.wrap_kt = ns_to_ktime(wrap);\n\n\trd = cd.read_data[0];\n\n\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/\n\tnew_epoch = read();\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\tcd.actual_read_sched_clock = read;\n\n\trd.read_sched_clock\t= read;\n\trd.sched_clock_mask\t= new_mask;\n\trd.mult\t\t\t= new_mult;\n\trd.shift\t\t= new_shift;\n\trd.epoch_cyc\t\t= new_epoch;\n\trd.epoch_ns\t\t= ns;\n\n\tupdate_clock_read_data(&rd);\n\n\tif (sched_clock_timer.function != NULL) {\n\t\t/* update timeout for clock wrap */\n\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt,\n\t\t\t      HRTIMER_MODE_REL_HARD);\n\t}\n\n\tr = rate;\n\tif (r >= 4000000) {\n\t\tr /= 1000000;\n\t\tr_unit = 'M';\n\t} else {\n\t\tif (r >= 1000) {\n\t\t\tr /= 1000;\n\t\t\tr_unit = 'k';\n\t\t} else {\n\t\t\tr_unit = ' ';\n\t\t}\n\t}\n\n\t/* Calculate the ns resolution of this counter */\n\tres = cyc_to_ns(1ULL, new_mult, new_shift);\n\n\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",\n\t\tbits, r, r_unit, res, wrap);\n\n\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */\n\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))\n\t\tenable_sched_clock_irqtime();\n\n\tlocal_irq_restore(flags);\n\n\tpr_debug(\"Registered %pS as sched_clock source\\n\", read);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer sched_clock_timer;",
      "static int irqtime = -1;",
      "notrace struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Registered %pS as sched_clock source\\n\"",
            "read"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_sched_clock_irqtime",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "enable_sched_clock_irqtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "24-27",
          "snippet": "void enable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 1;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define sched_clock_irqtime\t(0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid enable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\"",
            "bits",
            "r",
            "r_unit",
            "res",
            "wrap"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cyc_to_ns",
          "args": [
            "1ULL",
            "new_mult",
            "new_shift"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "cyc_to_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "66-69",
          "snippet": "static inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&sched_clock_timer",
            "cd.wrap_kt",
            "HRTIMER_MODE_REL_HARD"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_clock_read_data",
          "args": [
            "&rd"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "update_clock_read_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "109-122",
          "snippet": "static void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "notrace struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nnotrace struct;\n\nstatic void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd.actual_read_sched_clock",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "suspended_sched_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "259-264",
          "snippet": "static u64 notrace suspended_sched_clock_read(void)\n{\n\tunsigned int seq = raw_read_seqcount_latch(&cd.seq);\n\n\treturn cd.read_data[seq & 1].epoch_cyc;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic u64 notrace suspended_sched_clock_read(void)\n{\n\tunsigned int seq = raw_read_seqcount_latch(&cd.seq);\n\n\treturn cd.read_data[seq & 1].epoch_cyc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "wrap"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocks_calc_max_nsecs",
          "args": [
            "new_mult",
            "new_shift",
            "0",
            "new_mask",
            "NULL"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "clocks_calc_max_nsecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "879-907",
          "snippet": "u64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nu64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLOCKSOURCE_MASK",
          "args": [
            "bits"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocks_calc_mult_shift",
          "args": [
            "&new_mult",
            "&new_shift",
            "rate",
            "NSEC_PER_SEC",
            "3600"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "clocks_calc_mult_shift",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "46-75",
          "snippet": "void\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\nstatic int irqtime = -1;\nnotrace struct;\n\nvoid __init\nsched_clock_register(u64 (*read)(void), int bits, unsigned long rate)\n{\n\tu64 res, wrap, new_mask, new_epoch, cyc, ns;\n\tu32 new_mult, new_shift;\n\tunsigned long r, flags;\n\tchar r_unit;\n\tstruct clock_read_data rd;\n\n\tif (cd.rate > rate)\n\t\treturn;\n\n\t/* Cannot register a sched_clock with interrupts on */\n\tlocal_irq_save(flags);\n\n\t/* Calculate the mult/shift to convert counter ticks to ns. */\n\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);\n\n\tnew_mask = CLOCKSOURCE_MASK(bits);\n\tcd.rate = rate;\n\n\t/* Calculate how many nanosecs until we risk wrapping */\n\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);\n\tcd.wrap_kt = ns_to_ktime(wrap);\n\n\trd = cd.read_data[0];\n\n\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/\n\tnew_epoch = read();\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\tcd.actual_read_sched_clock = read;\n\n\trd.read_sched_clock\t= read;\n\trd.sched_clock_mask\t= new_mask;\n\trd.mult\t\t\t= new_mult;\n\trd.shift\t\t= new_shift;\n\trd.epoch_cyc\t\t= new_epoch;\n\trd.epoch_ns\t\t= ns;\n\n\tupdate_clock_read_data(&rd);\n\n\tif (sched_clock_timer.function != NULL) {\n\t\t/* update timeout for clock wrap */\n\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt,\n\t\t\t      HRTIMER_MODE_REL_HARD);\n\t}\n\n\tr = rate;\n\tif (r >= 4000000) {\n\t\tr /= 1000000;\n\t\tr_unit = 'M';\n\t} else {\n\t\tif (r >= 1000) {\n\t\t\tr /= 1000;\n\t\t\tr_unit = 'k';\n\t\t} else {\n\t\t\tr_unit = ' ';\n\t\t}\n\t}\n\n\t/* Calculate the ns resolution of this counter */\n\tres = cyc_to_ns(1ULL, new_mult, new_shift);\n\n\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",\n\t\tbits, r, r_unit, res, wrap);\n\n\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */\n\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))\n\t\tenable_sched_clock_irqtime();\n\n\tlocal_irq_restore(flags);\n\n\tpr_debug(\"Registered %pS as sched_clock source\\n\", read);\n}"
  },
  {
    "function_name": "sched_clock_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "144-150",
    "snippet": "static enum hrtimer_restart sched_clock_poll(struct hrtimer *hrt)\n{\n\tupdate_sched_clock();\n\thrtimer_forward_now(hrt, cd.wrap_kt);\n\n\treturn HRTIMER_RESTART;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "notrace struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_forward_now",
          "args": [
            "hrt",
            "cd.wrap_kt"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_sched_clock",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "update_sched_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "127-142",
          "snippet": "static void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "notrace struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nnotrace struct;\n\nstatic void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nnotrace struct;\n\nstatic enum hrtimer_restart sched_clock_poll(struct hrtimer *hrt)\n{\n\tupdate_sched_clock();\n\thrtimer_forward_now(hrt, cd.wrap_kt);\n\n\treturn HRTIMER_RESTART;\n}"
  },
  {
    "function_name": "update_sched_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "127-142",
    "snippet": "static void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "notrace struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_clock_read_data",
          "args": [
            "&rd"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "update_clock_read_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "109-122",
          "snippet": "static void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "notrace struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nnotrace struct;\n\nstatic void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cyc_to_ns",
          "args": [
            "(cyc - rd.epoch_cyc) & rd.sched_clock_mask",
            "rd.mult",
            "rd.shift"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "cyc_to_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "66-69",
          "snippet": "static inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd.actual_read_sched_clock",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nnotrace struct;\n\nstatic void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}"
  },
  {
    "function_name": "update_clock_read_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "109-122",
    "snippet": "static void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "notrace struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_write_seqcount_latch",
          "args": [
            "&cd.seq"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_latch",
          "args": [
            "&cd.seq"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nnotrace struct;\n\nstatic void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}"
  },
  {
    "function_name": "sched_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "82-97",
    "snippet": "unsigned long long notrace sched_clock(void)\n{\n\tu64 cyc, res;\n\tunsigned int seq;\n\tstruct clock_read_data *rd;\n\n\tdo {\n\t\trd = sched_clock_read_begin(&seq);\n\n\t\tcyc = (rd->read_sched_clock() - rd->epoch_cyc) &\n\t\t      rd->sched_clock_mask;\n\t\tres = rd->epoch_ns + cyc_to_ns(cyc, rd->mult, rd->shift);\n\t} while (sched_clock_read_retry(seq));\n\n\treturn res;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "notrace struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock_read_retry",
          "args": [
            "seq"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_read_retry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "77-80",
          "snippet": "notrace int sched_clock_read_retry(unsigned int seq)\n{\n\treturn read_seqcount_latch_retry(&cd.seq, seq);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nnotrace int sched_clock_read_retry(unsigned int seq)\n{\n\treturn read_seqcount_latch_retry(&cd.seq, seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cyc_to_ns",
          "args": [
            "cyc",
            "rd->mult",
            "rd->shift"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "cyc_to_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "66-69",
          "snippet": "static inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rd->read_sched_clock",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_read_begin",
          "args": [
            "&seq"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_read_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "71-75",
          "snippet": "clock_read_data *sched_clock_read_begin(unsigned int *seq)\n{\n\t*seq = raw_read_seqcount_latch(&cd.seq);\n\treturn cd.read_data + (*seq & 1);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nclock_read_data *sched_clock_read_begin(unsigned int *seq)\n{\n\t*seq = raw_read_seqcount_latch(&cd.seq);\n\treturn cd.read_data + (*seq & 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nnotrace struct;\n\nunsigned long long notrace sched_clock(void)\n{\n\tu64 cyc, res;\n\tunsigned int seq;\n\tstruct clock_read_data *rd;\n\n\tdo {\n\t\trd = sched_clock_read_begin(&seq);\n\n\t\tcyc = (rd->read_sched_clock() - rd->epoch_cyc) &\n\t\t      rd->sched_clock_mask;\n\t\tres = rd->epoch_ns + cyc_to_ns(cyc, rd->mult, rd->shift);\n\t} while (sched_clock_read_retry(seq));\n\n\treturn res;\n}"
  },
  {
    "function_name": "sched_clock_read_retry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "77-80",
    "snippet": "notrace int sched_clock_read_retry(unsigned int seq)\n{\n\treturn read_seqcount_latch_retry(&cd.seq, seq);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_latch_retry",
          "args": [
            "&cd.seq",
            "seq"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nnotrace int sched_clock_read_retry(unsigned int seq)\n{\n\treturn read_seqcount_latch_retry(&cd.seq, seq);\n}"
  },
  {
    "function_name": "sched_clock_read_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "71-75",
    "snippet": "clock_read_data *sched_clock_read_begin(unsigned int *seq)\n{\n\t*seq = raw_read_seqcount_latch(&cd.seq);\n\treturn cd.read_data + (*seq & 1);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_read_seqcount_latch",
          "args": [
            "&cd.seq"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nclock_read_data *sched_clock_read_begin(unsigned int *seq)\n{\n\t*seq = raw_read_seqcount_latch(&cd.seq);\n\treturn cd.read_data + (*seq & 1);\n}"
  },
  {
    "function_name": "cyc_to_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "66-69",
    "snippet": "static inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}"
  },
  {
    "function_name": "jiffy_sched_clock_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
    "lines": "51-58",
    "snippet": "static u64 notrace jiffy_sched_clock_read(void)\n{\n\t/*\n\t * We don't need to use get_jiffies_64 on 32-bit arches here\n\t * because we register with BITS_PER_LONG\n\t */\n\treturn (u64)(jiffies - INITIAL_JIFFIES);\n}",
    "includes": [
      "#include \"timekeeping.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "jiffies - INITIAL_JIFFIES"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic u64 notrace jiffy_sched_clock_read(void)\n{\n\t/*\n\t * We don't need to use get_jiffies_64 on 32-bit arches here\n\t * because we register with BITS_PER_LONG\n\t */\n\treturn (u64)(jiffies - INITIAL_JIFFIES);\n}"
  }
]