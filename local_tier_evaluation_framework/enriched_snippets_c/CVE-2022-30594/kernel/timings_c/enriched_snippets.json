[
  {
    "function_name": "irq_timings_selftest",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "927-956",
    "snippet": "static int __init irq_timings_selftest(void)\n{\n\tint ret;\n\n\tpr_info(\"------------------- selftest start -----------------\\n\");\n\n\t/*\n\t * At this point, we don't except any subsystem to use the irq\n\t * timings but us, so it should not be enabled.\n\t */\n\tif (static_branch_unlikely(&irq_timing_enabled)) {\n\t\tpr_warn(\"irq timings already initialized, skipping selftest\\n\");\n\t\treturn 0;\n\t}\n\n\tret = irq_timings_irqts_selftest();\n\tif (ret)\n\t\tgoto out;\n\n\tret = irq_timings_irqs_selftest();\n\tif (ret)\n\t\tgoto out;\n\n\tret = irq_timings_next_index_selftest();\nout:\n\tpr_info(\"---------- selftest end with %s -----------\\n\",\n\t\tret ? \"failure\" : \"success\");\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"---------- selftest end with %s -----------\\n\"",
            "ret ? \"failure\" : \"success\""
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_timings_next_index_selftest",
          "args": [],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_next_index_selftest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "757-772",
          "snippet": "static int __init irq_timings_next_index_selftest(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {\n\n\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",\n\t\t\ti, tis[i].count);\n\n\t\tret = irq_timings_test_next_index(&tis[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic int __init irq_timings_next_index_selftest(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {\n\n\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",\n\t\t\ti, tis[i].count);\n\n\t\tret = irq_timings_test_next_index(&tis[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_timings_irqs_selftest",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_irqs_selftest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "821-834",
          "snippet": "static int __init irq_timings_irqs_selftest(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {\n\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",\n\t\t\ti, tis[i].count);\n\t\tret = irq_timings_test_irqs(&tis[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic int __init irq_timings_irqs_selftest(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {\n\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",\n\t\t\ti, tis[i].count);\n\t\tret = irq_timings_test_irqs(&tis[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_timings_irqts_selftest",
          "args": [],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_irqts_selftest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "895-925",
          "snippet": "static int __init irq_timings_irqts_selftest(void)\n{\n\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);\n\tint i, ret;\n\n\t/*\n\t * Test the circular buffer with different number of\n\t * elements. The purpose is to test at the limits (empty, half\n\t * full, full, wrapped with the cursor at the boundaries,\n\t * wrapped several times, etc ...\n\t */\n\tint count[] = { 0,\n\t\t\tIRQ_TIMINGS_SIZE >> 1,\n\t\t\tIRQ_TIMINGS_SIZE,\n\t\t\tIRQ_TIMINGS_SIZE + (IRQ_TIMINGS_SIZE >> 1),\n\t\t\t2 * IRQ_TIMINGS_SIZE,\n\t\t\t(2 * IRQ_TIMINGS_SIZE) + 3,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(count); i++) {\n\n\t\tpr_info(\"---> Checking the timings with %d/%d values\\n\",\n\t\t\tcount[i], IRQ_TIMINGS_SIZE);\n\n\t\tret = irq_timings_test_irqts(irqts, count[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic int __init irq_timings_irqts_selftest(void)\n{\n\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);\n\tint i, ret;\n\n\t/*\n\t * Test the circular buffer with different number of\n\t * elements. The purpose is to test at the limits (empty, half\n\t * full, full, wrapped with the cursor at the boundaries,\n\t * wrapped several times, etc ...\n\t */\n\tint count[] = { 0,\n\t\t\tIRQ_TIMINGS_SIZE >> 1,\n\t\t\tIRQ_TIMINGS_SIZE,\n\t\t\tIRQ_TIMINGS_SIZE + (IRQ_TIMINGS_SIZE >> 1),\n\t\t\t2 * IRQ_TIMINGS_SIZE,\n\t\t\t(2 * IRQ_TIMINGS_SIZE) + 3,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(count); i++) {\n\n\t\tpr_info(\"---> Checking the timings with %d/%d values\\n\",\n\t\t\tcount[i], IRQ_TIMINGS_SIZE);\n\n\t\tret = irq_timings_test_irqts(irqts, count[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"irq timings already initialized, skipping selftest\\n\""
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&irq_timing_enabled"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"------------------- selftest start -----------------\\n\""
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic int __init irq_timings_selftest(void)\n{\n\tint ret;\n\n\tpr_info(\"------------------- selftest start -----------------\\n\");\n\n\t/*\n\t * At this point, we don't except any subsystem to use the irq\n\t * timings but us, so it should not be enabled.\n\t */\n\tif (static_branch_unlikely(&irq_timing_enabled)) {\n\t\tpr_warn(\"irq timings already initialized, skipping selftest\\n\");\n\t\treturn 0;\n\t}\n\n\tret = irq_timings_irqts_selftest();\n\tif (ret)\n\t\tgoto out;\n\n\tret = irq_timings_irqs_selftest();\n\tif (ret)\n\t\tgoto out;\n\n\tret = irq_timings_next_index_selftest();\nout:\n\tpr_info(\"---------- selftest end with %s -----------\\n\",\n\t\tret ? \"failure\" : \"success\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_timings_irqts_selftest",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "895-925",
    "snippet": "static int __init irq_timings_irqts_selftest(void)\n{\n\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);\n\tint i, ret;\n\n\t/*\n\t * Test the circular buffer with different number of\n\t * elements. The purpose is to test at the limits (empty, half\n\t * full, full, wrapped with the cursor at the boundaries,\n\t * wrapped several times, etc ...\n\t */\n\tint count[] = { 0,\n\t\t\tIRQ_TIMINGS_SIZE >> 1,\n\t\t\tIRQ_TIMINGS_SIZE,\n\t\t\tIRQ_TIMINGS_SIZE + (IRQ_TIMINGS_SIZE >> 1),\n\t\t\t2 * IRQ_TIMINGS_SIZE,\n\t\t\t(2 * IRQ_TIMINGS_SIZE) + 3,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(count); i++) {\n\n\t\tpr_info(\"---> Checking the timings with %d/%d values\\n\",\n\t\t\tcount[i], IRQ_TIMINGS_SIZE);\n\n\t\tret = irq_timings_test_irqts(irqts, count[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_timings_test_irqts",
          "args": [
            "irqts",
            "count[i]"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_test_irqts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "836-893",
          "snippet": "static int __init irq_timings_test_irqts(struct irq_timings *irqts,\n\t\t\t\t\t unsigned count)\n{\n\tint start = count >= IRQ_TIMINGS_SIZE ? count - IRQ_TIMINGS_SIZE : 0;\n\tint i, irq, oirq = 0xBEEF;\n\tu64 ots = 0xDEAD, ts;\n\n\t/*\n\t * Fill the circular buffer by using the dedicated function.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tpr_debug(\"%d: index=%d, ts=%llX irq=%X\\n\",\n\t\t\t i, i & IRQ_TIMINGS_MASK, ots + i, oirq + i);\n\n\t\tirq_timings_push(ots + i, oirq + i);\n\t}\n\n\t/*\n\t * Compute the first elements values after the index wrapped\n\t * up or not.\n\t */\n\tots += start;\n\toirq += start;\n\n\t/*\n\t * Test the circular buffer count is correct.\n\t */\n\tpr_debug(\"---> Checking timings array count (%d) is right\\n\", count);\n\tif (WARN_ON(irqts->count != count))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Test the macro allowing to browse all the irqts.\n\t */\n\tpr_debug(\"---> Checking the for_each_irqts() macro\\n\");\n\tfor_each_irqts(i, irqts) {\n\n\t\tirq = irq_timing_decode(irqts->values[i], &ts);\n\n\t\tpr_debug(\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\",\n\t\t\t i, ts, ots, irq, oirq);\n\n\t\tif (WARN_ON(ts != ots || irq != oirq))\n\t\t\treturn -EINVAL;\n\n\t\tots++; oirq++;\n\t}\n\n\t/*\n\t * The circular buffer should have be flushed when browsed\n\t * with for_each_irqts\n\t */\n\tpr_debug(\"---> Checking timings array is empty after browsing it\\n\");\n\tif (WARN_ON(irqts->count))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic int __init irq_timings_test_irqts(struct irq_timings *irqts,\n\t\t\t\t\t unsigned count)\n{\n\tint start = count >= IRQ_TIMINGS_SIZE ? count - IRQ_TIMINGS_SIZE : 0;\n\tint i, irq, oirq = 0xBEEF;\n\tu64 ots = 0xDEAD, ts;\n\n\t/*\n\t * Fill the circular buffer by using the dedicated function.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tpr_debug(\"%d: index=%d, ts=%llX irq=%X\\n\",\n\t\t\t i, i & IRQ_TIMINGS_MASK, ots + i, oirq + i);\n\n\t\tirq_timings_push(ots + i, oirq + i);\n\t}\n\n\t/*\n\t * Compute the first elements values after the index wrapped\n\t * up or not.\n\t */\n\tots += start;\n\toirq += start;\n\n\t/*\n\t * Test the circular buffer count is correct.\n\t */\n\tpr_debug(\"---> Checking timings array count (%d) is right\\n\", count);\n\tif (WARN_ON(irqts->count != count))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Test the macro allowing to browse all the irqts.\n\t */\n\tpr_debug(\"---> Checking the for_each_irqts() macro\\n\");\n\tfor_each_irqts(i, irqts) {\n\n\t\tirq = irq_timing_decode(irqts->values[i], &ts);\n\n\t\tpr_debug(\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\",\n\t\t\t i, ts, ots, irq, oirq);\n\n\t\tif (WARN_ON(ts != ots || irq != oirq))\n\t\t\treturn -EINVAL;\n\n\t\tots++; oirq++;\n\t}\n\n\t/*\n\t * The circular buffer should have be flushed when browsed\n\t * with for_each_irqts\n\t */\n\tpr_debug(\"---> Checking timings array is empty after browsing it\\n\");\n\tif (WARN_ON(irqts->count))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"---> Checking the timings with %d/%d values\\n\"",
            "count[i]",
            "IRQ_TIMINGS_SIZE"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "count"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&irq_timings"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic int __init irq_timings_irqts_selftest(void)\n{\n\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);\n\tint i, ret;\n\n\t/*\n\t * Test the circular buffer with different number of\n\t * elements. The purpose is to test at the limits (empty, half\n\t * full, full, wrapped with the cursor at the boundaries,\n\t * wrapped several times, etc ...\n\t */\n\tint count[] = { 0,\n\t\t\tIRQ_TIMINGS_SIZE >> 1,\n\t\t\tIRQ_TIMINGS_SIZE,\n\t\t\tIRQ_TIMINGS_SIZE + (IRQ_TIMINGS_SIZE >> 1),\n\t\t\t2 * IRQ_TIMINGS_SIZE,\n\t\t\t(2 * IRQ_TIMINGS_SIZE) + 3,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(count); i++) {\n\n\t\tpr_info(\"---> Checking the timings with %d/%d values\\n\",\n\t\t\tcount[i], IRQ_TIMINGS_SIZE);\n\n\t\tret = irq_timings_test_irqts(irqts, count[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_timings_test_irqts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "836-893",
    "snippet": "static int __init irq_timings_test_irqts(struct irq_timings *irqts,\n\t\t\t\t\t unsigned count)\n{\n\tint start = count >= IRQ_TIMINGS_SIZE ? count - IRQ_TIMINGS_SIZE : 0;\n\tint i, irq, oirq = 0xBEEF;\n\tu64 ots = 0xDEAD, ts;\n\n\t/*\n\t * Fill the circular buffer by using the dedicated function.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tpr_debug(\"%d: index=%d, ts=%llX irq=%X\\n\",\n\t\t\t i, i & IRQ_TIMINGS_MASK, ots + i, oirq + i);\n\n\t\tirq_timings_push(ots + i, oirq + i);\n\t}\n\n\t/*\n\t * Compute the first elements values after the index wrapped\n\t * up or not.\n\t */\n\tots += start;\n\toirq += start;\n\n\t/*\n\t * Test the circular buffer count is correct.\n\t */\n\tpr_debug(\"---> Checking timings array count (%d) is right\\n\", count);\n\tif (WARN_ON(irqts->count != count))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Test the macro allowing to browse all the irqts.\n\t */\n\tpr_debug(\"---> Checking the for_each_irqts() macro\\n\");\n\tfor_each_irqts(i, irqts) {\n\n\t\tirq = irq_timing_decode(irqts->values[i], &ts);\n\n\t\tpr_debug(\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\",\n\t\t\t i, ts, ots, irq, oirq);\n\n\t\tif (WARN_ON(ts != ots || irq != oirq))\n\t\t\treturn -EINVAL;\n\n\t\tots++; oirq++;\n\t}\n\n\t/*\n\t * The circular buffer should have be flushed when browsed\n\t * with for_each_irqts\n\t */\n\tpr_debug(\"---> Checking timings array is empty after browsing it\\n\");\n\tif (WARN_ON(irqts->count))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irqts->count"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"---> Checking timings array is empty after browsing it\\n\""
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ts != ots || irq != oirq"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\"",
            "i",
            "ts",
            "ots",
            "irq",
            "oirq"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_timing_decode",
          "args": [
            "irqts->values[i]",
            "&ts"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timing_decode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "354-358",
          "snippet": "static inline int irq_timing_decode(u64 value, u64 *timestamp)\n{\n\t*timestamp = value >> 16;\n\treturn value & U16_MAX;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline int irq_timing_decode(u64 value, u64 *timestamp)\n{\n\t*timestamp = value >> 16;\n\treturn value & U16_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irqts",
          "args": [
            "i",
            "irqts"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"---> Checking the for_each_irqts() macro\\n\""
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irqts->count != count"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"---> Checking timings array count (%d) is right\\n\"",
            "count"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_timings_push",
          "args": [
            "ots + i",
            "oirq + i"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_push",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "360-368",
          "snippet": "static __always_inline void irq_timings_push(u64 ts, int irq)\n{\n\tstruct irq_timings *timings = this_cpu_ptr(&irq_timings);\n\n\ttimings->values[timings->count & IRQ_TIMINGS_MASK] =\n\t\tirq_timing_encode(ts, irq);\n\n\ttimings->count++;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [
            "#define IRQ_TIMINGS_MASK\t(IRQ_TIMINGS_SIZE - 1)"
          ],
          "globals_used": [
            "extern bool irq_can_set_affinity_usr(unsigned int irq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\n#define IRQ_TIMINGS_MASK\t(IRQ_TIMINGS_SIZE - 1)\n\nextern bool irq_can_set_affinity_usr(unsigned int irq);\n\nstatic __always_inline void irq_timings_push(u64 ts, int irq)\n{\n\tstruct irq_timings *timings = this_cpu_ptr(&irq_timings);\n\n\ttimings->values[timings->count & IRQ_TIMINGS_MASK] =\n\t\tirq_timing_encode(ts, irq);\n\n\ttimings->count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%d: index=%d, ts=%llX irq=%X\\n\"",
            "i",
            "i & IRQ_TIMINGS_MASK",
            "ots + i",
            "oirq + i"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic int __init irq_timings_test_irqts(struct irq_timings *irqts,\n\t\t\t\t\t unsigned count)\n{\n\tint start = count >= IRQ_TIMINGS_SIZE ? count - IRQ_TIMINGS_SIZE : 0;\n\tint i, irq, oirq = 0xBEEF;\n\tu64 ots = 0xDEAD, ts;\n\n\t/*\n\t * Fill the circular buffer by using the dedicated function.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tpr_debug(\"%d: index=%d, ts=%llX irq=%X\\n\",\n\t\t\t i, i & IRQ_TIMINGS_MASK, ots + i, oirq + i);\n\n\t\tirq_timings_push(ots + i, oirq + i);\n\t}\n\n\t/*\n\t * Compute the first elements values after the index wrapped\n\t * up or not.\n\t */\n\tots += start;\n\toirq += start;\n\n\t/*\n\t * Test the circular buffer count is correct.\n\t */\n\tpr_debug(\"---> Checking timings array count (%d) is right\\n\", count);\n\tif (WARN_ON(irqts->count != count))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Test the macro allowing to browse all the irqts.\n\t */\n\tpr_debug(\"---> Checking the for_each_irqts() macro\\n\");\n\tfor_each_irqts(i, irqts) {\n\n\t\tirq = irq_timing_decode(irqts->values[i], &ts);\n\n\t\tpr_debug(\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\",\n\t\t\t i, ts, ots, irq, oirq);\n\n\t\tif (WARN_ON(ts != ots || irq != oirq))\n\t\t\treturn -EINVAL;\n\n\t\tots++; oirq++;\n\t}\n\n\t/*\n\t * The circular buffer should have be flushed when browsed\n\t * with for_each_irqts\n\t */\n\tpr_debug(\"---> Checking timings array is empty after browsing it\\n\");\n\tif (WARN_ON(irqts->count))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_timings_irqs_selftest",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "821-834",
    "snippet": "static int __init irq_timings_irqs_selftest(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {\n\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",\n\t\t\ti, tis[i].count);\n\t\tret = irq_timings_test_irqs(&tis[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_timings_test_irqs",
          "args": [
            "&tis[i]"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_test_irqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "774-819",
          "snippet": "static int __init irq_timings_test_irqs(struct timings_intervals *ti)\n{\n\tstruct irqt_stat __percpu *s;\n\tstruct irqt_stat *irqs;\n\tint i, index, ret, irq = 0xACE5;\n\n\tret = irq_timings_alloc(irq);\n\tif (ret) {\n\t\tpr_err(\"Failed to allocate irq timings\\n\");\n\t\treturn ret;\n\t}\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (!s) {\n\t\tret = -EIDRM;\n\t\tgoto out;\n\t}\n\n\tirqs = this_cpu_ptr(s);\n\n\tfor (i = 0; i < ti->count; i++) {\n\n\t\tindex = irq_timings_interval_index(ti->intervals[i]);\n\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",\n\t\t\t i, ti->intervals[i], index);\n\n\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);\n\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {\n\t\t\tret = -EBADSLT;\n\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (irqs->count != ti->count) {\n\t\tret = -ERANGE;\n\t\tpr_err(\"Count differs\\n\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tirq_timings_free(irq);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(irqt_stats);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_IDR(irqt_stats);\n\nstatic int __init irq_timings_test_irqs(struct timings_intervals *ti)\n{\n\tstruct irqt_stat __percpu *s;\n\tstruct irqt_stat *irqs;\n\tint i, index, ret, irq = 0xACE5;\n\n\tret = irq_timings_alloc(irq);\n\tif (ret) {\n\t\tpr_err(\"Failed to allocate irq timings\\n\");\n\t\treturn ret;\n\t}\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (!s) {\n\t\tret = -EIDRM;\n\t\tgoto out;\n\t}\n\n\tirqs = this_cpu_ptr(s);\n\n\tfor (i = 0; i < ti->count; i++) {\n\n\t\tindex = irq_timings_interval_index(ti->intervals[i]);\n\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",\n\t\t\t i, ti->intervals[i], index);\n\n\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);\n\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {\n\t\t\tret = -EBADSLT;\n\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (irqs->count != ti->count) {\n\t\tret = -ERANGE;\n\t\tpr_err(\"Count differs\\n\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tirq_timings_free(irq);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"---> Injecting intervals number #%d (count=%zd)\\n\"",
            "i",
            "tis[i].count"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tis"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic int __init irq_timings_irqs_selftest(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {\n\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",\n\t\t\ti, tis[i].count);\n\t\tret = irq_timings_test_irqs(&tis[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_timings_test_irqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "774-819",
    "snippet": "static int __init irq_timings_test_irqs(struct timings_intervals *ti)\n{\n\tstruct irqt_stat __percpu *s;\n\tstruct irqt_stat *irqs;\n\tint i, index, ret, irq = 0xACE5;\n\n\tret = irq_timings_alloc(irq);\n\tif (ret) {\n\t\tpr_err(\"Failed to allocate irq timings\\n\");\n\t\treturn ret;\n\t}\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (!s) {\n\t\tret = -EIDRM;\n\t\tgoto out;\n\t}\n\n\tirqs = this_cpu_ptr(s);\n\n\tfor (i = 0; i < ti->count; i++) {\n\n\t\tindex = irq_timings_interval_index(ti->intervals[i]);\n\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",\n\t\t\t i, ti->intervals[i], index);\n\n\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);\n\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {\n\t\t\tret = -EBADSLT;\n\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (irqs->count != ti->count) {\n\t\tret = -ERANGE;\n\t\tpr_err(\"Count differs\\n\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tirq_timings_free(irq);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(irqt_stats);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_timings_free",
          "args": [
            "irq"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "594-603",
          "snippet": "void irq_timings_free(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (s) {\n\t\tfree_percpu(s);\n\t\tidr_remove(&irqt_stats, irq);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(irqt_stats);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_IDR(irqt_stats);\n\nvoid irq_timings_free(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (s) {\n\t\tfree_percpu(s);\n\t\tidr_remove(&irqt_stats, irq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Count differs\\n\""
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to store in the circular buffer\\n\""
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_timings_store",
          "args": [
            "irq",
            "irqs",
            "ti->intervals[i]"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_timings_store",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "446-471",
          "snippet": "static __always_inline void __irq_timings_store(int irq, struct irqt_stat *irqs,\n\t\t\t\t\t\tu64 interval)\n{\n\tint index;\n\n\t/*\n\t * Get the index in the ema table for this interrupt.\n\t */\n\tindex = irq_timings_interval_index(interval);\n\n\tif (index > PREDICTION_BUFFER_SIZE - 1) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * Store the index as an element of the pattern in another\n\t * circular array.\n\t */\n\tirqs->circ_timings[irqs->count & IRQ_TIMINGS_MASK] = index;\n\n\tirqs->ema_time[index] = irq_timings_ema_new(interval,\n\t\t\t\t\t\t    irqs->ema_time[index]);\n\n\tirqs->count++;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREDICTION_BUFFER_SIZE\t16 /* slots for EMAs, hardly more than 16 */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_BUFFER_SIZE\t16 /* slots for EMAs, hardly more than 16 */\n\nstatic __always_inline void __irq_timings_store(int irq, struct irqt_stat *irqs,\n\t\t\t\t\t\tu64 interval)\n{\n\tint index;\n\n\t/*\n\t * Get the index in the ema table for this interrupt.\n\t */\n\tindex = irq_timings_interval_index(interval);\n\n\tif (index > PREDICTION_BUFFER_SIZE - 1) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * Store the index as an element of the pattern in another\n\t * circular array.\n\t */\n\tirqs->circ_timings[irqs->count & IRQ_TIMINGS_MASK] = index;\n\n\tirqs->ema_time[index] = irq_timings_ema_new(interval,\n\t\t\t\t\t\t    irqs->ema_time[index]);\n\n\tirqs->count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%d: interval=%llu ema_index=%d\\n\"",
            "i",
            "ti->intervals[i]",
            "index"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_timings_interval_index",
          "args": [
            "ti->intervals[i]"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_interval_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "435-444",
          "snippet": "static __always_inline int irq_timings_interval_index(u64 interval)\n{\n\t/*\n\t * The PREDICTION_FACTOR increase the interval size for the\n\t * array of exponential average.\n\t */\n\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;\n\n\treturn likely(interval_us) ? ilog2(interval_us) : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREDICTION_FACTOR\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_FACTOR\t4\n\nstatic __always_inline int irq_timings_interval_index(u64 interval)\n{\n\t/*\n\t * The PREDICTION_FACTOR increase the interval size for the\n\t * array of exponential average.\n\t */\n\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;\n\n\treturn likely(interval_us) ? ilog2(interval_us) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "s"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&irqt_stats",
            "irq"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate irq timings\\n\""
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_timings_alloc",
          "args": [
            "irq"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "605-634",
          "snippet": "int irq_timings_alloc(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\tint id;\n\n\t/*\n\t * Some platforms can have the same private interrupt per cpu,\n\t * so this function may be called several times with the\n\t * same interrupt number. Just bail out in case the per cpu\n\t * stat structure is already allocated.\n\t */\n\ts = idr_find(&irqt_stats, irq);\n\tif (s)\n\t\treturn 0;\n\n\ts = alloc_percpu(*s);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tidr_preload(GFP_KERNEL);\n\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);\n\tidr_preload_end();\n\n\tif (id < 0) {\n\t\tfree_percpu(s);\n\t\treturn id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(irqt_stats);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_IDR(irqt_stats);\n\nint irq_timings_alloc(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\tint id;\n\n\t/*\n\t * Some platforms can have the same private interrupt per cpu,\n\t * so this function may be called several times with the\n\t * same interrupt number. Just bail out in case the per cpu\n\t * stat structure is already allocated.\n\t */\n\ts = idr_find(&irqt_stats, irq);\n\tif (s)\n\t\treturn 0;\n\n\ts = alloc_percpu(*s);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tidr_preload(GFP_KERNEL);\n\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);\n\tidr_preload_end();\n\n\tif (id < 0) {\n\t\tfree_percpu(s);\n\t\treturn id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_IDR(irqt_stats);\n\nstatic int __init irq_timings_test_irqs(struct timings_intervals *ti)\n{\n\tstruct irqt_stat __percpu *s;\n\tstruct irqt_stat *irqs;\n\tint i, index, ret, irq = 0xACE5;\n\n\tret = irq_timings_alloc(irq);\n\tif (ret) {\n\t\tpr_err(\"Failed to allocate irq timings\\n\");\n\t\treturn ret;\n\t}\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (!s) {\n\t\tret = -EIDRM;\n\t\tgoto out;\n\t}\n\n\tirqs = this_cpu_ptr(s);\n\n\tfor (i = 0; i < ti->count; i++) {\n\n\t\tindex = irq_timings_interval_index(ti->intervals[i]);\n\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",\n\t\t\t i, ti->intervals[i], index);\n\n\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);\n\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {\n\t\t\tret = -EBADSLT;\n\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (irqs->count != ti->count) {\n\t\tret = -ERANGE;\n\t\tpr_err(\"Count differs\\n\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tirq_timings_free(irq);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_timings_next_index_selftest",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "757-772",
    "snippet": "static int __init irq_timings_next_index_selftest(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {\n\n\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",\n\t\t\ti, tis[i].count);\n\n\t\tret = irq_timings_test_next_index(&tis[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_timings_test_next_index",
          "args": [
            "&tis[i]"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_test_next_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "712-755",
          "snippet": "static int __init irq_timings_test_next_index(struct timings_intervals *ti)\n{\n\tint _buffer[IRQ_TIMINGS_SIZE];\n\tint buffer[IRQ_TIMINGS_SIZE];\n\tint index, start, i, count, period_max;\n\n\tcount = ti->count - 1;\n\n\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?\n\t\tPREDICTION_PERIOD_MAX : count / 3;\n\n\t/*\n\t * Inject all values except the last one which will be used\n\t * to compare with the next index result.\n\t */\n\tpr_debug(\"index suite: \");\n\n\tfor (i = 0; i < count; i++) {\n\t\tindex = irq_timings_interval_index(ti->intervals[i]);\n\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;\n\t\tpr_cont(\"%d \", index);\n\t}\n\n\tstart = count < IRQ_TIMINGS_SIZE ? 0 :\n\t\tcount & IRQ_TIMINGS_MASK;\n\n\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);\n\n\tfor (i = 0; i < count; i++) {\n\t\tint index = (start + i) & IRQ_TIMINGS_MASK;\n\t\tbuffer[i] = _buffer[index];\n\t}\n\n\tindex = irq_timings_next_event_index(buffer, count, period_max);\n\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);\n\n\tif (index != i) {\n\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",\n\t\t       i, index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREDICTION_PERIOD_MAX\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_PERIOD_MAX\t5\n\nstatic int __init irq_timings_test_next_index(struct timings_intervals *ti)\n{\n\tint _buffer[IRQ_TIMINGS_SIZE];\n\tint buffer[IRQ_TIMINGS_SIZE];\n\tint index, start, i, count, period_max;\n\n\tcount = ti->count - 1;\n\n\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?\n\t\tPREDICTION_PERIOD_MAX : count / 3;\n\n\t/*\n\t * Inject all values except the last one which will be used\n\t * to compare with the next index result.\n\t */\n\tpr_debug(\"index suite: \");\n\n\tfor (i = 0; i < count; i++) {\n\t\tindex = irq_timings_interval_index(ti->intervals[i]);\n\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;\n\t\tpr_cont(\"%d \", index);\n\t}\n\n\tstart = count < IRQ_TIMINGS_SIZE ? 0 :\n\t\tcount & IRQ_TIMINGS_MASK;\n\n\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);\n\n\tfor (i = 0; i < count; i++) {\n\t\tint index = (start + i) & IRQ_TIMINGS_MASK;\n\t\tbuffer[i] = _buffer[index];\n\t}\n\n\tindex = irq_timings_next_event_index(buffer, count, period_max);\n\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);\n\n\tif (index != i) {\n\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",\n\t\t       i, index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"---> Injecting intervals number #%d (count=%zd)\\n\"",
            "i",
            "tis[i].count"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tis"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic int __init irq_timings_next_index_selftest(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {\n\n\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",\n\t\t\ti, tis[i].count);\n\n\t\tret = irq_timings_test_next_index(&tis[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_timings_test_next_index",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "712-755",
    "snippet": "static int __init irq_timings_test_next_index(struct timings_intervals *ti)\n{\n\tint _buffer[IRQ_TIMINGS_SIZE];\n\tint buffer[IRQ_TIMINGS_SIZE];\n\tint index, start, i, count, period_max;\n\n\tcount = ti->count - 1;\n\n\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?\n\t\tPREDICTION_PERIOD_MAX : count / 3;\n\n\t/*\n\t * Inject all values except the last one which will be used\n\t * to compare with the next index result.\n\t */\n\tpr_debug(\"index suite: \");\n\n\tfor (i = 0; i < count; i++) {\n\t\tindex = irq_timings_interval_index(ti->intervals[i]);\n\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;\n\t\tpr_cont(\"%d \", index);\n\t}\n\n\tstart = count < IRQ_TIMINGS_SIZE ? 0 :\n\t\tcount & IRQ_TIMINGS_MASK;\n\n\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);\n\n\tfor (i = 0; i < count; i++) {\n\t\tint index = (start + i) & IRQ_TIMINGS_MASK;\n\t\tbuffer[i] = _buffer[index];\n\t}\n\n\tindex = irq_timings_next_event_index(buffer, count, period_max);\n\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);\n\n\tif (index != i) {\n\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",\n\t\t       i, index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PREDICTION_PERIOD_MAX\t5"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Expected (%d) and computed (%d) next indexes differ\\n\"",
            "i",
            "index"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_timings_interval_index",
          "args": [
            "ti->intervals[ti->count - 1]"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_interval_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "435-444",
          "snippet": "static __always_inline int irq_timings_interval_index(u64 interval)\n{\n\t/*\n\t * The PREDICTION_FACTOR increase the interval size for the\n\t * array of exponential average.\n\t */\n\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;\n\n\treturn likely(interval_us) ? ilog2(interval_us) : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREDICTION_FACTOR\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_FACTOR\t4\n\nstatic __always_inline int irq_timings_interval_index(u64 interval)\n{\n\t/*\n\t * The PREDICTION_FACTOR increase the interval size for the\n\t * array of exponential average.\n\t */\n\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;\n\n\treturn likely(interval_us) ? ilog2(interval_us) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_timings_next_event_index",
          "args": [
            "buffer",
            "count",
            "period_max"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_next_event_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "317-380",
          "snippet": "static int irq_timings_next_event_index(int *buffer, size_t len, int period_max)\n{\n\tint period;\n\n\t/*\n\t * Move the beginning pointer to the end minus the max period x 3.\n\t * We are at the point we can begin searching the pattern\n\t */\n\tbuffer = &buffer[len - (period_max * 3)];\n\n\t/* Adjust the length to the maximum allowed period x 3 */\n\tlen = period_max * 3;\n\n\t/*\n\t * The buffer contains the suite of intervals, in a ilog2\n\t * basis, we are looking for a repetition. We point the\n\t * beginning of the search three times the length of the\n\t * period beginning at the end of the buffer. We do that for\n\t * each suffix.\n\t */\n\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {\n\n\t\t/*\n\t\t * The first comparison always succeed because the\n\t\t * suffix is deduced from the first n-period bytes of\n\t\t * the buffer and we compare the initial suffix with\n\t\t * itself, so we can skip the first iteration.\n\t\t */\n\t\tint idx = period;\n\t\tsize_t size = period;\n\n\t\t/*\n\t\t * We look if the suite with period 'i' repeat\n\t\t * itself. If it is truncated at the end, as it\n\t\t * repeats we can use the period to find out the next\n\t\t * element with the modulo.\n\t\t */\n\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {\n\n\t\t\t/*\n\t\t\t * Move the index in a period basis\n\t\t\t */\n\t\t\tidx += size;\n\n\t\t\t/*\n\t\t\t * If this condition is reached, all previous\n\t\t\t * memcmp were successful, so the period is\n\t\t\t * found.\n\t\t\t */\n\t\t\tif (idx == len)\n\t\t\t\treturn buffer[len % period];\n\n\t\t\t/*\n\t\t\t * If the remaining elements to compare are\n\t\t\t * smaller than the period, readjust the size\n\t\t\t * of the comparison for the last iteration.\n\t\t\t */\n\t\t\tif (len - idx < period)\n\t\t\t\tsize = len - idx;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREDICTION_PERIOD_MIN\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_PERIOD_MIN\t3\n\nstatic int irq_timings_next_event_index(int *buffer, size_t len, int period_max)\n{\n\tint period;\n\n\t/*\n\t * Move the beginning pointer to the end minus the max period x 3.\n\t * We are at the point we can begin searching the pattern\n\t */\n\tbuffer = &buffer[len - (period_max * 3)];\n\n\t/* Adjust the length to the maximum allowed period x 3 */\n\tlen = period_max * 3;\n\n\t/*\n\t * The buffer contains the suite of intervals, in a ilog2\n\t * basis, we are looking for a repetition. We point the\n\t * beginning of the search three times the length of the\n\t * period beginning at the end of the buffer. We do that for\n\t * each suffix.\n\t */\n\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {\n\n\t\t/*\n\t\t * The first comparison always succeed because the\n\t\t * suffix is deduced from the first n-period bytes of\n\t\t * the buffer and we compare the initial suffix with\n\t\t * itself, so we can skip the first iteration.\n\t\t */\n\t\tint idx = period;\n\t\tsize_t size = period;\n\n\t\t/*\n\t\t * We look if the suite with period 'i' repeat\n\t\t * itself. If it is truncated at the end, as it\n\t\t * repeats we can use the period to find out the next\n\t\t * element with the modulo.\n\t\t */\n\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {\n\n\t\t\t/*\n\t\t\t * Move the index in a period basis\n\t\t\t */\n\t\t\tidx += size;\n\n\t\t\t/*\n\t\t\t * If this condition is reached, all previous\n\t\t\t * memcmp were successful, so the period is\n\t\t\t * found.\n\t\t\t */\n\t\t\tif (idx == len)\n\t\t\t\treturn buffer[len % period];\n\n\t\t\t/*\n\t\t\t * If the remaining elements to compare are\n\t\t\t * smaller than the period, readjust the size\n\t\t\t * of the comparison for the last iteration.\n\t\t\t */\n\t\t\tif (len - idx < period)\n\t\t\t\tsize = len - idx;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "count",
            "IRQ_TIMINGS_SIZE"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%d \"",
            "index"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"index suite: \""
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_PERIOD_MAX\t5\n\nstatic int __init irq_timings_test_next_index(struct timings_intervals *ti)\n{\n\tint _buffer[IRQ_TIMINGS_SIZE];\n\tint buffer[IRQ_TIMINGS_SIZE];\n\tint index, start, i, count, period_max;\n\n\tcount = ti->count - 1;\n\n\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?\n\t\tPREDICTION_PERIOD_MAX : count / 3;\n\n\t/*\n\t * Inject all values except the last one which will be used\n\t * to compare with the next index result.\n\t */\n\tpr_debug(\"index suite: \");\n\n\tfor (i = 0; i < count; i++) {\n\t\tindex = irq_timings_interval_index(ti->intervals[i]);\n\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;\n\t\tpr_cont(\"%d \", index);\n\t}\n\n\tstart = count < IRQ_TIMINGS_SIZE ? 0 :\n\t\tcount & IRQ_TIMINGS_MASK;\n\n\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);\n\n\tfor (i = 0; i < count; i++) {\n\t\tint index = (start + i) & IRQ_TIMINGS_MASK;\n\t\tbuffer[i] = _buffer[index];\n\t}\n\n\tindex = irq_timings_next_event_index(buffer, count, period_max);\n\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);\n\n\tif (index != i) {\n\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",\n\t\t       i, index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_timings_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "605-634",
    "snippet": "int irq_timings_alloc(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\tint id;\n\n\t/*\n\t * Some platforms can have the same private interrupt per cpu,\n\t * so this function may be called several times with the\n\t * same interrupt number. Just bail out in case the per cpu\n\t * stat structure is already allocated.\n\t */\n\ts = idr_find(&irqt_stats, irq);\n\tif (s)\n\t\treturn 0;\n\n\ts = alloc_percpu(*s);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tidr_preload(GFP_KERNEL);\n\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);\n\tidr_preload_end();\n\n\tif (id < 0) {\n\t\tfree_percpu(s);\n\t\treturn id;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(irqt_stats);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "s"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "&irqt_stats",
            "s",
            "irq",
            "irq + 1",
            "GFP_NOWAIT"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "319-330",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "*s"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&irqt_stats",
            "irq"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_IDR(irqt_stats);\n\nint irq_timings_alloc(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\tint id;\n\n\t/*\n\t * Some platforms can have the same private interrupt per cpu,\n\t * so this function may be called several times with the\n\t * same interrupt number. Just bail out in case the per cpu\n\t * stat structure is already allocated.\n\t */\n\ts = idr_find(&irqt_stats, irq);\n\tif (s)\n\t\treturn 0;\n\n\ts = alloc_percpu(*s);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tidr_preload(GFP_KERNEL);\n\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);\n\tidr_preload_end();\n\n\tif (id < 0) {\n\t\tfree_percpu(s);\n\t\treturn id;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_timings_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "594-603",
    "snippet": "void irq_timings_free(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (s) {\n\t\tfree_percpu(s);\n\t\tidr_remove(&irqt_stats, irq);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(irqt_stats);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&irqt_stats",
            "irq"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "342-347",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "s"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&irqt_stats",
            "irq"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_IDR(irqt_stats);\n\nvoid irq_timings_free(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (s) {\n\t\tfree_percpu(s);\n\t\tidr_remove(&irqt_stats, irq);\n\t}\n}"
  },
  {
    "function_name": "irq_timings_next_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "536-592",
    "snippet": "u64 irq_timings_next_event(u64 now)\n{\n\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);\n\tstruct irqt_stat *irqs;\n\tstruct irqt_stat __percpu *s;\n\tu64 ts, next_evt = U64_MAX;\n\tint i, irq = 0;\n\n\t/*\n\t * This function must be called with the local irq disabled in\n\t * order to prevent the timings circular buffer to be updated\n\t * while we are reading it.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tif (!irqts->count)\n\t\treturn next_evt;\n\n\t/*\n\t * Number of elements in the circular buffer: If it happens it\n\t * was flushed before, then the number of elements could be\n\t * smaller than IRQ_TIMINGS_SIZE, so the count is used,\n\t * otherwise the array size is used as we wrapped. The index\n\t * begins from zero when we did not wrap. That could be done\n\t * in a nicer way with the proper circular array structure\n\t * type but with the cost of extra computation in the\n\t * interrupt handler hot path. We choose efficiency.\n\t *\n\t * Inject measured irq/timestamp to the pattern prediction\n\t * model while decrementing the counter because we consume the\n\t * data from our circular buffer.\n\t */\n\tfor_each_irqts(i, irqts) {\n\t\tirq = irq_timing_decode(irqts->values[i], &ts);\n\t\ts = idr_find(&irqt_stats, irq);\n\t\tif (s)\n\t\t\tirq_timings_store(irq, this_cpu_ptr(s), ts);\n\t}\n\n\t/*\n\t * Look in the list of interrupts' statistics, the earliest\n\t * next event.\n\t */\n\tidr_for_each_entry(&irqt_stats, s, i) {\n\n\t\tirqs = this_cpu_ptr(s);\n\n\t\tts = __irq_timings_next_event(irqs, i, now);\n\t\tif (ts <= now)\n\t\t\treturn now;\n\n\t\tif (ts < next_evt)\n\t\t\tnext_evt = ts;\n\t}\n\n\treturn next_evt;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(irqt_stats);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_timings_next_event",
          "args": [
            "irqs",
            "i",
            "now"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_timings_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "382-433",
          "snippet": "static u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)\n{\n\tint index, i, period_max, count, start, min = INT_MAX;\n\n\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {\n\t\tirqs->count = irqs->last_ts = 0;\n\t\treturn U64_MAX;\n\t}\n\n\t/*\n\t * As we want to find three times the repetition, we need a\n\t * number of intervals greater or equal to three times the\n\t * maximum period, otherwise we truncate the max period.\n\t */\n\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?\n\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;\n\n\t/*\n\t * If we don't have enough irq timings for this prediction,\n\t * just bail out.\n\t */\n\tif (period_max <= PREDICTION_PERIOD_MIN)\n\t\treturn U64_MAX;\n\n\t/*\n\t * 'count' will depends if the circular buffer wrapped or not\n\t */\n\tcount = irqs->count < IRQ_TIMINGS_SIZE ?\n\t\tirqs->count : IRQ_TIMINGS_SIZE;\n\n\tstart = irqs->count < IRQ_TIMINGS_SIZE ?\n\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);\n\n\t/*\n\t * Copy the content of the circular buffer into another buffer\n\t * in order to linearize the buffer instead of dealing with\n\t * wrapping indexes and shifted array which will be prone to\n\t * error and extremely difficult to debug.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tint index = (start + i) & IRQ_TIMINGS_MASK;\n\n\t\tirqs->timings[i] = irqs->circ_timings[index];\n\t\tmin = min_t(int, irqs->timings[i], min);\n\t}\n\n\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);\n\tif (index < 0)\n\t\treturn irqs->last_ts + irqs->ema_time[min];\n\n\treturn irqs->last_ts + irqs->ema_time[index];\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREDICTION_PERIOD_MAX\t5",
            "#define PREDICTION_PERIOD_MIN\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_PERIOD_MAX\t5\n#define PREDICTION_PERIOD_MIN\t3\n\nstatic u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)\n{\n\tint index, i, period_max, count, start, min = INT_MAX;\n\n\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {\n\t\tirqs->count = irqs->last_ts = 0;\n\t\treturn U64_MAX;\n\t}\n\n\t/*\n\t * As we want to find three times the repetition, we need a\n\t * number of intervals greater or equal to three times the\n\t * maximum period, otherwise we truncate the max period.\n\t */\n\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?\n\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;\n\n\t/*\n\t * If we don't have enough irq timings for this prediction,\n\t * just bail out.\n\t */\n\tif (period_max <= PREDICTION_PERIOD_MIN)\n\t\treturn U64_MAX;\n\n\t/*\n\t * 'count' will depends if the circular buffer wrapped or not\n\t */\n\tcount = irqs->count < IRQ_TIMINGS_SIZE ?\n\t\tirqs->count : IRQ_TIMINGS_SIZE;\n\n\tstart = irqs->count < IRQ_TIMINGS_SIZE ?\n\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);\n\n\t/*\n\t * Copy the content of the circular buffer into another buffer\n\t * in order to linearize the buffer instead of dealing with\n\t * wrapping indexes and shifted array which will be prone to\n\t * error and extremely difficult to debug.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tint index = (start + i) & IRQ_TIMINGS_MASK;\n\n\t\tirqs->timings[i] = irqs->circ_timings[index];\n\t\tmin = min_t(int, irqs->timings[i], min);\n\t}\n\n\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);\n\tif (index < 0)\n\t\treturn irqs->last_ts + irqs->ema_time[min];\n\n\treturn irqs->last_ts + irqs->ema_time[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "s"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_for_each_entry",
          "args": [
            "&irqt_stats",
            "s",
            "i"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_timings_store",
          "args": [
            "irq",
            "this_cpu_ptr(s)",
            "ts"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_store",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "473-508",
          "snippet": "static inline void irq_timings_store(int irq, struct irqt_stat *irqs, u64 ts)\n{\n\tu64 old_ts = irqs->last_ts;\n\tu64 interval;\n\n\t/*\n\t * The timestamps are absolute time values, we need to compute\n\t * the timing interval between two interrupts.\n\t */\n\tirqs->last_ts = ts;\n\n\t/*\n\t * The interval type is u64 in order to deal with the same\n\t * type in our computation, that prevent mindfuck issues with\n\t * overflow, sign and division.\n\t */\n\tinterval = ts - old_ts;\n\n\t/*\n\t * The interrupt triggered more than one second apart, that\n\t * ends the sequence as predictable for our purpose. In this\n\t * case, assume we have the beginning of a sequence and the\n\t * timestamp is the first value. As it is impossible to\n\t * predict anything at this point, return.\n\t *\n\t * Note the first timestamp of the sequence will always fall\n\t * in this test because the old_ts is zero. That is what we\n\t * want as we need another timestamp to compute an interval.\n\t */\n\tif (interval >= NSEC_PER_SEC) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t__irq_timings_store(irq, irqs, interval);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic inline void irq_timings_store(int irq, struct irqt_stat *irqs, u64 ts)\n{\n\tu64 old_ts = irqs->last_ts;\n\tu64 interval;\n\n\t/*\n\t * The timestamps are absolute time values, we need to compute\n\t * the timing interval between two interrupts.\n\t */\n\tirqs->last_ts = ts;\n\n\t/*\n\t * The interval type is u64 in order to deal with the same\n\t * type in our computation, that prevent mindfuck issues with\n\t * overflow, sign and division.\n\t */\n\tinterval = ts - old_ts;\n\n\t/*\n\t * The interrupt triggered more than one second apart, that\n\t * ends the sequence as predictable for our purpose. In this\n\t * case, assume we have the beginning of a sequence and the\n\t * timestamp is the first value. As it is impossible to\n\t * predict anything at this point, return.\n\t *\n\t * Note the first timestamp of the sequence will always fall\n\t * in this test because the old_ts is zero. That is what we\n\t * want as we need another timestamp to compute an interval.\n\t */\n\tif (interval >= NSEC_PER_SEC) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t__irq_timings_store(irq, irqs, interval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "s"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&irqt_stats",
            "irq"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_timing_decode",
          "args": [
            "irqts->values[i]",
            "&ts"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timing_decode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "354-358",
          "snippet": "static inline int irq_timing_decode(u64 value, u64 *timestamp)\n{\n\t*timestamp = value >> 16;\n\treturn value & U16_MAX;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline int irq_timing_decode(u64 value, u64 *timestamp)\n{\n\t*timestamp = value >> 16;\n\treturn value & U16_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irqts",
          "args": [
            "i",
            "irqts"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&irq_timings"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_IDR(irqt_stats);\n\nu64 irq_timings_next_event(u64 now)\n{\n\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);\n\tstruct irqt_stat *irqs;\n\tstruct irqt_stat __percpu *s;\n\tu64 ts, next_evt = U64_MAX;\n\tint i, irq = 0;\n\n\t/*\n\t * This function must be called with the local irq disabled in\n\t * order to prevent the timings circular buffer to be updated\n\t * while we are reading it.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tif (!irqts->count)\n\t\treturn next_evt;\n\n\t/*\n\t * Number of elements in the circular buffer: If it happens it\n\t * was flushed before, then the number of elements could be\n\t * smaller than IRQ_TIMINGS_SIZE, so the count is used,\n\t * otherwise the array size is used as we wrapped. The index\n\t * begins from zero when we did not wrap. That could be done\n\t * in a nicer way with the proper circular array structure\n\t * type but with the cost of extra computation in the\n\t * interrupt handler hot path. We choose efficiency.\n\t *\n\t * Inject measured irq/timestamp to the pattern prediction\n\t * model while decrementing the counter because we consume the\n\t * data from our circular buffer.\n\t */\n\tfor_each_irqts(i, irqts) {\n\t\tirq = irq_timing_decode(irqts->values[i], &ts);\n\t\ts = idr_find(&irqt_stats, irq);\n\t\tif (s)\n\t\t\tirq_timings_store(irq, this_cpu_ptr(s), ts);\n\t}\n\n\t/*\n\t * Look in the list of interrupts' statistics, the earliest\n\t * next event.\n\t */\n\tidr_for_each_entry(&irqt_stats, s, i) {\n\n\t\tirqs = this_cpu_ptr(s);\n\n\t\tts = __irq_timings_next_event(irqs, i, now);\n\t\tif (ts <= now)\n\t\t\treturn now;\n\n\t\tif (ts < next_evt)\n\t\t\tnext_evt = ts;\n\t}\n\n\treturn next_evt;\n}"
  },
  {
    "function_name": "irq_timings_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "473-508",
    "snippet": "static inline void irq_timings_store(int irq, struct irqt_stat *irqs, u64 ts)\n{\n\tu64 old_ts = irqs->last_ts;\n\tu64 interval;\n\n\t/*\n\t * The timestamps are absolute time values, we need to compute\n\t * the timing interval between two interrupts.\n\t */\n\tirqs->last_ts = ts;\n\n\t/*\n\t * The interval type is u64 in order to deal with the same\n\t * type in our computation, that prevent mindfuck issues with\n\t * overflow, sign and division.\n\t */\n\tinterval = ts - old_ts;\n\n\t/*\n\t * The interrupt triggered more than one second apart, that\n\t * ends the sequence as predictable for our purpose. In this\n\t * case, assume we have the beginning of a sequence and the\n\t * timestamp is the first value. As it is impossible to\n\t * predict anything at this point, return.\n\t *\n\t * Note the first timestamp of the sequence will always fall\n\t * in this test because the old_ts is zero. That is what we\n\t * want as we need another timestamp to compute an interval.\n\t */\n\tif (interval >= NSEC_PER_SEC) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t__irq_timings_store(irq, irqs, interval);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_timings_store",
          "args": [
            "irq",
            "irqs",
            "interval"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_timings_store",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "446-471",
          "snippet": "static __always_inline void __irq_timings_store(int irq, struct irqt_stat *irqs,\n\t\t\t\t\t\tu64 interval)\n{\n\tint index;\n\n\t/*\n\t * Get the index in the ema table for this interrupt.\n\t */\n\tindex = irq_timings_interval_index(interval);\n\n\tif (index > PREDICTION_BUFFER_SIZE - 1) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * Store the index as an element of the pattern in another\n\t * circular array.\n\t */\n\tirqs->circ_timings[irqs->count & IRQ_TIMINGS_MASK] = index;\n\n\tirqs->ema_time[index] = irq_timings_ema_new(interval,\n\t\t\t\t\t\t    irqs->ema_time[index]);\n\n\tirqs->count++;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREDICTION_BUFFER_SIZE\t16 /* slots for EMAs, hardly more than 16 */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_BUFFER_SIZE\t16 /* slots for EMAs, hardly more than 16 */\n\nstatic __always_inline void __irq_timings_store(int irq, struct irqt_stat *irqs,\n\t\t\t\t\t\tu64 interval)\n{\n\tint index;\n\n\t/*\n\t * Get the index in the ema table for this interrupt.\n\t */\n\tindex = irq_timings_interval_index(interval);\n\n\tif (index > PREDICTION_BUFFER_SIZE - 1) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * Store the index as an element of the pattern in another\n\t * circular array.\n\t */\n\tirqs->circ_timings[irqs->count & IRQ_TIMINGS_MASK] = index;\n\n\tirqs->ema_time[index] = irq_timings_ema_new(interval,\n\t\t\t\t\t\t    irqs->ema_time[index]);\n\n\tirqs->count++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nstatic inline void irq_timings_store(int irq, struct irqt_stat *irqs, u64 ts)\n{\n\tu64 old_ts = irqs->last_ts;\n\tu64 interval;\n\n\t/*\n\t * The timestamps are absolute time values, we need to compute\n\t * the timing interval between two interrupts.\n\t */\n\tirqs->last_ts = ts;\n\n\t/*\n\t * The interval type is u64 in order to deal with the same\n\t * type in our computation, that prevent mindfuck issues with\n\t * overflow, sign and division.\n\t */\n\tinterval = ts - old_ts;\n\n\t/*\n\t * The interrupt triggered more than one second apart, that\n\t * ends the sequence as predictable for our purpose. In this\n\t * case, assume we have the beginning of a sequence and the\n\t * timestamp is the first value. As it is impossible to\n\t * predict anything at this point, return.\n\t *\n\t * Note the first timestamp of the sequence will always fall\n\t * in this test because the old_ts is zero. That is what we\n\t * want as we need another timestamp to compute an interval.\n\t */\n\tif (interval >= NSEC_PER_SEC) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t__irq_timings_store(irq, irqs, interval);\n}"
  },
  {
    "function_name": "__irq_timings_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "446-471",
    "snippet": "static __always_inline void __irq_timings_store(int irq, struct irqt_stat *irqs,\n\t\t\t\t\t\tu64 interval)\n{\n\tint index;\n\n\t/*\n\t * Get the index in the ema table for this interrupt.\n\t */\n\tindex = irq_timings_interval_index(interval);\n\n\tif (index > PREDICTION_BUFFER_SIZE - 1) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * Store the index as an element of the pattern in another\n\t * circular array.\n\t */\n\tirqs->circ_timings[irqs->count & IRQ_TIMINGS_MASK] = index;\n\n\tirqs->ema_time[index] = irq_timings_ema_new(interval,\n\t\t\t\t\t\t    irqs->ema_time[index]);\n\n\tirqs->count++;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PREDICTION_BUFFER_SIZE\t16 /* slots for EMAs, hardly more than 16 */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_timings_ema_new",
          "args": [
            "interval",
            "irqs->ema_time[index]"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_ema_new",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "300-315",
          "snippet": "static u64 irq_timings_ema_new(u64 value, u64 ema_old)\n{\n\ts64 diff;\n\n\tif (unlikely(!ema_old))\n\t\treturn value;\n\n\tdiff = (value - ema_old) * EMA_ALPHA_VAL;\n\t/*\n\t * We can use a s64 type variable to be added with the u64\n\t * ema_old variable as this one will never have its topmost\n\t * bit set, it will be always smaller than 2^63 nanosec\n\t * interrupt interval (292 years).\n\t */\n\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define EMA_ALPHA_SHIFT\t\t7",
            "#define EMA_ALPHA_VAL\t\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define EMA_ALPHA_SHIFT\t\t7\n#define EMA_ALPHA_VAL\t\t64\n\nstatic u64 irq_timings_ema_new(u64 value, u64 ema_old)\n{\n\ts64 diff;\n\n\tif (unlikely(!ema_old))\n\t\treturn value;\n\n\tdiff = (value - ema_old) * EMA_ALPHA_VAL;\n\t/*\n\t * We can use a s64 type variable to be added with the u64\n\t * ema_old variable as this one will never have its topmost\n\t * bit set, it will be always smaller than 2^63 nanosec\n\t * interrupt interval (292 years).\n\t */\n\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_timings_interval_index",
          "args": [
            "interval"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_interval_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "435-444",
          "snippet": "static __always_inline int irq_timings_interval_index(u64 interval)\n{\n\t/*\n\t * The PREDICTION_FACTOR increase the interval size for the\n\t * array of exponential average.\n\t */\n\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;\n\n\treturn likely(interval_us) ? ilog2(interval_us) : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREDICTION_FACTOR\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_FACTOR\t4\n\nstatic __always_inline int irq_timings_interval_index(u64 interval)\n{\n\t/*\n\t * The PREDICTION_FACTOR increase the interval size for the\n\t * array of exponential average.\n\t */\n\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;\n\n\treturn likely(interval_us) ? ilog2(interval_us) : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_BUFFER_SIZE\t16 /* slots for EMAs, hardly more than 16 */\n\nstatic __always_inline void __irq_timings_store(int irq, struct irqt_stat *irqs,\n\t\t\t\t\t\tu64 interval)\n{\n\tint index;\n\n\t/*\n\t * Get the index in the ema table for this interrupt.\n\t */\n\tindex = irq_timings_interval_index(interval);\n\n\tif (index > PREDICTION_BUFFER_SIZE - 1) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * Store the index as an element of the pattern in another\n\t * circular array.\n\t */\n\tirqs->circ_timings[irqs->count & IRQ_TIMINGS_MASK] = index;\n\n\tirqs->ema_time[index] = irq_timings_ema_new(interval,\n\t\t\t\t\t\t    irqs->ema_time[index]);\n\n\tirqs->count++;\n}"
  },
  {
    "function_name": "irq_timings_interval_index",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "435-444",
    "snippet": "static __always_inline int irq_timings_interval_index(u64 interval)\n{\n\t/*\n\t * The PREDICTION_FACTOR increase the interval size for the\n\t * array of exponential average.\n\t */\n\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;\n\n\treturn likely(interval_us) ? ilog2(interval_us) : 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PREDICTION_FACTOR\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "interval_us"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "interval_us"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_FACTOR\t4\n\nstatic __always_inline int irq_timings_interval_index(u64 interval)\n{\n\t/*\n\t * The PREDICTION_FACTOR increase the interval size for the\n\t * array of exponential average.\n\t */\n\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;\n\n\treturn likely(interval_us) ? ilog2(interval_us) : 0;\n}"
  },
  {
    "function_name": "__irq_timings_next_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "382-433",
    "snippet": "static u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)\n{\n\tint index, i, period_max, count, start, min = INT_MAX;\n\n\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {\n\t\tirqs->count = irqs->last_ts = 0;\n\t\treturn U64_MAX;\n\t}\n\n\t/*\n\t * As we want to find three times the repetition, we need a\n\t * number of intervals greater or equal to three times the\n\t * maximum period, otherwise we truncate the max period.\n\t */\n\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?\n\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;\n\n\t/*\n\t * If we don't have enough irq timings for this prediction,\n\t * just bail out.\n\t */\n\tif (period_max <= PREDICTION_PERIOD_MIN)\n\t\treturn U64_MAX;\n\n\t/*\n\t * 'count' will depends if the circular buffer wrapped or not\n\t */\n\tcount = irqs->count < IRQ_TIMINGS_SIZE ?\n\t\tirqs->count : IRQ_TIMINGS_SIZE;\n\n\tstart = irqs->count < IRQ_TIMINGS_SIZE ?\n\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);\n\n\t/*\n\t * Copy the content of the circular buffer into another buffer\n\t * in order to linearize the buffer instead of dealing with\n\t * wrapping indexes and shifted array which will be prone to\n\t * error and extremely difficult to debug.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tint index = (start + i) & IRQ_TIMINGS_MASK;\n\n\t\tirqs->timings[i] = irqs->circ_timings[index];\n\t\tmin = min_t(int, irqs->timings[i], min);\n\t}\n\n\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);\n\tif (index < 0)\n\t\treturn irqs->last_ts + irqs->ema_time[min];\n\n\treturn irqs->last_ts + irqs->ema_time[index];\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PREDICTION_PERIOD_MAX\t5",
      "#define PREDICTION_PERIOD_MIN\t3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_timings_next_event_index",
          "args": [
            "irqs->timings",
            "count",
            "period_max"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "irq_timings_next_event_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
          "lines": "317-380",
          "snippet": "static int irq_timings_next_event_index(int *buffer, size_t len, int period_max)\n{\n\tint period;\n\n\t/*\n\t * Move the beginning pointer to the end minus the max period x 3.\n\t * We are at the point we can begin searching the pattern\n\t */\n\tbuffer = &buffer[len - (period_max * 3)];\n\n\t/* Adjust the length to the maximum allowed period x 3 */\n\tlen = period_max * 3;\n\n\t/*\n\t * The buffer contains the suite of intervals, in a ilog2\n\t * basis, we are looking for a repetition. We point the\n\t * beginning of the search three times the length of the\n\t * period beginning at the end of the buffer. We do that for\n\t * each suffix.\n\t */\n\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {\n\n\t\t/*\n\t\t * The first comparison always succeed because the\n\t\t * suffix is deduced from the first n-period bytes of\n\t\t * the buffer and we compare the initial suffix with\n\t\t * itself, so we can skip the first iteration.\n\t\t */\n\t\tint idx = period;\n\t\tsize_t size = period;\n\n\t\t/*\n\t\t * We look if the suite with period 'i' repeat\n\t\t * itself. If it is truncated at the end, as it\n\t\t * repeats we can use the period to find out the next\n\t\t * element with the modulo.\n\t\t */\n\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {\n\n\t\t\t/*\n\t\t\t * Move the index in a period basis\n\t\t\t */\n\t\t\tidx += size;\n\n\t\t\t/*\n\t\t\t * If this condition is reached, all previous\n\t\t\t * memcmp were successful, so the period is\n\t\t\t * found.\n\t\t\t */\n\t\t\tif (idx == len)\n\t\t\t\treturn buffer[len % period];\n\n\t\t\t/*\n\t\t\t * If the remaining elements to compare are\n\t\t\t * smaller than the period, readjust the size\n\t\t\t * of the comparison for the last iteration.\n\t\t\t */\n\t\t\tif (len - idx < period)\n\t\t\t\tsize = len - idx;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/log2.h>",
            "#include <linux/math64.h>",
            "#include <linux/irq.h>",
            "#include <linux/idr.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/static_key.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PREDICTION_PERIOD_MIN\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_PERIOD_MIN\t3\n\nstatic int irq_timings_next_event_index(int *buffer, size_t len, int period_max)\n{\n\tint period;\n\n\t/*\n\t * Move the beginning pointer to the end minus the max period x 3.\n\t * We are at the point we can begin searching the pattern\n\t */\n\tbuffer = &buffer[len - (period_max * 3)];\n\n\t/* Adjust the length to the maximum allowed period x 3 */\n\tlen = period_max * 3;\n\n\t/*\n\t * The buffer contains the suite of intervals, in a ilog2\n\t * basis, we are looking for a repetition. We point the\n\t * beginning of the search three times the length of the\n\t * period beginning at the end of the buffer. We do that for\n\t * each suffix.\n\t */\n\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {\n\n\t\t/*\n\t\t * The first comparison always succeed because the\n\t\t * suffix is deduced from the first n-period bytes of\n\t\t * the buffer and we compare the initial suffix with\n\t\t * itself, so we can skip the first iteration.\n\t\t */\n\t\tint idx = period;\n\t\tsize_t size = period;\n\n\t\t/*\n\t\t * We look if the suite with period 'i' repeat\n\t\t * itself. If it is truncated at the end, as it\n\t\t * repeats we can use the period to find out the next\n\t\t * element with the modulo.\n\t\t */\n\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {\n\n\t\t\t/*\n\t\t\t * Move the index in a period basis\n\t\t\t */\n\t\t\tidx += size;\n\n\t\t\t/*\n\t\t\t * If this condition is reached, all previous\n\t\t\t * memcmp were successful, so the period is\n\t\t\t * found.\n\t\t\t */\n\t\t\tif (idx == len)\n\t\t\t\treturn buffer[len % period];\n\n\t\t\t/*\n\t\t\t * If the remaining elements to compare are\n\t\t\t * smaller than the period, readjust the size\n\t\t\t * of the comparison for the last iteration.\n\t\t\t */\n\t\t\tif (len - idx < period)\n\t\t\t\tsize = len - idx;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "irqs->timings[i]",
            "min"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_PERIOD_MAX\t5\n#define PREDICTION_PERIOD_MIN\t3\n\nstatic u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)\n{\n\tint index, i, period_max, count, start, min = INT_MAX;\n\n\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {\n\t\tirqs->count = irqs->last_ts = 0;\n\t\treturn U64_MAX;\n\t}\n\n\t/*\n\t * As we want to find three times the repetition, we need a\n\t * number of intervals greater or equal to three times the\n\t * maximum period, otherwise we truncate the max period.\n\t */\n\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?\n\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;\n\n\t/*\n\t * If we don't have enough irq timings for this prediction,\n\t * just bail out.\n\t */\n\tif (period_max <= PREDICTION_PERIOD_MIN)\n\t\treturn U64_MAX;\n\n\t/*\n\t * 'count' will depends if the circular buffer wrapped or not\n\t */\n\tcount = irqs->count < IRQ_TIMINGS_SIZE ?\n\t\tirqs->count : IRQ_TIMINGS_SIZE;\n\n\tstart = irqs->count < IRQ_TIMINGS_SIZE ?\n\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);\n\n\t/*\n\t * Copy the content of the circular buffer into another buffer\n\t * in order to linearize the buffer instead of dealing with\n\t * wrapping indexes and shifted array which will be prone to\n\t * error and extremely difficult to debug.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tint index = (start + i) & IRQ_TIMINGS_MASK;\n\n\t\tirqs->timings[i] = irqs->circ_timings[index];\n\t\tmin = min_t(int, irqs->timings[i], min);\n\t}\n\n\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);\n\tif (index < 0)\n\t\treturn irqs->last_ts + irqs->ema_time[min];\n\n\treturn irqs->last_ts + irqs->ema_time[index];\n}"
  },
  {
    "function_name": "irq_timings_next_event_index",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "317-380",
    "snippet": "static int irq_timings_next_event_index(int *buffer, size_t len, int period_max)\n{\n\tint period;\n\n\t/*\n\t * Move the beginning pointer to the end minus the max period x 3.\n\t * We are at the point we can begin searching the pattern\n\t */\n\tbuffer = &buffer[len - (period_max * 3)];\n\n\t/* Adjust the length to the maximum allowed period x 3 */\n\tlen = period_max * 3;\n\n\t/*\n\t * The buffer contains the suite of intervals, in a ilog2\n\t * basis, we are looking for a repetition. We point the\n\t * beginning of the search three times the length of the\n\t * period beginning at the end of the buffer. We do that for\n\t * each suffix.\n\t */\n\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {\n\n\t\t/*\n\t\t * The first comparison always succeed because the\n\t\t * suffix is deduced from the first n-period bytes of\n\t\t * the buffer and we compare the initial suffix with\n\t\t * itself, so we can skip the first iteration.\n\t\t */\n\t\tint idx = period;\n\t\tsize_t size = period;\n\n\t\t/*\n\t\t * We look if the suite with period 'i' repeat\n\t\t * itself. If it is truncated at the end, as it\n\t\t * repeats we can use the period to find out the next\n\t\t * element with the modulo.\n\t\t */\n\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {\n\n\t\t\t/*\n\t\t\t * Move the index in a period basis\n\t\t\t */\n\t\t\tidx += size;\n\n\t\t\t/*\n\t\t\t * If this condition is reached, all previous\n\t\t\t * memcmp were successful, so the period is\n\t\t\t * found.\n\t\t\t */\n\t\t\tif (idx == len)\n\t\t\t\treturn buffer[len % period];\n\n\t\t\t/*\n\t\t\t * If the remaining elements to compare are\n\t\t\t * smaller than the period, readjust the size\n\t\t\t * of the comparison for the last iteration.\n\t\t\t */\n\t\t\tif (len - idx < period)\n\t\t\t\tsize = len - idx;\n\t\t}\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PREDICTION_PERIOD_MIN\t3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "&buffer[idx]",
            "size * sizeof(int)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define PREDICTION_PERIOD_MIN\t3\n\nstatic int irq_timings_next_event_index(int *buffer, size_t len, int period_max)\n{\n\tint period;\n\n\t/*\n\t * Move the beginning pointer to the end minus the max period x 3.\n\t * We are at the point we can begin searching the pattern\n\t */\n\tbuffer = &buffer[len - (period_max * 3)];\n\n\t/* Adjust the length to the maximum allowed period x 3 */\n\tlen = period_max * 3;\n\n\t/*\n\t * The buffer contains the suite of intervals, in a ilog2\n\t * basis, we are looking for a repetition. We point the\n\t * beginning of the search three times the length of the\n\t * period beginning at the end of the buffer. We do that for\n\t * each suffix.\n\t */\n\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {\n\n\t\t/*\n\t\t * The first comparison always succeed because the\n\t\t * suffix is deduced from the first n-period bytes of\n\t\t * the buffer and we compare the initial suffix with\n\t\t * itself, so we can skip the first iteration.\n\t\t */\n\t\tint idx = period;\n\t\tsize_t size = period;\n\n\t\t/*\n\t\t * We look if the suite with period 'i' repeat\n\t\t * itself. If it is truncated at the end, as it\n\t\t * repeats we can use the period to find out the next\n\t\t * element with the modulo.\n\t\t */\n\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {\n\n\t\t\t/*\n\t\t\t * Move the index in a period basis\n\t\t\t */\n\t\t\tidx += size;\n\n\t\t\t/*\n\t\t\t * If this condition is reached, all previous\n\t\t\t * memcmp were successful, so the period is\n\t\t\t * found.\n\t\t\t */\n\t\t\tif (idx == len)\n\t\t\t\treturn buffer[len % period];\n\n\t\t\t/*\n\t\t\t * If the remaining elements to compare are\n\t\t\t * smaller than the period, readjust the size\n\t\t\t * of the comparison for the last iteration.\n\t\t\t */\n\t\t\tif (len - idx < period)\n\t\t\t\tsize = len - idx;\n\t\t}\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "irq_timings_ema_new",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "300-315",
    "snippet": "static u64 irq_timings_ema_new(u64 value, u64 ema_old)\n{\n\ts64 diff;\n\n\tif (unlikely(!ema_old))\n\t\treturn value;\n\n\tdiff = (value - ema_old) * EMA_ALPHA_VAL;\n\t/*\n\t * We can use a s64 type variable to be added with the u64\n\t * ema_old variable as this one will never have its topmost\n\t * bit set, it will be always smaller than 2^63 nanosec\n\t * interrupt interval (292 years).\n\t */\n\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define EMA_ALPHA_SHIFT\t\t7",
      "#define EMA_ALPHA_VAL\t\t64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ema_old"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\n#define EMA_ALPHA_SHIFT\t\t7\n#define EMA_ALPHA_VAL\t\t64\n\nstatic u64 irq_timings_ema_new(u64 value, u64 ema_old)\n{\n\ts64 diff;\n\n\tif (unlikely(!ema_old))\n\t\treturn value;\n\n\tdiff = (value - ema_old) * EMA_ALPHA_VAL;\n\t/*\n\t * We can use a s64 type variable to be added with the u64\n\t * ema_old variable as this one will never have its topmost\n\t * bit set, it will be always smaller than 2^63 nanosec\n\t * interrupt interval (292 years).\n\t */\n\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);\n}"
  },
  {
    "function_name": "irq_timings_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "31-34",
    "snippet": "void irq_timings_disable(void)\n{\n\tstatic_branch_disable(&irq_timing_enabled);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&irq_timing_enabled"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nvoid irq_timings_disable(void)\n{\n\tstatic_branch_disable(&irq_timing_enabled);\n}"
  },
  {
    "function_name": "irq_timings_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/timings.c",
    "lines": "26-29",
    "snippet": "void irq_timings_enable(void)\n{\n\tstatic_branch_enable(&irq_timing_enabled);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <trace/events/irq.h>",
      "#include <linux/log2.h>",
      "#include <linux/math64.h>",
      "#include <linux/irq.h>",
      "#include <linux/idr.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/static_key.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&irq_timing_enabled"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/irq.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/static_key.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/kernel.h>\n\nvoid irq_timings_enable(void)\n{\n\tstatic_branch_enable(&irq_timing_enabled);\n}"
  }
]