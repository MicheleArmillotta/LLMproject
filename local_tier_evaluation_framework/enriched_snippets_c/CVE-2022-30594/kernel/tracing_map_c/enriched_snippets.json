[
  {
    "function_name": "tracing_map_sort_entries",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "1069-1134",
    "snippet": "int tracing_map_sort_entries(struct tracing_map *map,\n\t\t\t     struct tracing_map_sort_key *sort_keys,\n\t\t\t     unsigned int n_sort_keys,\n\t\t\t     struct tracing_map_sort_entry ***sort_entries)\n{\n\tint (*cmp_entries_fn)(const void *, const void *);\n\tstruct tracing_map_sort_entry *sort_entry, **entries;\n\tint i, n_entries, ret;\n\n\tentries = vmalloc(array_size(sizeof(sort_entry), map->max_elts));\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, n_entries = 0; i < map->map_size; i++) {\n\t\tstruct tracing_map_entry *entry;\n\n\t\tentry = TRACING_MAP_ENTRY(map->map, i);\n\n\t\tif (!entry->key || !entry->val)\n\t\t\tcontinue;\n\n\t\tentries[n_entries] = create_sort_entry(entry->val->key,\n\t\t\t\t\t\t       entry->val);\n\t\tif (!entries[n_entries++]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (n_entries == 0) {\n\t\tret = 0;\n\t\tgoto free;\n\t}\n\n\tif (n_entries == 1) {\n\t\t*sort_entries = entries;\n\t\treturn 1;\n\t}\n\n\tdetect_dups(entries, n_entries, map->key_size);\n\n\tif (is_key(map, sort_keys[0].field_idx))\n\t\tcmp_entries_fn = cmp_entries_key;\n\telse\n\t\tcmp_entries_fn = cmp_entries_sum;\n\n\tset_sort_key(map, &sort_keys[0]);\n\n\tsort(entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_fn, NULL);\n\n\tif (n_sort_keys > 1)\n\t\tsort_secondary(map,\n\t\t\t       (const struct tracing_map_sort_entry **)entries,\n\t\t\t       n_entries,\n\t\t\t       &sort_keys[0],\n\t\t\t       &sort_keys[1]);\n\n\t*sort_entries = entries;\n\n\treturn n_entries;\n free:\n\ttracing_map_destroy_sort_entries(entries, n_entries);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_destroy_sort_entries",
          "args": [
            "entries",
            "n_entries"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_destroy_sort_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "935-944",
          "snippet": "void tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort_secondary",
          "args": [
            "map",
            "(const struct tracing_map_sort_entry **)entries",
            "n_entries",
            "&sort_keys[0]",
            "&sort_keys[1]"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sort_key",
          "args": [
            "map",
            "&sort_keys[0]"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "set_sort_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "707-711",
          "snippet": "static void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_key",
          "args": [
            "map",
            "sort_keys[0].field_idx"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "is_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "988-996",
          "snippet": "static bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_dups",
          "args": [
            "entries",
            "n_entries",
            "map->key_size"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "detect_dups",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "961-986",
          "snippet": "static void detect_dups(struct tracing_map_sort_entry **sort_entries,\n\t\t      int n_entries, unsigned int key_size)\n{\n\tunsigned int dups = 0, total_dups = 0;\n\tint i;\n\tvoid *key;\n\n\tif (n_entries < 2)\n\t\treturn;\n\n\tsort(sort_entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_dup, NULL);\n\n\tkey = sort_entries[0]->key;\n\tfor (i = 1; i < n_entries; i++) {\n\t\tif (!memcmp(sort_entries[i]->key, key, key_size)) {\n\t\t\tdups++; total_dups++;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = sort_entries[i]->key;\n\t\tdups = 0;\n\t}\n\n\tWARN_ONCE(total_dups > 0,\n\t\t  \"Duplicates detected: %d\\n\", total_dups);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void detect_dups(struct tracing_map_sort_entry **sort_entries,\n\t\t      int n_entries, unsigned int key_size)\n{\n\tunsigned int dups = 0, total_dups = 0;\n\tint i;\n\tvoid *key;\n\n\tif (n_entries < 2)\n\t\treturn;\n\n\tsort(sort_entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_dup, NULL);\n\n\tkey = sort_entries[0]->key;\n\tfor (i = 1; i < n_entries; i++) {\n\t\tif (!memcmp(sort_entries[i]->key, key, key_size)) {\n\t\t\tdups++; total_dups++;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = sort_entries[i]->key;\n\t\tdups = 0;\n\t}\n\n\tWARN_ONCE(total_dups > 0,\n\t\t  \"Duplicates detected: %d\\n\", total_dups);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_sort_entry",
          "args": [
            "entry->val->key",
            "entry->val"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "create_sort_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "946-959",
          "snippet": "static struct tracing_map_sort_entry *\ncreate_sort_entry(void *key, struct tracing_map_elt *elt)\n{\n\tstruct tracing_map_sort_entry *sort_entry;\n\n\tsort_entry = kzalloc(sizeof(*sort_entry), GFP_KERNEL);\n\tif (!sort_entry)\n\t\treturn NULL;\n\n\tsort_entry->key = key;\n\tsort_entry->elt = elt;\n\n\treturn sort_entry;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_sort_entry *\ncreate_sort_entry(void *key, struct tracing_map_elt *elt)\n{\n\tstruct tracing_map_sort_entry *sort_entry;\n\n\tsort_entry = kzalloc(sizeof(*sort_entry), GFP_KERNEL);\n\tif (!sort_entry)\n\t\treturn NULL;\n\n\tsort_entry->key = key;\n\tsort_entry->elt = elt;\n\n\treturn sort_entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ENTRY",
          "args": [
            "map->map",
            "i"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "array_size(sizeof(sort_entry), map->max_elts)"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "array_map_vmalloc_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "379-382",
          "snippet": "static void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "sizeof(sort_entry)",
            "map->max_elts"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_sort_entries(struct tracing_map *map,\n\t\t\t     struct tracing_map_sort_key *sort_keys,\n\t\t\t     unsigned int n_sort_keys,\n\t\t\t     struct tracing_map_sort_entry ***sort_entries)\n{\n\tint (*cmp_entries_fn)(const void *, const void *);\n\tstruct tracing_map_sort_entry *sort_entry, **entries;\n\tint i, n_entries, ret;\n\n\tentries = vmalloc(array_size(sizeof(sort_entry), map->max_elts));\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, n_entries = 0; i < map->map_size; i++) {\n\t\tstruct tracing_map_entry *entry;\n\n\t\tentry = TRACING_MAP_ENTRY(map->map, i);\n\n\t\tif (!entry->key || !entry->val)\n\t\t\tcontinue;\n\n\t\tentries[n_entries] = create_sort_entry(entry->val->key,\n\t\t\t\t\t\t       entry->val);\n\t\tif (!entries[n_entries++]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (n_entries == 0) {\n\t\tret = 0;\n\t\tgoto free;\n\t}\n\n\tif (n_entries == 1) {\n\t\t*sort_entries = entries;\n\t\treturn 1;\n\t}\n\n\tdetect_dups(entries, n_entries, map->key_size);\n\n\tif (is_key(map, sort_keys[0].field_idx))\n\t\tcmp_entries_fn = cmp_entries_key;\n\telse\n\t\tcmp_entries_fn = cmp_entries_sum;\n\n\tset_sort_key(map, &sort_keys[0]);\n\n\tsort(entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_fn, NULL);\n\n\tif (n_sort_keys > 1)\n\t\tsort_secondary(map,\n\t\t\t       (const struct tracing_map_sort_entry **)entries,\n\t\t\t       n_entries,\n\t\t\t       &sort_keys[0],\n\t\t\t       &sort_keys[1]);\n\n\t*sort_entries = entries;\n\n\treturn n_entries;\n free:\n\ttracing_map_destroy_sort_entries(entries, n_entries);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sort_secondary",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "998-1043",
    "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_sort_key",
          "args": [
            "map",
            "primary_key"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "set_sort_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "707-711",
          "snippet": "static void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "&entries[start]",
            "n_sub",
            "sizeof(struct tracing_map_sort_entry *)",
            "(int (*)(const void *, const void *))secondary_fn",
            "NULL"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "primary_fn",
          "args": [
            "a",
            "b"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_key",
          "args": [
            "map",
            "secondary_key->field_idx"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "is_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "988-996",
          "snippet": "static bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
  },
  {
    "function_name": "is_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "988-996",
    "snippet": "static bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "detect_dups",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "961-986",
    "snippet": "static void detect_dups(struct tracing_map_sort_entry **sort_entries,\n\t\t      int n_entries, unsigned int key_size)\n{\n\tunsigned int dups = 0, total_dups = 0;\n\tint i;\n\tvoid *key;\n\n\tif (n_entries < 2)\n\t\treturn;\n\n\tsort(sort_entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_dup, NULL);\n\n\tkey = sort_entries[0]->key;\n\tfor (i = 1; i < n_entries; i++) {\n\t\tif (!memcmp(sort_entries[i]->key, key, key_size)) {\n\t\t\tdups++; total_dups++;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = sort_entries[i]->key;\n\t\tdups = 0;\n\t}\n\n\tWARN_ONCE(total_dups > 0,\n\t\t  \"Duplicates detected: %d\\n\", total_dups);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "total_dups > 0",
            "\"Duplicates detected: %d\\n\"",
            "total_dups"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sort_entries[i]->key",
            "key",
            "key_size"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "sort_entries",
            "n_entries",
            "sizeof(struct tracing_map_sort_entry *)",
            "(int (*)(const void *, const void *))cmp_entries_dup",
            "NULL"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void detect_dups(struct tracing_map_sort_entry **sort_entries,\n\t\t      int n_entries, unsigned int key_size)\n{\n\tunsigned int dups = 0, total_dups = 0;\n\tint i;\n\tvoid *key;\n\n\tif (n_entries < 2)\n\t\treturn;\n\n\tsort(sort_entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_dup, NULL);\n\n\tkey = sort_entries[0]->key;\n\tfor (i = 1; i < n_entries; i++) {\n\t\tif (!memcmp(sort_entries[i]->key, key, key_size)) {\n\t\t\tdups++; total_dups++;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = sort_entries[i]->key;\n\t\tdups = 0;\n\t}\n\n\tWARN_ONCE(total_dups > 0,\n\t\t  \"Duplicates detected: %d\\n\", total_dups);\n}"
  },
  {
    "function_name": "create_sort_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "946-959",
    "snippet": "static struct tracing_map_sort_entry *\ncreate_sort_entry(void *key, struct tracing_map_elt *elt)\n{\n\tstruct tracing_map_sort_entry *sort_entry;\n\n\tsort_entry = kzalloc(sizeof(*sort_entry), GFP_KERNEL);\n\tif (!sort_entry)\n\t\treturn NULL;\n\n\tsort_entry->key = key;\n\tsort_entry->elt = elt;\n\n\treturn sort_entry;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sort_entry)",
            "GFP_KERNEL"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_sort_entry *\ncreate_sort_entry(void *key, struct tracing_map_elt *elt)\n{\n\tstruct tracing_map_sort_entry *sort_entry;\n\n\tsort_entry = kzalloc(sizeof(*sort_entry), GFP_KERNEL);\n\tif (!sort_entry)\n\t\treturn NULL;\n\n\tsort_entry->key = key;\n\tsort_entry->elt = elt;\n\n\treturn sort_entry;\n}"
  },
  {
    "function_name": "tracing_map_destroy_sort_entries",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "935-944",
    "snippet": "void tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "entries"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_sort_entry",
          "args": [
            "entries[i]"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_sort_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "917-926",
          "snippet": "static void destroy_sort_entry(struct tracing_map_sort_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tif (entry->elt_copied)\n\t\ttracing_map_elt_free(entry->elt);\n\n\tkfree(entry);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void destroy_sort_entry(struct tracing_map_sort_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tif (entry->elt_copied)\n\t\ttracing_map_elt_free(entry->elt);\n\n\tkfree(entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}"
  },
  {
    "function_name": "destroy_sort_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "917-926",
    "snippet": "static void destroy_sort_entry(struct tracing_map_sort_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tif (entry->elt_copied)\n\t\ttracing_map_elt_free(entry->elt);\n\n\tkfree(entry);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_elt_free",
          "args": [
            "entry->elt"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "389-401",
          "snippet": "static void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void destroy_sort_entry(struct tracing_map_sort_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tif (entry->elt_copied)\n\t\ttracing_map_elt_free(entry->elt);\n\n\tkfree(entry);\n}"
  },
  {
    "function_name": "cmp_entries_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "885-915",
    "snippet": "static int cmp_entries_key(const void *A, const void *B)\n{\n\tconst struct tracing_map_elt *elt_a, *elt_b;\n\tconst struct tracing_map_sort_entry *a, *b;\n\tstruct tracing_map_sort_key *sort_key;\n\tstruct tracing_map_field *field;\n\ttracing_map_cmp_fn_t cmp_fn;\n\tvoid *val_a, *val_b;\n\tint ret = 0;\n\n\ta = *(const struct tracing_map_sort_entry **)A;\n\tb = *(const struct tracing_map_sort_entry **)B;\n\n\telt_a = a->elt;\n\telt_b = b->elt;\n\n\tsort_key = &elt_a->map->sort_key;\n\n\tfield = &elt_a->fields[sort_key->field_idx];\n\n\tcmp_fn = field->cmp_fn;\n\n\tval_a = elt_a->key + field->offset;\n\tval_b = elt_b->key + field->offset;\n\n\tret = cmp_fn(val_a, val_b);\n\tif (sort_key->descending)\n\t\tret = -ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmp_fn",
          "args": [
            "val_a",
            "val_b"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int cmp_entries_key(const void *A, const void *B)\n{\n\tconst struct tracing_map_elt *elt_a, *elt_b;\n\tconst struct tracing_map_sort_entry *a, *b;\n\tstruct tracing_map_sort_key *sort_key;\n\tstruct tracing_map_field *field;\n\ttracing_map_cmp_fn_t cmp_fn;\n\tvoid *val_a, *val_b;\n\tint ret = 0;\n\n\ta = *(const struct tracing_map_sort_entry **)A;\n\tb = *(const struct tracing_map_sort_entry **)B;\n\n\telt_a = a->elt;\n\telt_b = b->elt;\n\n\tsort_key = &elt_a->map->sort_key;\n\n\tfield = &elt_a->fields[sort_key->field_idx];\n\n\tcmp_fn = field->cmp_fn;\n\n\tval_a = elt_a->key + field->offset;\n\tval_b = elt_b->key + field->offset;\n\n\tret = cmp_fn(val_a, val_b);\n\tif (sort_key->descending)\n\t\tret = -ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cmp_entries_sum",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "854-883",
    "snippet": "static int cmp_entries_sum(const void *A, const void *B)\n{\n\tconst struct tracing_map_elt *elt_a, *elt_b;\n\tconst struct tracing_map_sort_entry *a, *b;\n\tstruct tracing_map_sort_key *sort_key;\n\tstruct tracing_map_field *field;\n\ttracing_map_cmp_fn_t cmp_fn;\n\tvoid *val_a, *val_b;\n\tint ret = 0;\n\n\ta = *(const struct tracing_map_sort_entry **)A;\n\tb = *(const struct tracing_map_sort_entry **)B;\n\n\telt_a = a->elt;\n\telt_b = b->elt;\n\n\tsort_key = &elt_a->map->sort_key;\n\n\tfield = &elt_a->fields[sort_key->field_idx];\n\tcmp_fn = field->cmp_fn;\n\n\tval_a = &elt_a->fields[sort_key->field_idx].sum;\n\tval_b = &elt_b->fields[sort_key->field_idx].sum;\n\n\tret = cmp_fn(val_a, val_b);\n\tif (sort_key->descending)\n\t\tret = -ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmp_fn",
          "args": [
            "val_a",
            "val_b"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int cmp_entries_sum(const void *A, const void *B)\n{\n\tconst struct tracing_map_elt *elt_a, *elt_b;\n\tconst struct tracing_map_sort_entry *a, *b;\n\tstruct tracing_map_sort_key *sort_key;\n\tstruct tracing_map_field *field;\n\ttracing_map_cmp_fn_t cmp_fn;\n\tvoid *val_a, *val_b;\n\tint ret = 0;\n\n\ta = *(const struct tracing_map_sort_entry **)A;\n\tb = *(const struct tracing_map_sort_entry **)B;\n\n\telt_a = a->elt;\n\telt_b = b->elt;\n\n\tsort_key = &elt_a->map->sort_key;\n\n\tfield = &elt_a->fields[sort_key->field_idx];\n\tcmp_fn = field->cmp_fn;\n\n\tval_a = &elt_a->fields[sort_key->field_idx].sum;\n\tval_b = &elt_b->fields[sort_key->field_idx].sum;\n\n\tret = cmp_fn(val_a, val_b);\n\tif (sort_key->descending)\n\t\tret = -ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cmp_entries_dup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "840-852",
    "snippet": "static int cmp_entries_dup(const void *A, const void *B)\n{\n\tconst struct tracing_map_sort_entry *a, *b;\n\tint ret = 0;\n\n\ta = *(const struct tracing_map_sort_entry **)A;\n\tb = *(const struct tracing_map_sort_entry **)B;\n\n\tif (memcmp(a->key, b->key, a->elt->map->key_size))\n\t\tret = 1;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a->key",
            "b->key",
            "a->elt->map->key_size"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int cmp_entries_dup(const void *A, const void *B)\n{\n\tconst struct tracing_map_sort_entry *a, *b;\n\tint ret = 0;\n\n\ta = *(const struct tracing_map_sort_entry **)A;\n\tb = *(const struct tracing_map_sort_entry **)B;\n\n\tif (memcmp(a->key, b->key, a->elt->map->key_size))\n\t\tret = 1;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tracing_map_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "824-838",
    "snippet": "int tracing_map_init(struct tracing_map *map)\n{\n\tint err;\n\n\tif (map->n_fields < 2)\n\t\treturn -EINVAL; /* need at least 1 key and 1 val */\n\n\terr = tracing_map_alloc_elts(map);\n\tif (err)\n\t\treturn err;\n\n\ttracing_map_clear(map);\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_clear",
          "args": [
            "map"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "693-705",
          "snippet": "void tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_alloc_elts",
          "args": [
            "map"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_alloc_elts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "483-503",
          "snippet": "static int tracing_map_alloc_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tmap->elts = tracing_map_array_alloc(map->max_elts,\n\t\t\t\t\t    sizeof(struct tracing_map_elt *));\n\tif (!map->elts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = tracing_map_elt_alloc(map);\n\t\tif (IS_ERR(*(TRACING_MAP_ELT(map->elts, i)))) {\n\t\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t\t\ttracing_map_free_elts(map);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_alloc_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tmap->elts = tracing_map_array_alloc(map->max_elts,\n\t\t\t\t\t    sizeof(struct tracing_map_elt *));\n\tif (!map->elts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = tracing_map_elt_alloc(map);\n\t\tif (IS_ERR(*(TRACING_MAP_ELT(map->elts, i)))) {\n\t\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t\t\ttracing_map_free_elts(map);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_init(struct tracing_map *map)\n{\n\tint err;\n\n\tif (map->n_fields < 2)\n\t\treturn -EINVAL; /* need at least 1 key and 1 val */\n\n\terr = tracing_map_alloc_elts(map);\n\tif (err)\n\t\treturn err;\n\n\ttracing_map_clear(map);\n\n\treturn err;\n}"
  },
  {
    "function_name": "tracing_map_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "763-803",
    "snippet": "struct tracing_map *tracing_map_create(unsigned int map_bits,\n\t\t\t\t       unsigned int key_size,\n\t\t\t\t       const struct tracing_map_ops *ops,\n\t\t\t\t       void *private_data)\n{\n\tstruct tracing_map *map;\n\tunsigned int i;\n\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmap->map_bits = map_bits;\n\tmap->max_elts = (1 << map_bits);\n\tatomic_set(&map->next_elt, -1);\n\n\tmap->map_size = (1 << (map_bits + 1));\n\tmap->ops = ops;\n\n\tmap->private_data = private_data;\n\n\tmap->map = tracing_map_array_alloc(map->map_size,\n\t\t\t\t\t   sizeof(struct tracing_map_entry));\n\tif (!map->map)\n\t\tgoto free;\n\n\tmap->key_size = key_size;\n\tfor (i = 0; i < TRACING_MAP_KEYS_MAX; i++)\n\t\tmap->key_idx[i] = -1;\n out:\n\treturn map;\n free:\n\ttracing_map_destroy(map);\n\tmap = ERR_PTR(-ENOMEM);\n\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_destroy",
          "args": [
            "map"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_destroy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "671-680",
          "snippet": "void tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_array_alloc",
          "args": [
            "map->map_size",
            "sizeof(struct tracing_map_entry)"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "321-356",
          "snippet": "static struct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t\tkmemleak_alloc(a->pages[i], PAGE_SIZE, 1, GFP_KERNEL);\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t\tkmemleak_alloc(a->pages[i], PAGE_SIZE, 1, GFP_KERNEL);\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&map->next_elt",
            "-1"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*map)",
            "GFP_KERNEL"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map *tracing_map_create(unsigned int map_bits,\n\t\t\t\t       unsigned int key_size,\n\t\t\t\t       const struct tracing_map_ops *ops,\n\t\t\t\t       void *private_data)\n{\n\tstruct tracing_map *map;\n\tunsigned int i;\n\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmap->map_bits = map_bits;\n\tmap->max_elts = (1 << map_bits);\n\tatomic_set(&map->next_elt, -1);\n\n\tmap->map_size = (1 << (map_bits + 1));\n\tmap->ops = ops;\n\n\tmap->private_data = private_data;\n\n\tmap->map = tracing_map_array_alloc(map->map_size,\n\t\t\t\t\t   sizeof(struct tracing_map_entry));\n\tif (!map->map)\n\t\tgoto free;\n\n\tmap->key_size = key_size;\n\tfor (i = 0; i < TRACING_MAP_KEYS_MAX; i++)\n\t\tmap->key_idx[i] = -1;\n out:\n\treturn map;\n free:\n\ttracing_map_destroy(map);\n\tmap = ERR_PTR(-ENOMEM);\n\n\tgoto out;\n}"
  },
  {
    "function_name": "set_sort_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "707-711",
    "snippet": "static void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}"
  },
  {
    "function_name": "tracing_map_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "693-705",
    "snippet": "void tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_elt_clear",
          "args": [
            "*(TRACING_MAP_ELT(map->elts, i))"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "358-373",
          "snippet": "static void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_array_clear",
          "args": [
            "map->map"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "287-296",
          "snippet": "static void tracing_map_array_clear(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a->pages)\n\t\treturn;\n\n\tfor (i = 0; i < a->n_pages; i++)\n\t\tmemset(a->pages[i], 0, PAGE_SIZE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_array_clear(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a->pages)\n\t\treturn;\n\n\tfor (i = 0; i < a->n_pages; i++)\n\t\tmemset(a->pages[i], 0, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&map->drops",
            "0"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&map->hits",
            "0"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&map->next_elt",
            "-1"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}"
  },
  {
    "function_name": "tracing_map_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "671-680",
    "snippet": "void tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_array_free",
          "args": [
            "map->map"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "298-319",
          "snippet": "static void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tkmemleak_free(a->pages[i]);\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tkmemleak_free(a->pages[i]);\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_free_elts",
          "args": [
            "map"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_free_elts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "467-481",
          "snippet": "static void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}"
  },
  {
    "function_name": "tracing_map_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "656-659",
    "snippet": "struct tracing_map_elt *tracing_map_lookup(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, true);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tracing_map_insert",
          "args": [
            "map",
            "key",
            "true"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "__tracing_map_insert",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "515-595",
          "snippet": "static inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map_elt *tracing_map_lookup(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, true);\n}"
  },
  {
    "function_name": "tracing_map_insert",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "634-637",
    "snippet": "struct tracing_map_elt *tracing_map_insert(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, false);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tracing_map_insert",
          "args": [
            "map",
            "key",
            "false"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "__tracing_map_insert",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "515-595",
          "snippet": "static inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map_elt *tracing_map_insert(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, false);\n}"
  },
  {
    "function_name": "__tracing_map_insert",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "515-595",
    "snippet": "static inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->hits"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "elt->key",
            "key",
            "map->key_size"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->drops"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_free_elt",
          "args": [
            "map"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "get_free_elt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "452-465",
          "snippet": "static struct tracing_map_elt *get_free_elt(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt = NULL;\n\tint idx;\n\n\tidx = atomic_inc_return(&map->next_elt);\n\tif (idx < map->max_elts) {\n\t\telt = *(TRACING_MAP_ELT(map->elts, idx));\n\t\tif (map->ops && map->ops->elt_init)\n\t\t\tmap->ops->elt_init(elt);\n\t}\n\n\treturn elt;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_elt *get_free_elt(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt = NULL;\n\tint idx;\n\n\tidx = atomic_inc_return(&map->next_elt);\n\tif (idx < map->max_elts) {\n\t\telt = *(TRACING_MAP_ELT(map->elts, idx));\n\t\tif (map->ops && map->ops->elt_init)\n\t\t\tmap->ops->elt_init(elt);\n\t}\n\n\treturn elt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&entry->key",
            "0",
            "key_hash"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->drops"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!val"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->hits"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keys_match",
          "args": [
            "key",
            "val->key",
            "map->key_size"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "keys_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "505-513",
          "snippet": "static inline bool keys_match(void *key, void *test_key, unsigned key_size)\n{\n\tbool match = true;\n\n\tif (memcmp(key, test_key, key_size))\n\t\tmatch = false;\n\n\treturn match;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic inline bool keys_match(void *key, void *test_key, unsigned key_size)\n{\n\tbool match = true;\n\n\tif (memcmp(key, test_key, key_size))\n\t\tmatch = false;\n\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "entry->val"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ENTRY",
          "args": [
            "map->map",
            "idx"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "key",
            "map->key_size",
            "0"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t/*\n\t\t\t\t * The key is present. But, val (pointer to elt\n\t\t\t\t * struct) is still NULL. which means some other\n\t\t\t\t * thread is in the process of inserting an\n\t\t\t\t * element.\n\t\t\t\t *\n\t\t\t\t * On top of that, it's key_hash is same as the\n\t\t\t\t * one being inserted right now. So, it's\n\t\t\t\t * possible that the element has the same\n\t\t\t\t * key as well.\n\t\t\t\t */\n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * cmpxchg() failed. Loop around once\n\t\t\t\t * more to check what key was inserted.\n\t\t\t\t */\n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "keys_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "505-513",
    "snippet": "static inline bool keys_match(void *key, void *test_key, unsigned key_size)\n{\n\tbool match = true;\n\n\tif (memcmp(key, test_key, key_size))\n\t\tmatch = false;\n\n\treturn match;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "key",
            "test_key",
            "key_size"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic inline bool keys_match(void *key, void *test_key, unsigned key_size)\n{\n\tbool match = true;\n\n\tif (memcmp(key, test_key, key_size))\n\t\tmatch = false;\n\n\treturn match;\n}"
  },
  {
    "function_name": "tracing_map_alloc_elts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "483-503",
    "snippet": "static int tracing_map_alloc_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tmap->elts = tracing_map_array_alloc(map->max_elts,\n\t\t\t\t\t    sizeof(struct tracing_map_elt *));\n\tif (!map->elts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = tracing_map_elt_alloc(map);\n\t\tif (IS_ERR(*(TRACING_MAP_ELT(map->elts, i)))) {\n\t\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t\t\ttracing_map_free_elts(map);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_free_elts",
          "args": [
            "map"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_free_elts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "467-481",
          "snippet": "static void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*(TRACING_MAP_ELT(map->elts, i))"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_elt_alloc",
          "args": [
            "map"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "403-450",
          "snippet": "static struct tracing_map_elt *tracing_map_elt_alloc(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt;\n\tint err = 0;\n\n\telt = kzalloc(sizeof(*elt), GFP_KERNEL);\n\tif (!elt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\telt->map = map;\n\n\telt->key = kzalloc(map->key_size, GFP_KERNEL);\n\tif (!elt->key) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->fields = kcalloc(map->n_fields, sizeof(*elt->fields), GFP_KERNEL);\n\tif (!elt->fields) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->vars = kcalloc(map->n_vars, sizeof(*elt->vars), GFP_KERNEL);\n\tif (!elt->vars) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->var_set = kcalloc(map->n_vars, sizeof(*elt->var_set), GFP_KERNEL);\n\tif (!elt->var_set) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\ttracing_map_elt_init_fields(elt);\n\n\tif (map->ops && map->ops->elt_alloc) {\n\t\terr = map->ops->elt_alloc(elt);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\treturn elt;\n free:\n\ttracing_map_elt_free(elt);\n\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_elt *tracing_map_elt_alloc(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt;\n\tint err = 0;\n\n\telt = kzalloc(sizeof(*elt), GFP_KERNEL);\n\tif (!elt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\telt->map = map;\n\n\telt->key = kzalloc(map->key_size, GFP_KERNEL);\n\tif (!elt->key) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->fields = kcalloc(map->n_fields, sizeof(*elt->fields), GFP_KERNEL);\n\tif (!elt->fields) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->vars = kcalloc(map->n_vars, sizeof(*elt->vars), GFP_KERNEL);\n\tif (!elt->vars) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->var_set = kcalloc(map->n_vars, sizeof(*elt->var_set), GFP_KERNEL);\n\tif (!elt->var_set) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\ttracing_map_elt_init_fields(elt);\n\n\tif (map->ops && map->ops->elt_alloc) {\n\t\terr = map->ops->elt_alloc(elt);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\treturn elt;\n free:\n\ttracing_map_elt_free(elt);\n\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_array_alloc",
          "args": [
            "map->max_elts",
            "sizeof(struct tracing_map_elt *)"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "321-356",
          "snippet": "static struct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t\tkmemleak_alloc(a->pages[i], PAGE_SIZE, 1, GFP_KERNEL);\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t\tkmemleak_alloc(a->pages[i], PAGE_SIZE, 1, GFP_KERNEL);\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_alloc_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tmap->elts = tracing_map_array_alloc(map->max_elts,\n\t\t\t\t\t    sizeof(struct tracing_map_elt *));\n\tif (!map->elts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = tracing_map_elt_alloc(map);\n\t\tif (IS_ERR(*(TRACING_MAP_ELT(map->elts, i)))) {\n\t\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t\t\ttracing_map_free_elts(map);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tracing_map_free_elts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "467-481",
    "snippet": "static void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_array_free",
          "args": [
            "map->elts"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "298-319",
          "snippet": "static void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tkmemleak_free(a->pages[i]);\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tkmemleak_free(a->pages[i]);\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_elt_free",
          "args": [
            "*(TRACING_MAP_ELT(map->elts, i))"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "389-401",
          "snippet": "static void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "i"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}"
  },
  {
    "function_name": "get_free_elt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "452-465",
    "snippet": "static struct tracing_map_elt *get_free_elt(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt = NULL;\n\tint idx;\n\n\tidx = atomic_inc_return(&map->next_elt);\n\tif (idx < map->max_elts) {\n\t\telt = *(TRACING_MAP_ELT(map->elts, idx));\n\t\tif (map->ops && map->ops->elt_init)\n\t\t\tmap->ops->elt_init(elt);\n\t}\n\n\treturn elt;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->elt_init",
          "args": [
            "elt"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACING_MAP_ELT",
          "args": [
            "map->elts",
            "idx"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&map->next_elt"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_elt *get_free_elt(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt = NULL;\n\tint idx;\n\n\tidx = atomic_inc_return(&map->next_elt);\n\tif (idx < map->max_elts) {\n\t\telt = *(TRACING_MAP_ELT(map->elts, idx));\n\t\tif (map->ops && map->ops->elt_init)\n\t\t\tmap->ops->elt_init(elt);\n\t}\n\n\treturn elt;\n}"
  },
  {
    "function_name": "tracing_map_elt_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "403-450",
    "snippet": "static struct tracing_map_elt *tracing_map_elt_alloc(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt;\n\tint err = 0;\n\n\telt = kzalloc(sizeof(*elt), GFP_KERNEL);\n\tif (!elt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\telt->map = map;\n\n\telt->key = kzalloc(map->key_size, GFP_KERNEL);\n\tif (!elt->key) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->fields = kcalloc(map->n_fields, sizeof(*elt->fields), GFP_KERNEL);\n\tif (!elt->fields) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->vars = kcalloc(map->n_vars, sizeof(*elt->vars), GFP_KERNEL);\n\tif (!elt->vars) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->var_set = kcalloc(map->n_vars, sizeof(*elt->var_set), GFP_KERNEL);\n\tif (!elt->var_set) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\ttracing_map_elt_init_fields(elt);\n\n\tif (map->ops && map->ops->elt_alloc) {\n\t\terr = map->ops->elt_alloc(elt);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\treturn elt;\n free:\n\ttracing_map_elt_free(elt);\n\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_elt_free",
          "args": [
            "elt"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "389-401",
          "snippet": "static void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->elt_alloc",
          "args": [
            "elt"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_elt_init_fields",
          "args": [
            "elt"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_init_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "375-387",
          "snippet": "static void tracing_map_elt_init_fields(struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\ttracing_map_elt_clear(elt);\n\n\tfor (i = 0; i < elt->map->n_fields; i++) {\n\t\telt->fields[i].cmp_fn = elt->map->fields[i].cmp_fn;\n\n\t\tif (elt->fields[i].cmp_fn != tracing_map_cmp_atomic64)\n\t\t\telt->fields[i].offset = elt->map->fields[i].offset;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_init_fields(struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\ttracing_map_elt_clear(elt);\n\n\tfor (i = 0; i < elt->map->n_fields; i++) {\n\t\telt->fields[i].cmp_fn = elt->map->fields[i].cmp_fn;\n\n\t\tif (elt->fields[i].cmp_fn != tracing_map_cmp_atomic64)\n\t\t\telt->fields[i].offset = elt->map->fields[i].offset;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "map->n_vars",
            "sizeof(*elt->var_set)",
            "GFP_KERNEL"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "map->n_vars",
            "sizeof(*elt->vars)",
            "GFP_KERNEL"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "map->n_fields",
            "sizeof(*elt->fields)",
            "GFP_KERNEL"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "map->key_size",
            "GFP_KERNEL"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*elt)",
            "GFP_KERNEL"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_elt *tracing_map_elt_alloc(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt;\n\tint err = 0;\n\n\telt = kzalloc(sizeof(*elt), GFP_KERNEL);\n\tif (!elt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\telt->map = map;\n\n\telt->key = kzalloc(map->key_size, GFP_KERNEL);\n\tif (!elt->key) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->fields = kcalloc(map->n_fields, sizeof(*elt->fields), GFP_KERNEL);\n\tif (!elt->fields) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->vars = kcalloc(map->n_vars, sizeof(*elt->vars), GFP_KERNEL);\n\tif (!elt->vars) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->var_set = kcalloc(map->n_vars, sizeof(*elt->var_set), GFP_KERNEL);\n\tif (!elt->var_set) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\ttracing_map_elt_init_fields(elt);\n\n\tif (map->ops && map->ops->elt_alloc) {\n\t\terr = map->ops->elt_alloc(elt);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\treturn elt;\n free:\n\ttracing_map_elt_free(elt);\n\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "tracing_map_elt_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "389-401",
    "snippet": "static void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elt"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elt->map->ops->elt_free",
          "args": [
            "elt"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}"
  },
  {
    "function_name": "tracing_map_elt_init_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "375-387",
    "snippet": "static void tracing_map_elt_init_fields(struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\ttracing_map_elt_clear(elt);\n\n\tfor (i = 0; i < elt->map->n_fields; i++) {\n\t\telt->fields[i].cmp_fn = elt->map->fields[i].cmp_fn;\n\n\t\tif (elt->fields[i].cmp_fn != tracing_map_cmp_atomic64)\n\t\t\telt->fields[i].offset = elt->map->fields[i].offset;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_elt_clear",
          "args": [
            "elt"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_elt_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "358-373",
          "snippet": "static void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_init_fields(struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\ttracing_map_elt_clear(elt);\n\n\tfor (i = 0; i < elt->map->n_fields; i++) {\n\t\telt->fields[i].cmp_fn = elt->map->fields[i].cmp_fn;\n\n\t\tif (elt->fields[i].cmp_fn != tracing_map_cmp_atomic64)\n\t\t\telt->fields[i].offset = elt->map->fields[i].offset;\n\t}\n}"
  },
  {
    "function_name": "tracing_map_elt_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "358-373",
    "snippet": "static void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elt->map->ops->elt_clear",
          "args": [
            "elt"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&elt->vars[i]",
            "0"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&elt->fields[i].sum",
            "0"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}"
  },
  {
    "function_name": "tracing_map_array_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "321-356",
    "snippet": "static struct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t\tkmemleak_alloc(a->pages[i], PAGE_SIZE, 1, GFP_KERNEL);\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_array_free",
          "args": [
            "a"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_array_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "298-319",
          "snippet": "static void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tkmemleak_free(a->pages[i]);\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tkmemleak_free(a->pages[i]);\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_alloc",
          "args": [
            "a->pages[i]",
            "PAGE_SIZE",
            "1",
            "GFP_KERNEL"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "a->n_pages",
            "sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "a->entries_per_page"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "roundup_pow_of_two(entry_size) - 1"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "entry_size"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*a)",
            "GFP_KERNEL"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic struct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t\tkmemleak_alloc(a->pages[i], PAGE_SIZE, 1, GFP_KERNEL);\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}"
  },
  {
    "function_name": "tracing_map_array_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "298-319",
    "snippet": "static void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tkmemleak_free(a->pages[i]);\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "a"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)a->pages[i]"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "341-349",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_free",
          "args": [
            "a->pages[i]"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tkmemleak_free(a->pages[i]);\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}"
  },
  {
    "function_name": "tracing_map_array_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "287-296",
    "snippet": "static void tracing_map_array_clear(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a->pages)\n\t\treturn;\n\n\tfor (i = 0; i < a->n_pages; i++)\n\t\tmemset(a->pages[i], 0, PAGE_SIZE);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "a->pages[i]",
            "0",
            "PAGE_SIZE"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void tracing_map_array_clear(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a->pages)\n\t\treturn;\n\n\tfor (i = 0; i < a->n_pages; i++)\n\t\tmemset(a->pages[i], 0, PAGE_SIZE);\n}"
  },
  {
    "function_name": "tracing_map_add_key_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "270-285",
    "snippet": "int tracing_map_add_key_field(struct tracing_map *map,\n\t\t\t      unsigned int offset,\n\t\t\t      tracing_map_cmp_fn_t cmp_fn)\n\n{\n\tint idx = tracing_map_add_field(map, cmp_fn);\n\n\tif (idx < 0)\n\t\treturn idx;\n\n\tmap->fields[idx].offset = offset;\n\n\tmap->key_idx[map->n_keys++] = idx;\n\n\treturn idx;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_add_field",
          "args": [
            "map",
            "cmp_fn"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "202-213",
          "snippet": "static int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_key_field(struct tracing_map *map,\n\t\t\t      unsigned int offset,\n\t\t\t      tracing_map_cmp_fn_t cmp_fn)\n\n{\n\tint idx = tracing_map_add_field(map, cmp_fn);\n\n\tif (idx < 0)\n\t\treturn idx;\n\n\tmap->fields[idx].offset = offset;\n\n\tmap->key_idx[map->n_keys++] = idx;\n\n\treturn idx;\n}"
  },
  {
    "function_name": "tracing_map_add_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "244-252",
    "snippet": "int tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tracing_map_add_sum_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "227-230",
    "snippet": "int tracing_map_add_sum_field(struct tracing_map *map)\n{\n\treturn tracing_map_add_field(map, tracing_map_cmp_atomic64);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_add_field",
          "args": [
            "map",
            "tracing_map_cmp_atomic64"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "202-213",
          "snippet": "static int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_sum_field(struct tracing_map *map)\n{\n\treturn tracing_map_add_field(map, tracing_map_cmp_atomic64);\n}"
  },
  {
    "function_name": "tracing_map_add_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "202-213",
    "snippet": "static int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tracing_map_cmp_num",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "167-200",
    "snippet": "tracing_map_cmp_fn_t tracing_map_cmp_num(int field_size,\n\t\t\t\t\t int field_is_signed)\n{\n\ttracing_map_cmp_fn_t fn = tracing_map_cmp_none;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s64;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s32;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s16;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s8;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\ntracing_map_cmp_fn_t tracing_map_cmp_num(int field_size,\n\t\t\t\t\t int field_is_signed)\n{\n\ttracing_map_cmp_fn_t fn = tracing_map_cmp_none;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s64;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s32;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s16;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s8;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
  },
  {
    "function_name": "tracing_map_cmp_atomic64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "141-147",
    "snippet": "static int tracing_map_cmp_atomic64(void *val_a, void *val_b)\n{\n\tu64 a = atomic64_read((atomic64_t *)val_a);\n\tu64 b = atomic64_read((atomic64_t *)val_b);\n\n\treturn (a > b) ? 1 : ((a < b) ? -1 : 0);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "(atomic64_t *)val_b"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "(atomic64_t *)val_a"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic int tracing_map_cmp_atomic64(void *val_a, void *val_b)\n{\n\tu64 a = atomic64_read((atomic64_t *)val_a);\n\tu64 b = atomic64_read((atomic64_t *)val_b);\n\n\treturn (a > b) ? 1 : ((a < b) ? -1 : 0);\n}"
  },
  {
    "function_name": "tracing_map_cmp_none",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "136-139",
    "snippet": "int tracing_map_cmp_none(void *val_a, void *val_b)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_cmp_none(void *val_a, void *val_b)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "tracing_map_cmp_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "128-134",
    "snippet": "int tracing_map_cmp_string(void *val_a, void *val_b)\n{\n\tchar *a = val_a;\n\tchar *b = val_b;\n\n\treturn strcmp(a, b);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a",
            "b"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_cmp_string(void *val_a, void *val_b)\n{\n\tchar *a = val_a;\n\tchar *b = val_b;\n\n\treturn strcmp(a, b);\n}"
  },
  {
    "function_name": "tracing_map_read_var_once",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "122-126",
    "snippet": "u64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&elt->vars[i]"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}"
  },
  {
    "function_name": "tracing_map_read_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "103-106",
    "snippet": "u64 tracing_map_read_var(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&elt->vars[i]"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_var(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}"
  },
  {
    "function_name": "tracing_map_var_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "86-89",
    "snippet": "bool tracing_map_var_set(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn elt->var_set[i];\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nbool tracing_map_var_set(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn elt->var_set[i];\n}"
  },
  {
    "function_name": "tracing_map_set_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "71-75",
    "snippet": "void tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&elt->vars[i]",
            "n"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}"
  },
  {
    "function_name": "tracing_map_read_sum",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "56-59",
    "snippet": "u64 tracing_map_read_sum(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->fields[i].sum);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&elt->fields[i].sum"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_sum(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->fields[i].sum);\n}"
  },
  {
    "function_name": "tracing_map_update_sum",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
    "lines": "39-42",
    "snippet": "void tracing_map_update_sum(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_add(n, &elt->fields[i].sum);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/kmemleak.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/jhash.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "n",
            "&elt->fields[i].sum"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_update_sum(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_add(n, &elt->fields[i].sum);\n}"
  }
]