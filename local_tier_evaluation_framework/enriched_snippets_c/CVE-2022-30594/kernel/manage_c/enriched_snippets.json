[
  {
    "function_name": "irq_check_status_bit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2896-2907",
    "snippet": "bool irq_check_status_bit(unsigned int irq, unsigned int bitmask)\n{\n\tstruct irq_desc *desc;\n\tbool res = false;\n\n\trcu_read_lock();\n\tdesc = irq_to_desc(irq);\n\tif (desc)\n\t\tres = !!(desc->status_use_accessors & bitmask);\n\trcu_read_unlock();\n\treturn res;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2905
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nbool irq_check_status_bit(unsigned int irq, unsigned int bitmask)\n{\n\tstruct irq_desc *desc;\n\tbool res = false;\n\n\trcu_read_lock();\n\tdesc = irq_to_desc(irq);\n\tif (desc)\n\t\tres = !!(desc->status_use_accessors & bitmask);\n\trcu_read_unlock();\n\treturn res;\n}"
  },
  {
    "function_name": "irq_has_action",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2878-2886",
    "snippet": "bool irq_has_action(unsigned int irq)\n{\n\tbool res;\n\n\trcu_read_lock();\n\tres = irq_desc_has_action(irq_to_desc(irq));\n\trcu_read_unlock();\n\treturn res;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2884
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_has_action",
          "args": [
            "irq_to_desc(irq)"
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nbool irq_has_action(unsigned int irq)\n{\n\tbool res;\n\n\trcu_read_lock();\n\tres = irq_desc_has_action(irq_to_desc(irq));\n\trcu_read_unlock();\n\treturn res;\n}"
  },
  {
    "function_name": "irq_set_irqchip_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2833-2869",
    "snippet": "int irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool val)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (chip->irq_set_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_set_irqchip_state(data, which, val);\n\nout_unlock:\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_busunlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_busunlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "175-179",
          "snippet": "static inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_set_irqchip_state",
          "args": [
            "data",
            "which",
            "val"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_irqchip_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2833-2869",
          "snippet": "int irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool val)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (chip->irq_set_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_set_irqchip_state(data, which, val);\n\nout_unlock:\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!chip"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "data"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_buslock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 2842
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_buslock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "169-173",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool val)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (chip->irq_set_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_set_irqchip_state(data, which, val);\n\nout_unlock:\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}"
  },
  {
    "function_name": "irq_get_irqchip_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2800-2818",
    "snippet": "int irq_get_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool *state)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\terr = __irq_get_irqchip_state(data, which, state);\n\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_busunlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_busunlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "175-179",
          "snippet": "static inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_get_irqchip_state",
          "args": [
            "data",
            "which",
            "state"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_get_irqchip_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2763-2785",
          "snippet": "int __irq_get_irqchip_state(struct irq_data *data, enum irqchip_irq_state which,\n\t\t\t    bool *state)\n{\n\tstruct irq_chip *chip;\n\tint err = -EINVAL;\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip))\n\t\t\treturn -ENODEV;\n\t\tif (chip->irq_get_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_get_irqchip_state(data, which, state);\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint __irq_get_irqchip_state(struct irq_data *data, enum irqchip_irq_state which,\n\t\t\t    bool *state)\n{\n\tstruct irq_chip *chip;\n\tint err = -EINVAL;\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip))\n\t\t\treturn -ENODEV;\n\t\tif (chip->irq_get_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_get_irqchip_state(data, which, state);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_buslock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_buslock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "169-173",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_get_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool *state)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\terr = __irq_get_irqchip_state(data, which, state);\n\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}"
  },
  {
    "function_name": "__irq_get_irqchip_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2763-2785",
    "snippet": "int __irq_get_irqchip_state(struct irq_data *data, enum irqchip_irq_state which,\n\t\t\t    bool *state)\n{\n\tstruct irq_chip *chip;\n\tint err = -EINVAL;\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip))\n\t\t\treturn -ENODEV;\n\t\tif (chip->irq_get_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_get_irqchip_state(data, which, state);\n\treturn err;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chip->irq_get_irqchip_state",
          "args": [
            "data",
            "which",
            "state"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irqchip_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2800-2818",
          "snippet": "int irq_get_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool *state)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\terr = __irq_get_irqchip_state(data, which, state);\n\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_get_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool *state)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\terr = __irq_get_irqchip_state(data, which, state);\n\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!chip"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "data"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint __irq_get_irqchip_state(struct irq_data *data, enum irqchip_irq_state which,\n\t\t\t    bool *state)\n{\n\tstruct irq_chip *chip;\n\tint err = -EINVAL;\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip))\n\t\t\treturn -ENODEV;\n\t\tif (chip->irq_get_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_get_irqchip_state(data, which, state);\n\treturn err;\n}"
  },
  {
    "function_name": "teardown_percpu_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2743-2761",
    "snippet": "void teardown_percpu_nmi(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc;\n\n\tWARN_ON(preemptible());\n\n\tdesc = irq_get_desc_lock(irq, &flags,\n\t\t\t\t IRQ_GET_DESC_CHECK_PERCPU);\n\tif (!desc)\n\t\treturn;\n\n\tif (WARN_ON(!(desc->istate & IRQS_NMI)))\n\t\tgoto out;\n\n\tirq_nmi_teardown(desc);\nout:\n\tirq_put_desc_unlock(desc, flags);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_nmi_teardown",
          "args": [
            "desc"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "irq_nmi_teardown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1404-1411",
          "snippet": "static void irq_nmi_teardown(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_nmi_teardown)\n\t\tc->irq_nmi_teardown(d);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_nmi_teardown(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_nmi_teardown)\n\t\tc->irq_nmi_teardown(d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(desc->istate & IRQS_NMI)"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "IRQ_GET_DESC_CHECK_PERCPU"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "preemptible()"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid teardown_percpu_nmi(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc;\n\n\tWARN_ON(preemptible());\n\n\tdesc = irq_get_desc_lock(irq, &flags,\n\t\t\t\t IRQ_GET_DESC_CHECK_PERCPU);\n\tif (!desc)\n\t\treturn;\n\n\tif (WARN_ON(!(desc->istate & IRQS_NMI)))\n\t\tgoto out;\n\n\tirq_nmi_teardown(desc);\nout:\n\tirq_put_desc_unlock(desc, flags);\n}"
  },
  {
    "function_name": "prepare_percpu_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2700-2729",
    "snippet": "int prepare_percpu_nmi(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc;\n\tint ret = 0;\n\n\tWARN_ON(preemptible());\n\n\tdesc = irq_get_desc_lock(irq, &flags,\n\t\t\t\t IRQ_GET_DESC_CHECK_PERCPU);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (WARN(!(desc->istate & IRQS_NMI),\n\t\t KERN_ERR \"prepare_percpu_nmi called for a non-NMI interrupt: irq %u\\n\",\n\t\t irq)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = irq_nmi_setup(desc);\n\tif (ret) {\n\t\tpr_err(\"Failed to setup NMI delivery: irq %u\\n\", irq);\n\t\tgoto out;\n\t}\n\nout:\n\tirq_put_desc_unlock(desc, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to setup NMI delivery: irq %u\\n\"",
            "irq"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_nmi_setup",
          "args": [
            "desc"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "irq_nmi_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1396-1402",
          "snippet": "static int irq_nmi_setup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_nmi_setup ? c->irq_nmi_setup(d) : -EINVAL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_nmi_setup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_nmi_setup ? c->irq_nmi_setup(d) : -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!(desc->istate & IRQS_NMI)",
            "KERN_ERR \"prepare_percpu_nmi called for a non-NMI interrupt: irq %u\\n\"",
            "irq"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "IRQ_GET_DESC_CHECK_PERCPU"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "preemptible()"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint prepare_percpu_nmi(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc;\n\tint ret = 0;\n\n\tWARN_ON(preemptible());\n\n\tdesc = irq_get_desc_lock(irq, &flags,\n\t\t\t\t IRQ_GET_DESC_CHECK_PERCPU);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (WARN(!(desc->istate & IRQS_NMI),\n\t\t KERN_ERR \"prepare_percpu_nmi called for a non-NMI interrupt: irq %u\\n\",\n\t\t irq)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = irq_nmi_setup(desc);\n\tif (ret) {\n\t\tpr_err(\"Failed to setup NMI delivery: irq %u\\n\", irq);\n\t\tgoto out;\n\t}\n\nout:\n\tirq_put_desc_unlock(desc, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "request_percpu_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2632-2685",
    "snippet": "int request_percpu_nmi(unsigned int irq, irq_handler_t handler,\n\t\t       const char *name, void __percpu *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tunsigned long flags;\n\tint retval;\n\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\n\tif (!desc || !irq_settings_can_request(desc) ||\n\t    !irq_settings_is_per_cpu_devid(desc) ||\n\t    irq_settings_can_autoenable(desc) ||\n\t    !irq_supports_nmi(desc))\n\t\treturn -EINVAL;\n\n\t/* The line cannot already be NMI */\n\tif (desc->istate & IRQS_NMI)\n\t\treturn -EINVAL;\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->flags = IRQF_PERCPU | IRQF_NO_SUSPEND | IRQF_NO_THREAD\n\t\t| IRQF_NOBALANCING;\n\taction->name = name;\n\taction->percpu_dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0)\n\t\tgoto err_out;\n\n\tretval = __setup_irq(irq, desc, action);\n\tif (retval)\n\t\tgoto err_irq_setup;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tdesc->istate |= IRQS_NMI;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\treturn 0;\n\nerr_irq_setup:\n\tirq_chip_pm_put(&desc->irq_data);\nerr_out:\n\tkfree(action);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "action"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_put",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1591-1599",
          "snippet": "int irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setup_irq",
          "args": [
            "irq",
            "desc",
            "action"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "__setup_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1462-1834",
          "snippet": "static int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_get",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1568-1581",
          "snippet": "int irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct irqaction)",
            "GFP_KERNEL"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_supports_nmi",
          "args": [
            "desc"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "irq_supports_nmi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1380-1394",
          "snippet": "static bool irq_supports_nmi(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t/* Only IRQs directly managed by the root irqchip can be set as NMI */\n\tif (d->parent_data)\n\t\treturn false;\n#endif\n\t/* Don't support NMIs for chips behind a slow bus */\n\tif (d->chip->irq_bus_lock || d->chip->irq_bus_sync_unlock)\n\t\treturn false;\n\n\treturn d->chip->flags & IRQCHIP_SUPPORTS_NMI;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic bool irq_supports_nmi(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t/* Only IRQs directly managed by the root irqchip can be set as NMI */\n\tif (d->parent_data)\n\t\treturn false;\n#endif\n\t/* Don't support NMIs for chips behind a slow bus */\n\tif (d->chip->irq_bus_lock || d->chip->irq_bus_sync_unlock)\n\t\treturn false;\n\n\treturn d->chip->flags & IRQCHIP_SUPPORTS_NMI;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_can_autoenable",
          "args": [
            "desc"
          ],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_can_autoenable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "150-153",
          "snippet": "static inline bool irq_settings_can_autoenable(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOAUTOEN);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_can_autoenable(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOAUTOEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu_devid",
          "args": [
            "desc"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_can_request",
          "args": [
            "desc"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_can_request",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "100-103",
          "snippet": "static inline bool irq_settings_can_request(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOREQUEST);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_can_request(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOREQUEST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint request_percpu_nmi(unsigned int irq, irq_handler_t handler,\n\t\t       const char *name, void __percpu *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tunsigned long flags;\n\tint retval;\n\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\n\tif (!desc || !irq_settings_can_request(desc) ||\n\t    !irq_settings_is_per_cpu_devid(desc) ||\n\t    irq_settings_can_autoenable(desc) ||\n\t    !irq_supports_nmi(desc))\n\t\treturn -EINVAL;\n\n\t/* The line cannot already be NMI */\n\tif (desc->istate & IRQS_NMI)\n\t\treturn -EINVAL;\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->flags = IRQF_PERCPU | IRQF_NO_SUSPEND | IRQF_NO_THREAD\n\t\t| IRQF_NOBALANCING;\n\taction->name = name;\n\taction->percpu_dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0)\n\t\tgoto err_out;\n\n\tretval = __setup_irq(irq, desc, action);\n\tif (retval)\n\t\tgoto err_irq_setup;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tdesc->istate |= IRQS_NMI;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\treturn 0;\n\nerr_irq_setup:\n\tirq_chip_pm_put(&desc->irq_data);\nerr_out:\n\tkfree(action);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "__request_percpu_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2566-2608",
    "snippet": "int __request_percpu_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t unsigned long flags, const char *devname,\n\t\t\t void __percpu *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tint retval;\n\n\tif (!dev_id)\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc || !irq_settings_can_request(desc) ||\n\t    !irq_settings_is_per_cpu_devid(desc))\n\t\treturn -EINVAL;\n\n\tif (flags && flags != IRQF_TIMER)\n\t\treturn -EINVAL;\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->flags = flags | IRQF_PERCPU | IRQF_NO_SUSPEND;\n\taction->name = devname;\n\taction->percpu_dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0) {\n\t\tkfree(action);\n\t\treturn retval;\n\t}\n\n\tretval = __setup_irq(irq, desc, action);\n\n\tif (retval) {\n\t\tirq_chip_pm_put(&desc->irq_data);\n\t\tkfree(action);\n\t}\n\n\treturn retval;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "action"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_put",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1591-1599",
          "snippet": "int irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setup_irq",
          "args": [
            "irq",
            "desc",
            "action"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "__setup_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1462-1834",
          "snippet": "static int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_get",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1568-1581",
          "snippet": "int irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct irqaction)",
            "GFP_KERNEL"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu_devid",
          "args": [
            "desc"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_can_request",
          "args": [
            "desc"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_can_request",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "100-103",
          "snippet": "static inline bool irq_settings_can_request(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOREQUEST);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_can_request(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOREQUEST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint __request_percpu_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t unsigned long flags, const char *devname,\n\t\t\t void __percpu *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tint retval;\n\n\tif (!dev_id)\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc || !irq_settings_can_request(desc) ||\n\t    !irq_settings_is_per_cpu_devid(desc))\n\t\treturn -EINVAL;\n\n\tif (flags && flags != IRQF_TIMER)\n\t\treturn -EINVAL;\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->flags = flags | IRQF_PERCPU | IRQF_NO_SUSPEND;\n\taction->name = devname;\n\taction->percpu_dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0) {\n\t\tkfree(action);\n\t\treturn retval;\n\t}\n\n\tretval = __setup_irq(irq, desc, action);\n\n\tif (retval) {\n\t\tirq_chip_pm_put(&desc->irq_data);\n\t\tkfree(action);\n\t}\n\n\treturn retval;\n}"
  },
  {
    "function_name": "setup_percpu_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2529-2547",
    "snippet": "int setup_percpu_irq(unsigned int irq, struct irqaction *act)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tint retval;\n\n\tif (!desc || !irq_settings_is_per_cpu_devid(desc))\n\t\treturn -EINVAL;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = __setup_irq(irq, desc, act);\n\n\tif (retval)\n\t\tirq_chip_pm_put(&desc->irq_data);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_chip_pm_put",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1591-1599",
          "snippet": "int irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setup_irq",
          "args": [
            "irq",
            "desc",
            "act"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "__setup_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1462-1834",
          "snippet": "static int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_get",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1568-1581",
          "snippet": "int irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu_devid",
          "args": [
            "desc"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint setup_percpu_irq(unsigned int irq, struct irqaction *act)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tint retval;\n\n\tif (!desc || !irq_settings_is_per_cpu_devid(desc))\n\t\treturn -EINVAL;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = __setup_irq(irq, desc, act);\n\n\tif (retval)\n\t\tirq_chip_pm_put(&desc->irq_data);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "free_percpu_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2509-2520",
    "snippet": "void free_percpu_nmi(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (!desc || !irq_settings_is_per_cpu_devid(desc))\n\t\treturn;\n\n\tif (WARN_ON(!(desc->istate & IRQS_NMI)))\n\t\treturn;\n\n\tkfree(__free_percpu_irq(irq, dev_id));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "__free_percpu_irq(irq, dev_id)"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_percpu_irq",
          "args": [
            "irq",
            "dev_id"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "__free_percpu_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2426-2467",
          "snippet": "static struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tif (!desc)\n\t\treturn NULL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\taction = desc->action;\n\tif (!action || action->percpu_dev_id != dev_id) {\n\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\tgoto bad;\n\t}\n\n\tif (!cpumask_empty(desc->percpu_enabled)) {\n\t\tWARN(1, \"percpu IRQ %d still enabled on CPU%d!\\n\",\n\t\t     irq, cpumask_first(desc->percpu_enabled));\n\t\tgoto bad;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\tdesc->action = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tunregister_handler_proc(irq, action);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\treturn action;\n\nbad:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tif (!desc)\n\t\treturn NULL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\taction = desc->action;\n\tif (!action || action->percpu_dev_id != dev_id) {\n\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\tgoto bad;\n\t}\n\n\tif (!cpumask_empty(desc->percpu_enabled)) {\n\t\tWARN(1, \"percpu IRQ %d still enabled on CPU%d!\\n\",\n\t\t     irq, cpumask_first(desc->percpu_enabled));\n\t\tgoto bad;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\tdesc->action = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tunregister_handler_proc(irq, action);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\treturn action;\n\nbad:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(desc->istate & IRQS_NMI)"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu_devid",
          "args": [
            "desc"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid free_percpu_nmi(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (!desc || !irq_settings_is_per_cpu_devid(desc))\n\t\treturn;\n\n\tif (WARN_ON(!(desc->istate & IRQS_NMI)))\n\t\treturn;\n\n\tkfree(__free_percpu_irq(irq, dev_id));\n}"
  },
  {
    "function_name": "free_percpu_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2496-2506",
    "snippet": "void free_percpu_irq(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (!desc || !irq_settings_is_per_cpu_devid(desc))\n\t\treturn;\n\n\tchip_bus_lock(desc);\n\tkfree(__free_percpu_irq(irq, dev_id));\n\tchip_bus_sync_unlock(desc);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chip_bus_sync_unlock",
          "args": [
            "desc"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "chip_bus_sync_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "149-153",
          "snippet": "static inline void chip_bus_sync_unlock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))\n\t\tdesc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void chip_bus_sync_unlock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))\n\t\tdesc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "__free_percpu_irq(irq, dev_id)"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_percpu_irq",
          "args": [
            "irq",
            "dev_id"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "__free_percpu_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2426-2467",
          "snippet": "static struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tif (!desc)\n\t\treturn NULL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\taction = desc->action;\n\tif (!action || action->percpu_dev_id != dev_id) {\n\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\tgoto bad;\n\t}\n\n\tif (!cpumask_empty(desc->percpu_enabled)) {\n\t\tWARN(1, \"percpu IRQ %d still enabled on CPU%d!\\n\",\n\t\t     irq, cpumask_first(desc->percpu_enabled));\n\t\tgoto bad;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\tdesc->action = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tunregister_handler_proc(irq, action);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\treturn action;\n\nbad:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tif (!desc)\n\t\treturn NULL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\taction = desc->action;\n\tif (!action || action->percpu_dev_id != dev_id) {\n\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\tgoto bad;\n\t}\n\n\tif (!cpumask_empty(desc->percpu_enabled)) {\n\t\tWARN(1, \"percpu IRQ %d still enabled on CPU%d!\\n\",\n\t\t     irq, cpumask_first(desc->percpu_enabled));\n\t\tgoto bad;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\tdesc->action = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tunregister_handler_proc(irq, action);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\treturn action;\n\nbad:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip_bus_lock",
          "args": [
            "desc"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "chip_bus_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "143-147",
          "snippet": "static inline void chip_bus_lock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_lock))\n\t\tdesc->irq_data.chip->irq_bus_lock(&desc->irq_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void chip_bus_lock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_lock))\n\t\tdesc->irq_data.chip->irq_bus_lock(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu_devid",
          "args": [
            "desc"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid free_percpu_irq(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (!desc || !irq_settings_is_per_cpu_devid(desc))\n\t\treturn;\n\n\tchip_bus_lock(desc);\n\tkfree(__free_percpu_irq(irq, dev_id));\n\tchip_bus_sync_unlock(desc);\n}"
  },
  {
    "function_name": "remove_percpu_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2476-2482",
    "snippet": "void remove_percpu_irq(unsigned int irq, struct irqaction *act)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc && irq_settings_is_per_cpu_devid(desc))\n\t    __free_percpu_irq(irq, act->percpu_dev_id);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_percpu_irq",
          "args": [
            "irq",
            "act->percpu_dev_id"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "__free_percpu_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2426-2467",
          "snippet": "static struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tif (!desc)\n\t\treturn NULL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\taction = desc->action;\n\tif (!action || action->percpu_dev_id != dev_id) {\n\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\tgoto bad;\n\t}\n\n\tif (!cpumask_empty(desc->percpu_enabled)) {\n\t\tWARN(1, \"percpu IRQ %d still enabled on CPU%d!\\n\",\n\t\t     irq, cpumask_first(desc->percpu_enabled));\n\t\tgoto bad;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\tdesc->action = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tunregister_handler_proc(irq, action);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\treturn action;\n\nbad:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tif (!desc)\n\t\treturn NULL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\taction = desc->action;\n\tif (!action || action->percpu_dev_id != dev_id) {\n\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\tgoto bad;\n\t}\n\n\tif (!cpumask_empty(desc->percpu_enabled)) {\n\t\tWARN(1, \"percpu IRQ %d still enabled on CPU%d!\\n\",\n\t\t     irq, cpumask_first(desc->percpu_enabled));\n\t\tgoto bad;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\tdesc->action = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tunregister_handler_proc(irq, action);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\treturn action;\n\nbad:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu_devid",
          "args": [
            "desc"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid remove_percpu_irq(unsigned int irq, struct irqaction *act)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc && irq_settings_is_per_cpu_devid(desc))\n\t    __free_percpu_irq(irq, act->percpu_dev_id);\n}"
  },
  {
    "function_name": "__free_percpu_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2426-2467",
    "snippet": "static struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tif (!desc)\n\t\treturn NULL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\taction = desc->action;\n\tif (!action || action->percpu_dev_id != dev_id) {\n\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\tgoto bad;\n\t}\n\n\tif (!cpumask_empty(desc->percpu_enabled)) {\n\t\tWARN(1, \"percpu IRQ %d still enabled on CPU%d!\\n\",\n\t\t     irq, cpumask_first(desc->percpu_enabled));\n\t\tgoto bad;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\tdesc->action = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tunregister_handler_proc(irq, action);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\treturn action;\n\nbad:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "desc->owner"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1087-1098",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_put",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1591-1599",
          "snippet": "int irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_handler_proc",
          "args": [
            "irq",
            "action"
          ],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_handler_proc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "125-126",
          "snippet": "static inline void unregister_handler_proc(unsigned int irq,\n\t\t\t\t\t   struct irqaction *action) { }",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\n\nstatic inline void unregister_handler_proc(unsigned int irq,\n\t\t\t\t\t   struct irqaction *action) { }"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"percpu IRQ %d still enabled on CPU%d!\\n\"",
            "irq",
            "cpumask_first(desc->percpu_enabled)"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "desc->percpu_enabled"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "desc->percpu_enabled"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Trying to free already-free IRQ %d\\n\"",
            "irq"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "in_interrupt()",
            "\"Trying to free IRQ %d from IRQ context!\\n\"",
            "irq"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tif (!desc)\n\t\treturn NULL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\taction = desc->action;\n\tif (!action || action->percpu_dev_id != dev_id) {\n\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\tgoto bad;\n\t}\n\n\tif (!cpumask_empty(desc->percpu_enabled)) {\n\t\tWARN(1, \"percpu IRQ %d still enabled on CPU%d!\\n\",\n\t\t     irq, cpumask_first(desc->percpu_enabled));\n\t\tgoto bad;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\tdesc->action = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tunregister_handler_proc(irq, action);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\treturn action;\n\nbad:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn NULL;\n}"
  },
  {
    "function_name": "disable_percpu_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2418-2421",
    "snippet": "void disable_percpu_nmi(unsigned int irq)\n{\n\tdisable_percpu_irq(irq);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_percpu_irq",
          "args": [
            "irq"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "disable_percpu_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2404-2415",
          "snippet": "void disable_percpu_irq(unsigned int irq)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_PERCPU);\n\n\tif (!desc)\n\t\treturn;\n\n\tirq_percpu_disable(desc, cpu);\n\tirq_put_desc_unlock(desc, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid disable_percpu_irq(unsigned int irq)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_PERCPU);\n\n\tif (!desc)\n\t\treturn;\n\n\tirq_percpu_disable(desc, cpu);\n\tirq_put_desc_unlock(desc, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid disable_percpu_nmi(unsigned int irq)\n{\n\tdisable_percpu_irq(irq);\n}"
  },
  {
    "function_name": "disable_percpu_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2404-2415",
    "snippet": "void disable_percpu_irq(unsigned int irq)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_PERCPU);\n\n\tif (!desc)\n\t\treturn;\n\n\tirq_percpu_disable(desc, cpu);\n\tirq_put_desc_unlock(desc, flags);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_percpu_disable",
          "args": [
            "desc",
            "cpu"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "irq_percpu_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "400-407",
          "snippet": "void irq_percpu_disable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_disable)\n\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);\n\tcpumask_clear_cpu(cpu, desc->percpu_enabled);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_percpu_disable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_disable)\n\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);\n\tcpumask_clear_cpu(cpu, desc->percpu_enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "IRQ_GET_DESC_CHECK_PERCPU"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid disable_percpu_irq(unsigned int irq)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_PERCPU);\n\n\tif (!desc)\n\t\treturn;\n\n\tirq_percpu_disable(desc, cpu);\n\tirq_put_desc_unlock(desc, flags);\n}"
  },
  {
    "function_name": "irq_percpu_is_enabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2386-2401",
    "snippet": "bool irq_percpu_is_enabled(unsigned int irq)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct irq_desc *desc;\n\tunsigned long flags;\n\tbool is_enabled;\n\n\tdesc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_PERCPU);\n\tif (!desc)\n\t\treturn false;\n\n\tis_enabled = cpumask_test_cpu(cpu, desc->percpu_enabled);\n\tirq_put_desc_unlock(desc, flags);\n\n\treturn is_enabled;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "desc->percpu_enabled"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "IRQ_GET_DESC_CHECK_PERCPU"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nbool irq_percpu_is_enabled(unsigned int irq)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct irq_desc *desc;\n\tunsigned long flags;\n\tbool is_enabled;\n\n\tdesc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_PERCPU);\n\tif (!desc)\n\t\treturn false;\n\n\tis_enabled = cpumask_test_cpu(cpu, desc->percpu_enabled);\n\tirq_put_desc_unlock(desc, flags);\n\n\treturn is_enabled;\n}"
  },
  {
    "function_name": "enable_percpu_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2374-2377",
    "snippet": "void enable_percpu_nmi(unsigned int irq, unsigned int type)\n{\n\tenable_percpu_irq(irq, type);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_percpu_irq",
          "args": [
            "irq",
            "type"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "enable_percpu_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2340-2371",
          "snippet": "void enable_percpu_irq(unsigned int irq, unsigned int type)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_PERCPU);\n\n\tif (!desc)\n\t\treturn;\n\n\t/*\n\t * If the trigger type is not specified by the caller, then\n\t * use the default for this interrupt.\n\t */\n\ttype &= IRQ_TYPE_SENSE_MASK;\n\tif (type == IRQ_TYPE_NONE)\n\t\ttype = irqd_get_trigger_type(&desc->irq_data);\n\n\tif (type != IRQ_TYPE_NONE) {\n\t\tint ret;\n\n\t\tret = __irq_set_trigger(desc, type);\n\n\t\tif (ret) {\n\t\t\tWARN(1, \"failed to set type for IRQ%d\\n\", irq);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tirq_percpu_enable(desc, cpu);\nout:\n\tirq_put_desc_unlock(desc, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid enable_percpu_irq(unsigned int irq, unsigned int type)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_PERCPU);\n\n\tif (!desc)\n\t\treturn;\n\n\t/*\n\t * If the trigger type is not specified by the caller, then\n\t * use the default for this interrupt.\n\t */\n\ttype &= IRQ_TYPE_SENSE_MASK;\n\tif (type == IRQ_TYPE_NONE)\n\t\ttype = irqd_get_trigger_type(&desc->irq_data);\n\n\tif (type != IRQ_TYPE_NONE) {\n\t\tint ret;\n\n\t\tret = __irq_set_trigger(desc, type);\n\n\t\tif (ret) {\n\t\t\tWARN(1, \"failed to set type for IRQ%d\\n\", irq);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tirq_percpu_enable(desc, cpu);\nout:\n\tirq_put_desc_unlock(desc, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid enable_percpu_nmi(unsigned int irq, unsigned int type)\n{\n\tenable_percpu_irq(irq, type);\n}"
  },
  {
    "function_name": "enable_percpu_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2340-2371",
    "snippet": "void enable_percpu_irq(unsigned int irq, unsigned int type)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_PERCPU);\n\n\tif (!desc)\n\t\treturn;\n\n\t/*\n\t * If the trigger type is not specified by the caller, then\n\t * use the default for this interrupt.\n\t */\n\ttype &= IRQ_TYPE_SENSE_MASK;\n\tif (type == IRQ_TYPE_NONE)\n\t\ttype = irqd_get_trigger_type(&desc->irq_data);\n\n\tif (type != IRQ_TYPE_NONE) {\n\t\tint ret;\n\n\t\tret = __irq_set_trigger(desc, type);\n\n\t\tif (ret) {\n\t\t\tWARN(1, \"failed to set type for IRQ%d\\n\", irq);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tirq_percpu_enable(desc, cpu);\nout:\n\tirq_put_desc_unlock(desc, flags);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_percpu_enable",
          "args": [
            "desc",
            "cpu"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "irq_percpu_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "391-398",
          "snippet": "void irq_percpu_enable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_enable)\n\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_unmask(&desc->irq_data);\n\tcpumask_set_cpu(cpu, desc->percpu_enabled);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_percpu_enable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_enable)\n\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_unmask(&desc->irq_data);\n\tcpumask_set_cpu(cpu, desc->percpu_enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"failed to set type for IRQ%d\\n\"",
            "irq"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_set_trigger",
          "args": [
            "desc",
            "type"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_set_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "939-992",
          "snippet": "int __irq_set_trigger(struct irq_desc *desc, unsigned long flags)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\tint ret, unmask = 0;\n\n\tif (!chip || !chip->irq_set_type) {\n\t\t/*\n\t\t * IRQF_TRIGGER_* but the PIC does not support multiple\n\t\t * flow-types?\n\t\t */\n\t\tpr_debug(\"No set_type function for IRQ %d (%s)\\n\",\n\t\t\t irq_desc_get_irq(desc),\n\t\t\t chip ? (chip->name ? : \"unknown\") : \"unknown\");\n\t\treturn 0;\n\t}\n\n\tif (chip->flags & IRQCHIP_SET_TYPE_MASKED) {\n\t\tif (!irqd_irq_masked(&desc->irq_data))\n\t\t\tmask_irq(desc);\n\t\tif (!irqd_irq_disabled(&desc->irq_data))\n\t\t\tunmask = 1;\n\t}\n\n\t/* Mask all flags except trigger mode */\n\tflags &= IRQ_TYPE_SENSE_MASK;\n\tret = chip->irq_set_type(&desc->irq_data, flags);\n\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tirqd_clear(&desc->irq_data, IRQD_TRIGGER_MASK);\n\t\tirqd_set(&desc->irq_data, flags);\n\t\tfallthrough;\n\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tflags = irqd_get_trigger_type(&desc->irq_data);\n\t\tirq_settings_set_trigger_mask(desc, flags);\n\t\tirqd_clear(&desc->irq_data, IRQD_LEVEL);\n\t\tirq_settings_clr_level(desc);\n\t\tif (flags & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tirq_settings_set_level(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Setting trigger mode %lu for irq %u failed (%pS)\\n\",\n\t\t       flags, irq_desc_get_irq(desc), chip->irq_set_type);\n\t}\n\tif (unmask)\n\t\tunmask_irq(desc);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint __irq_set_trigger(struct irq_desc *desc, unsigned long flags)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\tint ret, unmask = 0;\n\n\tif (!chip || !chip->irq_set_type) {\n\t\t/*\n\t\t * IRQF_TRIGGER_* but the PIC does not support multiple\n\t\t * flow-types?\n\t\t */\n\t\tpr_debug(\"No set_type function for IRQ %d (%s)\\n\",\n\t\t\t irq_desc_get_irq(desc),\n\t\t\t chip ? (chip->name ? : \"unknown\") : \"unknown\");\n\t\treturn 0;\n\t}\n\n\tif (chip->flags & IRQCHIP_SET_TYPE_MASKED) {\n\t\tif (!irqd_irq_masked(&desc->irq_data))\n\t\t\tmask_irq(desc);\n\t\tif (!irqd_irq_disabled(&desc->irq_data))\n\t\t\tunmask = 1;\n\t}\n\n\t/* Mask all flags except trigger mode */\n\tflags &= IRQ_TYPE_SENSE_MASK;\n\tret = chip->irq_set_type(&desc->irq_data, flags);\n\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tirqd_clear(&desc->irq_data, IRQD_TRIGGER_MASK);\n\t\tirqd_set(&desc->irq_data, flags);\n\t\tfallthrough;\n\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tflags = irqd_get_trigger_type(&desc->irq_data);\n\t\tirq_settings_set_trigger_mask(desc, flags);\n\t\tirqd_clear(&desc->irq_data, IRQD_LEVEL);\n\t\tirq_settings_clr_level(desc);\n\t\tif (flags & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tirq_settings_set_level(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Setting trigger mode %lu for irq %u failed (%pS)\\n\",\n\t\t       flags, irq_desc_get_irq(desc), chip->irq_set_type);\n\t}\n\tif (unmask)\n\t\tunmask_irq(desc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_get_trigger_type",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "IRQ_GET_DESC_CHECK_PERCPU"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid enable_percpu_irq(unsigned int irq, unsigned int type)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_PERCPU);\n\n\tif (!desc)\n\t\treturn;\n\n\t/*\n\t * If the trigger type is not specified by the caller, then\n\t * use the default for this interrupt.\n\t */\n\ttype &= IRQ_TYPE_SENSE_MASK;\n\tif (type == IRQ_TYPE_NONE)\n\t\ttype = irqd_get_trigger_type(&desc->irq_data);\n\n\tif (type != IRQ_TYPE_NONE) {\n\t\tint ret;\n\n\t\tret = __irq_set_trigger(desc, type);\n\n\t\tif (ret) {\n\t\t\tWARN(1, \"failed to set type for IRQ%d\\n\", irq);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tirq_percpu_enable(desc, cpu);\nout:\n\tirq_put_desc_unlock(desc, flags);\n}"
  },
  {
    "function_name": "request_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2270-2338",
    "snippet": "int request_nmi(unsigned int irq, irq_handler_t handler,\n\t\tunsigned long irqflags, const char *name, void *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tunsigned long flags;\n\tint retval;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\t/* NMI cannot be shared, used for Polling */\n\tif (irqflags & (IRQF_SHARED | IRQF_COND_SUSPEND | IRQF_IRQPOLL))\n\t\treturn -EINVAL;\n\n\tif (!(irqflags & IRQF_PERCPU))\n\t\treturn -EINVAL;\n\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\n\tif (!desc || (irq_settings_can_autoenable(desc) &&\n\t    !(irqflags & IRQF_NO_AUTOEN)) ||\n\t    !irq_settings_can_request(desc) ||\n\t    WARN_ON(irq_settings_is_per_cpu_devid(desc)) ||\n\t    !irq_supports_nmi(desc))\n\t\treturn -EINVAL;\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->flags = irqflags | IRQF_NO_THREAD | IRQF_NOBALANCING;\n\taction->name = name;\n\taction->dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0)\n\t\tgoto err_out;\n\n\tretval = __setup_irq(irq, desc, action);\n\tif (retval)\n\t\tgoto err_irq_setup;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t/* Setup NMI state */\n\tdesc->istate |= IRQS_NMI;\n\tretval = irq_nmi_setup(desc);\n\tif (retval) {\n\t\t__cleanup_nmi(irq, desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\treturn 0;\n\nerr_irq_setup:\n\tirq_chip_pm_put(&desc->irq_data);\nerr_out:\n\tkfree(action);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "action"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_put",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1591-1599",
          "snippet": "int irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cleanup_nmi",
          "args": [
            "irq",
            "desc"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "__cleanup_nmi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2018-2042",
          "snippet": "static const void *__cleanup_nmi(unsigned int irq, struct irq_desc *desc)\n{\n\tconst char *devname = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\tif (!WARN_ON(desc->action == NULL)) {\n\t\tirq_pm_remove_action(desc, desc->action);\n\t\tdevname = desc->action->name;\n\t\tunregister_handler_proc(irq, desc->action);\n\n\t\tkfree(desc->action);\n\t\tdesc->action = NULL;\n\t}\n\n\tirq_settings_clr_disable_unlazy(desc);\n\tirq_shutdown_and_deactivate(desc);\n\n\tirq_release_resources(desc);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\n\treturn devname;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic const void *__cleanup_nmi(unsigned int irq, struct irq_desc *desc)\n{\n\tconst char *devname = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\tif (!WARN_ON(desc->action == NULL)) {\n\t\tirq_pm_remove_action(desc, desc->action);\n\t\tdevname = desc->action->name;\n\t\tunregister_handler_proc(irq, desc->action);\n\n\t\tkfree(desc->action);\n\t\tdesc->action = NULL;\n\t}\n\n\tirq_settings_clr_disable_unlazy(desc);\n\tirq_shutdown_and_deactivate(desc);\n\n\tirq_release_resources(desc);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\n\treturn devname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_nmi_setup",
          "args": [
            "desc"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "irq_nmi_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1396-1402",
          "snippet": "static int irq_nmi_setup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_nmi_setup ? c->irq_nmi_setup(d) : -EINVAL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_nmi_setup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_nmi_setup ? c->irq_nmi_setup(d) : -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setup_irq",
          "args": [
            "irq",
            "desc",
            "action"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "__setup_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1462-1834",
          "snippet": "static int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_get",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1568-1581",
          "snippet": "int irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct irqaction)",
            "GFP_KERNEL"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_supports_nmi",
          "args": [
            "desc"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "irq_supports_nmi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1380-1394",
          "snippet": "static bool irq_supports_nmi(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t/* Only IRQs directly managed by the root irqchip can be set as NMI */\n\tif (d->parent_data)\n\t\treturn false;\n#endif\n\t/* Don't support NMIs for chips behind a slow bus */\n\tif (d->chip->irq_bus_lock || d->chip->irq_bus_sync_unlock)\n\t\treturn false;\n\n\treturn d->chip->flags & IRQCHIP_SUPPORTS_NMI;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic bool irq_supports_nmi(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t/* Only IRQs directly managed by the root irqchip can be set as NMI */\n\tif (d->parent_data)\n\t\treturn false;\n#endif\n\t/* Don't support NMIs for chips behind a slow bus */\n\tif (d->chip->irq_bus_lock || d->chip->irq_bus_sync_unlock)\n\t\treturn false;\n\n\treturn d->chip->flags & IRQCHIP_SUPPORTS_NMI;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irq_settings_is_per_cpu_devid(desc)"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu_devid",
          "args": [
            "desc"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_can_request",
          "args": [
            "desc"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_can_request",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "100-103",
          "snippet": "static inline bool irq_settings_can_request(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOREQUEST);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_can_request(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOREQUEST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_can_autoenable",
          "args": [
            "desc"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_can_autoenable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "150-153",
          "snippet": "static inline bool irq_settings_can_autoenable(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOAUTOEN);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_can_autoenable(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOAUTOEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint request_nmi(unsigned int irq, irq_handler_t handler,\n\t\tunsigned long irqflags, const char *name, void *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tunsigned long flags;\n\tint retval;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\t/* NMI cannot be shared, used for Polling */\n\tif (irqflags & (IRQF_SHARED | IRQF_COND_SUSPEND | IRQF_IRQPOLL))\n\t\treturn -EINVAL;\n\n\tif (!(irqflags & IRQF_PERCPU))\n\t\treturn -EINVAL;\n\n\tif (!handler)\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\n\tif (!desc || (irq_settings_can_autoenable(desc) &&\n\t    !(irqflags & IRQF_NO_AUTOEN)) ||\n\t    !irq_settings_can_request(desc) ||\n\t    WARN_ON(irq_settings_is_per_cpu_devid(desc)) ||\n\t    !irq_supports_nmi(desc))\n\t\treturn -EINVAL;\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->flags = irqflags | IRQF_NO_THREAD | IRQF_NOBALANCING;\n\taction->name = name;\n\taction->dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0)\n\t\tgoto err_out;\n\n\tretval = __setup_irq(irq, desc, action);\n\tif (retval)\n\t\tgoto err_irq_setup;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t/* Setup NMI state */\n\tdesc->istate |= IRQS_NMI;\n\tretval = irq_nmi_setup(desc);\n\tif (retval) {\n\t\t__cleanup_nmi(irq, desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\treturn 0;\n\nerr_irq_setup:\n\tirq_chip_pm_put(&desc->irq_data);\nerr_out:\n\tkfree(action);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "request_any_context_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2220-2241",
    "snippet": "int request_any_context_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t    unsigned long flags, const char *name, void *dev_id)\n{\n\tstruct irq_desc *desc;\n\tint ret;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (irq_settings_is_nested_thread(desc)) {\n\t\tret = request_threaded_irq(irq, NULL, handler,\n\t\t\t\t\t   flags, name, dev_id);\n\t\treturn !ret ? IRQC_IS_NESTED : ret;\n\t}\n\n\tret = request_irq(irq, handler, flags, name, dev_id);\n\treturn !ret ? IRQC_IS_HARDIRQ : ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "request_irq",
          "args": [
            "irq",
            "handler",
            "flags",
            "name",
            "dev_id"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_threaded_irq",
          "args": [
            "irq",
            "NULL",
            "handler",
            "flags",
            "name",
            "dev_id"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "request_threaded_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2112-2200",
          "snippet": "int request_threaded_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t irq_handler_t thread_fn, unsigned long irqflags,\n\t\t\t const char *devname, void *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tint retval;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\t/*\n\t * Sanity-check: shared interrupts must pass in a real dev-ID,\n\t * otherwise we'll have trouble later trying to figure out\n\t * which interrupt is which (messes up the interrupt freeing\n\t * logic etc).\n\t *\n\t * Also shared interrupts do not go well with disabling auto enable.\n\t * The sharing interrupt might request it while it's still disabled\n\t * and then wait for interrupts forever.\n\t *\n\t * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and\n\t * it cannot be set along with IRQF_NO_SUSPEND.\n\t */\n\tif (((irqflags & IRQF_SHARED) && !dev_id) ||\n\t    ((irqflags & IRQF_SHARED) && (irqflags & IRQF_NO_AUTOEN)) ||\n\t    (!(irqflags & IRQF_SHARED) && (irqflags & IRQF_COND_SUSPEND)) ||\n\t    ((irqflags & IRQF_NO_SUSPEND) && (irqflags & IRQF_COND_SUSPEND)))\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!irq_settings_can_request(desc) ||\n\t    WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn -EINVAL;\n\n\tif (!handler) {\n\t\tif (!thread_fn)\n\t\t\treturn -EINVAL;\n\t\thandler = irq_default_primary_handler;\n\t}\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->thread_fn = thread_fn;\n\taction->flags = irqflags;\n\taction->name = devname;\n\taction->dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0) {\n\t\tkfree(action);\n\t\treturn retval;\n\t}\n\n\tretval = __setup_irq(irq, desc, action);\n\n\tif (retval) {\n\t\tirq_chip_pm_put(&desc->irq_data);\n\t\tkfree(action->secondary);\n\t\tkfree(action);\n\t}\n\n#ifdef CONFIG_DEBUG_SHIRQ_FIXME\n\tif (!retval && (irqflags & IRQF_SHARED)) {\n\t\t/*\n\t\t * It's a shared IRQ -- the driver ought to be prepared for it\n\t\t * to happen immediately, so let's make sure....\n\t\t * We disable the irq to make sure that a 'real' IRQ doesn't\n\t\t * run in parallel with our fake.\n\t\t */\n\t\tunsigned long flags;\n\n\t\tdisable_irq(irq);\n\t\tlocal_irq_save(flags);\n\n\t\thandler(irq, dev_id);\n\n\t\tlocal_irq_restore(flags);\n\t\tenable_irq(irq);\n\t}\n#endif\n\treturn retval;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint request_threaded_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t irq_handler_t thread_fn, unsigned long irqflags,\n\t\t\t const char *devname, void *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tint retval;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\t/*\n\t * Sanity-check: shared interrupts must pass in a real dev-ID,\n\t * otherwise we'll have trouble later trying to figure out\n\t * which interrupt is which (messes up the interrupt freeing\n\t * logic etc).\n\t *\n\t * Also shared interrupts do not go well with disabling auto enable.\n\t * The sharing interrupt might request it while it's still disabled\n\t * and then wait for interrupts forever.\n\t *\n\t * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and\n\t * it cannot be set along with IRQF_NO_SUSPEND.\n\t */\n\tif (((irqflags & IRQF_SHARED) && !dev_id) ||\n\t    ((irqflags & IRQF_SHARED) && (irqflags & IRQF_NO_AUTOEN)) ||\n\t    (!(irqflags & IRQF_SHARED) && (irqflags & IRQF_COND_SUSPEND)) ||\n\t    ((irqflags & IRQF_NO_SUSPEND) && (irqflags & IRQF_COND_SUSPEND)))\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!irq_settings_can_request(desc) ||\n\t    WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn -EINVAL;\n\n\tif (!handler) {\n\t\tif (!thread_fn)\n\t\t\treturn -EINVAL;\n\t\thandler = irq_default_primary_handler;\n\t}\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->thread_fn = thread_fn;\n\taction->flags = irqflags;\n\taction->name = devname;\n\taction->dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0) {\n\t\tkfree(action);\n\t\treturn retval;\n\t}\n\n\tretval = __setup_irq(irq, desc, action);\n\n\tif (retval) {\n\t\tirq_chip_pm_put(&desc->irq_data);\n\t\tkfree(action->secondary);\n\t\tkfree(action);\n\t}\n\n#ifdef CONFIG_DEBUG_SHIRQ_FIXME\n\tif (!retval && (irqflags & IRQF_SHARED)) {\n\t\t/*\n\t\t * It's a shared IRQ -- the driver ought to be prepared for it\n\t\t * to happen immediately, so let's make sure....\n\t\t * We disable the irq to make sure that a 'real' IRQ doesn't\n\t\t * run in parallel with our fake.\n\t\t */\n\t\tunsigned long flags;\n\n\t\tdisable_irq(irq);\n\t\tlocal_irq_save(flags);\n\n\t\thandler(irq, dev_id);\n\n\t\tlocal_irq_restore(flags);\n\t\tenable_irq(irq);\n\t}\n#endif\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_nested_thread",
          "args": [
            "desc"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_nested_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "155-158",
          "snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint request_any_context_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t    unsigned long flags, const char *name, void *dev_id)\n{\n\tstruct irq_desc *desc;\n\tint ret;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (irq_settings_is_nested_thread(desc)) {\n\t\tret = request_threaded_irq(irq, NULL, handler,\n\t\t\t\t\t   flags, name, dev_id);\n\t\treturn !ret ? IRQC_IS_NESTED : ret;\n\t}\n\n\tret = request_irq(irq, handler, flags, name, dev_id);\n\treturn !ret ? IRQC_IS_HARDIRQ : ret;\n}"
  },
  {
    "function_name": "request_threaded_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2112-2200",
    "snippet": "int request_threaded_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t irq_handler_t thread_fn, unsigned long irqflags,\n\t\t\t const char *devname, void *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tint retval;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\t/*\n\t * Sanity-check: shared interrupts must pass in a real dev-ID,\n\t * otherwise we'll have trouble later trying to figure out\n\t * which interrupt is which (messes up the interrupt freeing\n\t * logic etc).\n\t *\n\t * Also shared interrupts do not go well with disabling auto enable.\n\t * The sharing interrupt might request it while it's still disabled\n\t * and then wait for interrupts forever.\n\t *\n\t * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and\n\t * it cannot be set along with IRQF_NO_SUSPEND.\n\t */\n\tif (((irqflags & IRQF_SHARED) && !dev_id) ||\n\t    ((irqflags & IRQF_SHARED) && (irqflags & IRQF_NO_AUTOEN)) ||\n\t    (!(irqflags & IRQF_SHARED) && (irqflags & IRQF_COND_SUSPEND)) ||\n\t    ((irqflags & IRQF_NO_SUSPEND) && (irqflags & IRQF_COND_SUSPEND)))\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!irq_settings_can_request(desc) ||\n\t    WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn -EINVAL;\n\n\tif (!handler) {\n\t\tif (!thread_fn)\n\t\t\treturn -EINVAL;\n\t\thandler = irq_default_primary_handler;\n\t}\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->thread_fn = thread_fn;\n\taction->flags = irqflags;\n\taction->name = devname;\n\taction->dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0) {\n\t\tkfree(action);\n\t\treturn retval;\n\t}\n\n\tretval = __setup_irq(irq, desc, action);\n\n\tif (retval) {\n\t\tirq_chip_pm_put(&desc->irq_data);\n\t\tkfree(action->secondary);\n\t\tkfree(action);\n\t}\n\n#ifdef CONFIG_DEBUG_SHIRQ_FIXME\n\tif (!retval && (irqflags & IRQF_SHARED)) {\n\t\t/*\n\t\t * It's a shared IRQ -- the driver ought to be prepared for it\n\t\t * to happen immediately, so let's make sure....\n\t\t * We disable the irq to make sure that a 'real' IRQ doesn't\n\t\t * run in parallel with our fake.\n\t\t */\n\t\tunsigned long flags;\n\n\t\tdisable_irq(irq);\n\t\tlocal_irq_save(flags);\n\n\t\thandler(irq, dev_id);\n\n\t\tlocal_irq_restore(flags);\n\t\tenable_irq(irq);\n\t}\n#endif\n\treturn retval;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_irq",
          "args": [
            "irq"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "enable_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "808-822",
          "snippet": "void enable_irq(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn;\n\tif (WARN(!desc->irq_data.chip,\n\t\t KERN_ERR \"enable_irq before setup/request_irq: irq %u\\n\", irq))\n\t\tgoto out;\n\n\t__enable_irq(desc);\nout:\n\tirq_put_desc_busunlock(desc, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid enable_irq(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn;\n\tif (WARN(!desc->irq_data.chip,\n\t\t KERN_ERR \"enable_irq before setup/request_irq: irq %u\\n\", irq))\n\t\tgoto out;\n\n\t__enable_irq(desc);\nout:\n\tirq_put_desc_busunlock(desc, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler",
          "args": [
            "irq",
            "dev_id"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "irq_forced_secondary_handler",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1031-1035",
          "snippet": "static irqreturn_t irq_forced_secondary_handler(int irq, void *dev_id)\n{\n\tWARN(1, \"Secondary action handler called for irq %d\\n\", irq);\n\treturn IRQ_NONE;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic irqreturn_t irq_forced_secondary_handler(int irq, void *dev_id)\n{\n\tWARN(1, \"Secondary action handler called for irq %d\\n\", irq);\n\treturn IRQ_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_irq",
          "args": [
            "irq"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "disable_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "721-725",
          "snippet": "void disable_irq(unsigned int irq)\n{\n\tif (!__disable_irq_nosync(irq))\n\t\tsynchronize_irq(irq);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid disable_irq(unsigned int irq)\n{\n\tif (!__disable_irq_nosync(irq))\n\t\tsynchronize_irq(irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "action"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_put",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1591-1599",
          "snippet": "int irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setup_irq",
          "args": [
            "irq",
            "desc",
            "action"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "__setup_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1462-1834",
          "snippet": "static int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_get",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1568-1581",
          "snippet": "int irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_get(struct irq_data *data)\n{\n\tint retval;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device) {\n\t\tretval = pm_runtime_get_sync(data->chip->parent_device);\n\t\tif (retval < 0) {\n\t\t\tpm_runtime_put_noidle(data->chip->parent_device);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct irqaction)",
            "GFP_KERNEL"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irq_settings_is_per_cpu_devid(desc)"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu_devid",
          "args": [
            "desc"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_can_request",
          "args": [
            "desc"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_can_request",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "100-103",
          "snippet": "static inline bool irq_settings_can_request(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOREQUEST);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_can_request(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOREQUEST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint request_threaded_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t irq_handler_t thread_fn, unsigned long irqflags,\n\t\t\t const char *devname, void *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tint retval;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\t/*\n\t * Sanity-check: shared interrupts must pass in a real dev-ID,\n\t * otherwise we'll have trouble later trying to figure out\n\t * which interrupt is which (messes up the interrupt freeing\n\t * logic etc).\n\t *\n\t * Also shared interrupts do not go well with disabling auto enable.\n\t * The sharing interrupt might request it while it's still disabled\n\t * and then wait for interrupts forever.\n\t *\n\t * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and\n\t * it cannot be set along with IRQF_NO_SUSPEND.\n\t */\n\tif (((irqflags & IRQF_SHARED) && !dev_id) ||\n\t    ((irqflags & IRQF_SHARED) && (irqflags & IRQF_NO_AUTOEN)) ||\n\t    (!(irqflags & IRQF_SHARED) && (irqflags & IRQF_COND_SUSPEND)) ||\n\t    ((irqflags & IRQF_NO_SUSPEND) && (irqflags & IRQF_COND_SUSPEND)))\n\t\treturn -EINVAL;\n\n\tdesc = irq_to_desc(irq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!irq_settings_can_request(desc) ||\n\t    WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn -EINVAL;\n\n\tif (!handler) {\n\t\tif (!thread_fn)\n\t\t\treturn -EINVAL;\n\t\thandler = irq_default_primary_handler;\n\t}\n\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->thread_fn = thread_fn;\n\taction->flags = irqflags;\n\taction->name = devname;\n\taction->dev_id = dev_id;\n\n\tretval = irq_chip_pm_get(&desc->irq_data);\n\tif (retval < 0) {\n\t\tkfree(action);\n\t\treturn retval;\n\t}\n\n\tretval = __setup_irq(irq, desc, action);\n\n\tif (retval) {\n\t\tirq_chip_pm_put(&desc->irq_data);\n\t\tkfree(action->secondary);\n\t\tkfree(action);\n\t}\n\n#ifdef CONFIG_DEBUG_SHIRQ_FIXME\n\tif (!retval && (irqflags & IRQF_SHARED)) {\n\t\t/*\n\t\t * It's a shared IRQ -- the driver ought to be prepared for it\n\t\t * to happen immediately, so let's make sure....\n\t\t * We disable the irq to make sure that a 'real' IRQ doesn't\n\t\t * run in parallel with our fake.\n\t\t */\n\t\tunsigned long flags;\n\n\t\tdisable_irq(irq);\n\t\tlocal_irq_save(flags);\n\n\t\thandler(irq, dev_id);\n\n\t\tlocal_irq_restore(flags);\n\t\tenable_irq(irq);\n\t}\n#endif\n\treturn retval;\n}"
  },
  {
    "function_name": "free_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2044-2068",
    "snippet": "const void *free_nmi(unsigned int irq, void *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tconst void *devname;\n\n\tif (!desc || WARN_ON(!(desc->istate & IRQS_NMI)))\n\t\treturn NULL;\n\n\tif (WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn NULL;\n\n\t/* NMI still enabled */\n\tif (WARN_ON(desc->depth == 0))\n\t\tdisable_nmi_nosync(irq);\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\tirq_nmi_teardown(desc);\n\tdevname = __cleanup_nmi(irq, desc);\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\treturn devname;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cleanup_nmi",
          "args": [
            "irq",
            "desc"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "__cleanup_nmi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2018-2042",
          "snippet": "static const void *__cleanup_nmi(unsigned int irq, struct irq_desc *desc)\n{\n\tconst char *devname = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\tif (!WARN_ON(desc->action == NULL)) {\n\t\tirq_pm_remove_action(desc, desc->action);\n\t\tdevname = desc->action->name;\n\t\tunregister_handler_proc(irq, desc->action);\n\n\t\tkfree(desc->action);\n\t\tdesc->action = NULL;\n\t}\n\n\tirq_settings_clr_disable_unlazy(desc);\n\tirq_shutdown_and_deactivate(desc);\n\n\tirq_release_resources(desc);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\n\treturn devname;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic const void *__cleanup_nmi(unsigned int irq, struct irq_desc *desc)\n{\n\tconst char *devname = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\tif (!WARN_ON(desc->action == NULL)) {\n\t\tirq_pm_remove_action(desc, desc->action);\n\t\tdevname = desc->action->name;\n\t\tunregister_handler_proc(irq, desc->action);\n\n\t\tkfree(desc->action);\n\t\tdesc->action = NULL;\n\t}\n\n\tirq_settings_clr_disable_unlazy(desc);\n\tirq_shutdown_and_deactivate(desc);\n\n\tirq_release_resources(desc);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\n\treturn devname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_nmi_teardown",
          "args": [
            "desc"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "irq_nmi_teardown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1404-1411",
          "snippet": "static void irq_nmi_teardown(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_nmi_teardown)\n\t\tc->irq_nmi_teardown(d);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_nmi_teardown(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_nmi_teardown)\n\t\tc->irq_nmi_teardown(d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_nmi_nosync",
          "args": [
            "irq"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "disable_nmi_nosync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "764-767",
          "snippet": "void disable_nmi_nosync(unsigned int irq)\n{\n\tdisable_irq_nosync(irq);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid disable_nmi_nosync(unsigned int irq)\n{\n\tdisable_irq_nosync(irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "desc->depth == 0"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irq_settings_is_per_cpu_devid(desc)"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu_devid",
          "args": [
            "desc"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(desc->istate & IRQS_NMI)"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nconst void *free_nmi(unsigned int irq, void *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tconst void *devname;\n\n\tif (!desc || WARN_ON(!(desc->istate & IRQS_NMI)))\n\t\treturn NULL;\n\n\tif (WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn NULL;\n\n\t/* NMI still enabled */\n\tif (WARN_ON(desc->depth == 0))\n\t\tdisable_nmi_nosync(irq);\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\tirq_nmi_teardown(desc);\n\tdevname = __cleanup_nmi(irq, desc);\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\treturn devname;\n}"
  },
  {
    "function_name": "__cleanup_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "2018-2042",
    "snippet": "static const void *__cleanup_nmi(unsigned int irq, struct irq_desc *desc)\n{\n\tconst char *devname = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\tif (!WARN_ON(desc->action == NULL)) {\n\t\tirq_pm_remove_action(desc, desc->action);\n\t\tdevname = desc->action->name;\n\t\tunregister_handler_proc(irq, desc->action);\n\n\t\tkfree(desc->action);\n\t\tdesc->action = NULL;\n\t}\n\n\tirq_settings_clr_disable_unlazy(desc);\n\tirq_shutdown_and_deactivate(desc);\n\n\tirq_release_resources(desc);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\n\treturn devname;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "desc->owner"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1087-1098",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_put",
          "args": [
            "&desc->irq_data"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1591-1599",
          "snippet": "int irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_release_resources",
          "args": [
            "desc"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "irq_release_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1371-1378",
          "snippet": "static void irq_release_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_release_resources)\n\t\tc->irq_release_resources(d);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_release_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_release_resources)\n\t\tc->irq_release_resources(d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_shutdown_and_deactivate",
          "args": [
            "desc"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "irq_shutdown_and_deactivate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "323-333",
          "snippet": "void irq_shutdown_and_deactivate(struct irq_desc *desc)\n{\n\tirq_shutdown(desc);\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_shutdown_and_deactivate(struct irq_desc *desc)\n{\n\tirq_shutdown(desc);\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_clr_disable_unlazy",
          "args": [
            "desc"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_clr_disable_unlazy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "170-173",
          "snippet": "static inline void irq_settings_clr_disable_unlazy(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors &= ~_IRQ_DISABLE_UNLAZY;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void irq_settings_clr_disable_unlazy(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors &= ~_IRQ_DISABLE_UNLAZY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "desc->action"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_handler_proc",
          "args": [
            "irq",
            "desc->action"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_handler_proc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "125-126",
          "snippet": "static inline void unregister_handler_proc(unsigned int irq,\n\t\t\t\t\t   struct irqaction *action) { }",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\n\nstatic inline void unregister_handler_proc(unsigned int irq,\n\t\t\t\t\t   struct irqaction *action) { }"
        }
      },
      {
        "call_info": {
          "callee": "irq_pm_remove_action",
          "args": [
            "desc",
            "desc->action"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "irq_pm_remove_action",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "280-281",
          "snippet": "static inline void\nirq_pm_remove_action(struct irq_desc *desc, struct irqaction *action) { }",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_pm_remove_action(struct irq_desc *desc, struct irqaction *action) { }"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "desc->action == NULL"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic const void *__cleanup_nmi(unsigned int irq, struct irq_desc *desc)\n{\n\tconst char *devname = NULL;\n\n\tdesc->istate &= ~IRQS_NMI;\n\n\tif (!WARN_ON(desc->action == NULL)) {\n\t\tirq_pm_remove_action(desc, desc->action);\n\t\tdevname = desc->action->name;\n\t\tunregister_handler_proc(irq, desc->action);\n\n\t\tkfree(desc->action);\n\t\tdesc->action = NULL;\n\t}\n\n\tirq_settings_clr_disable_unlazy(desc);\n\tirq_shutdown_and_deactivate(desc);\n\n\tirq_release_resources(desc);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\n\treturn devname;\n}"
  },
  {
    "function_name": "free_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1992-2014",
    "snippet": "const void *free_irq(unsigned int irq, void *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tconst char *devname;\n\n\tif (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn NULL;\n\n#ifdef CONFIG_SMP\n\tif (WARN_ON(desc->affinity_notify))\n\t\tdesc->affinity_notify = NULL;\n#endif\n\n\taction = __free_irq(desc, dev_id);\n\n\tif (!action)\n\t\treturn NULL;\n\n\tdevname = action->name;\n\tkfree(action);\n\treturn devname;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "action"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_irq",
          "args": [
            "desc",
            "dev_id"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "__free_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1840-1974",
          "snippet": "static struct irqaction *__free_irq(struct irq_desc *desc, void *dev_id)\n{\n\tunsigned irq = desc->irq_data.irq;\n\tstruct irqaction *action, **action_ptr;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tmutex_lock(&desc->request_mutex);\n\tchip_bus_lock(desc);\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t/*\n\t * There can be multiple actions per IRQ descriptor, find the right\n\t * one based on the dev_id:\n\t */\n\taction_ptr = &desc->action;\n\tfor (;;) {\n\t\taction = *action_ptr;\n\n\t\tif (!action) {\n\t\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t\t\tchip_bus_sync_unlock(desc);\n\t\t\tmutex_unlock(&desc->request_mutex);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (action->dev_id == dev_id)\n\t\t\tbreak;\n\t\taction_ptr = &action->next;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\t*action_ptr = action->next;\n\n\tirq_pm_remove_action(desc, action);\n\n\t/* If this was the last handler, shut down the IRQ line: */\n\tif (!desc->action) {\n\t\tirq_settings_clr_disable_unlazy(desc);\n\t\t/* Only shutdown. Deactivate after synchronize_hardirq() */\n\t\tirq_shutdown(desc);\n\t}\n\n#ifdef CONFIG_SMP\n\t/* make sure affinity_hint is cleaned up */\n\tif (WARN_ON_ONCE(desc->affinity_hint))\n\t\tdesc->affinity_hint = NULL;\n#endif\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t/*\n\t * Drop bus_lock here so the changes which were done in the chip\n\t * callbacks above are synced out to the irq chips which hang\n\t * behind a slow bus (I2C, SPI) before calling synchronize_hardirq().\n\t *\n\t * Aside of that the bus_lock can also be taken from the threaded\n\t * handler in irq_finalize_oneshot() which results in a deadlock\n\t * because kthread_stop() would wait forever for the thread to\n\t * complete, which is blocked on the bus lock.\n\t *\n\t * The still held desc->request_mutex() protects against a\n\t * concurrent request_irq() of this irq so the release of resources\n\t * and timing data is properly serialized.\n\t */\n\tchip_bus_sync_unlock(desc);\n\n\tunregister_handler_proc(irq, action);\n\n\t/*\n\t * Make sure it's not being used on another CPU and if the chip\n\t * supports it also make sure that there is no (not yet serviced)\n\t * interrupt in flight at the hardware level.\n\t */\n\t__synchronize_hardirq(desc, true);\n\n#ifdef CONFIG_DEBUG_SHIRQ\n\t/*\n\t * It's a shared IRQ -- the driver ought to be prepared for an IRQ\n\t * event to happen even now it's being freed, so let's make sure that\n\t * is so by doing an extra call to the handler ....\n\t *\n\t * ( We do this after actually deregistering it, to make sure that a\n\t *   'real' IRQ doesn't run in parallel with our fake. )\n\t */\n\tif (action->flags & IRQF_SHARED) {\n\t\tlocal_irq_save(flags);\n\t\taction->handler(irq, dev_id);\n\t\tlocal_irq_restore(flags);\n\t}\n#endif\n\n\t/*\n\t * The action has already been removed above, but the thread writes\n\t * its oneshot mask bit when it completes. Though request_mutex is\n\t * held across this which prevents __setup_irq() from handing out\n\t * the same bit to a newly requested action.\n\t */\n\tif (action->thread) {\n\t\tkthread_stop(action->thread);\n\t\tput_task_struct(action->thread);\n\t\tif (action->secondary && action->secondary->thread) {\n\t\t\tkthread_stop(action->secondary->thread);\n\t\t\tput_task_struct(action->secondary->thread);\n\t\t}\n\t}\n\n\t/* Last action releases resources */\n\tif (!desc->action) {\n\t\t/*\n\t\t * Reacquire bus lock as irq_release_resources() might\n\t\t * require it to deallocate resources over the slow bus.\n\t\t */\n\t\tchip_bus_lock(desc);\n\t\t/*\n\t\t * There is no interrupt on the fly anymore. Deactivate it\n\t\t * completely.\n\t\t */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tirq_domain_deactivate_irq(&desc->irq_data);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\tirq_release_resources(desc);\n\t\tchip_bus_sync_unlock(desc);\n\t\tirq_remove_timings(desc);\n\t}\n\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\tkfree(action->secondary);\n\treturn action;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic struct irqaction *__free_irq(struct irq_desc *desc, void *dev_id)\n{\n\tunsigned irq = desc->irq_data.irq;\n\tstruct irqaction *action, **action_ptr;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tmutex_lock(&desc->request_mutex);\n\tchip_bus_lock(desc);\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t/*\n\t * There can be multiple actions per IRQ descriptor, find the right\n\t * one based on the dev_id:\n\t */\n\taction_ptr = &desc->action;\n\tfor (;;) {\n\t\taction = *action_ptr;\n\n\t\tif (!action) {\n\t\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t\t\tchip_bus_sync_unlock(desc);\n\t\t\tmutex_unlock(&desc->request_mutex);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (action->dev_id == dev_id)\n\t\t\tbreak;\n\t\taction_ptr = &action->next;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\t*action_ptr = action->next;\n\n\tirq_pm_remove_action(desc, action);\n\n\t/* If this was the last handler, shut down the IRQ line: */\n\tif (!desc->action) {\n\t\tirq_settings_clr_disable_unlazy(desc);\n\t\t/* Only shutdown. Deactivate after synchronize_hardirq() */\n\t\tirq_shutdown(desc);\n\t}\n\n#ifdef CONFIG_SMP\n\t/* make sure affinity_hint is cleaned up */\n\tif (WARN_ON_ONCE(desc->affinity_hint))\n\t\tdesc->affinity_hint = NULL;\n#endif\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t/*\n\t * Drop bus_lock here so the changes which were done in the chip\n\t * callbacks above are synced out to the irq chips which hang\n\t * behind a slow bus (I2C, SPI) before calling synchronize_hardirq().\n\t *\n\t * Aside of that the bus_lock can also be taken from the threaded\n\t * handler in irq_finalize_oneshot() which results in a deadlock\n\t * because kthread_stop() would wait forever for the thread to\n\t * complete, which is blocked on the bus lock.\n\t *\n\t * The still held desc->request_mutex() protects against a\n\t * concurrent request_irq() of this irq so the release of resources\n\t * and timing data is properly serialized.\n\t */\n\tchip_bus_sync_unlock(desc);\n\n\tunregister_handler_proc(irq, action);\n\n\t/*\n\t * Make sure it's not being used on another CPU and if the chip\n\t * supports it also make sure that there is no (not yet serviced)\n\t * interrupt in flight at the hardware level.\n\t */\n\t__synchronize_hardirq(desc, true);\n\n#ifdef CONFIG_DEBUG_SHIRQ\n\t/*\n\t * It's a shared IRQ -- the driver ought to be prepared for an IRQ\n\t * event to happen even now it's being freed, so let's make sure that\n\t * is so by doing an extra call to the handler ....\n\t *\n\t * ( We do this after actually deregistering it, to make sure that a\n\t *   'real' IRQ doesn't run in parallel with our fake. )\n\t */\n\tif (action->flags & IRQF_SHARED) {\n\t\tlocal_irq_save(flags);\n\t\taction->handler(irq, dev_id);\n\t\tlocal_irq_restore(flags);\n\t}\n#endif\n\n\t/*\n\t * The action has already been removed above, but the thread writes\n\t * its oneshot mask bit when it completes. Though request_mutex is\n\t * held across this which prevents __setup_irq() from handing out\n\t * the same bit to a newly requested action.\n\t */\n\tif (action->thread) {\n\t\tkthread_stop(action->thread);\n\t\tput_task_struct(action->thread);\n\t\tif (action->secondary && action->secondary->thread) {\n\t\t\tkthread_stop(action->secondary->thread);\n\t\t\tput_task_struct(action->secondary->thread);\n\t\t}\n\t}\n\n\t/* Last action releases resources */\n\tif (!desc->action) {\n\t\t/*\n\t\t * Reacquire bus lock as irq_release_resources() might\n\t\t * require it to deallocate resources over the slow bus.\n\t\t */\n\t\tchip_bus_lock(desc);\n\t\t/*\n\t\t * There is no interrupt on the fly anymore. Deactivate it\n\t\t * completely.\n\t\t */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tirq_domain_deactivate_irq(&desc->irq_data);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\tirq_release_resources(desc);\n\t\tchip_bus_sync_unlock(desc);\n\t\tirq_remove_timings(desc);\n\t}\n\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\tkfree(action->secondary);\n\treturn action;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "desc->affinity_notify"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irq_settings_is_per_cpu_devid(desc)"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu_devid",
          "args": [
            "desc"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nconst void *free_irq(unsigned int irq, void *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tconst char *devname;\n\n\tif (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn NULL;\n\n#ifdef CONFIG_SMP\n\tif (WARN_ON(desc->affinity_notify))\n\t\tdesc->affinity_notify = NULL;\n#endif\n\n\taction = __free_irq(desc, dev_id);\n\n\tif (!action)\n\t\treturn NULL;\n\n\tdevname = action->name;\n\tkfree(action);\n\treturn devname;\n}"
  },
  {
    "function_name": "__free_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1840-1974",
    "snippet": "static struct irqaction *__free_irq(struct irq_desc *desc, void *dev_id)\n{\n\tunsigned irq = desc->irq_data.irq;\n\tstruct irqaction *action, **action_ptr;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tmutex_lock(&desc->request_mutex);\n\tchip_bus_lock(desc);\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t/*\n\t * There can be multiple actions per IRQ descriptor, find the right\n\t * one based on the dev_id:\n\t */\n\taction_ptr = &desc->action;\n\tfor (;;) {\n\t\taction = *action_ptr;\n\n\t\tif (!action) {\n\t\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t\t\tchip_bus_sync_unlock(desc);\n\t\t\tmutex_unlock(&desc->request_mutex);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (action->dev_id == dev_id)\n\t\t\tbreak;\n\t\taction_ptr = &action->next;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\t*action_ptr = action->next;\n\n\tirq_pm_remove_action(desc, action);\n\n\t/* If this was the last handler, shut down the IRQ line: */\n\tif (!desc->action) {\n\t\tirq_settings_clr_disable_unlazy(desc);\n\t\t/* Only shutdown. Deactivate after synchronize_hardirq() */\n\t\tirq_shutdown(desc);\n\t}\n\n#ifdef CONFIG_SMP\n\t/* make sure affinity_hint is cleaned up */\n\tif (WARN_ON_ONCE(desc->affinity_hint))\n\t\tdesc->affinity_hint = NULL;\n#endif\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t/*\n\t * Drop bus_lock here so the changes which were done in the chip\n\t * callbacks above are synced out to the irq chips which hang\n\t * behind a slow bus (I2C, SPI) before calling synchronize_hardirq().\n\t *\n\t * Aside of that the bus_lock can also be taken from the threaded\n\t * handler in irq_finalize_oneshot() which results in a deadlock\n\t * because kthread_stop() would wait forever for the thread to\n\t * complete, which is blocked on the bus lock.\n\t *\n\t * The still held desc->request_mutex() protects against a\n\t * concurrent request_irq() of this irq so the release of resources\n\t * and timing data is properly serialized.\n\t */\n\tchip_bus_sync_unlock(desc);\n\n\tunregister_handler_proc(irq, action);\n\n\t/*\n\t * Make sure it's not being used on another CPU and if the chip\n\t * supports it also make sure that there is no (not yet serviced)\n\t * interrupt in flight at the hardware level.\n\t */\n\t__synchronize_hardirq(desc, true);\n\n#ifdef CONFIG_DEBUG_SHIRQ\n\t/*\n\t * It's a shared IRQ -- the driver ought to be prepared for an IRQ\n\t * event to happen even now it's being freed, so let's make sure that\n\t * is so by doing an extra call to the handler ....\n\t *\n\t * ( We do this after actually deregistering it, to make sure that a\n\t *   'real' IRQ doesn't run in parallel with our fake. )\n\t */\n\tif (action->flags & IRQF_SHARED) {\n\t\tlocal_irq_save(flags);\n\t\taction->handler(irq, dev_id);\n\t\tlocal_irq_restore(flags);\n\t}\n#endif\n\n\t/*\n\t * The action has already been removed above, but the thread writes\n\t * its oneshot mask bit when it completes. Though request_mutex is\n\t * held across this which prevents __setup_irq() from handing out\n\t * the same bit to a newly requested action.\n\t */\n\tif (action->thread) {\n\t\tkthread_stop(action->thread);\n\t\tput_task_struct(action->thread);\n\t\tif (action->secondary && action->secondary->thread) {\n\t\t\tkthread_stop(action->secondary->thread);\n\t\t\tput_task_struct(action->secondary->thread);\n\t\t}\n\t}\n\n\t/* Last action releases resources */\n\tif (!desc->action) {\n\t\t/*\n\t\t * Reacquire bus lock as irq_release_resources() might\n\t\t * require it to deallocate resources over the slow bus.\n\t\t */\n\t\tchip_bus_lock(desc);\n\t\t/*\n\t\t * There is no interrupt on the fly anymore. Deactivate it\n\t\t * completely.\n\t\t */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tirq_domain_deactivate_irq(&desc->irq_data);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\tirq_release_resources(desc);\n\t\tchip_bus_sync_unlock(desc);\n\t\tirq_remove_timings(desc);\n\t}\n\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\tkfree(action->secondary);\n\treturn action;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "action->secondary"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "desc->owner"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1087-1098",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_chip_pm_put",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_pm_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1591-1599",
          "snippet": "int irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_pm_put(struct irq_data *data)\n{\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && data->chip->parent_device)\n\t\tretval = pm_runtime_put(data->chip->parent_device);\n\n\treturn (retval < 0) ? retval : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&desc->request_mutex"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_remove_timings",
          "args": [
            "desc"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "irq_remove_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "387-387",
          "snippet": "static inline void irq_remove_timings(struct irq_desc *desc) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_remove_timings(struct irq_desc *desc) {}"
        }
      },
      {
        "call_info": {
          "callee": "chip_bus_sync_unlock",
          "args": [
            "desc"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "chip_bus_sync_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "149-153",
          "snippet": "static inline void chip_bus_sync_unlock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))\n\t\tdesc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void chip_bus_sync_unlock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))\n\t\tdesc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_release_resources",
          "args": [
            "desc"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "irq_release_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1371-1378",
          "snippet": "static void irq_release_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_release_resources)\n\t\tc->irq_release_resources(d);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_release_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_release_resources)\n\t\tc->irq_release_resources(d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_deactivate_irq",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_deactivate_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "470-473",
          "snippet": "static inline void irq_domain_deactivate_irq(struct irq_data *data)\n{\n\tirqd_clr_activated(data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irq_domain_deactivate_irq(struct irq_data *data)\n{\n\tirqd_clr_activated(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip_bus_lock",
          "args": [
            "desc"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "chip_bus_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "143-147",
          "snippet": "static inline void chip_bus_lock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_lock))\n\t\tdesc->irq_data.chip->irq_bus_lock(&desc->irq_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void chip_bus_lock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_lock))\n\t\tdesc->irq_data.chip->irq_bus_lock(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "action->secondary->thread"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "action->secondary->thread"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "action->handler",
          "args": [
            "irq",
            "dev_id"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__synchronize_hardirq",
          "args": [
            "desc",
            "true"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "__synchronize_hardirq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "38-74",
          "snippet": "static void __synchronize_hardirq(struct irq_desc *desc, bool sync_chip)\n{\n\tstruct irq_data *irqd = irq_desc_get_irq_data(desc);\n\tbool inprogress;\n\n\tdo {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * Wait until we're out of the critical section.  This might\n\t\t * give the wrong answer due to the lack of memory barriers.\n\t\t */\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\n\t\t/* Ok, that indicated we're done: double-check carefully. */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tinprogress = irqd_irq_inprogress(&desc->irq_data);\n\n\t\t/*\n\t\t * If requested and supported, check at the chip whether it\n\t\t * is in flight at the hardware level, i.e. already pending\n\t\t * in a CPU and waiting for service and acknowledge.\n\t\t */\n\t\tif (!inprogress && sync_chip) {\n\t\t\t/*\n\t\t\t * Ignore the return code. inprogress is only updated\n\t\t\t * when the chip supports it.\n\t\t\t */\n\t\t\t__irq_get_irqchip_state(irqd, IRQCHIP_STATE_ACTIVE,\n\t\t\t\t\t\t&inprogress);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\t/* Oops, that failed? */\n\t} while (inprogress);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void __synchronize_hardirq(struct irq_desc *desc, bool sync_chip)\n{\n\tstruct irq_data *irqd = irq_desc_get_irq_data(desc);\n\tbool inprogress;\n\n\tdo {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * Wait until we're out of the critical section.  This might\n\t\t * give the wrong answer due to the lack of memory barriers.\n\t\t */\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\n\t\t/* Ok, that indicated we're done: double-check carefully. */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tinprogress = irqd_irq_inprogress(&desc->irq_data);\n\n\t\t/*\n\t\t * If requested and supported, check at the chip whether it\n\t\t * is in flight at the hardware level, i.e. already pending\n\t\t * in a CPU and waiting for service and acknowledge.\n\t\t */\n\t\tif (!inprogress && sync_chip) {\n\t\t\t/*\n\t\t\t * Ignore the return code. inprogress is only updated\n\t\t\t * when the chip supports it.\n\t\t\t */\n\t\t\t__irq_get_irqchip_state(irqd, IRQCHIP_STATE_ACTIVE,\n\t\t\t\t\t\t&inprogress);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\t/* Oops, that failed? */\n\t} while (inprogress);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_handler_proc",
          "args": [
            "irq",
            "action"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_handler_proc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "125-126",
          "snippet": "static inline void unregister_handler_proc(unsigned int irq,\n\t\t\t\t\t   struct irqaction *action) { }",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\n\nstatic inline void unregister_handler_proc(unsigned int irq,\n\t\t\t\t\t   struct irqaction *action) { }"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "desc->affinity_hint"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_shutdown",
          "args": [
            "desc"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "irq_shutdown_and_deactivate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "323-333",
          "snippet": "void irq_shutdown_and_deactivate(struct irq_desc *desc)\n{\n\tirq_shutdown(desc);\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_shutdown_and_deactivate(struct irq_desc *desc)\n{\n\tirq_shutdown(desc);\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_clr_disable_unlazy",
          "args": [
            "desc"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_clr_disable_unlazy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "170-173",
          "snippet": "static inline void irq_settings_clr_disable_unlazy(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors &= ~_IRQ_DISABLE_UNLAZY;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void irq_settings_clr_disable_unlazy(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors &= ~_IRQ_DISABLE_UNLAZY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_pm_remove_action",
          "args": [
            "desc",
            "action"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "irq_pm_remove_action",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "280-281",
          "snippet": "static inline void\nirq_pm_remove_action(struct irq_desc *desc, struct irqaction *action) { }",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_pm_remove_action(struct irq_desc *desc, struct irqaction *action) { }"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Trying to free already-free IRQ %d\\n\"",
            "irq"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&desc->request_mutex"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "in_interrupt()",
            "\"Trying to free IRQ %d from IRQ context!\\n\"",
            "irq"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic struct irqaction *__free_irq(struct irq_desc *desc, void *dev_id)\n{\n\tunsigned irq = desc->irq_data.irq;\n\tstruct irqaction *action, **action_ptr;\n\tunsigned long flags;\n\n\tWARN(in_interrupt(), \"Trying to free IRQ %d from IRQ context!\\n\", irq);\n\n\tmutex_lock(&desc->request_mutex);\n\tchip_bus_lock(desc);\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t/*\n\t * There can be multiple actions per IRQ descriptor, find the right\n\t * one based on the dev_id:\n\t */\n\taction_ptr = &desc->action;\n\tfor (;;) {\n\t\taction = *action_ptr;\n\n\t\tif (!action) {\n\t\t\tWARN(1, \"Trying to free already-free IRQ %d\\n\", irq);\n\t\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t\t\tchip_bus_sync_unlock(desc);\n\t\t\tmutex_unlock(&desc->request_mutex);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (action->dev_id == dev_id)\n\t\t\tbreak;\n\t\taction_ptr = &action->next;\n\t}\n\n\t/* Found it - now remove it from the list of entries: */\n\t*action_ptr = action->next;\n\n\tirq_pm_remove_action(desc, action);\n\n\t/* If this was the last handler, shut down the IRQ line: */\n\tif (!desc->action) {\n\t\tirq_settings_clr_disable_unlazy(desc);\n\t\t/* Only shutdown. Deactivate after synchronize_hardirq() */\n\t\tirq_shutdown(desc);\n\t}\n\n#ifdef CONFIG_SMP\n\t/* make sure affinity_hint is cleaned up */\n\tif (WARN_ON_ONCE(desc->affinity_hint))\n\t\tdesc->affinity_hint = NULL;\n#endif\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t/*\n\t * Drop bus_lock here so the changes which were done in the chip\n\t * callbacks above are synced out to the irq chips which hang\n\t * behind a slow bus (I2C, SPI) before calling synchronize_hardirq().\n\t *\n\t * Aside of that the bus_lock can also be taken from the threaded\n\t * handler in irq_finalize_oneshot() which results in a deadlock\n\t * because kthread_stop() would wait forever for the thread to\n\t * complete, which is blocked on the bus lock.\n\t *\n\t * The still held desc->request_mutex() protects against a\n\t * concurrent request_irq() of this irq so the release of resources\n\t * and timing data is properly serialized.\n\t */\n\tchip_bus_sync_unlock(desc);\n\n\tunregister_handler_proc(irq, action);\n\n\t/*\n\t * Make sure it's not being used on another CPU and if the chip\n\t * supports it also make sure that there is no (not yet serviced)\n\t * interrupt in flight at the hardware level.\n\t */\n\t__synchronize_hardirq(desc, true);\n\n#ifdef CONFIG_DEBUG_SHIRQ\n\t/*\n\t * It's a shared IRQ -- the driver ought to be prepared for an IRQ\n\t * event to happen even now it's being freed, so let's make sure that\n\t * is so by doing an extra call to the handler ....\n\t *\n\t * ( We do this after actually deregistering it, to make sure that a\n\t *   'real' IRQ doesn't run in parallel with our fake. )\n\t */\n\tif (action->flags & IRQF_SHARED) {\n\t\tlocal_irq_save(flags);\n\t\taction->handler(irq, dev_id);\n\t\tlocal_irq_restore(flags);\n\t}\n#endif\n\n\t/*\n\t * The action has already been removed above, but the thread writes\n\t * its oneshot mask bit when it completes. Though request_mutex is\n\t * held across this which prevents __setup_irq() from handing out\n\t * the same bit to a newly requested action.\n\t */\n\tif (action->thread) {\n\t\tkthread_stop(action->thread);\n\t\tput_task_struct(action->thread);\n\t\tif (action->secondary && action->secondary->thread) {\n\t\t\tkthread_stop(action->secondary->thread);\n\t\t\tput_task_struct(action->secondary->thread);\n\t\t}\n\t}\n\n\t/* Last action releases resources */\n\tif (!desc->action) {\n\t\t/*\n\t\t * Reacquire bus lock as irq_release_resources() might\n\t\t * require it to deallocate resources over the slow bus.\n\t\t */\n\t\tchip_bus_lock(desc);\n\t\t/*\n\t\t * There is no interrupt on the fly anymore. Deactivate it\n\t\t * completely.\n\t\t */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tirq_domain_deactivate_irq(&desc->irq_data);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\tirq_release_resources(desc);\n\t\tchip_bus_sync_unlock(desc);\n\t\tirq_remove_timings(desc);\n\t}\n\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_chip_pm_put(&desc->irq_data);\n\tmodule_put(desc->owner);\n\tkfree(action->secondary);\n\treturn action;\n}"
  },
  {
    "function_name": "__setup_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1462-1834",
    "snippet": "static int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "desc->owner"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1087-1098",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "t"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "t"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&desc->request_mutex"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip_bus_sync_unlock",
          "args": [
            "desc"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "chip_bus_sync_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "149-153",
          "snippet": "static inline void chip_bus_sync_unlock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))\n\t\tdesc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void chip_bus_sync_unlock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))\n\t\tdesc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_release_resources",
          "args": [
            "desc"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "irq_release_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1371-1378",
          "snippet": "static void irq_release_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_release_resources)\n\t\tc->irq_release_resources(d);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_release_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_release_resources)\n\t\tc->irq_release_resources(d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\"",
            "irq",
            "new->flags",
            "new->name",
            "old->flags",
            "old->name"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_handler_proc",
          "args": [
            "irq",
            "new"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_handler_proc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "125-126",
          "snippet": "static inline void unregister_handler_proc(unsigned int irq,\n\t\t\t\t\t   struct irqaction *action) { }",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\n\nstatic inline void unregister_handler_proc(unsigned int irq,\n\t\t\t\t\t   struct irqaction *action) { }"
        }
      },
      {
        "call_info": {
          "callee": "register_irq_proc",
          "args": [
            "irq",
            "desc"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_irq_proc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "122-122",
          "snippet": "static inline void unregister_irq_proc(unsigned int irq, struct irq_desc *desc) { }",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void unregister_irq_proc(unsigned int irq, struct irq_desc *desc) { }"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "new->secondary->thread"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_setup_timings",
          "args": [
            "desc",
            "new"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "__enable_irq",
          "args": [
            "desc"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "__enable_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "769-795",
          "snippet": "void __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_pm_install_action",
          "args": [
            "desc",
            "new"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "irq_pm_install_action",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "278-279",
          "snippet": "static inline void\nirq_pm_install_action(struct irq_desc *desc, struct irqaction *action) { }",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_pm_install_action(struct irq_desc *desc, struct irqaction *action) { }"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"irq %d uses trigger mode %u; requested %u\\n\"",
            "irq",
            "omsk",
            "nmsk"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_get_trigger_type",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "new->flags & IRQF_SHARED"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_startup",
          "args": [
            "desc",
            "IRQ_RESEND",
            "IRQ_START_COND"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "irq_startup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "255-287",
          "snippet": "int irq_startup(struct irq_desc *desc, bool resend, bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct cpumask *aff = irq_data_get_affinity_mask(d);\n\tint ret = 0;\n\n\tdesc->depth = 0;\n\n\tif (irqd_is_started(d)) {\n\t\tirq_enable(desc);\n\t} else {\n\t\tswitch (__irq_startup_managed(desc, aff, force)) {\n\t\tcase IRQ_STARTUP_NORMAL:\n\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tret = __irq_startup(desc);\n\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_MANAGED:\n\t\t\tirq_do_set_affinity(d, aff, false);\n\t\t\tret = __irq_startup(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_ABORT:\n\t\t\tirqd_set_managed_shutdown(d);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (resend)\n\t\tcheck_irq_resend(desc, false);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_startup(struct irq_desc *desc, bool resend, bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct cpumask *aff = irq_data_get_affinity_mask(d);\n\tint ret = 0;\n\n\tdesc->depth = 0;\n\n\tif (irqd_is_started(d)) {\n\t\tirq_enable(desc);\n\t} else {\n\t\tswitch (__irq_startup_managed(desc, aff, force)) {\n\t\tcase IRQ_STARTUP_NORMAL:\n\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tret = __irq_startup(desc);\n\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_MANAGED:\n\t\t\tirq_do_set_affinity(d, aff, false);\n\t\t\tret = __irq_startup(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_ABORT:\n\t\t\tirqd_set_managed_shutdown(d);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (resend)\n\t\tcheck_irq_resend(desc, false);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_can_autoenable",
          "args": [
            "desc"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_can_autoenable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "150-153",
          "snippet": "static inline bool irq_settings_can_autoenable(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOAUTOEN);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_can_autoenable(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOAUTOEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "&desc->irq_data",
            "IRQD_NO_BALANCING"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_set_no_balancing",
          "args": [
            "desc"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_set_no_balancing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "63-66",
          "snippet": "static inline void irq_settings_set_no_balancing(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NO_BALANCING;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void irq_settings_set_no_balancing(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NO_BALANCING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_set_no_debug",
          "args": [
            "desc"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_set_no_debug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "180-183",
          "snippet": "static inline void irq_settings_set_no_debug(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NO_DEBUG;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void irq_settings_set_no_debug(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NO_DEBUG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_set_per_cpu",
          "args": [
            "desc"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "58-61",
          "snippet": "static inline void irq_settings_set_per_cpu(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_PER_CPU;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void irq_settings_set_per_cpu(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_PER_CPU;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "&desc->irq_data",
            "IRQD_IRQ_INPROGRESS"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_activate",
          "args": [
            "desc"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "irq_activate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "289-296",
          "snippet": "int irq_activate(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\tif (!irqd_affinity_is_managed(d))\n\t\treturn irq_domain_activate_irq(d, false);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_activate(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\tif (!irqd_affinity_is_managed(d))\n\t\treturn irq_domain_activate_irq(d, false);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_set_trigger",
          "args": [
            "desc",
            "new->flags & IRQF_TRIGGER_MASK"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_set_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "939-992",
          "snippet": "int __irq_set_trigger(struct irq_desc *desc, unsigned long flags)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\tint ret, unmask = 0;\n\n\tif (!chip || !chip->irq_set_type) {\n\t\t/*\n\t\t * IRQF_TRIGGER_* but the PIC does not support multiple\n\t\t * flow-types?\n\t\t */\n\t\tpr_debug(\"No set_type function for IRQ %d (%s)\\n\",\n\t\t\t irq_desc_get_irq(desc),\n\t\t\t chip ? (chip->name ? : \"unknown\") : \"unknown\");\n\t\treturn 0;\n\t}\n\n\tif (chip->flags & IRQCHIP_SET_TYPE_MASKED) {\n\t\tif (!irqd_irq_masked(&desc->irq_data))\n\t\t\tmask_irq(desc);\n\t\tif (!irqd_irq_disabled(&desc->irq_data))\n\t\t\tunmask = 1;\n\t}\n\n\t/* Mask all flags except trigger mode */\n\tflags &= IRQ_TYPE_SENSE_MASK;\n\tret = chip->irq_set_type(&desc->irq_data, flags);\n\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tirqd_clear(&desc->irq_data, IRQD_TRIGGER_MASK);\n\t\tirqd_set(&desc->irq_data, flags);\n\t\tfallthrough;\n\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tflags = irqd_get_trigger_type(&desc->irq_data);\n\t\tirq_settings_set_trigger_mask(desc, flags);\n\t\tirqd_clear(&desc->irq_data, IRQD_LEVEL);\n\t\tirq_settings_clr_level(desc);\n\t\tif (flags & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tirq_settings_set_level(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Setting trigger mode %lu for irq %u failed (%pS)\\n\",\n\t\t       flags, irq_desc_get_irq(desc), chip->irq_set_type);\n\t}\n\tif (unmask)\n\t\tunmask_irq(desc);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint __irq_set_trigger(struct irq_desc *desc, unsigned long flags)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\tint ret, unmask = 0;\n\n\tif (!chip || !chip->irq_set_type) {\n\t\t/*\n\t\t * IRQF_TRIGGER_* but the PIC does not support multiple\n\t\t * flow-types?\n\t\t */\n\t\tpr_debug(\"No set_type function for IRQ %d (%s)\\n\",\n\t\t\t irq_desc_get_irq(desc),\n\t\t\t chip ? (chip->name ? : \"unknown\") : \"unknown\");\n\t\treturn 0;\n\t}\n\n\tif (chip->flags & IRQCHIP_SET_TYPE_MASKED) {\n\t\tif (!irqd_irq_masked(&desc->irq_data))\n\t\t\tmask_irq(desc);\n\t\tif (!irqd_irq_disabled(&desc->irq_data))\n\t\t\tunmask = 1;\n\t}\n\n\t/* Mask all flags except trigger mode */\n\tflags &= IRQ_TYPE_SENSE_MASK;\n\tret = chip->irq_set_type(&desc->irq_data, flags);\n\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tirqd_clear(&desc->irq_data, IRQD_TRIGGER_MASK);\n\t\tirqd_set(&desc->irq_data, flags);\n\t\tfallthrough;\n\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tflags = irqd_get_trigger_type(&desc->irq_data);\n\t\tirq_settings_set_trigger_mask(desc, flags);\n\t\tirqd_clear(&desc->irq_data, IRQD_LEVEL);\n\t\tirq_settings_clr_level(desc);\n\t\tif (flags & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tirq_settings_set_level(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Setting trigger mode %lu for irq %u failed (%pS)\\n\",\n\t\t       flags, irq_desc_get_irq(desc), chip->irq_set_type);\n\t}\n\tif (unmask)\n\t\tunmask_irq(desc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&desc->wait_for_threads"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\"",
            "new->name",
            "irq"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "thread_mask"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_set_trigger_type",
          "args": [
            "&desc->irq_data",
            "oldtype"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_get_trigger_type",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_trigger_type_was_set",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\"",
            "new->name",
            "irq",
            "desc->irq_data.chip->name"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to request resources for %s (irq %d) on irqchip %s\\n\"",
            "new->name",
            "irq",
            "desc->irq_data.chip->name"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_request_resources",
          "args": [
            "desc"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "irq_request_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1363-1369",
          "snippet": "static int irq_request_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_request_resources ? c->irq_request_resources(d) : 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_request_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_request_resources ? c->irq_request_resources(d) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip_bus_lock",
          "args": [
            "desc"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "chip_bus_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "143-147",
          "snippet": "static inline void chip_bus_lock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_lock))\n\t\tdesc->irq_data.chip->irq_bus_lock(&desc->irq_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void chip_bus_lock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_lock))\n\t\tdesc->irq_data.chip->irq_bus_lock(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&desc->request_mutex"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_irq_thread",
          "args": [
            "new->secondary",
            "irq",
            "true"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "setup_irq_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1413-1446",
          "snippet": "static int\nsetup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary)\n{\n\tstruct task_struct *t;\n\n\tif (!secondary) {\n\t\tt = kthread_create(irq_thread, new, \"irq/%d-%s\", irq,\n\t\t\t\t   new->name);\n\t} else {\n\t\tt = kthread_create(irq_thread, new, \"irq/%d-s-%s\", irq,\n\t\t\t\t   new->name);\n\t}\n\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\t/*\n\t * We keep the reference to the task struct even if\n\t * the thread dies to avoid that the interrupt code\n\t * references an already freed task_struct.\n\t */\n\tnew->thread = get_task_struct(t);\n\t/*\n\t * Tell the thread to set its affinity. This is\n\t * important for shared interrupt handlers as we do\n\t * not invoke setup_affinity() for the secondary\n\t * handlers as everything is already set up. Even for\n\t * interrupts marked with IRQF_NO_BALANCE this is\n\t * correct as we want the thread to move to the cpu(s)\n\t * on which the requesting code placed the interrupt.\n\t */\n\tset_bit(IRQTF_AFFINITY, &new->thread_flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int\nsetup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary)\n{\n\tstruct task_struct *t;\n\n\tif (!secondary) {\n\t\tt = kthread_create(irq_thread, new, \"irq/%d-%s\", irq,\n\t\t\t\t   new->name);\n\t} else {\n\t\tt = kthread_create(irq_thread, new, \"irq/%d-s-%s\", irq,\n\t\t\t\t   new->name);\n\t}\n\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\t/*\n\t * We keep the reference to the task struct even if\n\t * the thread dies to avoid that the interrupt code\n\t * references an already freed task_struct.\n\t */\n\tnew->thread = get_task_struct(t);\n\t/*\n\t * Tell the thread to set its affinity. This is\n\t * important for shared interrupt handlers as we do\n\t * not invoke setup_affinity() for the secondary\n\t * handlers as everything is already set up. Even for\n\t * interrupts marked with IRQF_NO_BALANCE this is\n\t * correct as we want the thread to move to the cpu(s)\n\t * on which the requesting code placed the interrupt.\n\t */\n\tset_bit(IRQTF_AFFINITY, &new->thread_flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_setup_forced_threading",
          "args": [
            "new"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_forced_threading",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1324-1361",
          "snippet": "static int irq_setup_forced_threading(struct irqaction *new)\n{\n\tif (!force_irqthreads())\n\t\treturn 0;\n\tif (new->flags & (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT))\n\t\treturn 0;\n\n\t/*\n\t * No further action required for interrupts which are requested as\n\t * threaded interrupts already\n\t */\n\tif (new->handler == irq_default_primary_handler)\n\t\treturn 0;\n\n\tnew->flags |= IRQF_ONESHOT;\n\n\t/*\n\t * Handle the case where we have a real primary handler and a\n\t * thread handler. We force thread them as well by creating a\n\t * secondary action.\n\t */\n\tif (new->handler && new->thread_fn) {\n\t\t/* Allocate the secondary action */\n\t\tnew->secondary = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\t\tif (!new->secondary)\n\t\t\treturn -ENOMEM;\n\t\tnew->secondary->handler = irq_forced_secondary_handler;\n\t\tnew->secondary->thread_fn = new->thread_fn;\n\t\tnew->secondary->dev_id = new->dev_id;\n\t\tnew->secondary->irq = new->irq;\n\t\tnew->secondary->name = new->name;\n\t}\n\t/* Deal with the primary handler */\n\tset_bit(IRQTF_FORCED_THREAD, &new->thread_flags);\n\tnew->thread_fn = new->handler;\n\tnew->handler = irq_default_primary_handler;\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_setup_forced_threading(struct irqaction *new)\n{\n\tif (!force_irqthreads())\n\t\treturn 0;\n\tif (new->flags & (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT))\n\t\treturn 0;\n\n\t/*\n\t * No further action required for interrupts which are requested as\n\t * threaded interrupts already\n\t */\n\tif (new->handler == irq_default_primary_handler)\n\t\treturn 0;\n\n\tnew->flags |= IRQF_ONESHOT;\n\n\t/*\n\t * Handle the case where we have a real primary handler and a\n\t * thread handler. We force thread them as well by creating a\n\t * secondary action.\n\t */\n\tif (new->handler && new->thread_fn) {\n\t\t/* Allocate the secondary action */\n\t\tnew->secondary = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\t\tif (!new->secondary)\n\t\t\treturn -ENOMEM;\n\t\tnew->secondary->handler = irq_forced_secondary_handler;\n\t\tnew->secondary->thread_fn = new->thread_fn;\n\t\tnew->secondary->dev_id = new->dev_id;\n\t\tnew->secondary->irq = new->irq;\n\t\tnew->secondary->name = new->name;\n\t}\n\t/* Deal with the primary handler */\n\tset_bit(IRQTF_FORCED_THREAD, &new->thread_flags);\n\tnew->thread_fn = new->handler;\n\tnew->handler = irq_default_primary_handler;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_can_thread",
          "args": [
            "desc"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_can_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "115-118",
          "snippet": "static inline bool irq_settings_can_thread(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOTHREAD);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_can_thread(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOTHREAD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_nested_thread",
          "args": [
            "desc"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_nested_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "155-158",
          "snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_get_trigger_type",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "desc->owner"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\tnew->irq = irq;\n\n\t/*\n\t * If the trigger type is not specified by the caller,\n\t * then use the default for this interrupt.\n\t */\n\tif (!(new->flags & IRQF_TRIGGER_MASK))\n\t\tnew->flags |= irqd_get_trigger_type(&desc->irq_data);\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\tif (irq_settings_can_thread(desc)) {\n\t\t\tret = irq_setup_forced_threading(new);\n\t\t\tif (ret)\n\t\t\t\tgoto out_mput;\n\t\t}\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\tif (new->thread_fn && !nested) {\n\t\tret = setup_irq_thread(new, irq, false);\n\t\tif (ret)\n\t\t\tgoto out_mput;\n\t\tif (new->secondary) {\n\t\t\tret = setup_irq_thread(new->secondary, irq, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_thread;\n\t\t}\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * Protects against a concurrent __free_irq() call which might wait\n\t * for synchronize_hardirq() to complete without holding the optional\n\t * chip bus lock and desc->lock. Also protects against handing out\n\t * a recycled oneshot thread_mask bit while it's still in use by\n\t * its previous owner.\n\t */\n\tmutex_lock(&desc->request_mutex);\n\n\t/*\n\t * Acquire bus lock as the irq_request_resources() callback below\n\t * might rely on the serialization or the magic power management\n\t * functions which are abusing the irq_bus_lock() callback,\n\t */\n\tchip_bus_lock(desc);\n\n\t/* First installed action requests resources. */\n\tif (!desc->action) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_bus_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t * protected against a concurrent interrupt and any of the other\n\t * management calls which are not serialized via\n\t * desc->request_mutex or the optional bus lock.\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t * Interrupt lines used for NMIs cannot be shared.\n\t\t */\n\t\tunsigned int oldtype;\n\n\t\tif (desc->istate & IRQS_NMI) {\n\t\t\tpr_err(\"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\\n\",\n\t\t\t\tnew->name, irq, desc->irq_data.chip->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * If nobody did set the configuration before, inherit\n\t\t * the one provided by the requester.\n\t\t */\n\t\tif (irqd_trigger_type_was_set(&desc->irq_data)) {\n\t\t\toldtype = irqd_get_trigger_type(&desc->irq_data);\n\t\t} else {\n\t\t\toldtype = new->flags & IRQF_TRIGGER_MASK;\n\t\t\tirqd_set_trigger_type(&desc->irq_data, oldtype);\n\t\t}\n\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    (oldtype != (new->flags & IRQF_TRIGGER_MASK)) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1UL << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\\n\",\n\t\t       new->name, irq);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!shared) {\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc,\n\t\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Activate the interrupt. That activation must happen\n\t\t * independently of IRQ_NOAUTOEN. request_irq() can fail\n\t\t * and the callers are supposed to handle\n\t\t * that. enable_irq() of an interrupt requested with\n\t\t * IRQ_NOAUTOEN is not supposed to fail. The activation\n\t\t * keeps it in shutdown mode, it merily associates\n\t\t * resources if necessary and if that's not possible it\n\t\t * fails. Interrupts which are in managed shutdown mode\n\t\t * will simply ignore that activation request.\n\t\t */\n\t\tret = irq_activate(desc);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t\tif (new->flags & IRQF_NO_DEBUG)\n\t\t\t\tirq_settings_set_no_debug(desc);\n\t\t}\n\n\t\tif (noirqdebug)\n\t\t\tirq_settings_set_no_debug(desc);\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\tif (!(new->flags & IRQF_NO_AUTOEN) &&\n\t\t    irq_settings_can_autoenable(desc)) {\n\t\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Shared interrupts do not go well with disabling\n\t\t\t * auto enable. The sharing interrupt might request\n\t\t\t * it while it's still disabled and then wait for\n\t\t\t * interrupts forever.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(new->flags & IRQF_SHARED);\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\t\t}\n\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irqd_get_trigger_type(&desc->irq_data);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warn(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\tirq, omsk, nmsk);\n\t}\n\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\n\tirq_setup_timings(desc, new);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\tif (new->secondary)\n\t\twake_up_process(new->secondary->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (!desc->action)\n\t\tirq_release_resources(desc);\nout_bus_unlock:\n\tchip_bus_sync_unlock(desc);\n\tmutex_unlock(&desc->request_mutex);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\n\tif (new->secondary && new->secondary->thread) {\n\t\tstruct task_struct *t = new->secondary->thread;\n\n\t\tnew->secondary->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}"
  },
  {
    "function_name": "setup_irq_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1413-1446",
    "snippet": "static int\nsetup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary)\n{\n\tstruct task_struct *t;\n\n\tif (!secondary) {\n\t\tt = kthread_create(irq_thread, new, \"irq/%d-%s\", irq,\n\t\t\t\t   new->name);\n\t} else {\n\t\tt = kthread_create(irq_thread, new, \"irq/%d-s-%s\", irq,\n\t\t\t\t   new->name);\n\t}\n\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\t/*\n\t * We keep the reference to the task struct even if\n\t * the thread dies to avoid that the interrupt code\n\t * references an already freed task_struct.\n\t */\n\tnew->thread = get_task_struct(t);\n\t/*\n\t * Tell the thread to set its affinity. This is\n\t * important for shared interrupt handlers as we do\n\t * not invoke setup_affinity() for the secondary\n\t * handlers as everything is already set up. Even for\n\t * interrupts marked with IRQF_NO_BALANCE this is\n\t * correct as we want the thread to move to the cpu(s)\n\t * on which the requesting code placed the interrupt.\n\t */\n\tset_bit(IRQTF_AFFINITY, &new->thread_flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "IRQTF_AFFINITY",
            "&new->thread_flags"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "t"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "t"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "irq_thread",
            "new",
            "\"irq/%d-s-%s\"",
            "irq",
            "new->name"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "882-893",
          "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int\nsetup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary)\n{\n\tstruct task_struct *t;\n\n\tif (!secondary) {\n\t\tt = kthread_create(irq_thread, new, \"irq/%d-%s\", irq,\n\t\t\t\t   new->name);\n\t} else {\n\t\tt = kthread_create(irq_thread, new, \"irq/%d-s-%s\", irq,\n\t\t\t\t   new->name);\n\t}\n\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\t/*\n\t * We keep the reference to the task struct even if\n\t * the thread dies to avoid that the interrupt code\n\t * references an already freed task_struct.\n\t */\n\tnew->thread = get_task_struct(t);\n\t/*\n\t * Tell the thread to set its affinity. This is\n\t * important for shared interrupt handlers as we do\n\t * not invoke setup_affinity() for the secondary\n\t * handlers as everything is already set up. Even for\n\t * interrupts marked with IRQF_NO_BALANCE this is\n\t * correct as we want the thread to move to the cpu(s)\n\t * on which the requesting code placed the interrupt.\n\t */\n\tset_bit(IRQTF_AFFINITY, &new->thread_flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_nmi_teardown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1404-1411",
    "snippet": "static void irq_nmi_teardown(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_nmi_teardown)\n\t\tc->irq_nmi_teardown(d);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->irq_nmi_teardown",
          "args": [
            "d"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "irq_nmi_teardown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1404-1411",
          "snippet": "static void irq_nmi_teardown(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_nmi_teardown)\n\t\tc->irq_nmi_teardown(d);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_nmi_teardown(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_nmi_teardown)\n\t\tc->irq_nmi_teardown(d);\n}"
  },
  {
    "function_name": "irq_nmi_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1396-1402",
    "snippet": "static int irq_nmi_setup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_nmi_setup ? c->irq_nmi_setup(d) : -EINVAL;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->irq_nmi_setup",
          "args": [
            "d"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "irq_nmi_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1396-1402",
          "snippet": "static int irq_nmi_setup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_nmi_setup ? c->irq_nmi_setup(d) : -EINVAL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_nmi_setup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_nmi_setup ? c->irq_nmi_setup(d) : -EINVAL;\n}"
  },
  {
    "function_name": "irq_supports_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1380-1394",
    "snippet": "static bool irq_supports_nmi(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t/* Only IRQs directly managed by the root irqchip can be set as NMI */\n\tif (d->parent_data)\n\t\treturn false;\n#endif\n\t/* Don't support NMIs for chips behind a slow bus */\n\tif (d->chip->irq_bus_lock || d->chip->irq_bus_sync_unlock)\n\t\treturn false;\n\n\treturn d->chip->flags & IRQCHIP_SUPPORTS_NMI;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic bool irq_supports_nmi(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t/* Only IRQs directly managed by the root irqchip can be set as NMI */\n\tif (d->parent_data)\n\t\treturn false;\n#endif\n\t/* Don't support NMIs for chips behind a slow bus */\n\tif (d->chip->irq_bus_lock || d->chip->irq_bus_sync_unlock)\n\t\treturn false;\n\n\treturn d->chip->flags & IRQCHIP_SUPPORTS_NMI;\n}"
  },
  {
    "function_name": "irq_release_resources",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1371-1378",
    "snippet": "static void irq_release_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_release_resources)\n\t\tc->irq_release_resources(d);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->irq_release_resources",
          "args": [
            "d"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "irq_release_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1371-1378",
          "snippet": "static void irq_release_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_release_resources)\n\t\tc->irq_release_resources(d);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_release_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\tif (c->irq_release_resources)\n\t\tc->irq_release_resources(d);\n}"
  },
  {
    "function_name": "irq_request_resources",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1363-1369",
    "snippet": "static int irq_request_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_request_resources ? c->irq_request_resources(d) : 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->irq_request_resources",
          "args": [
            "d"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "irq_request_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1363-1369",
          "snippet": "static int irq_request_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_request_resources ? c->irq_request_resources(d) : 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_request_resources(struct irq_desc *desc)\n{\n\tstruct irq_data *d = &desc->irq_data;\n\tstruct irq_chip *c = d->chip;\n\n\treturn c->irq_request_resources ? c->irq_request_resources(d) : 0;\n}"
  },
  {
    "function_name": "irq_setup_forced_threading",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1324-1361",
    "snippet": "static int irq_setup_forced_threading(struct irqaction *new)\n{\n\tif (!force_irqthreads())\n\t\treturn 0;\n\tif (new->flags & (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT))\n\t\treturn 0;\n\n\t/*\n\t * No further action required for interrupts which are requested as\n\t * threaded interrupts already\n\t */\n\tif (new->handler == irq_default_primary_handler)\n\t\treturn 0;\n\n\tnew->flags |= IRQF_ONESHOT;\n\n\t/*\n\t * Handle the case where we have a real primary handler and a\n\t * thread handler. We force thread them as well by creating a\n\t * secondary action.\n\t */\n\tif (new->handler && new->thread_fn) {\n\t\t/* Allocate the secondary action */\n\t\tnew->secondary = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\t\tif (!new->secondary)\n\t\t\treturn -ENOMEM;\n\t\tnew->secondary->handler = irq_forced_secondary_handler;\n\t\tnew->secondary->thread_fn = new->thread_fn;\n\t\tnew->secondary->dev_id = new->dev_id;\n\t\tnew->secondary->irq = new->irq;\n\t\tnew->secondary->name = new->name;\n\t}\n\t/* Deal with the primary handler */\n\tset_bit(IRQTF_FORCED_THREAD, &new->thread_flags);\n\tnew->thread_fn = new->handler;\n\tnew->handler = irq_default_primary_handler;\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "IRQTF_FORCED_THREAD",
            "&new->thread_flags"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct irqaction)",
            "GFP_KERNEL"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_irqthreads",
          "args": [],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_setup_forced_threading(struct irqaction *new)\n{\n\tif (!force_irqthreads())\n\t\treturn 0;\n\tif (new->flags & (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT))\n\t\treturn 0;\n\n\t/*\n\t * No further action required for interrupts which are requested as\n\t * threaded interrupts already\n\t */\n\tif (new->handler == irq_default_primary_handler)\n\t\treturn 0;\n\n\tnew->flags |= IRQF_ONESHOT;\n\n\t/*\n\t * Handle the case where we have a real primary handler and a\n\t * thread handler. We force thread them as well by creating a\n\t * secondary action.\n\t */\n\tif (new->handler && new->thread_fn) {\n\t\t/* Allocate the secondary action */\n\t\tnew->secondary = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\t\tif (!new->secondary)\n\t\t\treturn -ENOMEM;\n\t\tnew->secondary->handler = irq_forced_secondary_handler;\n\t\tnew->secondary->thread_fn = new->thread_fn;\n\t\tnew->secondary->dev_id = new->dev_id;\n\t\tnew->secondary->irq = new->irq;\n\t\tnew->secondary->name = new->name;\n\t}\n\t/* Deal with the primary handler */\n\tset_bit(IRQTF_FORCED_THREAD, &new->thread_flags);\n\tnew->thread_fn = new->handler;\n\tnew->handler = irq_default_primary_handler;\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_wake_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1303-1321",
    "snippet": "void irq_wake_thread(unsigned int irq, void *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tif (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tif (action->dev_id == dev_id) {\n\t\t\tif (action->thread)\n\t\t\t\t__irq_wake_thread(desc, action);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_wake_thread",
          "args": [
            "desc",
            "action"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_wake_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "61-137",
          "snippet": "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action)\n{\n\t/*\n\t * In case the thread crashed and was killed we just pretend that\n\t * we handled the interrupt. The hardirq handler has disabled the\n\t * device interrupt, so no irq storm is lurking.\n\t */\n\tif (action->thread->flags & PF_EXITING)\n\t\treturn;\n\n\t/*\n\t * Wake up the handler thread for this action. If the\n\t * RUNTHREAD bit is already set, nothing to do.\n\t */\n\tif (test_and_set_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\treturn;\n\n\t/*\n\t * It's safe to OR the mask lockless here. We have only two\n\t * places which write to threads_oneshot: This code and the\n\t * irq thread.\n\t *\n\t * This code is the hard irq context and can never run on two\n\t * cpus in parallel. If it ever does we have more serious\n\t * problems than this bitmask.\n\t *\n\t * The irq threads of this irq which clear their \"running\" bit\n\t * in threads_oneshot are serialized via desc->lock against\n\t * each other and they are serialized against this code by\n\t * IRQS_INPROGRESS.\n\t *\n\t * Hard irq handler:\n\t *\n\t *\tspin_lock(desc->lock);\n\t *\tdesc->state |= IRQS_INPROGRESS;\n\t *\tspin_unlock(desc->lock);\n\t *\tset_bit(IRQTF_RUNTHREAD, &action->thread_flags);\n\t *\tdesc->threads_oneshot |= mask;\n\t *\tspin_lock(desc->lock);\n\t *\tdesc->state &= ~IRQS_INPROGRESS;\n\t *\tspin_unlock(desc->lock);\n\t *\n\t * irq thread:\n\t *\n\t * again:\n\t *\tspin_lock(desc->lock);\n\t *\tif (desc->state & IRQS_INPROGRESS) {\n\t *\t\tspin_unlock(desc->lock);\n\t *\t\twhile(desc->state & IRQS_INPROGRESS)\n\t *\t\t\tcpu_relax();\n\t *\t\tgoto again;\n\t *\t}\n\t *\tif (!test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t *\t\tdesc->threads_oneshot &= ~mask;\n\t *\tspin_unlock(desc->lock);\n\t *\n\t * So either the thread waits for us to clear IRQS_INPROGRESS\n\t * or we are waiting in the flow handler for desc->lock to be\n\t * released before we reach this point. The thread also checks\n\t * IRQTF_RUNTHREAD under desc->lock. If set it leaves\n\t * threads_oneshot untouched and runs the thread another time.\n\t */\n\tdesc->threads_oneshot |= action->thread_mask;\n\n\t/*\n\t * We increment the threads_active counter in case we wake up\n\t * the irq thread. The irq thread decrements the counter when\n\t * it returns from the handler or in the exit path and wakes\n\t * up waiters which are stuck in synchronize_irq() when the\n\t * active count becomes zero. synchronize_irq() is serialized\n\t * against this code (hard irq handler) via IRQS_INPROGRESS\n\t * like the finalize_oneshot() code. See comment above.\n\t */\n\tatomic_inc(&desc->threads_active);\n\n\twake_up_process(action->thread);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action)\n{\n\t/*\n\t * In case the thread crashed and was killed we just pretend that\n\t * we handled the interrupt. The hardirq handler has disabled the\n\t * device interrupt, so no irq storm is lurking.\n\t */\n\tif (action->thread->flags & PF_EXITING)\n\t\treturn;\n\n\t/*\n\t * Wake up the handler thread for this action. If the\n\t * RUNTHREAD bit is already set, nothing to do.\n\t */\n\tif (test_and_set_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\treturn;\n\n\t/*\n\t * It's safe to OR the mask lockless here. We have only two\n\t * places which write to threads_oneshot: This code and the\n\t * irq thread.\n\t *\n\t * This code is the hard irq context and can never run on two\n\t * cpus in parallel. If it ever does we have more serious\n\t * problems than this bitmask.\n\t *\n\t * The irq threads of this irq which clear their \"running\" bit\n\t * in threads_oneshot are serialized via desc->lock against\n\t * each other and they are serialized against this code by\n\t * IRQS_INPROGRESS.\n\t *\n\t * Hard irq handler:\n\t *\n\t *\tspin_lock(desc->lock);\n\t *\tdesc->state |= IRQS_INPROGRESS;\n\t *\tspin_unlock(desc->lock);\n\t *\tset_bit(IRQTF_RUNTHREAD, &action->thread_flags);\n\t *\tdesc->threads_oneshot |= mask;\n\t *\tspin_lock(desc->lock);\n\t *\tdesc->state &= ~IRQS_INPROGRESS;\n\t *\tspin_unlock(desc->lock);\n\t *\n\t * irq thread:\n\t *\n\t * again:\n\t *\tspin_lock(desc->lock);\n\t *\tif (desc->state & IRQS_INPROGRESS) {\n\t *\t\tspin_unlock(desc->lock);\n\t *\t\twhile(desc->state & IRQS_INPROGRESS)\n\t *\t\t\tcpu_relax();\n\t *\t\tgoto again;\n\t *\t}\n\t *\tif (!test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t *\t\tdesc->threads_oneshot &= ~mask;\n\t *\tspin_unlock(desc->lock);\n\t *\n\t * So either the thread waits for us to clear IRQS_INPROGRESS\n\t * or we are waiting in the flow handler for desc->lock to be\n\t * released before we reach this point. The thread also checks\n\t * IRQTF_RUNTHREAD under desc->lock. If set it leaves\n\t * threads_oneshot untouched and runs the thread another time.\n\t */\n\tdesc->threads_oneshot |= action->thread_mask;\n\n\t/*\n\t * We increment the threads_active counter in case we wake up\n\t * the irq thread. The irq thread decrements the counter when\n\t * it returns from the handler or in the exit path and wakes\n\t * up waiters which are stuck in synchronize_irq() when the\n\t * active count becomes zero. synchronize_irq() is serialized\n\t * against this code (hard irq handler) via IRQS_INPROGRESS\n\t * like the finalize_oneshot() code. See comment above.\n\t */\n\tatomic_inc(&desc->threads_active);\n\n\twake_up_process(action->thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_action_of_desc",
          "args": [
            "desc",
            "action"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irq_settings_is_per_cpu_devid(desc)"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu_devid",
          "args": [
            "desc"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid irq_wake_thread(unsigned int irq, void *dev_id)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tif (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tif (action->dev_id == dev_id) {\n\t\t\tif (action->thread)\n\t\t\t\t__irq_wake_thread(desc, action);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n}"
  },
  {
    "function_name": "irq_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1254-1295",
    "snippet": "static int irq_thread(void *data)\n{\n\tstruct callback_head on_exit_work;\n\tstruct irqaction *action = data;\n\tstruct irq_desc *desc = irq_to_desc(action->irq);\n\tirqreturn_t (*handler_fn)(struct irq_desc *desc,\n\t\t\tstruct irqaction *action);\n\n\tsched_set_fifo(current);\n\n\tif (force_irqthreads() && test_bit(IRQTF_FORCED_THREAD,\n\t\t\t\t\t   &action->thread_flags))\n\t\thandler_fn = irq_forced_thread_fn;\n\telse\n\t\thandler_fn = irq_thread_fn;\n\n\tinit_task_work(&on_exit_work, irq_thread_dtor);\n\ttask_work_add(current, &on_exit_work, TWA_NONE);\n\n\tirq_thread_check_affinity(desc, action);\n\n\twhile (!irq_wait_for_interrupt(action)) {\n\t\tirqreturn_t action_ret;\n\n\t\tirq_thread_check_affinity(desc, action);\n\n\t\taction_ret = handler_fn(desc, action);\n\t\tif (action_ret == IRQ_WAKE_THREAD)\n\t\t\tirq_wake_secondary(desc, action);\n\n\t\twake_threads_waitq(desc);\n\t}\n\n\t/*\n\t * This is the regular exit path. __free_irq() is stopping the\n\t * thread via kthread_stop() after calling\n\t * synchronize_hardirq(). So neither IRQTF_RUNTHREAD nor the\n\t * oneshot mask bit can be set.\n\t */\n\ttask_work_cancel(current, irq_thread_dtor);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_work_cancel",
          "args": [
            "current",
            "irq_thread_dtor"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/task_work.c",
          "lines": "117-121",
          "snippet": "struct callback_head *\ntask_work_cancel(struct task_struct *task, task_work_func_t func)\n{\n\treturn task_work_cancel_match(task, task_work_func_match, func);\n}",
          "includes": [
            "#include <linux/resume_user_mode.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/resume_user_mode.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstruct callback_head *\ntask_work_cancel(struct task_struct *task, task_work_func_t func)\n{\n\treturn task_work_cancel_match(task, task_work_func_match, func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_threads_waitq",
          "args": [
            "desc"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "wake_threads_waitq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1206-1210",
          "snippet": "static void wake_threads_waitq(struct irq_desc *desc)\n{\n\tif (atomic_dec_and_test(&desc->threads_active))\n\t\twake_up(&desc->wait_for_threads);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void wake_threads_waitq(struct irq_desc *desc)\n{\n\tif (atomic_dec_and_test(&desc->threads_active))\n\t\twake_up(&desc->wait_for_threads);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_wake_secondary",
          "args": [
            "desc",
            "action"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "irq_wake_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1239-1249",
          "snippet": "static void irq_wake_secondary(struct irq_desc *desc, struct irqaction *action)\n{\n\tstruct irqaction *secondary = action->secondary;\n\n\tif (WARN_ON_ONCE(!secondary))\n\t\treturn;\n\n\traw_spin_lock_irq(&desc->lock);\n\t__irq_wake_thread(desc, secondary);\n\traw_spin_unlock_irq(&desc->lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_wake_secondary(struct irq_desc *desc, struct irqaction *action)\n{\n\tstruct irqaction *secondary = action->secondary;\n\n\tif (WARN_ON_ONCE(!secondary))\n\t\treturn;\n\n\traw_spin_lock_irq(&desc->lock);\n\t__irq_wake_thread(desc, secondary);\n\traw_spin_unlock_irq(&desc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handler_fn",
          "args": [
            "desc",
            "action"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_thread_check_affinity",
          "args": [
            "desc",
            "action"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "irq_thread_check_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1159-1160",
          "snippet": "static inline void\nirq_thread_check_affinity(struct irq_desc *desc, struct irqaction *action) { }",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic inline void\nirq_thread_check_affinity(struct irq_desc *desc, struct irqaction *action) { }"
        }
      },
      {
        "call_info": {
          "callee": "irq_wait_for_interrupt",
          "args": [
            "action"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "irq_wait_for_interrupt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1037-1060",
          "snippet": "static int irq_wait_for_interrupt(struct irqaction *action)\n{\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (kthread_should_stop()) {\n\t\t\t/* may need to run one last time */\n\t\t\tif (test_and_clear_bit(IRQTF_RUNTHREAD,\n\t\t\t\t\t       &action->thread_flags)) {\n\t\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (test_and_clear_bit(IRQTF_RUNTHREAD,\n\t\t\t\t       &action->thread_flags)) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\treturn 0;\n\t\t}\n\t\tschedule();\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_wait_for_interrupt(struct irqaction *action)\n{\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (kthread_should_stop()) {\n\t\t\t/* may need to run one last time */\n\t\t\tif (test_and_clear_bit(IRQTF_RUNTHREAD,\n\t\t\t\t\t       &action->thread_flags)) {\n\t\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (test_and_clear_bit(IRQTF_RUNTHREAD,\n\t\t\t\t       &action->thread_flags)) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\treturn 0;\n\t\t}\n\t\tschedule();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_work_add",
          "args": [
            "current",
            "&on_exit_work",
            "TWA_NONE"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/task_work.c",
          "lines": "32-62",
          "snippet": "int task_work_add(struct task_struct *task, struct callback_head *work,\n\t\t  enum task_work_notify_mode notify)\n{\n\tstruct callback_head *head;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack(work);\n\n\tdo {\n\t\thead = READ_ONCE(task->task_works);\n\t\tif (unlikely(head == &work_exited))\n\t\t\treturn -ESRCH;\n\t\twork->next = head;\n\t} while (cmpxchg(&task->task_works, head, work) != head);\n\n\tswitch (notify) {\n\tcase TWA_NONE:\n\t\tbreak;\n\tcase TWA_RESUME:\n\t\tset_notify_resume(task);\n\t\tbreak;\n\tcase TWA_SIGNAL:\n\t\tset_notify_signal(task);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/resume_user_mode.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_head work_exited;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/resume_user_mode.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nint task_work_add(struct task_struct *task, struct callback_head *work,\n\t\t  enum task_work_notify_mode notify)\n{\n\tstruct callback_head *head;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack(work);\n\n\tdo {\n\t\thead = READ_ONCE(task->task_works);\n\t\tif (unlikely(head == &work_exited))\n\t\t\treturn -ESRCH;\n\t\twork->next = head;\n\t} while (cmpxchg(&task->task_works, head, work) != head);\n\n\tswitch (notify) {\n\tcase TWA_NONE:\n\t\tbreak;\n\tcase TWA_RESUME:\n\t\tset_notify_resume(task);\n\t\tbreak;\n\tcase TWA_SIGNAL:\n\t\tset_notify_signal(task);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_task_work",
          "args": [
            "&on_exit_work",
            "irq_thread_dtor"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "IRQTF_FORCED_THREAD",
            "&action->thread_flags"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_irqthreads",
          "args": [],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_set_fifo",
          "args": [
            "current"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_fifo_low",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7599-7603",
          "snippet": "void sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "action->irq"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_thread(void *data)\n{\n\tstruct callback_head on_exit_work;\n\tstruct irqaction *action = data;\n\tstruct irq_desc *desc = irq_to_desc(action->irq);\n\tirqreturn_t (*handler_fn)(struct irq_desc *desc,\n\t\t\tstruct irqaction *action);\n\n\tsched_set_fifo(current);\n\n\tif (force_irqthreads() && test_bit(IRQTF_FORCED_THREAD,\n\t\t\t\t\t   &action->thread_flags))\n\t\thandler_fn = irq_forced_thread_fn;\n\telse\n\t\thandler_fn = irq_thread_fn;\n\n\tinit_task_work(&on_exit_work, irq_thread_dtor);\n\ttask_work_add(current, &on_exit_work, TWA_NONE);\n\n\tirq_thread_check_affinity(desc, action);\n\n\twhile (!irq_wait_for_interrupt(action)) {\n\t\tirqreturn_t action_ret;\n\n\t\tirq_thread_check_affinity(desc, action);\n\n\t\taction_ret = handler_fn(desc, action);\n\t\tif (action_ret == IRQ_WAKE_THREAD)\n\t\t\tirq_wake_secondary(desc, action);\n\n\t\twake_threads_waitq(desc);\n\t}\n\n\t/*\n\t * This is the regular exit path. __free_irq() is stopping the\n\t * thread via kthread_stop() after calling\n\t * synchronize_hardirq(). So neither IRQTF_RUNTHREAD nor the\n\t * oneshot mask bit can be set.\n\t */\n\ttask_work_cancel(current, irq_thread_dtor);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_wake_secondary",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1239-1249",
    "snippet": "static void irq_wake_secondary(struct irq_desc *desc, struct irqaction *action)\n{\n\tstruct irqaction *secondary = action->secondary;\n\n\tif (WARN_ON_ONCE(!secondary))\n\t\treturn;\n\n\traw_spin_lock_irq(&desc->lock);\n\t__irq_wake_thread(desc, secondary);\n\traw_spin_unlock_irq(&desc->lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_wake_thread",
          "args": [
            "desc",
            "secondary"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_wake_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "61-137",
          "snippet": "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action)\n{\n\t/*\n\t * In case the thread crashed and was killed we just pretend that\n\t * we handled the interrupt. The hardirq handler has disabled the\n\t * device interrupt, so no irq storm is lurking.\n\t */\n\tif (action->thread->flags & PF_EXITING)\n\t\treturn;\n\n\t/*\n\t * Wake up the handler thread for this action. If the\n\t * RUNTHREAD bit is already set, nothing to do.\n\t */\n\tif (test_and_set_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\treturn;\n\n\t/*\n\t * It's safe to OR the mask lockless here. We have only two\n\t * places which write to threads_oneshot: This code and the\n\t * irq thread.\n\t *\n\t * This code is the hard irq context and can never run on two\n\t * cpus in parallel. If it ever does we have more serious\n\t * problems than this bitmask.\n\t *\n\t * The irq threads of this irq which clear their \"running\" bit\n\t * in threads_oneshot are serialized via desc->lock against\n\t * each other and they are serialized against this code by\n\t * IRQS_INPROGRESS.\n\t *\n\t * Hard irq handler:\n\t *\n\t *\tspin_lock(desc->lock);\n\t *\tdesc->state |= IRQS_INPROGRESS;\n\t *\tspin_unlock(desc->lock);\n\t *\tset_bit(IRQTF_RUNTHREAD, &action->thread_flags);\n\t *\tdesc->threads_oneshot |= mask;\n\t *\tspin_lock(desc->lock);\n\t *\tdesc->state &= ~IRQS_INPROGRESS;\n\t *\tspin_unlock(desc->lock);\n\t *\n\t * irq thread:\n\t *\n\t * again:\n\t *\tspin_lock(desc->lock);\n\t *\tif (desc->state & IRQS_INPROGRESS) {\n\t *\t\tspin_unlock(desc->lock);\n\t *\t\twhile(desc->state & IRQS_INPROGRESS)\n\t *\t\t\tcpu_relax();\n\t *\t\tgoto again;\n\t *\t}\n\t *\tif (!test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t *\t\tdesc->threads_oneshot &= ~mask;\n\t *\tspin_unlock(desc->lock);\n\t *\n\t * So either the thread waits for us to clear IRQS_INPROGRESS\n\t * or we are waiting in the flow handler for desc->lock to be\n\t * released before we reach this point. The thread also checks\n\t * IRQTF_RUNTHREAD under desc->lock. If set it leaves\n\t * threads_oneshot untouched and runs the thread another time.\n\t */\n\tdesc->threads_oneshot |= action->thread_mask;\n\n\t/*\n\t * We increment the threads_active counter in case we wake up\n\t * the irq thread. The irq thread decrements the counter when\n\t * it returns from the handler or in the exit path and wakes\n\t * up waiters which are stuck in synchronize_irq() when the\n\t * active count becomes zero. synchronize_irq() is serialized\n\t * against this code (hard irq handler) via IRQS_INPROGRESS\n\t * like the finalize_oneshot() code. See comment above.\n\t */\n\tatomic_inc(&desc->threads_active);\n\n\twake_up_process(action->thread);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action)\n{\n\t/*\n\t * In case the thread crashed and was killed we just pretend that\n\t * we handled the interrupt. The hardirq handler has disabled the\n\t * device interrupt, so no irq storm is lurking.\n\t */\n\tif (action->thread->flags & PF_EXITING)\n\t\treturn;\n\n\t/*\n\t * Wake up the handler thread for this action. If the\n\t * RUNTHREAD bit is already set, nothing to do.\n\t */\n\tif (test_and_set_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\treturn;\n\n\t/*\n\t * It's safe to OR the mask lockless here. We have only two\n\t * places which write to threads_oneshot: This code and the\n\t * irq thread.\n\t *\n\t * This code is the hard irq context and can never run on two\n\t * cpus in parallel. If it ever does we have more serious\n\t * problems than this bitmask.\n\t *\n\t * The irq threads of this irq which clear their \"running\" bit\n\t * in threads_oneshot are serialized via desc->lock against\n\t * each other and they are serialized against this code by\n\t * IRQS_INPROGRESS.\n\t *\n\t * Hard irq handler:\n\t *\n\t *\tspin_lock(desc->lock);\n\t *\tdesc->state |= IRQS_INPROGRESS;\n\t *\tspin_unlock(desc->lock);\n\t *\tset_bit(IRQTF_RUNTHREAD, &action->thread_flags);\n\t *\tdesc->threads_oneshot |= mask;\n\t *\tspin_lock(desc->lock);\n\t *\tdesc->state &= ~IRQS_INPROGRESS;\n\t *\tspin_unlock(desc->lock);\n\t *\n\t * irq thread:\n\t *\n\t * again:\n\t *\tspin_lock(desc->lock);\n\t *\tif (desc->state & IRQS_INPROGRESS) {\n\t *\t\tspin_unlock(desc->lock);\n\t *\t\twhile(desc->state & IRQS_INPROGRESS)\n\t *\t\t\tcpu_relax();\n\t *\t\tgoto again;\n\t *\t}\n\t *\tif (!test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t *\t\tdesc->threads_oneshot &= ~mask;\n\t *\tspin_unlock(desc->lock);\n\t *\n\t * So either the thread waits for us to clear IRQS_INPROGRESS\n\t * or we are waiting in the flow handler for desc->lock to be\n\t * released before we reach this point. The thread also checks\n\t * IRQTF_RUNTHREAD under desc->lock. If set it leaves\n\t * threads_oneshot untouched and runs the thread another time.\n\t */\n\tdesc->threads_oneshot |= action->thread_mask;\n\n\t/*\n\t * We increment the threads_active counter in case we wake up\n\t * the irq thread. The irq thread decrements the counter when\n\t * it returns from the handler or in the exit path and wakes\n\t * up waiters which are stuck in synchronize_irq() when the\n\t * active count becomes zero. synchronize_irq() is serialized\n\t * against this code (hard irq handler) via IRQS_INPROGRESS\n\t * like the finalize_oneshot() code. See comment above.\n\t */\n\tatomic_inc(&desc->threads_active);\n\n\twake_up_process(action->thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!secondary"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_wake_secondary(struct irq_desc *desc, struct irqaction *action)\n{\n\tstruct irqaction *secondary = action->secondary;\n\n\tif (WARN_ON_ONCE(!secondary))\n\t\treturn;\n\n\traw_spin_lock_irq(&desc->lock);\n\t__irq_wake_thread(desc, secondary);\n\traw_spin_unlock_irq(&desc->lock);\n}"
  },
  {
    "function_name": "irq_thread_dtor",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1212-1237",
    "snippet": "static void irq_thread_dtor(struct callback_head *unused)\n{\n\tstruct task_struct *tsk = current;\n\tstruct irq_desc *desc;\n\tstruct irqaction *action;\n\n\tif (WARN_ON_ONCE(!(current->flags & PF_EXITING)))\n\t\treturn;\n\n\taction = kthread_data(tsk);\n\n\tpr_err(\"exiting task \\\"%s\\\" (%d) is an active IRQ thread (irq %d)\\n\",\n\t       tsk->comm, tsk->pid, action->irq);\n\n\n\tdesc = irq_to_desc(action->irq);\n\t/*\n\t * If IRQTF_RUNTHREAD is set, we need to decrement\n\t * desc->threads_active and wake possible waiters.\n\t */\n\tif (test_and_clear_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\twake_threads_waitq(desc);\n\n\t/* Prevent a stale desc->threads_oneshot */\n\tirq_finalize_oneshot(desc, action);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_finalize_oneshot",
          "args": [
            "desc",
            "action"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "irq_finalize_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1067-1115",
          "snippet": "static void irq_finalize_oneshot(struct irq_desc *desc,\n\t\t\t\t struct irqaction *action)\n{\n\tif (!(desc->istate & IRQS_ONESHOT) ||\n\t    action->handler == irq_forced_secondary_handler)\n\t\treturn;\nagain:\n\tchip_bus_lock(desc);\n\traw_spin_lock_irq(&desc->lock);\n\n\t/*\n\t * Implausible though it may be we need to protect us against\n\t * the following scenario:\n\t *\n\t * The thread is faster done than the hard interrupt handler\n\t * on the other CPU. If we unmask the irq line then the\n\t * interrupt can come in again and masks the line, leaves due\n\t * to IRQS_INPROGRESS and the irq line is masked forever.\n\t *\n\t * This also serializes the state of shared oneshot handlers\n\t * versus \"desc->threads_oneshot |= action->thread_mask;\" in\n\t * irq_wake_thread(). See the comment there which explains the\n\t * serialization.\n\t */\n\tif (unlikely(irqd_irq_inprogress(&desc->irq_data))) {\n\t\traw_spin_unlock_irq(&desc->lock);\n\t\tchip_bus_sync_unlock(desc);\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\n\t/*\n\t * Now check again, whether the thread should run. Otherwise\n\t * we would clear the threads_oneshot bit of this thread which\n\t * was just set.\n\t */\n\tif (test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\tgoto out_unlock;\n\n\tdesc->threads_oneshot &= ~action->thread_mask;\n\n\tif (!desc->threads_oneshot && !irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data))\n\t\tunmask_threaded_irq(desc);\n\nout_unlock:\n\traw_spin_unlock_irq(&desc->lock);\n\tchip_bus_sync_unlock(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_finalize_oneshot(struct irq_desc *desc,\n\t\t\t\t struct irqaction *action)\n{\n\tif (!(desc->istate & IRQS_ONESHOT) ||\n\t    action->handler == irq_forced_secondary_handler)\n\t\treturn;\nagain:\n\tchip_bus_lock(desc);\n\traw_spin_lock_irq(&desc->lock);\n\n\t/*\n\t * Implausible though it may be we need to protect us against\n\t * the following scenario:\n\t *\n\t * The thread is faster done than the hard interrupt handler\n\t * on the other CPU. If we unmask the irq line then the\n\t * interrupt can come in again and masks the line, leaves due\n\t * to IRQS_INPROGRESS and the irq line is masked forever.\n\t *\n\t * This also serializes the state of shared oneshot handlers\n\t * versus \"desc->threads_oneshot |= action->thread_mask;\" in\n\t * irq_wake_thread(). See the comment there which explains the\n\t * serialization.\n\t */\n\tif (unlikely(irqd_irq_inprogress(&desc->irq_data))) {\n\t\traw_spin_unlock_irq(&desc->lock);\n\t\tchip_bus_sync_unlock(desc);\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\n\t/*\n\t * Now check again, whether the thread should run. Otherwise\n\t * we would clear the threads_oneshot bit of this thread which\n\t * was just set.\n\t */\n\tif (test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\tgoto out_unlock;\n\n\tdesc->threads_oneshot &= ~action->thread_mask;\n\n\tif (!desc->threads_oneshot && !irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data))\n\t\tunmask_threaded_irq(desc);\n\nout_unlock:\n\traw_spin_unlock_irq(&desc->lock);\n\tchip_bus_sync_unlock(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_threads_waitq",
          "args": [
            "desc"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "wake_threads_waitq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1206-1210",
          "snippet": "static void wake_threads_waitq(struct irq_desc *desc)\n{\n\tif (atomic_dec_and_test(&desc->threads_active))\n\t\twake_up(&desc->wait_for_threads);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void wake_threads_waitq(struct irq_desc *desc)\n{\n\tif (atomic_dec_and_test(&desc->threads_active))\n\t\twake_up(&desc->wait_for_threads);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "IRQTF_RUNTHREAD",
            "&action->thread_flags"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "action->irq"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"exiting task \\\"%s\\\" (%d) is an active IRQ thread (irq %d)\\n\"",
            "tsk->comm",
            "tsk->pid",
            "action->irq"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_data",
          "args": [
            "tsk"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "233-236",
          "snippet": "void *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(current->flags & PF_EXITING)"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_thread_dtor(struct callback_head *unused)\n{\n\tstruct task_struct *tsk = current;\n\tstruct irq_desc *desc;\n\tstruct irqaction *action;\n\n\tif (WARN_ON_ONCE(!(current->flags & PF_EXITING)))\n\t\treturn;\n\n\taction = kthread_data(tsk);\n\n\tpr_err(\"exiting task \\\"%s\\\" (%d) is an active IRQ thread (irq %d)\\n\",\n\t       tsk->comm, tsk->pid, action->irq);\n\n\n\tdesc = irq_to_desc(action->irq);\n\t/*\n\t * If IRQTF_RUNTHREAD is set, we need to decrement\n\t * desc->threads_active and wake possible waiters.\n\t */\n\tif (test_and_clear_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\twake_threads_waitq(desc);\n\n\t/* Prevent a stale desc->threads_oneshot */\n\tirq_finalize_oneshot(desc, action);\n}"
  },
  {
    "function_name": "wake_threads_waitq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1206-1210",
    "snippet": "static void wake_threads_waitq(struct irq_desc *desc)\n{\n\tif (atomic_dec_and_test(&desc->threads_active))\n\t\twake_up(&desc->wait_for_threads);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&desc->wait_for_threads"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&desc->threads_active"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void wake_threads_waitq(struct irq_desc *desc)\n{\n\tif (atomic_dec_and_test(&desc->threads_active))\n\t\twake_up(&desc->wait_for_threads);\n}"
  },
  {
    "function_name": "irq_thread_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1193-1204",
    "snippet": "static irqreturn_t irq_thread_fn(struct irq_desc *desc,\n\t\tstruct irqaction *action)\n{\n\tirqreturn_t ret;\n\n\tret = action->thread_fn(action->irq, action->dev_id);\n\tif (ret == IRQ_HANDLED)\n\t\tatomic_inc(&desc->threads_handled);\n\n\tirq_finalize_oneshot(desc, action);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_finalize_oneshot",
          "args": [
            "desc",
            "action"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "irq_finalize_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1067-1115",
          "snippet": "static void irq_finalize_oneshot(struct irq_desc *desc,\n\t\t\t\t struct irqaction *action)\n{\n\tif (!(desc->istate & IRQS_ONESHOT) ||\n\t    action->handler == irq_forced_secondary_handler)\n\t\treturn;\nagain:\n\tchip_bus_lock(desc);\n\traw_spin_lock_irq(&desc->lock);\n\n\t/*\n\t * Implausible though it may be we need to protect us against\n\t * the following scenario:\n\t *\n\t * The thread is faster done than the hard interrupt handler\n\t * on the other CPU. If we unmask the irq line then the\n\t * interrupt can come in again and masks the line, leaves due\n\t * to IRQS_INPROGRESS and the irq line is masked forever.\n\t *\n\t * This also serializes the state of shared oneshot handlers\n\t * versus \"desc->threads_oneshot |= action->thread_mask;\" in\n\t * irq_wake_thread(). See the comment there which explains the\n\t * serialization.\n\t */\n\tif (unlikely(irqd_irq_inprogress(&desc->irq_data))) {\n\t\traw_spin_unlock_irq(&desc->lock);\n\t\tchip_bus_sync_unlock(desc);\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\n\t/*\n\t * Now check again, whether the thread should run. Otherwise\n\t * we would clear the threads_oneshot bit of this thread which\n\t * was just set.\n\t */\n\tif (test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\tgoto out_unlock;\n\n\tdesc->threads_oneshot &= ~action->thread_mask;\n\n\tif (!desc->threads_oneshot && !irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data))\n\t\tunmask_threaded_irq(desc);\n\nout_unlock:\n\traw_spin_unlock_irq(&desc->lock);\n\tchip_bus_sync_unlock(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_finalize_oneshot(struct irq_desc *desc,\n\t\t\t\t struct irqaction *action)\n{\n\tif (!(desc->istate & IRQS_ONESHOT) ||\n\t    action->handler == irq_forced_secondary_handler)\n\t\treturn;\nagain:\n\tchip_bus_lock(desc);\n\traw_spin_lock_irq(&desc->lock);\n\n\t/*\n\t * Implausible though it may be we need to protect us against\n\t * the following scenario:\n\t *\n\t * The thread is faster done than the hard interrupt handler\n\t * on the other CPU. If we unmask the irq line then the\n\t * interrupt can come in again and masks the line, leaves due\n\t * to IRQS_INPROGRESS and the irq line is masked forever.\n\t *\n\t * This also serializes the state of shared oneshot handlers\n\t * versus \"desc->threads_oneshot |= action->thread_mask;\" in\n\t * irq_wake_thread(). See the comment there which explains the\n\t * serialization.\n\t */\n\tif (unlikely(irqd_irq_inprogress(&desc->irq_data))) {\n\t\traw_spin_unlock_irq(&desc->lock);\n\t\tchip_bus_sync_unlock(desc);\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\n\t/*\n\t * Now check again, whether the thread should run. Otherwise\n\t * we would clear the threads_oneshot bit of this thread which\n\t * was just set.\n\t */\n\tif (test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\tgoto out_unlock;\n\n\tdesc->threads_oneshot &= ~action->thread_mask;\n\n\tif (!desc->threads_oneshot && !irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data))\n\t\tunmask_threaded_irq(desc);\n\nout_unlock:\n\traw_spin_unlock_irq(&desc->lock);\n\tchip_bus_sync_unlock(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&desc->threads_handled"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "action->thread_fn",
          "args": [
            "action->irq",
            "action->dev_id"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic irqreturn_t irq_thread_fn(struct irq_desc *desc,\n\t\tstruct irqaction *action)\n{\n\tirqreturn_t ret;\n\n\tret = action->thread_fn(action->irq, action->dev_id);\n\tif (ret == IRQ_HANDLED)\n\t\tatomic_inc(&desc->threads_handled);\n\n\tirq_finalize_oneshot(desc, action);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_forced_thread_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1169-1186",
    "snippet": "static irqreturn_t\nirq_forced_thread_fn(struct irq_desc *desc, struct irqaction *action)\n{\n\tirqreturn_t ret;\n\n\tlocal_bh_disable();\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tlocal_irq_disable();\n\tret = action->thread_fn(action->irq, action->dev_id);\n\tif (ret == IRQ_HANDLED)\n\t\tatomic_inc(&desc->threads_handled);\n\n\tirq_finalize_oneshot(desc, action);\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tlocal_irq_enable();\n\tlocal_bh_enable();\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "353-357",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_finalize_oneshot",
          "args": [
            "desc",
            "action"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "irq_finalize_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "1067-1115",
          "snippet": "static void irq_finalize_oneshot(struct irq_desc *desc,\n\t\t\t\t struct irqaction *action)\n{\n\tif (!(desc->istate & IRQS_ONESHOT) ||\n\t    action->handler == irq_forced_secondary_handler)\n\t\treturn;\nagain:\n\tchip_bus_lock(desc);\n\traw_spin_lock_irq(&desc->lock);\n\n\t/*\n\t * Implausible though it may be we need to protect us against\n\t * the following scenario:\n\t *\n\t * The thread is faster done than the hard interrupt handler\n\t * on the other CPU. If we unmask the irq line then the\n\t * interrupt can come in again and masks the line, leaves due\n\t * to IRQS_INPROGRESS and the irq line is masked forever.\n\t *\n\t * This also serializes the state of shared oneshot handlers\n\t * versus \"desc->threads_oneshot |= action->thread_mask;\" in\n\t * irq_wake_thread(). See the comment there which explains the\n\t * serialization.\n\t */\n\tif (unlikely(irqd_irq_inprogress(&desc->irq_data))) {\n\t\traw_spin_unlock_irq(&desc->lock);\n\t\tchip_bus_sync_unlock(desc);\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\n\t/*\n\t * Now check again, whether the thread should run. Otherwise\n\t * we would clear the threads_oneshot bit of this thread which\n\t * was just set.\n\t */\n\tif (test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\tgoto out_unlock;\n\n\tdesc->threads_oneshot &= ~action->thread_mask;\n\n\tif (!desc->threads_oneshot && !irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data))\n\t\tunmask_threaded_irq(desc);\n\nout_unlock:\n\traw_spin_unlock_irq(&desc->lock);\n\tchip_bus_sync_unlock(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_finalize_oneshot(struct irq_desc *desc,\n\t\t\t\t struct irqaction *action)\n{\n\tif (!(desc->istate & IRQS_ONESHOT) ||\n\t    action->handler == irq_forced_secondary_handler)\n\t\treturn;\nagain:\n\tchip_bus_lock(desc);\n\traw_spin_lock_irq(&desc->lock);\n\n\t/*\n\t * Implausible though it may be we need to protect us against\n\t * the following scenario:\n\t *\n\t * The thread is faster done than the hard interrupt handler\n\t * on the other CPU. If we unmask the irq line then the\n\t * interrupt can come in again and masks the line, leaves due\n\t * to IRQS_INPROGRESS and the irq line is masked forever.\n\t *\n\t * This also serializes the state of shared oneshot handlers\n\t * versus \"desc->threads_oneshot |= action->thread_mask;\" in\n\t * irq_wake_thread(). See the comment there which explains the\n\t * serialization.\n\t */\n\tif (unlikely(irqd_irq_inprogress(&desc->irq_data))) {\n\t\traw_spin_unlock_irq(&desc->lock);\n\t\tchip_bus_sync_unlock(desc);\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\n\t/*\n\t * Now check again, whether the thread should run. Otherwise\n\t * we would clear the threads_oneshot bit of this thread which\n\t * was just set.\n\t */\n\tif (test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\tgoto out_unlock;\n\n\tdesc->threads_oneshot &= ~action->thread_mask;\n\n\tif (!desc->threads_oneshot && !irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data))\n\t\tunmask_threaded_irq(desc);\n\nout_unlock:\n\traw_spin_unlock_irq(&desc->lock);\n\tchip_bus_sync_unlock(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&desc->threads_handled"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "action->thread_fn",
          "args": [
            "action->irq",
            "action->dev_id"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic irqreturn_t\nirq_forced_thread_fn(struct irq_desc *desc, struct irqaction *action)\n{\n\tirqreturn_t ret;\n\n\tlocal_bh_disable();\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tlocal_irq_disable();\n\tret = action->thread_fn(action->irq, action->dev_id);\n\tif (ret == IRQ_HANDLED)\n\t\tatomic_inc(&desc->threads_handled);\n\n\tirq_finalize_oneshot(desc, action);\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tlocal_irq_enable();\n\tlocal_bh_enable();\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_thread_check_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1159-1160",
    "snippet": "static inline void\nirq_thread_check_affinity(struct irq_desc *desc, struct irqaction *action) { }",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic inline void\nirq_thread_check_affinity(struct irq_desc *desc, struct irqaction *action) { }"
  },
  {
    "function_name": "irq_thread_check_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1121-1157",
    "snippet": "static void\nirq_thread_check_affinity(struct irq_desc *desc, struct irqaction *action)\n{\n\tcpumask_var_t mask;\n\tbool valid = true;\n\n\tif (!test_and_clear_bit(IRQTF_AFFINITY, &action->thread_flags))\n\t\treturn;\n\n\t/*\n\t * In case we are out of memory we set IRQTF_AFFINITY again and\n\t * try again next time\n\t */\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL)) {\n\t\tset_bit(IRQTF_AFFINITY, &action->thread_flags);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irq(&desc->lock);\n\t/*\n\t * This code is triggered unconditionally. Check the affinity\n\t * mask pointer. For CPU_MASK_OFFSTACK=n this is optimized out.\n\t */\n\tif (cpumask_available(desc->irq_common_data.affinity)) {\n\t\tconst struct cpumask *m;\n\n\t\tm = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tcpumask_copy(mask, m);\n\t} else {\n\t\tvalid = false;\n\t}\n\traw_spin_unlock_irq(&desc->lock);\n\n\tif (valid)\n\t\tset_cpus_allowed_ptr(current, mask);\n\tfree_cpumask_var(mask);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "mask"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "current",
            "mask"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "mask",
            "m"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_effective_affinity_mask",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_available",
          "args": [
            "desc->irq_common_data.affinity"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "IRQTF_AFFINITY",
            "&action->thread_flags"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&mask",
            "GFP_KERNEL"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "IRQTF_AFFINITY",
            "&action->thread_flags"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void\nirq_thread_check_affinity(struct irq_desc *desc, struct irqaction *action)\n{\n\tcpumask_var_t mask;\n\tbool valid = true;\n\n\tif (!test_and_clear_bit(IRQTF_AFFINITY, &action->thread_flags))\n\t\treturn;\n\n\t/*\n\t * In case we are out of memory we set IRQTF_AFFINITY again and\n\t * try again next time\n\t */\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL)) {\n\t\tset_bit(IRQTF_AFFINITY, &action->thread_flags);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irq(&desc->lock);\n\t/*\n\t * This code is triggered unconditionally. Check the affinity\n\t * mask pointer. For CPU_MASK_OFFSTACK=n this is optimized out.\n\t */\n\tif (cpumask_available(desc->irq_common_data.affinity)) {\n\t\tconst struct cpumask *m;\n\n\t\tm = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tcpumask_copy(mask, m);\n\t} else {\n\t\tvalid = false;\n\t}\n\traw_spin_unlock_irq(&desc->lock);\n\n\tif (valid)\n\t\tset_cpus_allowed_ptr(current, mask);\n\tfree_cpumask_var(mask);\n}"
  },
  {
    "function_name": "irq_finalize_oneshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1067-1115",
    "snippet": "static void irq_finalize_oneshot(struct irq_desc *desc,\n\t\t\t\t struct irqaction *action)\n{\n\tif (!(desc->istate & IRQS_ONESHOT) ||\n\t    action->handler == irq_forced_secondary_handler)\n\t\treturn;\nagain:\n\tchip_bus_lock(desc);\n\traw_spin_lock_irq(&desc->lock);\n\n\t/*\n\t * Implausible though it may be we need to protect us against\n\t * the following scenario:\n\t *\n\t * The thread is faster done than the hard interrupt handler\n\t * on the other CPU. If we unmask the irq line then the\n\t * interrupt can come in again and masks the line, leaves due\n\t * to IRQS_INPROGRESS and the irq line is masked forever.\n\t *\n\t * This also serializes the state of shared oneshot handlers\n\t * versus \"desc->threads_oneshot |= action->thread_mask;\" in\n\t * irq_wake_thread(). See the comment there which explains the\n\t * serialization.\n\t */\n\tif (unlikely(irqd_irq_inprogress(&desc->irq_data))) {\n\t\traw_spin_unlock_irq(&desc->lock);\n\t\tchip_bus_sync_unlock(desc);\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\n\t/*\n\t * Now check again, whether the thread should run. Otherwise\n\t * we would clear the threads_oneshot bit of this thread which\n\t * was just set.\n\t */\n\tif (test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\tgoto out_unlock;\n\n\tdesc->threads_oneshot &= ~action->thread_mask;\n\n\tif (!desc->threads_oneshot && !irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data))\n\t\tunmask_threaded_irq(desc);\n\nout_unlock:\n\traw_spin_unlock_irq(&desc->lock);\n\tchip_bus_sync_unlock(desc);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chip_bus_sync_unlock",
          "args": [
            "desc"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "chip_bus_sync_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "149-153",
          "snippet": "static inline void chip_bus_sync_unlock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))\n\t\tdesc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void chip_bus_sync_unlock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))\n\t\tdesc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmask_threaded_irq",
          "args": [
            "desc"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "unmask_threaded_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "443-451",
          "snippet": "void unmask_threaded_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\tif (chip->flags & IRQCHIP_EOI_THREADED)\n\t\tchip->irq_eoi(&desc->irq_data);\n\n\tunmask_irq(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid unmask_threaded_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\tif (chip->flags & IRQCHIP_EOI_THREADED)\n\t\tchip->irq_eoi(&desc->irq_data);\n\n\tunmask_irq(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_masked",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "IRQTF_RUNTHREAD",
            "&action->thread_flags"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "irqd_irq_inprogress(&desc->irq_data)"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_inprogress",
          "args": [
            "&desc->irq_data"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip_bus_lock",
          "args": [
            "desc"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "chip_bus_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "143-147",
          "snippet": "static inline void chip_bus_lock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_lock))\n\t\tdesc->irq_data.chip->irq_bus_lock(&desc->irq_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void chip_bus_lock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_lock))\n\t\tdesc->irq_data.chip->irq_bus_lock(&desc->irq_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_finalize_oneshot(struct irq_desc *desc,\n\t\t\t\t struct irqaction *action)\n{\n\tif (!(desc->istate & IRQS_ONESHOT) ||\n\t    action->handler == irq_forced_secondary_handler)\n\t\treturn;\nagain:\n\tchip_bus_lock(desc);\n\traw_spin_lock_irq(&desc->lock);\n\n\t/*\n\t * Implausible though it may be we need to protect us against\n\t * the following scenario:\n\t *\n\t * The thread is faster done than the hard interrupt handler\n\t * on the other CPU. If we unmask the irq line then the\n\t * interrupt can come in again and masks the line, leaves due\n\t * to IRQS_INPROGRESS and the irq line is masked forever.\n\t *\n\t * This also serializes the state of shared oneshot handlers\n\t * versus \"desc->threads_oneshot |= action->thread_mask;\" in\n\t * irq_wake_thread(). See the comment there which explains the\n\t * serialization.\n\t */\n\tif (unlikely(irqd_irq_inprogress(&desc->irq_data))) {\n\t\traw_spin_unlock_irq(&desc->lock);\n\t\tchip_bus_sync_unlock(desc);\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\n\t/*\n\t * Now check again, whether the thread should run. Otherwise\n\t * we would clear the threads_oneshot bit of this thread which\n\t * was just set.\n\t */\n\tif (test_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\tgoto out_unlock;\n\n\tdesc->threads_oneshot &= ~action->thread_mask;\n\n\tif (!desc->threads_oneshot && !irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data))\n\t\tunmask_threaded_irq(desc);\n\nout_unlock:\n\traw_spin_unlock_irq(&desc->lock);\n\tchip_bus_sync_unlock(desc);\n}"
  },
  {
    "function_name": "irq_wait_for_interrupt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1037-1060",
    "snippet": "static int irq_wait_for_interrupt(struct irqaction *action)\n{\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (kthread_should_stop()) {\n\t\t\t/* may need to run one last time */\n\t\t\tif (test_and_clear_bit(IRQTF_RUNTHREAD,\n\t\t\t\t\t       &action->thread_flags)) {\n\t\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (test_and_clear_bit(IRQTF_RUNTHREAD,\n\t\t\t\t       &action->thread_flags)) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\treturn 0;\n\t\t}\n\t\tschedule();\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "IRQTF_RUNTHREAD",
            "&action->thread_flags"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "IRQTF_RUNTHREAD",
            "&action->thread_flags"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_wait_for_interrupt(struct irqaction *action)\n{\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (kthread_should_stop()) {\n\t\t\t/* may need to run one last time */\n\t\t\tif (test_and_clear_bit(IRQTF_RUNTHREAD,\n\t\t\t\t\t       &action->thread_flags)) {\n\t\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (test_and_clear_bit(IRQTF_RUNTHREAD,\n\t\t\t\t       &action->thread_flags)) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\treturn 0;\n\t\t}\n\t\tschedule();\n\t}\n}"
  },
  {
    "function_name": "irq_forced_secondary_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1031-1035",
    "snippet": "static irqreturn_t irq_forced_secondary_handler(int irq, void *dev_id)\n{\n\tWARN(1, \"Secondary action handler called for irq %d\\n\", irq);\n\treturn IRQ_NONE;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Secondary action handler called for irq %d\\n\"",
            "irq"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic irqreturn_t irq_forced_secondary_handler(int irq, void *dev_id)\n{\n\tWARN(1, \"Secondary action handler called for irq %d\\n\", irq);\n\treturn IRQ_NONE;\n}"
  },
  {
    "function_name": "irq_nested_primary_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1025-1029",
    "snippet": "static irqreturn_t irq_nested_primary_handler(int irq, void *dev_id)\n{\n\tWARN(1, \"Primary handler called for nested irq %d\\n\", irq);\n\treturn IRQ_NONE;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Primary handler called for nested irq %d\\n\"",
            "irq"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic irqreturn_t irq_nested_primary_handler(int irq, void *dev_id)\n{\n\tWARN(1, \"Primary handler called for nested irq %d\\n\", irq);\n\treturn IRQ_NONE;\n}"
  },
  {
    "function_name": "irq_default_primary_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "1016-1019",
    "snippet": "static irqreturn_t irq_default_primary_handler(int irq, void *dev_id)\n{\n\treturn IRQ_WAKE_THREAD;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic irqreturn_t irq_default_primary_handler(int irq, void *dev_id)\n{\n\treturn IRQ_WAKE_THREAD;\n}"
  },
  {
    "function_name": "irq_set_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "995-1007",
    "snippet": "int irq_set_parent(int irq, int parent_irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tdesc->parent_irq = parent_irq;\n\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_set_parent(int irq, int parent_irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tdesc->parent_irq = parent_irq;\n\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "__irq_set_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "939-992",
    "snippet": "int __irq_set_trigger(struct irq_desc *desc, unsigned long flags)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\tint ret, unmask = 0;\n\n\tif (!chip || !chip->irq_set_type) {\n\t\t/*\n\t\t * IRQF_TRIGGER_* but the PIC does not support multiple\n\t\t * flow-types?\n\t\t */\n\t\tpr_debug(\"No set_type function for IRQ %d (%s)\\n\",\n\t\t\t irq_desc_get_irq(desc),\n\t\t\t chip ? (chip->name ? : \"unknown\") : \"unknown\");\n\t\treturn 0;\n\t}\n\n\tif (chip->flags & IRQCHIP_SET_TYPE_MASKED) {\n\t\tif (!irqd_irq_masked(&desc->irq_data))\n\t\t\tmask_irq(desc);\n\t\tif (!irqd_irq_disabled(&desc->irq_data))\n\t\t\tunmask = 1;\n\t}\n\n\t/* Mask all flags except trigger mode */\n\tflags &= IRQ_TYPE_SENSE_MASK;\n\tret = chip->irq_set_type(&desc->irq_data, flags);\n\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tirqd_clear(&desc->irq_data, IRQD_TRIGGER_MASK);\n\t\tirqd_set(&desc->irq_data, flags);\n\t\tfallthrough;\n\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tflags = irqd_get_trigger_type(&desc->irq_data);\n\t\tirq_settings_set_trigger_mask(desc, flags);\n\t\tirqd_clear(&desc->irq_data, IRQD_LEVEL);\n\t\tirq_settings_clr_level(desc);\n\t\tif (flags & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tirq_settings_set_level(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Setting trigger mode %lu for irq %u failed (%pS)\\n\",\n\t\t       flags, irq_desc_get_irq(desc), chip->irq_set_type);\n\t}\n\tif (unmask)\n\t\tunmask_irq(desc);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmask_irq",
          "args": [
            "desc"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "cond_unmask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "608-620",
          "snippet": "static void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void cond_unmask_irq(struct irq_desc *desc)\n{\n\t/*\n\t * We need to unmask in the following cases:\n\t * - Standard level irq (IRQF_ONESHOT is not set)\n\t * - Oneshot irq which did not wake the thread (caused by a\n\t *   spurious interrupt or a primary handler handling it\n\t *   completely).\n\t */\n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Setting trigger mode %lu for irq %u failed (%pS)\\n\"",
            "flags",
            "irq_desc_get_irq(desc)",
            "chip->irq_set_type"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "&desc->irq_data",
            "IRQD_LEVEL"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_set_level",
          "args": [
            "desc"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_set_level",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "95-98",
          "snippet": "static inline void irq_settings_set_level(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_LEVEL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void irq_settings_set_level(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_LEVEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_clr_level",
          "args": [
            "desc"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_clr_level",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "90-93",
          "snippet": "static inline void irq_settings_clr_level(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors &= ~_IRQ_LEVEL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void irq_settings_clr_level(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors &= ~_IRQ_LEVEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "&desc->irq_data",
            "IRQD_LEVEL"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_set_trigger_mask",
          "args": [
            "desc",
            "flags"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_set_trigger_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "78-83",
          "snippet": "static inline void\nirq_settings_set_trigger_mask(struct irq_desc *desc, u32 mask)\n{\n\tdesc->status_use_accessors &= ~IRQ_TYPE_SENSE_MASK;\n\tdesc->status_use_accessors |= mask & IRQ_TYPE_SENSE_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nirq_settings_set_trigger_mask(struct irq_desc *desc, u32 mask)\n{\n\tdesc->status_use_accessors &= ~IRQ_TYPE_SENSE_MASK;\n\tdesc->status_use_accessors |= mask & IRQ_TYPE_SENSE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_get_trigger_type",
          "args": [
            "&desc->irq_data"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chip->irq_set_type",
          "args": [
            "&desc->irq_data",
            "flags"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mask_irq",
          "args": [
            "desc"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "handle_fasteoi_mask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1249-1285",
          "snippet": "void handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_masked",
          "args": [
            "&desc->irq_data"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"No set_type function for IRQ %d (%s)\\n\"",
            "irq_desc_get_irq(desc)",
            "chip ? (chip->name ? : \"unknown\") : \"unknown\""
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint __irq_set_trigger(struct irq_desc *desc, unsigned long flags)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\tint ret, unmask = 0;\n\n\tif (!chip || !chip->irq_set_type) {\n\t\t/*\n\t\t * IRQF_TRIGGER_* but the PIC does not support multiple\n\t\t * flow-types?\n\t\t */\n\t\tpr_debug(\"No set_type function for IRQ %d (%s)\\n\",\n\t\t\t irq_desc_get_irq(desc),\n\t\t\t chip ? (chip->name ? : \"unknown\") : \"unknown\");\n\t\treturn 0;\n\t}\n\n\tif (chip->flags & IRQCHIP_SET_TYPE_MASKED) {\n\t\tif (!irqd_irq_masked(&desc->irq_data))\n\t\t\tmask_irq(desc);\n\t\tif (!irqd_irq_disabled(&desc->irq_data))\n\t\t\tunmask = 1;\n\t}\n\n\t/* Mask all flags except trigger mode */\n\tflags &= IRQ_TYPE_SENSE_MASK;\n\tret = chip->irq_set_type(&desc->irq_data, flags);\n\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tirqd_clear(&desc->irq_data, IRQD_TRIGGER_MASK);\n\t\tirqd_set(&desc->irq_data, flags);\n\t\tfallthrough;\n\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tflags = irqd_get_trigger_type(&desc->irq_data);\n\t\tirq_settings_set_trigger_mask(desc, flags);\n\t\tirqd_clear(&desc->irq_data, IRQD_LEVEL);\n\t\tirq_settings_clr_level(desc);\n\t\tif (flags & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tirq_settings_set_level(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Setting trigger mode %lu for irq %u failed (%pS)\\n\",\n\t\t       flags, irq_desc_get_irq(desc), chip->irq_set_type);\n\t}\n\tif (unmask)\n\t\tunmask_irq(desc);\n\treturn ret;\n}"
  },
  {
    "function_name": "can_request_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "921-937",
    "snippet": "int can_request_irq(unsigned int irq, unsigned long irqflags)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\tint canrequest = 0;\n\n\tif (!desc)\n\t\treturn 0;\n\n\tif (irq_settings_can_request(desc)) {\n\t\tif (!desc->action ||\n\t\t    irqflags & desc->action->flags & IRQF_SHARED)\n\t\t\tcanrequest = 1;\n\t}\n\tirq_put_desc_unlock(desc, flags);\n\treturn canrequest;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_can_request",
          "args": [
            "desc"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_can_request",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "100-103",
          "snippet": "static inline bool irq_settings_can_request(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOREQUEST);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_can_request(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOREQUEST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint can_request_irq(unsigned int irq, unsigned long irqflags)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\tint canrequest = 0;\n\n\tif (!desc)\n\t\treturn 0;\n\n\tif (irq_settings_can_request(desc)) {\n\t\tif (!desc->action ||\n\t\t    irqflags & desc->action->flags & IRQF_SHARED)\n\t\t\tcanrequest = 1;\n\t}\n\tirq_put_desc_unlock(desc, flags);\n\treturn canrequest;\n}"
  },
  {
    "function_name": "irq_set_irq_wake",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "872-913",
    "snippet": "int irq_set_irq_wake(unsigned int irq, unsigned int on)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\tint ret = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/* Don't use NMIs as wake up interrupts please */\n\tif (desc->istate & IRQS_NMI) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* wakeup-capable irqs can be shared between drivers that\n\t * don't need to have the same sleep mode behaviors.\n\t */\n\tif (on) {\n\t\tif (desc->wake_depth++ == 0) {\n\t\t\tret = set_irq_wake_real(irq, on);\n\t\t\tif (ret)\n\t\t\t\tdesc->wake_depth = 0;\n\t\t\telse\n\t\t\t\tirqd_set(&desc->irq_data, IRQD_WAKEUP_STATE);\n\t\t}\n\t} else {\n\t\tif (desc->wake_depth == 0) {\n\t\t\tWARN(1, \"Unbalanced IRQ %d wake disable\\n\", irq);\n\t\t} else if (--desc->wake_depth == 0) {\n\t\t\tret = set_irq_wake_real(irq, on);\n\t\t\tif (ret)\n\t\t\t\tdesc->wake_depth = 1;\n\t\t\telse\n\t\t\t\tirqd_clear(&desc->irq_data, IRQD_WAKEUP_STATE);\n\t\t}\n\t}\n\nout_unlock:\n\tirq_put_desc_busunlock(desc, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_busunlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_busunlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "175-179",
          "snippet": "static inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "&desc->irq_data",
            "IRQD_WAKEUP_STATE"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_irq_wake_real",
          "args": [
            "irq",
            "on"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "set_irq_wake_real",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "839-851",
          "snippet": "static int set_irq_wake_real(unsigned int irq, unsigned int on)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tint ret = -ENXIO;\n\n\tif (irq_desc_get_chip(desc)->flags &  IRQCHIP_SKIP_SET_WAKE)\n\t\treturn 0;\n\n\tif (desc->irq_data.chip->irq_set_wake)\n\t\tret = desc->irq_data.chip->irq_set_wake(&desc->irq_data, on);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int set_irq_wake_real(unsigned int irq, unsigned int on)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tint ret = -ENXIO;\n\n\tif (irq_desc_get_chip(desc)->flags &  IRQCHIP_SKIP_SET_WAKE)\n\t\treturn 0;\n\n\tif (desc->irq_data.chip->irq_set_wake)\n\t\tret = desc->irq_data.chip->irq_set_wake(&desc->irq_data, on);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Unbalanced IRQ %d wake disable\\n\"",
            "irq"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "&desc->irq_data",
            "IRQD_WAKEUP_STATE"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_buslock",
          "args": [
            "irq",
            "&flags",
            "IRQ_GET_DESC_CHECK_GLOBAL"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_buslock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "169-173",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_set_irq_wake(unsigned int irq, unsigned int on)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\tint ret = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/* Don't use NMIs as wake up interrupts please */\n\tif (desc->istate & IRQS_NMI) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* wakeup-capable irqs can be shared between drivers that\n\t * don't need to have the same sleep mode behaviors.\n\t */\n\tif (on) {\n\t\tif (desc->wake_depth++ == 0) {\n\t\t\tret = set_irq_wake_real(irq, on);\n\t\t\tif (ret)\n\t\t\t\tdesc->wake_depth = 0;\n\t\t\telse\n\t\t\t\tirqd_set(&desc->irq_data, IRQD_WAKEUP_STATE);\n\t\t}\n\t} else {\n\t\tif (desc->wake_depth == 0) {\n\t\t\tWARN(1, \"Unbalanced IRQ %d wake disable\\n\", irq);\n\t\t} else if (--desc->wake_depth == 0) {\n\t\t\tret = set_irq_wake_real(irq, on);\n\t\t\tif (ret)\n\t\t\t\tdesc->wake_depth = 1;\n\t\t\telse\n\t\t\t\tirqd_clear(&desc->irq_data, IRQD_WAKEUP_STATE);\n\t\t}\n\t}\n\nout_unlock:\n\tirq_put_desc_busunlock(desc, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "set_irq_wake_real",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "839-851",
    "snippet": "static int set_irq_wake_real(unsigned int irq, unsigned int on)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tint ret = -ENXIO;\n\n\tif (irq_desc_get_chip(desc)->flags &  IRQCHIP_SKIP_SET_WAKE)\n\t\treturn 0;\n\n\tif (desc->irq_data.chip->irq_set_wake)\n\t\tret = desc->irq_data.chip->irq_set_wake(&desc->irq_data, on);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_set_wake",
          "args": [
            "&desc->irq_data",
            "on"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_chip",
          "args": [
            "desc"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int set_irq_wake_real(unsigned int irq, unsigned int on)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tint ret = -ENXIO;\n\n\tif (irq_desc_get_chip(desc)->flags &  IRQCHIP_SKIP_SET_WAKE)\n\t\treturn 0;\n\n\tif (desc->irq_data.chip->irq_set_wake)\n\t\tret = desc->irq_data.chip->irq_set_wake(&desc->irq_data, on);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "enable_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "834-837",
    "snippet": "void enable_nmi(unsigned int irq)\n{\n\tenable_irq(irq);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_irq",
          "args": [
            "irq"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "enable_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "808-822",
          "snippet": "void enable_irq(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn;\n\tif (WARN(!desc->irq_data.chip,\n\t\t KERN_ERR \"enable_irq before setup/request_irq: irq %u\\n\", irq))\n\t\tgoto out;\n\n\t__enable_irq(desc);\nout:\n\tirq_put_desc_busunlock(desc, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid enable_irq(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn;\n\tif (WARN(!desc->irq_data.chip,\n\t\t KERN_ERR \"enable_irq before setup/request_irq: irq %u\\n\", irq))\n\t\tgoto out;\n\n\t__enable_irq(desc);\nout:\n\tirq_put_desc_busunlock(desc, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid enable_nmi(unsigned int irq)\n{\n\tenable_irq(irq);\n}"
  },
  {
    "function_name": "enable_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "808-822",
    "snippet": "void enable_irq(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn;\n\tif (WARN(!desc->irq_data.chip,\n\t\t KERN_ERR \"enable_irq before setup/request_irq: irq %u\\n\", irq))\n\t\tgoto out;\n\n\t__enable_irq(desc);\nout:\n\tirq_put_desc_busunlock(desc, flags);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_busunlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_busunlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "175-179",
          "snippet": "static inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__enable_irq",
          "args": [
            "desc"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "__enable_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "769-795",
          "snippet": "void __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!desc->irq_data.chip",
            "KERN_ERR \"enable_irq before setup/request_irq: irq %u\\n\"",
            "irq"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_buslock",
          "args": [
            "irq",
            "&flags",
            "IRQ_GET_DESC_CHECK_GLOBAL"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_buslock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "169-173",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid enable_irq(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn;\n\tif (WARN(!desc->irq_data.chip,\n\t\t KERN_ERR \"enable_irq before setup/request_irq: irq %u\\n\", irq))\n\t\tgoto out;\n\n\t__enable_irq(desc);\nout:\n\tirq_put_desc_busunlock(desc, flags);\n}"
  },
  {
    "function_name": "__enable_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "769-795",
    "snippet": "void __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_startup",
          "args": [
            "desc",
            "IRQ_RESEND",
            "IRQ_START_FORCE"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "irq_startup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "255-287",
          "snippet": "int irq_startup(struct irq_desc *desc, bool resend, bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct cpumask *aff = irq_data_get_affinity_mask(d);\n\tint ret = 0;\n\n\tdesc->depth = 0;\n\n\tif (irqd_is_started(d)) {\n\t\tirq_enable(desc);\n\t} else {\n\t\tswitch (__irq_startup_managed(desc, aff, force)) {\n\t\tcase IRQ_STARTUP_NORMAL:\n\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tret = __irq_startup(desc);\n\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_MANAGED:\n\t\t\tirq_do_set_affinity(d, aff, false);\n\t\t\tret = __irq_startup(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_ABORT:\n\t\t\tirqd_set_managed_shutdown(d);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (resend)\n\t\tcheck_irq_resend(desc, false);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_startup(struct irq_desc *desc, bool resend, bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct cpumask *aff = irq_data_get_affinity_mask(d);\n\tint ret = 0;\n\n\tdesc->depth = 0;\n\n\tif (irqd_is_started(d)) {\n\t\tirq_enable(desc);\n\t} else {\n\t\tswitch (__irq_startup_managed(desc, aff, force)) {\n\t\tcase IRQ_STARTUP_NORMAL:\n\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tret = __irq_startup(desc);\n\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_MANAGED:\n\t\t\tirq_do_set_affinity(d, aff, false);\n\t\t\tret = __irq_startup(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_ABORT:\n\t\t\tirqd_set_managed_shutdown(d);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (resend)\n\t\tcheck_irq_resend(desc, false);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_set_noprobe",
          "args": [
            "desc"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_set_noprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "140-143",
          "snippet": "static inline void irq_settings_set_noprobe(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NOPROBE;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void irq_settings_set_noprobe(struct irq_desc *desc)\n{\n\tdesc->status_use_accessors |= _IRQ_NOPROBE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_WARNING \"Unbalanced enable for IRQ %d\\n\"",
            "irq_desc_get_irq(desc)"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}"
  },
  {
    "function_name": "disable_nmi_nosync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "764-767",
    "snippet": "void disable_nmi_nosync(unsigned int irq)\n{\n\tdisable_irq_nosync(irq);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_irq_nosync",
          "args": [
            "irq"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "disable_irq_nosync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "703-706",
          "snippet": "void disable_irq_nosync(unsigned int irq)\n{\n\t__disable_irq_nosync(irq);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid disable_irq_nosync(unsigned int irq)\n{\n\t__disable_irq_nosync(irq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid disable_nmi_nosync(unsigned int irq)\n{\n\tdisable_irq_nosync(irq);\n}"
  },
  {
    "function_name": "disable_hardirq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "745-751",
    "snippet": "bool disable_hardirq(unsigned int irq)\n{\n\tif (!__disable_irq_nosync(irq))\n\t\treturn synchronize_hardirq(irq);\n\n\treturn false;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_hardirq",
          "args": [
            "irq"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_hardirq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "98-108",
          "snippet": "bool synchronize_hardirq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, false);\n\t\treturn !atomic_read(&desc->threads_active);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nbool synchronize_hardirq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, false);\n\t\treturn !atomic_read(&desc->threads_active);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__disable_irq_nosync",
          "args": [
            "irq"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_irq_nosync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "680-690",
          "snippet": "static int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nbool disable_hardirq(unsigned int irq)\n{\n\tif (!__disable_irq_nosync(irq))\n\t\treturn synchronize_hardirq(irq);\n\n\treturn false;\n}"
  },
  {
    "function_name": "disable_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "721-725",
    "snippet": "void disable_irq(unsigned int irq)\n{\n\tif (!__disable_irq_nosync(irq))\n\t\tsynchronize_irq(irq);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_irq",
          "args": [
            "irq"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "126-140",
          "snippet": "void synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, true);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, true);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__disable_irq_nosync",
          "args": [
            "irq"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_irq_nosync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "680-690",
          "snippet": "static int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid disable_irq(unsigned int irq)\n{\n\tif (!__disable_irq_nosync(irq))\n\t\tsynchronize_irq(irq);\n}"
  },
  {
    "function_name": "disable_irq_nosync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "703-706",
    "snippet": "void disable_irq_nosync(unsigned int irq)\n{\n\t__disable_irq_nosync(irq);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__disable_irq_nosync",
          "args": [
            "irq"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_irq_nosync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "680-690",
          "snippet": "static int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid disable_irq_nosync(unsigned int irq)\n{\n\t__disable_irq_nosync(irq);\n}"
  },
  {
    "function_name": "__disable_irq_nosync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "680-690",
    "snippet": "static int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_busunlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_busunlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "175-179",
          "snippet": "static inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__disable_irq",
          "args": [
            "desc"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_irq_nosync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "680-690",
          "snippet": "static int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_buslock",
          "args": [
            "irq",
            "&flags",
            "IRQ_GET_DESC_CHECK_GLOBAL"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_buslock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "169-173",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "__disable_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "674-678",
    "snippet": "void __disable_irq(struct irq_desc *desc)\n{\n\tif (!desc->depth++)\n\t\tirq_disable(desc);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_disable",
          "args": [
            "desc"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "irq_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "386-389",
          "snippet": "void irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid __disable_irq(struct irq_desc *desc)\n{\n\tif (!desc->depth++)\n\t\tirq_disable(desc);\n}"
  },
  {
    "function_name": "irq_set_vcpu_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "643-671",
    "snippet": "int irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tint ret = -ENOSYS;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tdata = irq_desc_get_irq_data(desc);\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (chip && chip->irq_set_vcpu_affinity)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\tret = chip->irq_set_vcpu_affinity(data, vcpu_info);\n\tirq_put_desc_unlock(desc, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_set_vcpu_affinity",
          "args": [
            "data",
            "vcpu_info"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_vcpu_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "643-671",
          "snippet": "int irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tint ret = -ENOSYS;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tdata = irq_desc_get_irq_data(desc);\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (chip && chip->irq_set_vcpu_affinity)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\tret = chip->irq_set_vcpu_affinity(data, vcpu_info);\n\tirq_put_desc_unlock(desc, flags);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "data"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tint ret = -ENOSYS;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tdata = irq_desc_get_irq_data(desc);\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (chip && chip->irq_set_vcpu_affinity)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\tret = chip->irq_set_vcpu_affinity(data, vcpu_info);\n\tirq_put_desc_unlock(desc, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_setup_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "624-627",
    "snippet": "int irq_setup_affinity(struct irq_desc *desc)\n{\n\treturn irq_select_affinity(irq_desc_get_irq(desc));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_select_affinity",
          "args": [
            "irq_desc_get_irq(desc)"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "irq_select_affinity_usr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "131-134",
          "snippet": "static inline int irq_select_affinity_usr(unsigned int irq)\n{\n\treturn irq_select_affinity(irq);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic inline int irq_select_affinity_usr(unsigned int irq)\n{\n\treturn irq_select_affinity(irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_setup_affinity(struct irq_desc *desc)\n{\n\treturn irq_select_affinity(irq_desc_get_irq(desc));\n}"
  },
  {
    "function_name": "irq_setup_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "582-621",
    "snippet": "int irq_setup_affinity(struct irq_desc *desc)\n{\n\tstruct cpumask *set = irq_default_affinity;\n\tint ret, node = irq_desc_get_node(desc);\n\tstatic DEFINE_RAW_SPINLOCK(mask_lock);\n\tstatic struct cpumask mask;\n\n\t/* Excludes PER_CPU and NO_BALANCE interrupts */\n\tif (!__irq_can_set_affinity(desc))\n\t\treturn 0;\n\n\traw_spin_lock(&mask_lock);\n\t/*\n\t * Preserve the managed affinity setting and a userspace affinity\n\t * setup, but make sure that one of the targets is online.\n\t */\n\tif (irqd_affinity_is_managed(&desc->irq_data) ||\n\t    irqd_has_set(&desc->irq_data, IRQD_AFFINITY_SET)) {\n\t\tif (cpumask_intersects(desc->irq_common_data.affinity,\n\t\t\t\t       cpu_online_mask))\n\t\t\tset = desc->irq_common_data.affinity;\n\t\telse\n\t\t\tirqd_clear(&desc->irq_data, IRQD_AFFINITY_SET);\n\t}\n\n\tcpumask_and(&mask, cpu_online_mask, set);\n\tif (cpumask_empty(&mask))\n\t\tcpumask_copy(&mask, cpu_online_mask);\n\n\tif (node != NUMA_NO_NODE) {\n\t\tconst struct cpumask *nodemask = cpumask_of_node(node);\n\n\t\t/* make sure at least one of the cpus in nodemask is online */\n\t\tif (cpumask_intersects(&mask, nodemask))\n\t\t\tcpumask_and(&mask, &mask, nodemask);\n\t}\n\tret = irq_do_set_affinity(&desc->irq_data, &mask, false);\n\traw_spin_unlock(&mask_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&mask_lock"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_do_set_affinity",
          "args": [
            "&desc->irq_data",
            "&mask",
            "false"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "irq_do_set_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "220-281",
          "snippet": "int irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t\tbool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tint ret;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If this is a managed interrupt and housekeeping is enabled on\n\t * it check whether the requested affinity mask intersects with\n\t * a housekeeping CPU. If so, then remove the isolated CPUs from\n\t * the mask and just keep the housekeeping CPU(s). This prevents\n\t * the affinity setter from routing the interrupt to an isolated\n\t * CPU to avoid that I/O submitted from a housekeeping CPU causes\n\t * interrupts on an isolated one.\n\t *\n\t * If the masks do not intersect or include online CPU(s) then\n\t * keep the requested mask. The isolated target CPUs are only\n\t * receiving interrupts when the I/O operation was submitted\n\t * directly from them.\n\t *\n\t * If all housekeeping CPUs in the affinity mask are offline, the\n\t * interrupt will be migrated by the CPU hotplug code once a\n\t * housekeeping CPU which belongs to the affinity mask comes\n\t * online.\n\t */\n\tif (irqd_affinity_is_managed(data) &&\n\t    housekeeping_enabled(HK_FLAG_MANAGED_IRQ)) {\n\t\tconst struct cpumask *hk_mask, *prog_mask;\n\n\t\tstatic DEFINE_RAW_SPINLOCK(tmp_mask_lock);\n\t\tstatic struct cpumask tmp_mask;\n\n\t\thk_mask = housekeeping_cpumask(HK_FLAG_MANAGED_IRQ);\n\n\t\traw_spin_lock(&tmp_mask_lock);\n\t\tcpumask_and(&tmp_mask, mask, hk_mask);\n\t\tif (!cpumask_intersects(&tmp_mask, cpu_online_mask))\n\t\t\tprog_mask = mask;\n\t\telse\n\t\t\tprog_mask = &tmp_mask;\n\t\tret = chip->irq_set_affinity(data, prog_mask, force);\n\t\traw_spin_unlock(&tmp_mask_lock);\n\t} else {\n\t\tret = chip->irq_set_affinity(data, mask, force);\n\t}\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\t\tfallthrough;\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tirq_validate_effective_affinity(data);\n\t\tirq_set_thread_affinity(desc);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t\tbool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tint ret;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If this is a managed interrupt and housekeeping is enabled on\n\t * it check whether the requested affinity mask intersects with\n\t * a housekeeping CPU. If so, then remove the isolated CPUs from\n\t * the mask and just keep the housekeeping CPU(s). This prevents\n\t * the affinity setter from routing the interrupt to an isolated\n\t * CPU to avoid that I/O submitted from a housekeeping CPU causes\n\t * interrupts on an isolated one.\n\t *\n\t * If the masks do not intersect or include online CPU(s) then\n\t * keep the requested mask. The isolated target CPUs are only\n\t * receiving interrupts when the I/O operation was submitted\n\t * directly from them.\n\t *\n\t * If all housekeeping CPUs in the affinity mask are offline, the\n\t * interrupt will be migrated by the CPU hotplug code once a\n\t * housekeeping CPU which belongs to the affinity mask comes\n\t * online.\n\t */\n\tif (irqd_affinity_is_managed(data) &&\n\t    housekeeping_enabled(HK_FLAG_MANAGED_IRQ)) {\n\t\tconst struct cpumask *hk_mask, *prog_mask;\n\n\t\tstatic DEFINE_RAW_SPINLOCK(tmp_mask_lock);\n\t\tstatic struct cpumask tmp_mask;\n\n\t\thk_mask = housekeeping_cpumask(HK_FLAG_MANAGED_IRQ);\n\n\t\traw_spin_lock(&tmp_mask_lock);\n\t\tcpumask_and(&tmp_mask, mask, hk_mask);\n\t\tif (!cpumask_intersects(&tmp_mask, cpu_online_mask))\n\t\t\tprog_mask = mask;\n\t\telse\n\t\t\tprog_mask = &tmp_mask;\n\t\tret = chip->irq_set_affinity(data, prog_mask, force);\n\t\traw_spin_unlock(&tmp_mask_lock);\n\t} else {\n\t\tret = chip->irq_set_affinity(data, mask, force);\n\t}\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\t\tfallthrough;\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tirq_validate_effective_affinity(data);\n\t\tirq_set_thread_affinity(desc);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "&mask",
            "&mask",
            "nodemask"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "&mask",
            "nodemask"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "node"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&mask",
            "cpu_online_mask"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "&mask"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "&mask",
            "cpu_online_mask",
            "set"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "&desc->irq_data",
            "IRQD_AFFINITY_SET"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "desc->irq_common_data.affinity",
            "cpu_online_mask"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_has_set",
          "args": [
            "&desc->irq_data",
            "IRQD_AFFINITY_SET"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_has_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "233-236",
          "snippet": "static inline bool irqd_has_set(struct irq_data *d, unsigned int mask)\n{\n\treturn __irqd_to_state(d) & mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline bool irqd_has_set(struct irq_data *d, unsigned int mask)\n{\n\treturn __irqd_to_state(d) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_affinity_is_managed",
          "args": [
            "&desc->irq_data"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&mask_lock"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_can_set_affinity",
          "args": [
            "desc"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_can_set_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "146-152",
          "snippet": "static bool __irq_can_set_affinity(struct irq_desc *desc)\n{\n\tif (!desc || !irqd_can_balance(&desc->irq_data) ||\n\t    !desc->irq_data.chip || !desc->irq_data.chip->irq_set_affinity)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic bool __irq_can_set_affinity(struct irq_desc *desc)\n{\n\tif (!desc || !irqd_can_balance(&desc->irq_data) ||\n\t    !desc->irq_data.chip || !desc->irq_data.chip->irq_set_affinity)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_node",
          "args": [
            "desc"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "irq_desc_get_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "262-265",
          "snippet": "static inline int irq_desc_get_node(struct irq_desc *desc)\n{\n\treturn irq_common_data_get_node(&desc->irq_common_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline int irq_desc_get_node(struct irq_desc *desc)\n{\n\treturn irq_common_data_get_node(&desc->irq_common_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_setup_affinity(struct irq_desc *desc)\n{\n\tstruct cpumask *set = irq_default_affinity;\n\tint ret, node = irq_desc_get_node(desc);\n\tstatic DEFINE_RAW_SPINLOCK(mask_lock);\n\tstatic struct cpumask mask;\n\n\t/* Excludes PER_CPU and NO_BALANCE interrupts */\n\tif (!__irq_can_set_affinity(desc))\n\t\treturn 0;\n\n\traw_spin_lock(&mask_lock);\n\t/*\n\t * Preserve the managed affinity setting and a userspace affinity\n\t * setup, but make sure that one of the targets is online.\n\t */\n\tif (irqd_affinity_is_managed(&desc->irq_data) ||\n\t    irqd_has_set(&desc->irq_data, IRQD_AFFINITY_SET)) {\n\t\tif (cpumask_intersects(desc->irq_common_data.affinity,\n\t\t\t\t       cpu_online_mask))\n\t\t\tset = desc->irq_common_data.affinity;\n\t\telse\n\t\t\tirqd_clear(&desc->irq_data, IRQD_AFFINITY_SET);\n\t}\n\n\tcpumask_and(&mask, cpu_online_mask, set);\n\tif (cpumask_empty(&mask))\n\t\tcpumask_copy(&mask, cpu_online_mask);\n\n\tif (node != NUMA_NO_NODE) {\n\t\tconst struct cpumask *nodemask = cpumask_of_node(node);\n\n\t\t/* make sure at least one of the cpus in nodemask is online */\n\t\tif (cpumask_intersects(&mask, nodemask))\n\t\t\tcpumask_and(&mask, &mask, nodemask);\n\t}\n\tret = irq_do_set_affinity(&desc->irq_data, &mask, false);\n\traw_spin_unlock(&mask_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_set_affinity_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "541-575",
    "snippet": "int\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc || desc->istate & IRQS_NMI)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify) {\n\t\tif (cancel_work_sync(&old_notify->work)) {\n\t\t\t/* Pending work had a ref, put that one too */\n\t\t\tkref_put(&old_notify->kref, old_notify->release);\n\t\t}\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&old_notify->kref",
            "old_notify->release"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&old_notify->kref",
            "old_notify->release"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&old_notify->work"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_work_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3214-3217",
          "snippet": "bool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&notify->work",
            "irq_affinity_notify"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&notify->kref"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc || desc->istate & IRQS_NMI)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify) {\n\t\tif (cancel_work_sync(&old_notify->work)) {\n\t\t\t/* Pending work had a ref, put that one too */\n\t\t\tkref_put(&old_notify->kref, old_notify->release);\n\t\t}\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_affinity_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "505-528",
    "snippet": "static void irq_affinity_notify(struct work_struct *work)\n{\n\tstruct irq_affinity_notify *notify =\n\t\tcontainer_of(work, struct irq_affinity_notify, work);\n\tstruct irq_desc *desc = irq_to_desc(notify->irq);\n\tcpumask_var_t cpumask;\n\tunsigned long flags;\n\n\tif (!desc || !alloc_cpumask_var(&cpumask, GFP_KERNEL))\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (irq_move_pending(&desc->irq_data))\n\t\tirq_get_pending(cpumask, desc);\n\telse\n\t\tcpumask_copy(cpumask, desc->irq_common_data.affinity);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tnotify->notify(notify, cpumask);\n\n\tfree_cpumask_var(cpumask);\nout:\n\tkref_put(&notify->kref, notify->release);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&notify->kref",
            "notify->release"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cpumask"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify->notify",
          "args": [
            "notify",
            "cpumask"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cpumask",
            "desc->irq_common_data.affinity"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_pending",
          "args": [
            "cpumask",
            "desc"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "446-449",
          "snippet": "static inline void\nirq_get_pending(struct cpumask *mask, struct irq_desc *desc)\n{\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_get_pending(struct cpumask *mask, struct irq_desc *desc)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_move_pending",
          "args": [
            "&desc->irq_data"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "irq_move_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "438-441",
          "snippet": "static inline bool irq_move_pending(struct irq_data *data)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline bool irq_move_pending(struct irq_data *data)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&cpumask",
            "GFP_KERNEL"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "notify->irq"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structirq_affinity_notify",
            "work"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_affinity_notify(struct work_struct *work)\n{\n\tstruct irq_affinity_notify *notify =\n\t\tcontainer_of(work, struct irq_affinity_notify, work);\n\tstruct irq_desc *desc = irq_to_desc(notify->irq);\n\tcpumask_var_t cpumask;\n\tunsigned long flags;\n\n\tif (!desc || !alloc_cpumask_var(&cpumask, GFP_KERNEL))\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (irq_move_pending(&desc->irq_data))\n\t\tirq_get_pending(cpumask, desc);\n\telse\n\t\tcpumask_copy(cpumask, desc->irq_common_data.affinity);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tnotify->notify(notify, cpumask);\n\n\tfree_cpumask_var(cpumask);\nout:\n\tkref_put(&notify->kref, notify->release);\n}"
  },
  {
    "function_name": "__irq_apply_affinity_hint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "489-502",
    "snippet": "int __irq_apply_affinity_hint(unsigned int irq, const struct cpumask *m,\n\t\t\t      bool setaffinity)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->affinity_hint = m;\n\tirq_put_desc_unlock(desc, flags);\n\tif (m && setaffinity)\n\t\t__irq_set_affinity(irq, m, false);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_set_affinity",
          "args": [
            "irq",
            "m",
            "false"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_set_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "443-457",
          "snippet": "static int __irq_set_affinity(unsigned int irq, const struct cpumask *mask,\n\t\t\t      bool force)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int __irq_set_affinity(unsigned int irq, const struct cpumask *mask,\n\t\t\t      bool force)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_put_desc_unlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "187-191",
          "snippet": "static inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_desc_lock",
          "args": [
            "irq",
            "&flags",
            "IRQ_GET_DESC_CHECK_GLOBAL"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "181-185",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint __irq_apply_affinity_hint(unsigned int irq, const struct cpumask *m,\n\t\t\t      bool setaffinity)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->affinity_hint = m;\n\tirq_put_desc_unlock(desc, flags);\n\tif (m && setaffinity)\n\t\t__irq_set_affinity(irq, m, false);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_force_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "483-486",
    "snippet": "int irq_force_affinity(unsigned int irq, const struct cpumask *cpumask)\n{\n\treturn __irq_set_affinity(irq, cpumask, true);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_set_affinity",
          "args": [
            "irq",
            "cpumask",
            "true"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_set_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "443-457",
          "snippet": "static int __irq_set_affinity(unsigned int irq, const struct cpumask *mask,\n\t\t\t      bool force)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int __irq_set_affinity(unsigned int irq, const struct cpumask *mask,\n\t\t\t      bool force)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_force_affinity(unsigned int irq, const struct cpumask *cpumask)\n{\n\treturn __irq_set_affinity(irq, cpumask, true);\n}"
  },
  {
    "function_name": "irq_set_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "466-469",
    "snippet": "int irq_set_affinity(unsigned int irq, const struct cpumask *cpumask)\n{\n\treturn __irq_set_affinity(irq, cpumask, false);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_set_affinity",
          "args": [
            "irq",
            "cpumask",
            "false"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_set_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "443-457",
          "snippet": "static int __irq_set_affinity(unsigned int irq, const struct cpumask *mask,\n\t\t\t      bool force)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int __irq_set_affinity(unsigned int irq, const struct cpumask *mask,\n\t\t\t      bool force)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_set_affinity(unsigned int irq, const struct cpumask *cpumask)\n{\n\treturn __irq_set_affinity(irq, cpumask, false);\n}"
  },
  {
    "function_name": "__irq_set_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "443-457",
    "snippet": "static int __irq_set_affinity(unsigned int irq, const struct cpumask *mask,\n\t\t\t      bool force)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_affinity_locked",
          "args": [
            "irq_desc_get_irq_data(desc)",
            "mask",
            "force"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_affinity_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "340-371",
          "snippet": "int irq_set_affinity_locked(struct irq_data *data, const struct cpumask *mask,\n\t\t\t    bool force)\n{\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tint ret = 0;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\tif (irq_set_affinity_deactivated(data, mask, force))\n\t\treturn 0;\n\n\tif (irq_can_move_pcntxt(data) && !irqd_is_setaffinity_pending(data)) {\n\t\tret = irq_try_set_affinity(data, mask, force);\n\t} else {\n\t\tirqd_set_move_pending(data);\n\t\tirq_copy_pending(desc, mask);\n\t}\n\n\tif (desc->affinity_notify) {\n\t\tkref_get(&desc->affinity_notify->kref);\n\t\tif (!schedule_work(&desc->affinity_notify->work)) {\n\t\t\t/* Work was already scheduled, drop our extra ref */\n\t\t\tkref_put(&desc->affinity_notify->kref,\n\t\t\t\t desc->affinity_notify->release);\n\t\t}\n\t}\n\tirqd_set(data, IRQD_AFFINITY_SET);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_set_affinity_locked(struct irq_data *data, const struct cpumask *mask,\n\t\t\t    bool force)\n{\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tint ret = 0;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\tif (irq_set_affinity_deactivated(data, mask, force))\n\t\treturn 0;\n\n\tif (irq_can_move_pcntxt(data) && !irqd_is_setaffinity_pending(data)) {\n\t\tret = irq_try_set_affinity(data, mask, force);\n\t} else {\n\t\tirqd_set_move_pending(data);\n\t\tirq_copy_pending(desc, mask);\n\t}\n\n\tif (desc->affinity_notify) {\n\t\tkref_get(&desc->affinity_notify->kref);\n\t\tif (!schedule_work(&desc->affinity_notify->work)) {\n\t\t\t/* Work was already scheduled, drop our extra ref */\n\t\t\tkref_put(&desc->affinity_notify->kref,\n\t\t\t\t desc->affinity_notify->release);\n\t\t}\n\t}\n\tirqd_set(data, IRQD_AFFINITY_SET);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int __irq_set_affinity(unsigned int irq, const struct cpumask *mask,\n\t\t\t      bool force)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_update_affinity_desc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "388-441",
    "snippet": "int irq_update_affinity_desc(unsigned int irq,\n\t\t\t     struct irq_affinity_desc *affinity)\n{\n\tstruct irq_desc *desc;\n\tunsigned long flags;\n\tbool activated;\n\tint ret = 0;\n\n\t/*\n\t * Supporting this with the reservation scheme used by x86 needs\n\t * some more thought. Fail it for now.\n\t */\n\tif (IS_ENABLED(CONFIG_GENERIC_IRQ_RESERVATION_MODE))\n\t\treturn -EOPNOTSUPP;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/* Requires the interrupt to be shut down */\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Interrupts which are already managed cannot be modified */\n\tif (irqd_affinity_is_managed(&desc->irq_data)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Deactivate the interrupt. That's required to undo\n\t * anything an earlier activation has established.\n\t */\n\tactivated = irqd_is_activated(&desc->irq_data);\n\tif (activated)\n\t\tirq_domain_deactivate_irq(&desc->irq_data);\n\n\tif (affinity->is_managed) {\n\t\tirqd_set(&desc->irq_data, IRQD_AFFINITY_MANAGED);\n\t\tirqd_set(&desc->irq_data, IRQD_MANAGED_SHUTDOWN);\n\t}\n\n\tcpumask_copy(desc->irq_common_data.affinity, &affinity->mask);\n\n\t/* Restore the activation state */\n\tif (activated)\n\t\tirq_domain_activate_irq(&desc->irq_data, false);\n\nout_unlock:\n\tirq_put_desc_busunlock(desc, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_busunlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_busunlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "175-179",
          "snippet": "static inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_activate_irq",
          "args": [
            "&desc->irq_data",
            "false"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_activate_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "465-469",
          "snippet": "static inline int irq_domain_activate_irq(struct irq_data *data, bool reserve)\n{\n\tirqd_set_activated(data);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline int irq_domain_activate_irq(struct irq_data *data, bool reserve)\n{\n\tirqd_set_activated(data);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "desc->irq_common_data.affinity",
            "&affinity->mask"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "&desc->irq_data",
            "IRQD_MANAGED_SHUTDOWN"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_deactivate_irq",
          "args": [
            "&desc->irq_data"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_deactivate_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "470-473",
          "snippet": "static inline void irq_domain_deactivate_irq(struct irq_data *data)\n{\n\tirqd_clr_activated(data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irq_domain_deactivate_irq(struct irq_data *data)\n{\n\tirqd_clr_activated(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_activated",
          "args": [
            "&desc->irq_data"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_affinity_is_managed",
          "args": [
            "&desc->irq_data"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_is_started",
          "args": [
            "&desc->irq_data"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_buslock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_buslock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "169-173",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_GENERIC_IRQ_RESERVATION_MODE"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_update_affinity_desc(unsigned int irq,\n\t\t\t     struct irq_affinity_desc *affinity)\n{\n\tstruct irq_desc *desc;\n\tunsigned long flags;\n\tbool activated;\n\tint ret = 0;\n\n\t/*\n\t * Supporting this with the reservation scheme used by x86 needs\n\t * some more thought. Fail it for now.\n\t */\n\tif (IS_ENABLED(CONFIG_GENERIC_IRQ_RESERVATION_MODE))\n\t\treturn -EOPNOTSUPP;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/* Requires the interrupt to be shut down */\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Interrupts which are already managed cannot be modified */\n\tif (irqd_affinity_is_managed(&desc->irq_data)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Deactivate the interrupt. That's required to undo\n\t * anything an earlier activation has established.\n\t */\n\tactivated = irqd_is_activated(&desc->irq_data);\n\tif (activated)\n\t\tirq_domain_deactivate_irq(&desc->irq_data);\n\n\tif (affinity->is_managed) {\n\t\tirqd_set(&desc->irq_data, IRQD_AFFINITY_MANAGED);\n\t\tirqd_set(&desc->irq_data, IRQD_MANAGED_SHUTDOWN);\n\t}\n\n\tcpumask_copy(desc->irq_common_data.affinity, &affinity->mask);\n\n\t/* Restore the activation state */\n\tif (activated)\n\t\tirq_domain_activate_irq(&desc->irq_data, false);\n\nout_unlock:\n\tirq_put_desc_busunlock(desc, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_set_affinity_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "340-371",
    "snippet": "int irq_set_affinity_locked(struct irq_data *data, const struct cpumask *mask,\n\t\t\t    bool force)\n{\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tint ret = 0;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\tif (irq_set_affinity_deactivated(data, mask, force))\n\t\treturn 0;\n\n\tif (irq_can_move_pcntxt(data) && !irqd_is_setaffinity_pending(data)) {\n\t\tret = irq_try_set_affinity(data, mask, force);\n\t} else {\n\t\tirqd_set_move_pending(data);\n\t\tirq_copy_pending(desc, mask);\n\t}\n\n\tif (desc->affinity_notify) {\n\t\tkref_get(&desc->affinity_notify->kref);\n\t\tif (!schedule_work(&desc->affinity_notify->work)) {\n\t\t\t/* Work was already scheduled, drop our extra ref */\n\t\t\tkref_put(&desc->affinity_notify->kref,\n\t\t\t\t desc->affinity_notify->release);\n\t\t}\n\t}\n\tirqd_set(data, IRQD_AFFINITY_SET);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "data",
            "IRQD_AFFINITY_SET"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&desc->affinity_notify->kref",
            "desc->affinity_notify->release"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&desc->affinity_notify->work"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&desc->affinity_notify->kref"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "43-47",
          "snippet": "static inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_copy_pending",
          "args": [
            "desc",
            "mask"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "irq_copy_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "442-445",
          "snippet": "static inline void\nirq_copy_pending(struct irq_desc *desc, const struct cpumask *mask)\n{\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_copy_pending(struct irq_desc *desc, const struct cpumask *mask)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_set_move_pending",
          "args": [
            "data"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set_move_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "203-206",
          "snippet": "static inline void irqd_set_move_pending(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_SETAFFINITY_PENDING;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set_move_pending(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_SETAFFINITY_PENDING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_try_set_affinity",
          "args": [
            "data",
            "mask",
            "force"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "irq_try_set_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "301-314",
          "snippet": "static int irq_try_set_affinity(struct irq_data *data,\n\t\t\t\tconst struct cpumask *dest, bool force)\n{\n\tint ret = irq_do_set_affinity(data, dest, force);\n\n\t/*\n\t * In case that the underlying vector management is busy and the\n\t * architecture supports the generic pending mechanism then utilize\n\t * this to avoid returning an error to user space.\n\t */\n\tif (ret == -EBUSY && !force)\n\t\tret = irq_set_affinity_pending(data, dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_try_set_affinity(struct irq_data *data,\n\t\t\t\tconst struct cpumask *dest, bool force)\n{\n\tint ret = irq_do_set_affinity(data, dest, force);\n\n\t/*\n\t * In case that the underlying vector management is busy and the\n\t * architecture supports the generic pending mechanism then utilize\n\t * this to avoid returning an error to user space.\n\t */\n\tif (ret == -EBUSY && !force)\n\t\tret = irq_set_affinity_pending(data, dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_setaffinity_pending",
          "args": [
            "data"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_can_move_pcntxt",
          "args": [
            "data"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "irq_can_move_pcntxt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "434-437",
          "snippet": "static inline bool irq_can_move_pcntxt(struct irq_data *data)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline bool irq_can_move_pcntxt(struct irq_data *data)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_affinity_deactivated",
          "args": [
            "data",
            "mask",
            "force"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_affinity_deactivated",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "316-338",
          "snippet": "static bool irq_set_affinity_deactivated(struct irq_data *data,\n\t\t\t\t\t const struct cpumask *mask, bool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\n\t/*\n\t * Handle irq chips which can handle affinity only in activated\n\t * state correctly\n\t *\n\t * If the interrupt is not yet activated, just store the affinity\n\t * mask and do not call the chip driver at all. On activation the\n\t * driver has to make sure anyway that the interrupt is in a\n\t * usable state so startup works.\n\t */\n\tif (!IS_ENABLED(CONFIG_IRQ_DOMAIN_HIERARCHY) ||\n\t    irqd_is_activated(data) || !irqd_affinity_on_activate(data))\n\t\treturn false;\n\n\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\tirq_init_effective_affinity(data, mask);\n\tirqd_set(data, IRQD_AFFINITY_SET);\n\treturn true;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic bool irq_set_affinity_deactivated(struct irq_data *data,\n\t\t\t\t\t const struct cpumask *mask, bool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\n\t/*\n\t * Handle irq chips which can handle affinity only in activated\n\t * state correctly\n\t *\n\t * If the interrupt is not yet activated, just store the affinity\n\t * mask and do not call the chip driver at all. On activation the\n\t * driver has to make sure anyway that the interrupt is in a\n\t * usable state so startup works.\n\t */\n\tif (!IS_ENABLED(CONFIG_IRQ_DOMAIN_HIERARCHY) ||\n\t    irqd_is_activated(data) || !irqd_affinity_on_activate(data))\n\t\treturn false;\n\n\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\tirq_init_effective_affinity(data, mask);\n\tirqd_set(data, IRQD_AFFINITY_SET);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_data_to_desc",
          "args": [
            "data"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "data"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_set_affinity_locked(struct irq_data *data, const struct cpumask *mask,\n\t\t\t    bool force)\n{\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tint ret = 0;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\tif (irq_set_affinity_deactivated(data, mask, force))\n\t\treturn 0;\n\n\tif (irq_can_move_pcntxt(data) && !irqd_is_setaffinity_pending(data)) {\n\t\tret = irq_try_set_affinity(data, mask, force);\n\t} else {\n\t\tirqd_set_move_pending(data);\n\t\tirq_copy_pending(desc, mask);\n\t}\n\n\tif (desc->affinity_notify) {\n\t\tkref_get(&desc->affinity_notify->kref);\n\t\tif (!schedule_work(&desc->affinity_notify->work)) {\n\t\t\t/* Work was already scheduled, drop our extra ref */\n\t\t\tkref_put(&desc->affinity_notify->kref,\n\t\t\t\t desc->affinity_notify->release);\n\t\t}\n\t}\n\tirqd_set(data, IRQD_AFFINITY_SET);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_set_affinity_deactivated",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "316-338",
    "snippet": "static bool irq_set_affinity_deactivated(struct irq_data *data,\n\t\t\t\t\t const struct cpumask *mask, bool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\n\t/*\n\t * Handle irq chips which can handle affinity only in activated\n\t * state correctly\n\t *\n\t * If the interrupt is not yet activated, just store the affinity\n\t * mask and do not call the chip driver at all. On activation the\n\t * driver has to make sure anyway that the interrupt is in a\n\t * usable state so startup works.\n\t */\n\tif (!IS_ENABLED(CONFIG_IRQ_DOMAIN_HIERARCHY) ||\n\t    irqd_is_activated(data) || !irqd_affinity_on_activate(data))\n\t\treturn false;\n\n\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\tirq_init_effective_affinity(data, mask);\n\tirqd_set(data, IRQD_AFFINITY_SET);\n\treturn true;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "data",
            "IRQD_AFFINITY_SET"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_init_effective_affinity",
          "args": [
            "data",
            "mask"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "irq_init_effective_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "216-217",
          "snippet": "static inline void irq_init_effective_affinity(struct irq_data *data,\n\t\t\t\t\t       const struct cpumask *mask) { }",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic inline void irq_init_effective_affinity(struct irq_data *data,\n\t\t\t\t\t       const struct cpumask *mask) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "desc->irq_common_data.affinity",
            "mask"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_affinity_on_activate",
          "args": [
            "data"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_is_activated",
          "args": [
            "data"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IRQ_DOMAIN_HIERARCHY"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_to_desc",
          "args": [
            "data"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic bool irq_set_affinity_deactivated(struct irq_data *data,\n\t\t\t\t\t const struct cpumask *mask, bool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\n\t/*\n\t * Handle irq chips which can handle affinity only in activated\n\t * state correctly\n\t *\n\t * If the interrupt is not yet activated, just store the affinity\n\t * mask and do not call the chip driver at all. On activation the\n\t * driver has to make sure anyway that the interrupt is in a\n\t * usable state so startup works.\n\t */\n\tif (!IS_ENABLED(CONFIG_IRQ_DOMAIN_HIERARCHY) ||\n\t    irqd_is_activated(data) || !irqd_affinity_on_activate(data))\n\t\treturn false;\n\n\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\tirq_init_effective_affinity(data, mask);\n\tirqd_set(data, IRQD_AFFINITY_SET);\n\treturn true;\n}"
  },
  {
    "function_name": "irq_try_set_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "301-314",
    "snippet": "static int irq_try_set_affinity(struct irq_data *data,\n\t\t\t\tconst struct cpumask *dest, bool force)\n{\n\tint ret = irq_do_set_affinity(data, dest, force);\n\n\t/*\n\t * In case that the underlying vector management is busy and the\n\t * architecture supports the generic pending mechanism then utilize\n\t * this to avoid returning an error to user space.\n\t */\n\tif (ret == -EBUSY && !force)\n\t\tret = irq_set_affinity_pending(data, dest);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_set_affinity_pending",
          "args": [
            "data",
            "dest"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_affinity_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "294-298",
          "snippet": "static inline int irq_set_affinity_pending(struct irq_data *data,\n\t\t\t\t\t   const struct cpumask *dest)\n{\n\treturn -EBUSY;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic inline int irq_set_affinity_pending(struct irq_data *data,\n\t\t\t\t\t   const struct cpumask *dest)\n{\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_do_set_affinity",
          "args": [
            "data",
            "dest",
            "force"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "irq_do_set_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "220-281",
          "snippet": "int irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t\tbool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tint ret;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If this is a managed interrupt and housekeeping is enabled on\n\t * it check whether the requested affinity mask intersects with\n\t * a housekeeping CPU. If so, then remove the isolated CPUs from\n\t * the mask and just keep the housekeeping CPU(s). This prevents\n\t * the affinity setter from routing the interrupt to an isolated\n\t * CPU to avoid that I/O submitted from a housekeeping CPU causes\n\t * interrupts on an isolated one.\n\t *\n\t * If the masks do not intersect or include online CPU(s) then\n\t * keep the requested mask. The isolated target CPUs are only\n\t * receiving interrupts when the I/O operation was submitted\n\t * directly from them.\n\t *\n\t * If all housekeeping CPUs in the affinity mask are offline, the\n\t * interrupt will be migrated by the CPU hotplug code once a\n\t * housekeeping CPU which belongs to the affinity mask comes\n\t * online.\n\t */\n\tif (irqd_affinity_is_managed(data) &&\n\t    housekeeping_enabled(HK_FLAG_MANAGED_IRQ)) {\n\t\tconst struct cpumask *hk_mask, *prog_mask;\n\n\t\tstatic DEFINE_RAW_SPINLOCK(tmp_mask_lock);\n\t\tstatic struct cpumask tmp_mask;\n\n\t\thk_mask = housekeeping_cpumask(HK_FLAG_MANAGED_IRQ);\n\n\t\traw_spin_lock(&tmp_mask_lock);\n\t\tcpumask_and(&tmp_mask, mask, hk_mask);\n\t\tif (!cpumask_intersects(&tmp_mask, cpu_online_mask))\n\t\t\tprog_mask = mask;\n\t\telse\n\t\t\tprog_mask = &tmp_mask;\n\t\tret = chip->irq_set_affinity(data, prog_mask, force);\n\t\traw_spin_unlock(&tmp_mask_lock);\n\t} else {\n\t\tret = chip->irq_set_affinity(data, mask, force);\n\t}\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\t\tfallthrough;\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tirq_validate_effective_affinity(data);\n\t\tirq_set_thread_affinity(desc);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t\tbool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tint ret;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If this is a managed interrupt and housekeeping is enabled on\n\t * it check whether the requested affinity mask intersects with\n\t * a housekeeping CPU. If so, then remove the isolated CPUs from\n\t * the mask and just keep the housekeeping CPU(s). This prevents\n\t * the affinity setter from routing the interrupt to an isolated\n\t * CPU to avoid that I/O submitted from a housekeeping CPU causes\n\t * interrupts on an isolated one.\n\t *\n\t * If the masks do not intersect or include online CPU(s) then\n\t * keep the requested mask. The isolated target CPUs are only\n\t * receiving interrupts when the I/O operation was submitted\n\t * directly from them.\n\t *\n\t * If all housekeeping CPUs in the affinity mask are offline, the\n\t * interrupt will be migrated by the CPU hotplug code once a\n\t * housekeeping CPU which belongs to the affinity mask comes\n\t * online.\n\t */\n\tif (irqd_affinity_is_managed(data) &&\n\t    housekeeping_enabled(HK_FLAG_MANAGED_IRQ)) {\n\t\tconst struct cpumask *hk_mask, *prog_mask;\n\n\t\tstatic DEFINE_RAW_SPINLOCK(tmp_mask_lock);\n\t\tstatic struct cpumask tmp_mask;\n\n\t\thk_mask = housekeeping_cpumask(HK_FLAG_MANAGED_IRQ);\n\n\t\traw_spin_lock(&tmp_mask_lock);\n\t\tcpumask_and(&tmp_mask, mask, hk_mask);\n\t\tif (!cpumask_intersects(&tmp_mask, cpu_online_mask))\n\t\t\tprog_mask = mask;\n\t\telse\n\t\t\tprog_mask = &tmp_mask;\n\t\tret = chip->irq_set_affinity(data, prog_mask, force);\n\t\traw_spin_unlock(&tmp_mask_lock);\n\t} else {\n\t\tret = chip->irq_set_affinity(data, mask, force);\n\t}\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\t\tfallthrough;\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tirq_validate_effective_affinity(data);\n\t\tirq_set_thread_affinity(desc);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int irq_try_set_affinity(struct irq_data *data,\n\t\t\t\tconst struct cpumask *dest, bool force)\n{\n\tint ret = irq_do_set_affinity(data, dest, force);\n\n\t/*\n\t * In case that the underlying vector management is busy and the\n\t * architecture supports the generic pending mechanism then utilize\n\t * this to avoid returning an error to user space.\n\t */\n\tif (ret == -EBUSY && !force)\n\t\tret = irq_set_affinity_pending(data, dest);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_set_affinity_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "294-298",
    "snippet": "static inline int irq_set_affinity_pending(struct irq_data *data,\n\t\t\t\t\t   const struct cpumask *dest)\n{\n\treturn -EBUSY;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic inline int irq_set_affinity_pending(struct irq_data *data,\n\t\t\t\t\t   const struct cpumask *dest)\n{\n\treturn -EBUSY;\n}"
  },
  {
    "function_name": "irq_set_affinity_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "284-292",
    "snippet": "static inline int irq_set_affinity_pending(struct irq_data *data,\n\t\t\t\t\t   const struct cpumask *dest)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\n\tirqd_set_move_pending(data);\n\tirq_copy_pending(desc, dest);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_copy_pending",
          "args": [
            "desc",
            "dest"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "irq_copy_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "442-445",
          "snippet": "static inline void\nirq_copy_pending(struct irq_desc *desc, const struct cpumask *mask)\n{\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_copy_pending(struct irq_desc *desc, const struct cpumask *mask)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_set_move_pending",
          "args": [
            "data"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set_move_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "203-206",
          "snippet": "static inline void irqd_set_move_pending(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_SETAFFINITY_PENDING;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set_move_pending(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_SETAFFINITY_PENDING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_data_to_desc",
          "args": [
            "data"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic inline int irq_set_affinity_pending(struct irq_data *data,\n\t\t\t\t\t   const struct cpumask *dest)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\n\tirqd_set_move_pending(data);\n\tirq_copy_pending(desc, dest);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_do_set_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "220-281",
    "snippet": "int irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t\tbool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tint ret;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If this is a managed interrupt and housekeeping is enabled on\n\t * it check whether the requested affinity mask intersects with\n\t * a housekeeping CPU. If so, then remove the isolated CPUs from\n\t * the mask and just keep the housekeeping CPU(s). This prevents\n\t * the affinity setter from routing the interrupt to an isolated\n\t * CPU to avoid that I/O submitted from a housekeeping CPU causes\n\t * interrupts on an isolated one.\n\t *\n\t * If the masks do not intersect or include online CPU(s) then\n\t * keep the requested mask. The isolated target CPUs are only\n\t * receiving interrupts when the I/O operation was submitted\n\t * directly from them.\n\t *\n\t * If all housekeeping CPUs in the affinity mask are offline, the\n\t * interrupt will be migrated by the CPU hotplug code once a\n\t * housekeeping CPU which belongs to the affinity mask comes\n\t * online.\n\t */\n\tif (irqd_affinity_is_managed(data) &&\n\t    housekeeping_enabled(HK_FLAG_MANAGED_IRQ)) {\n\t\tconst struct cpumask *hk_mask, *prog_mask;\n\n\t\tstatic DEFINE_RAW_SPINLOCK(tmp_mask_lock);\n\t\tstatic struct cpumask tmp_mask;\n\n\t\thk_mask = housekeeping_cpumask(HK_FLAG_MANAGED_IRQ);\n\n\t\traw_spin_lock(&tmp_mask_lock);\n\t\tcpumask_and(&tmp_mask, mask, hk_mask);\n\t\tif (!cpumask_intersects(&tmp_mask, cpu_online_mask))\n\t\t\tprog_mask = mask;\n\t\telse\n\t\t\tprog_mask = &tmp_mask;\n\t\tret = chip->irq_set_affinity(data, prog_mask, force);\n\t\traw_spin_unlock(&tmp_mask_lock);\n\t} else {\n\t\tret = chip->irq_set_affinity(data, mask, force);\n\t}\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\t\tfallthrough;\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tirq_validate_effective_affinity(data);\n\t\tirq_set_thread_affinity(desc);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_set_thread_affinity",
          "args": [
            "desc"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_thread_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "188-195",
          "snippet": "void irq_set_thread_affinity(struct irq_desc *desc)\n{\n\tstruct irqaction *action;\n\n\tfor_each_action_of_desc(desc, action)\n\t\tif (action->thread)\n\t\t\tset_bit(IRQTF_AFFINITY, &action->thread_flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid irq_set_thread_affinity(struct irq_desc *desc)\n{\n\tstruct irqaction *action;\n\n\tfor_each_action_of_desc(desc, action)\n\t\tif (action->thread)\n\t\t\tset_bit(IRQTF_AFFINITY, &action->thread_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_validate_effective_affinity",
          "args": [
            "data"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "irq_validate_effective_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "215-215",
          "snippet": "static inline void irq_validate_effective_affinity(struct irq_data *data) { }",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic inline void irq_validate_effective_affinity(struct irq_data *data) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "desc->irq_common_data.affinity",
            "mask"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chip->irq_set_affinity",
          "args": [
            "data",
            "mask",
            "force"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tmp_mask_lock"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chip->irq_set_affinity",
          "args": [
            "data",
            "prog_mask",
            "force"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "&tmp_mask",
            "cpu_online_mask"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "&tmp_mask",
            "mask",
            "hk_mask"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tmp_mask_lock"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_MANAGED_IRQ"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/isolation.c",
          "lines": "40-46",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "housekeeping_enabled",
          "args": [
            "HK_FLAG_MANAGED_IRQ"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/isolation.c",
          "lines": "17-20",
          "snippet": "bool housekeeping_enabled(enum hk_flags flags)\n{\n\treturn !!(housekeeping_flags & flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic unsigned int housekeeping_flags;\n\nbool housekeeping_enabled(enum hk_flags flags)\n{\n\treturn !!(housekeeping_flags & flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_affinity_is_managed",
          "args": [
            "data"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "data"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_to_desc",
          "args": [
            "data"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t\tbool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tint ret;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If this is a managed interrupt and housekeeping is enabled on\n\t * it check whether the requested affinity mask intersects with\n\t * a housekeeping CPU. If so, then remove the isolated CPUs from\n\t * the mask and just keep the housekeeping CPU(s). This prevents\n\t * the affinity setter from routing the interrupt to an isolated\n\t * CPU to avoid that I/O submitted from a housekeeping CPU causes\n\t * interrupts on an isolated one.\n\t *\n\t * If the masks do not intersect or include online CPU(s) then\n\t * keep the requested mask. The isolated target CPUs are only\n\t * receiving interrupts when the I/O operation was submitted\n\t * directly from them.\n\t *\n\t * If all housekeeping CPUs in the affinity mask are offline, the\n\t * interrupt will be migrated by the CPU hotplug code once a\n\t * housekeeping CPU which belongs to the affinity mask comes\n\t * online.\n\t */\n\tif (irqd_affinity_is_managed(data) &&\n\t    housekeeping_enabled(HK_FLAG_MANAGED_IRQ)) {\n\t\tconst struct cpumask *hk_mask, *prog_mask;\n\n\t\tstatic DEFINE_RAW_SPINLOCK(tmp_mask_lock);\n\t\tstatic struct cpumask tmp_mask;\n\n\t\thk_mask = housekeeping_cpumask(HK_FLAG_MANAGED_IRQ);\n\n\t\traw_spin_lock(&tmp_mask_lock);\n\t\tcpumask_and(&tmp_mask, mask, hk_mask);\n\t\tif (!cpumask_intersects(&tmp_mask, cpu_online_mask))\n\t\t\tprog_mask = mask;\n\t\telse\n\t\t\tprog_mask = &tmp_mask;\n\t\tret = chip->irq_set_affinity(data, prog_mask, force);\n\t\traw_spin_unlock(&tmp_mask_lock);\n\t} else {\n\t\tret = chip->irq_set_affinity(data, mask, force);\n\t}\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n\t\tcpumask_copy(desc->irq_common_data.affinity, mask);\n\t\tfallthrough;\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tirq_validate_effective_affinity(data);\n\t\tirq_set_thread_affinity(desc);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_init_effective_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "216-217",
    "snippet": "static inline void irq_init_effective_affinity(struct irq_data *data,\n\t\t\t\t\t       const struct cpumask *mask) { }",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic inline void irq_init_effective_affinity(struct irq_data *data,\n\t\t\t\t\t       const struct cpumask *mask) { }"
  },
  {
    "function_name": "irq_validate_effective_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "215-215",
    "snippet": "static inline void irq_validate_effective_affinity(struct irq_data *data) { }",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic inline void irq_validate_effective_affinity(struct irq_data *data) { }"
  },
  {
    "function_name": "irq_init_effective_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "209-213",
    "snippet": "static inline void irq_init_effective_affinity(struct irq_data *data,\n\t\t\t\t\t       const struct cpumask *mask)\n{\n\tcpumask_copy(irq_data_get_effective_affinity_mask(data), mask);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "irq_data_get_effective_affinity_mask(data)",
            "mask"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_effective_affinity_mask",
          "args": [
            "data"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic inline void irq_init_effective_affinity(struct irq_data *data,\n\t\t\t\t\t       const struct cpumask *mask)\n{\n\tcpumask_copy(irq_data_get_effective_affinity_mask(data), mask);\n}"
  },
  {
    "function_name": "irq_validate_effective_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "198-207",
    "snippet": "static void irq_validate_effective_affinity(struct irq_data *data)\n{\n\tconst struct cpumask *m = irq_data_get_effective_affinity_mask(data);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\n\tif (!cpumask_empty(m))\n\t\treturn;\n\tpr_warn_once(\"irq_chip %s did not update eff. affinity mask of irq %u\\n\",\n\t\t     chip->name, data->irq);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"irq_chip %s did not update eff. affinity mask of irq %u\\n\"",
            "chip->name",
            "data->irq"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "m"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_irq_chip",
          "args": [
            "data"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_effective_affinity_mask",
          "args": [
            "data"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void irq_validate_effective_affinity(struct irq_data *data)\n{\n\tconst struct cpumask *m = irq_data_get_effective_affinity_mask(data);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\n\tif (!cpumask_empty(m))\n\t\treturn;\n\tpr_warn_once(\"irq_chip %s did not update eff. affinity mask of irq %u\\n\",\n\t\t     chip->name, data->irq);\n}"
  },
  {
    "function_name": "irq_set_thread_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "188-195",
    "snippet": "void irq_set_thread_affinity(struct irq_desc *desc)\n{\n\tstruct irqaction *action;\n\n\tfor_each_action_of_desc(desc, action)\n\t\tif (action->thread)\n\t\t\tset_bit(IRQTF_AFFINITY, &action->thread_flags);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "IRQTF_AFFINITY",
            "&action->thread_flags"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_action_of_desc",
          "args": [
            "desc",
            "action"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid irq_set_thread_affinity(struct irq_desc *desc)\n{\n\tstruct irqaction *action;\n\n\tfor_each_action_of_desc(desc, action)\n\t\tif (action->thread)\n\t\t\tset_bit(IRQTF_AFFINITY, &action->thread_flags);\n}"
  },
  {
    "function_name": "irq_can_set_affinity_usr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "171-177",
    "snippet": "bool irq_can_set_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn __irq_can_set_affinity(desc) &&\n\t\t!irqd_affinity_is_managed(&desc->irq_data);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_affinity_is_managed",
          "args": [
            "&desc->irq_data"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_can_set_affinity",
          "args": [
            "desc"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_can_set_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "146-152",
          "snippet": "static bool __irq_can_set_affinity(struct irq_desc *desc)\n{\n\tif (!desc || !irqd_can_balance(&desc->irq_data) ||\n\t    !desc->irq_data.chip || !desc->irq_data.chip->irq_set_affinity)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic bool __irq_can_set_affinity(struct irq_desc *desc)\n{\n\tif (!desc || !irqd_can_balance(&desc->irq_data) ||\n\t    !desc->irq_data.chip || !desc->irq_data.chip->irq_set_affinity)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nbool irq_can_set_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn __irq_can_set_affinity(desc) &&\n\t\t!irqd_affinity_is_managed(&desc->irq_data);\n}"
  },
  {
    "function_name": "irq_can_set_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "159-162",
    "snippet": "int irq_can_set_affinity(unsigned int irq)\n{\n\treturn __irq_can_set_affinity(irq_to_desc(irq));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_can_set_affinity",
          "args": [
            "irq_to_desc(irq)"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_can_set_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "146-152",
          "snippet": "static bool __irq_can_set_affinity(struct irq_desc *desc)\n{\n\tif (!desc || !irqd_can_balance(&desc->irq_data) ||\n\t    !desc->irq_data.chip || !desc->irq_data.chip->irq_set_affinity)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic bool __irq_can_set_affinity(struct irq_desc *desc)\n{\n\tif (!desc || !irqd_can_balance(&desc->irq_data) ||\n\t    !desc->irq_data.chip || !desc->irq_data.chip->irq_set_affinity)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_can_set_affinity(unsigned int irq)\n{\n\treturn __irq_can_set_affinity(irq_to_desc(irq));\n}"
  },
  {
    "function_name": "__irq_can_set_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "146-152",
    "snippet": "static bool __irq_can_set_affinity(struct irq_desc *desc)\n{\n\tif (!desc || !irqd_can_balance(&desc->irq_data) ||\n\t    !desc->irq_data.chip || !desc->irq_data.chip->irq_set_affinity)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_can_balance",
          "args": [
            "&desc->irq_data"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic bool __irq_can_set_affinity(struct irq_desc *desc)\n{\n\tif (!desc || !irqd_can_balance(&desc->irq_data) ||\n\t    !desc->irq_data.chip || !desc->irq_data.chip->irq_set_affinity)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "synchronize_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "126-140",
    "snippet": "void synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, true);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "desc->wait_for_threads",
            "!atomic_read(&desc->threads_active)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&desc->threads_active"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__synchronize_hardirq",
          "args": [
            "desc",
            "true"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "__synchronize_hardirq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "38-74",
          "snippet": "static void __synchronize_hardirq(struct irq_desc *desc, bool sync_chip)\n{\n\tstruct irq_data *irqd = irq_desc_get_irq_data(desc);\n\tbool inprogress;\n\n\tdo {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * Wait until we're out of the critical section.  This might\n\t\t * give the wrong answer due to the lack of memory barriers.\n\t\t */\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\n\t\t/* Ok, that indicated we're done: double-check carefully. */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tinprogress = irqd_irq_inprogress(&desc->irq_data);\n\n\t\t/*\n\t\t * If requested and supported, check at the chip whether it\n\t\t * is in flight at the hardware level, i.e. already pending\n\t\t * in a CPU and waiting for service and acknowledge.\n\t\t */\n\t\tif (!inprogress && sync_chip) {\n\t\t\t/*\n\t\t\t * Ignore the return code. inprogress is only updated\n\t\t\t * when the chip supports it.\n\t\t\t */\n\t\t\t__irq_get_irqchip_state(irqd, IRQCHIP_STATE_ACTIVE,\n\t\t\t\t\t\t&inprogress);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\t/* Oops, that failed? */\n\t} while (inprogress);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void __synchronize_hardirq(struct irq_desc *desc, bool sync_chip)\n{\n\tstruct irq_data *irqd = irq_desc_get_irq_data(desc);\n\tbool inprogress;\n\n\tdo {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * Wait until we're out of the critical section.  This might\n\t\t * give the wrong answer due to the lack of memory barriers.\n\t\t */\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\n\t\t/* Ok, that indicated we're done: double-check carefully. */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tinprogress = irqd_irq_inprogress(&desc->irq_data);\n\n\t\t/*\n\t\t * If requested and supported, check at the chip whether it\n\t\t * is in flight at the hardware level, i.e. already pending\n\t\t * in a CPU and waiting for service and acknowledge.\n\t\t */\n\t\tif (!inprogress && sync_chip) {\n\t\t\t/*\n\t\t\t * Ignore the return code. inprogress is only updated\n\t\t\t * when the chip supports it.\n\t\t\t */\n\t\t\t__irq_get_irqchip_state(irqd, IRQCHIP_STATE_ACTIVE,\n\t\t\t\t\t\t&inprogress);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\t/* Oops, that failed? */\n\t} while (inprogress);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, true);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}"
  },
  {
    "function_name": "synchronize_hardirq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "98-108",
    "snippet": "bool synchronize_hardirq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, false);\n\t\treturn !atomic_read(&desc->threads_active);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&desc->threads_active"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__synchronize_hardirq",
          "args": [
            "desc",
            "false"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "__synchronize_hardirq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "38-74",
          "snippet": "static void __synchronize_hardirq(struct irq_desc *desc, bool sync_chip)\n{\n\tstruct irq_data *irqd = irq_desc_get_irq_data(desc);\n\tbool inprogress;\n\n\tdo {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * Wait until we're out of the critical section.  This might\n\t\t * give the wrong answer due to the lack of memory barriers.\n\t\t */\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\n\t\t/* Ok, that indicated we're done: double-check carefully. */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tinprogress = irqd_irq_inprogress(&desc->irq_data);\n\n\t\t/*\n\t\t * If requested and supported, check at the chip whether it\n\t\t * is in flight at the hardware level, i.e. already pending\n\t\t * in a CPU and waiting for service and acknowledge.\n\t\t */\n\t\tif (!inprogress && sync_chip) {\n\t\t\t/*\n\t\t\t * Ignore the return code. inprogress is only updated\n\t\t\t * when the chip supports it.\n\t\t\t */\n\t\t\t__irq_get_irqchip_state(irqd, IRQCHIP_STATE_ACTIVE,\n\t\t\t\t\t\t&inprogress);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\t/* Oops, that failed? */\n\t} while (inprogress);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void __synchronize_hardirq(struct irq_desc *desc, bool sync_chip)\n{\n\tstruct irq_data *irqd = irq_desc_get_irq_data(desc);\n\tbool inprogress;\n\n\tdo {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * Wait until we're out of the critical section.  This might\n\t\t * give the wrong answer due to the lack of memory barriers.\n\t\t */\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\n\t\t/* Ok, that indicated we're done: double-check carefully. */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tinprogress = irqd_irq_inprogress(&desc->irq_data);\n\n\t\t/*\n\t\t * If requested and supported, check at the chip whether it\n\t\t * is in flight at the hardware level, i.e. already pending\n\t\t * in a CPU and waiting for service and acknowledge.\n\t\t */\n\t\tif (!inprogress && sync_chip) {\n\t\t\t/*\n\t\t\t * Ignore the return code. inprogress is only updated\n\t\t\t * when the chip supports it.\n\t\t\t */\n\t\t\t__irq_get_irqchip_state(irqd, IRQCHIP_STATE_ACTIVE,\n\t\t\t\t\t\t&inprogress);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\t/* Oops, that failed? */\n\t} while (inprogress);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nbool synchronize_hardirq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, false);\n\t\treturn !atomic_read(&desc->threads_active);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "__synchronize_hardirq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "38-74",
    "snippet": "static void __synchronize_hardirq(struct irq_desc *desc, bool sync_chip)\n{\n\tstruct irq_data *irqd = irq_desc_get_irq_data(desc);\n\tbool inprogress;\n\n\tdo {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * Wait until we're out of the critical section.  This might\n\t\t * give the wrong answer due to the lack of memory barriers.\n\t\t */\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\n\t\t/* Ok, that indicated we're done: double-check carefully. */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tinprogress = irqd_irq_inprogress(&desc->irq_data);\n\n\t\t/*\n\t\t * If requested and supported, check at the chip whether it\n\t\t * is in flight at the hardware level, i.e. already pending\n\t\t * in a CPU and waiting for service and acknowledge.\n\t\t */\n\t\tif (!inprogress && sync_chip) {\n\t\t\t/*\n\t\t\t * Ignore the return code. inprogress is only updated\n\t\t\t * when the chip supports it.\n\t\t\t */\n\t\t\t__irq_get_irqchip_state(irqd, IRQCHIP_STATE_ACTIVE,\n\t\t\t\t\t\t&inprogress);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\t/* Oops, that failed? */\n\t} while (inprogress);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_get_irqchip_state",
          "args": [
            "irqd",
            "IRQCHIP_STATE_ACTIVE",
            "&inprogress"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_get_irqchip_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2763-2785",
          "snippet": "int __irq_get_irqchip_state(struct irq_data *data, enum irqchip_irq_state which,\n\t\t\t    bool *state)\n{\n\tstruct irq_chip *chip;\n\tint err = -EINVAL;\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip))\n\t\t\treturn -ENODEV;\n\t\tif (chip->irq_get_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_get_irqchip_state(data, which, state);\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint __irq_get_irqchip_state(struct irq_data *data, enum irqchip_irq_state which,\n\t\t\t    bool *state)\n{\n\tstruct irq_chip *chip;\n\tint err = -EINVAL;\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip))\n\t\t\treturn -ENODEV;\n\t\tif (chip->irq_get_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_get_irqchip_state(data, which, state);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_inprogress",
          "args": [
            "&desc->irq_data"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_inprogress",
          "args": [
            "&desc->irq_data"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq_data",
          "args": [
            "desc"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic void __synchronize_hardirq(struct irq_desc *desc, bool sync_chip)\n{\n\tstruct irq_data *irqd = irq_desc_get_irq_data(desc);\n\tbool inprogress;\n\n\tdo {\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * Wait until we're out of the critical section.  This might\n\t\t * give the wrong answer due to the lack of memory barriers.\n\t\t */\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\n\t\t/* Ok, that indicated we're done: double-check carefully. */\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tinprogress = irqd_irq_inprogress(&desc->irq_data);\n\n\t\t/*\n\t\t * If requested and supported, check at the chip whether it\n\t\t * is in flight at the hardware level, i.e. already pending\n\t\t * in a CPU and waiting for service and acknowledge.\n\t\t */\n\t\tif (!inprogress && sync_chip) {\n\t\t\t/*\n\t\t\t * Ignore the return code. inprogress is only updated\n\t\t\t * when the chip supports it.\n\t\t\t */\n\t\t\t__irq_get_irqchip_state(irqd, IRQCHIP_STATE_ACTIVE,\n\t\t\t\t\t\t&inprogress);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\t/* Oops, that failed? */\n\t} while (inprogress);\n}"
  },
  {
    "function_name": "setup_forced_irqthreads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
    "lines": "30-34",
    "snippet": "static int __init setup_forced_irqthreads(char *arg)\n{\n\tstatic_branch_enable(&force_irqthreads_key);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/task_work.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&force_irqthreads_key"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int __init setup_forced_irqthreads(char *arg)\n{\n\tstatic_branch_enable(&force_irqthreads_key);\n\treturn 0;\n}"
  }
]