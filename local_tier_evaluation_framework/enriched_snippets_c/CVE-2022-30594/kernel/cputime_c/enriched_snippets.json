[
  {
    "function_name": "kcpustat_cpu_fetch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "1049-1081",
    "snippet": "void kcpustat_cpu_fetch(struct kernel_cpustat *dst, int cpu)\n{\n\tconst struct kernel_cpustat *src = &kcpustat_cpu(cpu);\n\tstruct rq *rq;\n\tint err;\n\n\tif (!vtime_accounting_enabled_cpu(cpu)) {\n\t\t*dst = *src;\n\t\treturn;\n\t}\n\n\trq = cpu_rq(cpu);\n\n\tfor (;;) {\n\t\tstruct task_struct *curr;\n\n\t\trcu_read_lock();\n\t\tcurr = rcu_dereference(rq->curr);\n\t\tif (WARN_ON_ONCE(!curr)) {\n\t\t\trcu_read_unlock();\n\t\t\t*dst = *src;\n\t\t\treturn;\n\t\t}\n\n\t\terr = kcpustat_cpu_fetch_vtime(dst, src, curr, cpu);\n\t\trcu_read_unlock();\n\n\t\tif (!err)\n\t\t\treturn;\n\n\t\tcpu_relax();\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcpustat_cpu_fetch_vtime",
          "args": [
            "dst",
            "src",
            "curr",
            "cpu"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "kcpustat_cpu_fetch_vtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "996-1047",
          "snippet": "static int kcpustat_cpu_fetch_vtime(struct kernel_cpustat *dst,\n\t\t\t\t    const struct kernel_cpustat *src,\n\t\t\t\t    struct task_struct *tsk, int cpu)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\tunsigned int seq;\n\n\tdo {\n\t\tu64 *cpustat;\n\t\tu64 delta;\n\t\tint state;\n\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tstate = vtime_state_fetch(vtime, cpu);\n\t\tif (state < 0)\n\t\t\treturn state;\n\n\t\t*dst = *src;\n\t\tcpustat = dst->cpustat;\n\n\t\t/* Task is sleeping, dead or idle, nothing to add */\n\t\tif (state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (state == VTIME_SYS) {\n\t\t\tcpustat[CPUTIME_SYSTEM] += vtime->stime + delta;\n\t\t} else if (state == VTIME_USER) {\n\t\t\tif (task_nice(tsk) > 0)\n\t\t\t\tcpustat[CPUTIME_NICE] += vtime->utime + delta;\n\t\t\telse\n\t\t\t\tcpustat[CPUTIME_USER] += vtime->utime + delta;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(state != VTIME_GUEST);\n\t\t\tif (task_nice(tsk) > 0) {\n\t\t\t\tcpustat[CPUTIME_GUEST_NICE] += vtime->gtime + delta;\n\t\t\t\tcpustat[CPUTIME_NICE] += vtime->gtime + delta;\n\t\t\t} else {\n\t\t\t\tcpustat[CPUTIME_GUEST] += vtime->gtime + delta;\n\t\t\t\tcpustat[CPUTIME_USER] += vtime->gtime + delta;\n\t\t\t}\n\t\t}\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int kcpustat_cpu_fetch_vtime(struct kernel_cpustat *dst,\n\t\t\t\t    const struct kernel_cpustat *src,\n\t\t\t\t    struct task_struct *tsk, int cpu)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\tunsigned int seq;\n\n\tdo {\n\t\tu64 *cpustat;\n\t\tu64 delta;\n\t\tint state;\n\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tstate = vtime_state_fetch(vtime, cpu);\n\t\tif (state < 0)\n\t\t\treturn state;\n\n\t\t*dst = *src;\n\t\tcpustat = dst->cpustat;\n\n\t\t/* Task is sleeping, dead or idle, nothing to add */\n\t\tif (state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (state == VTIME_SYS) {\n\t\t\tcpustat[CPUTIME_SYSTEM] += vtime->stime + delta;\n\t\t} else if (state == VTIME_USER) {\n\t\t\tif (task_nice(tsk) > 0)\n\t\t\t\tcpustat[CPUTIME_NICE] += vtime->utime + delta;\n\t\t\telse\n\t\t\t\tcpustat[CPUTIME_USER] += vtime->utime + delta;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(state != VTIME_GUEST);\n\t\t\tif (task_nice(tsk) > 0) {\n\t\t\t\tcpustat[CPUTIME_GUEST_NICE] += vtime->gtime + delta;\n\t\t\t\tcpustat[CPUTIME_NICE] += vtime->gtime + delta;\n\t\t\t} else {\n\t\t\t\tcpustat[CPUTIME_GUEST] += vtime->gtime + delta;\n\t\t\t\tcpustat[CPUTIME_USER] += vtime->gtime + delta;\n\t\t\t}\n\t\t}\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!curr"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "rq->curr"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_accounting_enabled_cpu",
          "args": [
            "cpu"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcpustat_cpu",
          "args": [
            "cpu"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid kcpustat_cpu_fetch(struct kernel_cpustat *dst, int cpu)\n{\n\tconst struct kernel_cpustat *src = &kcpustat_cpu(cpu);\n\tstruct rq *rq;\n\tint err;\n\n\tif (!vtime_accounting_enabled_cpu(cpu)) {\n\t\t*dst = *src;\n\t\treturn;\n\t}\n\n\trq = cpu_rq(cpu);\n\n\tfor (;;) {\n\t\tstruct task_struct *curr;\n\n\t\trcu_read_lock();\n\t\tcurr = rcu_dereference(rq->curr);\n\t\tif (WARN_ON_ONCE(!curr)) {\n\t\t\trcu_read_unlock();\n\t\t\t*dst = *src;\n\t\t\treturn;\n\t\t}\n\n\t\terr = kcpustat_cpu_fetch_vtime(dst, src, curr, cpu);\n\t\trcu_read_unlock();\n\n\t\tif (!err)\n\t\t\treturn;\n\n\t\tcpu_relax();\n\t}\n}"
  },
  {
    "function_name": "kcpustat_cpu_fetch_vtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "996-1047",
    "snippet": "static int kcpustat_cpu_fetch_vtime(struct kernel_cpustat *dst,\n\t\t\t\t    const struct kernel_cpustat *src,\n\t\t\t\t    struct task_struct *tsk, int cpu)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\tunsigned int seq;\n\n\tdo {\n\t\tu64 *cpustat;\n\t\tu64 delta;\n\t\tint state;\n\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tstate = vtime_state_fetch(vtime, cpu);\n\t\tif (state < 0)\n\t\t\treturn state;\n\n\t\t*dst = *src;\n\t\tcpustat = dst->cpustat;\n\n\t\t/* Task is sleeping, dead or idle, nothing to add */\n\t\tif (state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (state == VTIME_SYS) {\n\t\t\tcpustat[CPUTIME_SYSTEM] += vtime->stime + delta;\n\t\t} else if (state == VTIME_USER) {\n\t\t\tif (task_nice(tsk) > 0)\n\t\t\t\tcpustat[CPUTIME_NICE] += vtime->utime + delta;\n\t\t\telse\n\t\t\t\tcpustat[CPUTIME_USER] += vtime->utime + delta;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(state != VTIME_GUEST);\n\t\t\tif (task_nice(tsk) > 0) {\n\t\t\t\tcpustat[CPUTIME_GUEST_NICE] += vtime->gtime + delta;\n\t\t\t\tcpustat[CPUTIME_NICE] += vtime->gtime + delta;\n\t\t\t} else {\n\t\t\t\tcpustat[CPUTIME_GUEST] += vtime->gtime + delta;\n\t\t\t\tcpustat[CPUTIME_USER] += vtime->gtime + delta;\n\t\t\t}\n\t\t}\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&vtime->seqcount",
            "seq"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "tsk"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "state != VTIME_GUEST"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "tsk"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "645-662",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_state_fetch",
          "args": [
            "vtime",
            "cpu"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_state_fetch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "872-896",
          "snippet": "static int vtime_state_fetch(struct vtime *vtime, int cpu)\n{\n\tint state = READ_ONCE(vtime->state);\n\n\t/*\n\t * We raced against a context switch, fetch the\n\t * kcpustat task again.\n\t */\n\tif (vtime->cpu != cpu && vtime->cpu != -1)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * Two possible things here:\n\t * 1) We are seeing the scheduling out task (prev) or any past one.\n\t * 2) We are seeing the scheduling in task (next) but it hasn't\n\t *    passed though vtime_task_switch() yet so the pending\n\t *    cputime of the prev task may not be flushed yet.\n\t *\n\t * Case 1) is ok but 2) is not. So wait for a safe VTIME state.\n\t */\n\tif (state == VTIME_INACTIVE)\n\t\treturn -EAGAIN;\n\n\treturn state;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int vtime_state_fetch(struct vtime *vtime, int cpu)\n{\n\tint state = READ_ONCE(vtime->state);\n\n\t/*\n\t * We raced against a context switch, fetch the\n\t * kcpustat task again.\n\t */\n\tif (vtime->cpu != cpu && vtime->cpu != -1)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * Two possible things here:\n\t * 1) We are seeing the scheduling out task (prev) or any past one.\n\t * 2) We are seeing the scheduling in task (next) but it hasn't\n\t *    passed though vtime_task_switch() yet so the pending\n\t *    cputime of the prev task may not be flushed yet.\n\t *\n\t * Case 1) is ok but 2) is not. So wait for a safe VTIME state.\n\t */\n\tif (state == VTIME_INACTIVE)\n\t\treturn -EAGAIN;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int kcpustat_cpu_fetch_vtime(struct kernel_cpustat *dst,\n\t\t\t\t    const struct kernel_cpustat *src,\n\t\t\t\t    struct task_struct *tsk, int cpu)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\tunsigned int seq;\n\n\tdo {\n\t\tu64 *cpustat;\n\t\tu64 delta;\n\t\tint state;\n\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tstate = vtime_state_fetch(vtime, cpu);\n\t\tif (state < 0)\n\t\t\treturn state;\n\n\t\t*dst = *src;\n\t\tcpustat = dst->cpustat;\n\n\t\t/* Task is sleeping, dead or idle, nothing to add */\n\t\tif (state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (state == VTIME_SYS) {\n\t\t\tcpustat[CPUTIME_SYSTEM] += vtime->stime + delta;\n\t\t} else if (state == VTIME_USER) {\n\t\t\tif (task_nice(tsk) > 0)\n\t\t\t\tcpustat[CPUTIME_NICE] += vtime->utime + delta;\n\t\t\telse\n\t\t\t\tcpustat[CPUTIME_USER] += vtime->utime + delta;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(state != VTIME_GUEST);\n\t\t\tif (task_nice(tsk) > 0) {\n\t\t\t\tcpustat[CPUTIME_GUEST_NICE] += vtime->gtime + delta;\n\t\t\t\tcpustat[CPUTIME_NICE] += vtime->gtime + delta;\n\t\t\t} else {\n\t\t\t\tcpustat[CPUTIME_GUEST] += vtime->gtime + delta;\n\t\t\t\tcpustat[CPUTIME_USER] += vtime->gtime + delta;\n\t\t\t}\n\t\t}\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kcpustat_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "962-993",
    "snippet": "u64 kcpustat_field(struct kernel_cpustat *kcpustat,\n\t\t   enum cpu_usage_stat usage, int cpu)\n{\n\tu64 *cpustat = kcpustat->cpustat;\n\tu64 val = cpustat[usage];\n\tstruct rq *rq;\n\tint err;\n\n\tif (!vtime_accounting_enabled_cpu(cpu))\n\t\treturn val;\n\n\trq = cpu_rq(cpu);\n\n\tfor (;;) {\n\t\tstruct task_struct *curr;\n\n\t\trcu_read_lock();\n\t\tcurr = rcu_dereference(rq->curr);\n\t\tif (WARN_ON_ONCE(!curr)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn cpustat[usage];\n\t\t}\n\n\t\terr = kcpustat_field_vtime(cpustat, curr, usage, cpu, &val);\n\t\trcu_read_unlock();\n\n\t\tif (!err)\n\t\t\treturn val;\n\n\t\tcpu_relax();\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcpustat_field_vtime",
          "args": [
            "cpustat",
            "curr",
            "usage",
            "cpu",
            "&val"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "kcpustat_field_vtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "907-960",
          "snippet": "static int kcpustat_field_vtime(u64 *cpustat,\n\t\t\t\tstruct task_struct *tsk,\n\t\t\t\tenum cpu_usage_stat usage,\n\t\t\t\tint cpu, u64 *val)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\tunsigned int seq;\n\n\tdo {\n\t\tint state;\n\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tstate = vtime_state_fetch(vtime, cpu);\n\t\tif (state < 0)\n\t\t\treturn state;\n\n\t\t*val = cpustat[usage];\n\n\t\t/*\n\t\t * Nice VS unnice cputime accounting may be inaccurate if\n\t\t * the nice value has changed since the last vtime update.\n\t\t * But proper fix would involve interrupting target on nice\n\t\t * updates which is a no go on nohz_full (although the scheduler\n\t\t * may still interrupt the target if rescheduling is needed...)\n\t\t */\n\t\tswitch (usage) {\n\t\tcase CPUTIME_SYSTEM:\n\t\t\tif (state == VTIME_SYS)\n\t\t\t\t*val += vtime->stime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_USER:\n\t\t\tif (task_nice(tsk) <= 0)\n\t\t\t\t*val += kcpustat_user_vtime(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_NICE:\n\t\t\tif (task_nice(tsk) > 0)\n\t\t\t\t*val += kcpustat_user_vtime(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_GUEST:\n\t\t\tif (state == VTIME_GUEST && task_nice(tsk) <= 0)\n\t\t\t\t*val += vtime->gtime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_GUEST_NICE:\n\t\t\tif (state == VTIME_GUEST && task_nice(tsk) > 0)\n\t\t\t\t*val += vtime->gtime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int kcpustat_field_vtime(u64 *cpustat,\n\t\t\t\tstruct task_struct *tsk,\n\t\t\t\tenum cpu_usage_stat usage,\n\t\t\t\tint cpu, u64 *val)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\tunsigned int seq;\n\n\tdo {\n\t\tint state;\n\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tstate = vtime_state_fetch(vtime, cpu);\n\t\tif (state < 0)\n\t\t\treturn state;\n\n\t\t*val = cpustat[usage];\n\n\t\t/*\n\t\t * Nice VS unnice cputime accounting may be inaccurate if\n\t\t * the nice value has changed since the last vtime update.\n\t\t * But proper fix would involve interrupting target on nice\n\t\t * updates which is a no go on nohz_full (although the scheduler\n\t\t * may still interrupt the target if rescheduling is needed...)\n\t\t */\n\t\tswitch (usage) {\n\t\tcase CPUTIME_SYSTEM:\n\t\t\tif (state == VTIME_SYS)\n\t\t\t\t*val += vtime->stime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_USER:\n\t\t\tif (task_nice(tsk) <= 0)\n\t\t\t\t*val += kcpustat_user_vtime(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_NICE:\n\t\t\tif (task_nice(tsk) > 0)\n\t\t\t\t*val += kcpustat_user_vtime(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_GUEST:\n\t\t\tif (state == VTIME_GUEST && task_nice(tsk) <= 0)\n\t\t\t\t*val += vtime->gtime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_GUEST_NICE:\n\t\t\tif (state == VTIME_GUEST && task_nice(tsk) > 0)\n\t\t\t\t*val += vtime->gtime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!curr"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "rq->curr"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_accounting_enabled_cpu",
          "args": [
            "cpu"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nu64 kcpustat_field(struct kernel_cpustat *kcpustat,\n\t\t   enum cpu_usage_stat usage, int cpu)\n{\n\tu64 *cpustat = kcpustat->cpustat;\n\tu64 val = cpustat[usage];\n\tstruct rq *rq;\n\tint err;\n\n\tif (!vtime_accounting_enabled_cpu(cpu))\n\t\treturn val;\n\n\trq = cpu_rq(cpu);\n\n\tfor (;;) {\n\t\tstruct task_struct *curr;\n\n\t\trcu_read_lock();\n\t\tcurr = rcu_dereference(rq->curr);\n\t\tif (WARN_ON_ONCE(!curr)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn cpustat[usage];\n\t\t}\n\n\t\terr = kcpustat_field_vtime(cpustat, curr, usage, cpu, &val);\n\t\trcu_read_unlock();\n\n\t\tif (!err)\n\t\t\treturn val;\n\n\t\tcpu_relax();\n\t}\n}"
  },
  {
    "function_name": "kcpustat_field_vtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "907-960",
    "snippet": "static int kcpustat_field_vtime(u64 *cpustat,\n\t\t\t\tstruct task_struct *tsk,\n\t\t\t\tenum cpu_usage_stat usage,\n\t\t\t\tint cpu, u64 *val)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\tunsigned int seq;\n\n\tdo {\n\t\tint state;\n\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tstate = vtime_state_fetch(vtime, cpu);\n\t\tif (state < 0)\n\t\t\treturn state;\n\n\t\t*val = cpustat[usage];\n\n\t\t/*\n\t\t * Nice VS unnice cputime accounting may be inaccurate if\n\t\t * the nice value has changed since the last vtime update.\n\t\t * But proper fix would involve interrupting target on nice\n\t\t * updates which is a no go on nohz_full (although the scheduler\n\t\t * may still interrupt the target if rescheduling is needed...)\n\t\t */\n\t\tswitch (usage) {\n\t\tcase CPUTIME_SYSTEM:\n\t\t\tif (state == VTIME_SYS)\n\t\t\t\t*val += vtime->stime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_USER:\n\t\t\tif (task_nice(tsk) <= 0)\n\t\t\t\t*val += kcpustat_user_vtime(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_NICE:\n\t\t\tif (task_nice(tsk) > 0)\n\t\t\t\t*val += kcpustat_user_vtime(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_GUEST:\n\t\t\tif (state == VTIME_GUEST && task_nice(tsk) <= 0)\n\t\t\t\t*val += vtime->gtime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_GUEST_NICE:\n\t\t\tif (state == VTIME_GUEST && task_nice(tsk) > 0)\n\t\t\t\t*val += vtime->gtime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&vtime->seqcount",
            "seq"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "645-662",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "tsk"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "tsk"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcpustat_user_vtime",
          "args": [
            "vtime"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "kcpustat_user_vtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "898-905",
          "snippet": "static u64 kcpustat_user_vtime(struct vtime *vtime)\n{\n\tif (vtime->state == VTIME_USER)\n\t\treturn vtime->utime + vtime_delta(vtime);\n\telse if (vtime->state == VTIME_GUEST)\n\t\treturn vtime->gtime + vtime_delta(vtime);\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 kcpustat_user_vtime(struct vtime *vtime)\n{\n\tif (vtime->state == VTIME_USER)\n\t\treturn vtime->utime + vtime_delta(vtime);\n\telse if (vtime->state == VTIME_GUEST)\n\t\treturn vtime->gtime + vtime_delta(vtime);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "tsk"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "tsk"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_state_fetch",
          "args": [
            "vtime",
            "cpu"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_state_fetch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "872-896",
          "snippet": "static int vtime_state_fetch(struct vtime *vtime, int cpu)\n{\n\tint state = READ_ONCE(vtime->state);\n\n\t/*\n\t * We raced against a context switch, fetch the\n\t * kcpustat task again.\n\t */\n\tif (vtime->cpu != cpu && vtime->cpu != -1)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * Two possible things here:\n\t * 1) We are seeing the scheduling out task (prev) or any past one.\n\t * 2) We are seeing the scheduling in task (next) but it hasn't\n\t *    passed though vtime_task_switch() yet so the pending\n\t *    cputime of the prev task may not be flushed yet.\n\t *\n\t * Case 1) is ok but 2) is not. So wait for a safe VTIME state.\n\t */\n\tif (state == VTIME_INACTIVE)\n\t\treturn -EAGAIN;\n\n\treturn state;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int vtime_state_fetch(struct vtime *vtime, int cpu)\n{\n\tint state = READ_ONCE(vtime->state);\n\n\t/*\n\t * We raced against a context switch, fetch the\n\t * kcpustat task again.\n\t */\n\tif (vtime->cpu != cpu && vtime->cpu != -1)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * Two possible things here:\n\t * 1) We are seeing the scheduling out task (prev) or any past one.\n\t * 2) We are seeing the scheduling in task (next) but it hasn't\n\t *    passed though vtime_task_switch() yet so the pending\n\t *    cputime of the prev task may not be flushed yet.\n\t *\n\t * Case 1) is ok but 2) is not. So wait for a safe VTIME state.\n\t */\n\tif (state == VTIME_INACTIVE)\n\t\treturn -EAGAIN;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int kcpustat_field_vtime(u64 *cpustat,\n\t\t\t\tstruct task_struct *tsk,\n\t\t\t\tenum cpu_usage_stat usage,\n\t\t\t\tint cpu, u64 *val)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\tunsigned int seq;\n\n\tdo {\n\t\tint state;\n\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tstate = vtime_state_fetch(vtime, cpu);\n\t\tif (state < 0)\n\t\t\treturn state;\n\n\t\t*val = cpustat[usage];\n\n\t\t/*\n\t\t * Nice VS unnice cputime accounting may be inaccurate if\n\t\t * the nice value has changed since the last vtime update.\n\t\t * But proper fix would involve interrupting target on nice\n\t\t * updates which is a no go on nohz_full (although the scheduler\n\t\t * may still interrupt the target if rescheduling is needed...)\n\t\t */\n\t\tswitch (usage) {\n\t\tcase CPUTIME_SYSTEM:\n\t\t\tif (state == VTIME_SYS)\n\t\t\t\t*val += vtime->stime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_USER:\n\t\t\tif (task_nice(tsk) <= 0)\n\t\t\t\t*val += kcpustat_user_vtime(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_NICE:\n\t\t\tif (task_nice(tsk) > 0)\n\t\t\t\t*val += kcpustat_user_vtime(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_GUEST:\n\t\t\tif (state == VTIME_GUEST && task_nice(tsk) <= 0)\n\t\t\t\t*val += vtime->gtime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tcase CPUTIME_GUEST_NICE:\n\t\t\tif (state == VTIME_GUEST && task_nice(tsk) > 0)\n\t\t\t\t*val += vtime->gtime + vtime_delta(vtime);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kcpustat_user_vtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "898-905",
    "snippet": "static u64 kcpustat_user_vtime(struct vtime *vtime)\n{\n\tif (vtime->state == VTIME_USER)\n\t\treturn vtime->utime + vtime_delta(vtime);\n\telse if (vtime->state == VTIME_GUEST)\n\t\treturn vtime->gtime + vtime_delta(vtime);\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "645-662",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 kcpustat_user_vtime(struct vtime *vtime)\n{\n\tif (vtime->state == VTIME_USER)\n\t\treturn vtime->utime + vtime_delta(vtime);\n\telse if (vtime->state == VTIME_GUEST)\n\t\treturn vtime->gtime + vtime_delta(vtime);\n\treturn 0;\n}"
  },
  {
    "function_name": "vtime_state_fetch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "872-896",
    "snippet": "static int vtime_state_fetch(struct vtime *vtime, int cpu)\n{\n\tint state = READ_ONCE(vtime->state);\n\n\t/*\n\t * We raced against a context switch, fetch the\n\t * kcpustat task again.\n\t */\n\tif (vtime->cpu != cpu && vtime->cpu != -1)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * Two possible things here:\n\t * 1) We are seeing the scheduling out task (prev) or any past one.\n\t * 2) We are seeing the scheduling in task (next) but it hasn't\n\t *    passed though vtime_task_switch() yet so the pending\n\t *    cputime of the prev task may not be flushed yet.\n\t *\n\t * Case 1) is ok but 2) is not. So wait for a safe VTIME state.\n\t */\n\tif (state == VTIME_INACTIVE)\n\t\treturn -EAGAIN;\n\n\treturn state;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "vtime->state"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int vtime_state_fetch(struct vtime *vtime, int cpu)\n{\n\tint state = READ_ONCE(vtime->state);\n\n\t/*\n\t * We raced against a context switch, fetch the\n\t * kcpustat task again.\n\t */\n\tif (vtime->cpu != cpu && vtime->cpu != -1)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * Two possible things here:\n\t * 1) We are seeing the scheduling out task (prev) or any past one.\n\t * 2) We are seeing the scheduling in task (next) but it hasn't\n\t *    passed though vtime_task_switch() yet so the pending\n\t *    cputime of the prev task may not be flushed yet.\n\t *\n\t * Case 1) is ok but 2) is not. So wait for a safe VTIME state.\n\t */\n\tif (state == VTIME_INACTIVE)\n\t\treturn -EAGAIN;\n\n\treturn state;\n}"
  },
  {
    "function_name": "task_cputime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "832-870",
    "snippet": "bool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&vtime->seqcount",
            "seq"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "645-662",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_accounting_enabled",
          "args": [],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nbool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "task_gtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "806-825",
    "snippet": "u64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_GUEST)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&vtime->seqcount",
            "seq"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "645-662",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_accounting_enabled",
          "args": [],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nu64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_GUEST)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}"
  },
  {
    "function_name": "vtime_init_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "792-804",
    "snippet": "void vtime_init_idle(struct task_struct *t, int cpu)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_IDLE;\n\tvtime->starttime = sched_clock();\n\tvtime->cpu = cpu;\n\twrite_seqcount_end(&vtime->seqcount);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "disable_sched_clock_irqtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "29-32",
          "snippet": "void disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define sched_clock_irqtime\t(0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_init_idle(struct task_struct *t, int cpu)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_IDLE;\n\tvtime->starttime = sched_clock();\n\tvtime->cpu = cpu;\n\twrite_seqcount_end(&vtime->seqcount);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "vtime_task_switch_generic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "765-790",
    "snippet": "void vtime_task_switch_generic(struct task_struct *prev)\n{\n\tstruct vtime *vtime = &prev->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tif (vtime->state == VTIME_IDLE)\n\t\tvtime_account_idle(prev);\n\telse\n\t\t__vtime_account_kernel(prev, vtime);\n\tvtime->state = VTIME_INACTIVE;\n\tvtime->cpu = -1;\n\twrite_seqcount_end(&vtime->seqcount);\n\n\tvtime = &current->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tif (is_idle_task(current))\n\t\tvtime->state = VTIME_IDLE;\n\telse if (current->flags & PF_VCPU)\n\t\tvtime->state = VTIME_GUEST;\n\telse\n\t\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\tvtime->cpu = smp_processor_id();\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "disable_sched_clock_irqtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "29-32",
          "snippet": "void disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define sched_clock_irqtime\t(0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vtime_account_kernel",
          "args": [
            "prev",
            "vtime"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "__vtime_account_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "684-692",
          "snippet": "static void __vtime_account_kernel(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\t/* We might have scheduled out from guest path */\n\tif (vtime->state == VTIME_GUEST)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\tvtime_account_system(tsk, vtime);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __vtime_account_kernel(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\t/* We might have scheduled out from guest path */\n\tif (vtime->state == VTIME_GUEST)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\tvtime_account_system(tsk, vtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_account_idle",
          "args": [
            "prev"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "760-763",
          "snippet": "void vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_task_switch_generic(struct task_struct *prev)\n{\n\tstruct vtime *vtime = &prev->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tif (vtime->state == VTIME_IDLE)\n\t\tvtime_account_idle(prev);\n\telse\n\t\t__vtime_account_kernel(prev, vtime);\n\tvtime->state = VTIME_INACTIVE;\n\tvtime->cpu = -1;\n\twrite_seqcount_end(&vtime->seqcount);\n\n\tvtime = &current->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tif (is_idle_task(current))\n\t\tvtime->state = VTIME_IDLE;\n\telse if (current->flags & PF_VCPU)\n\t\tvtime->state = VTIME_GUEST;\n\telse\n\t\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\tvtime->cpu = smp_processor_id();\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "vtime_account_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "760-763",
    "snippet": "void vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_idle_time",
          "args": [
            "get_vtime_delta(&tsk->vtime)"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "account_idle_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "219-228",
          "snippet": "void account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vtime_delta",
          "args": [
            "&tsk->vtime"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "645-662",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}"
  },
  {
    "function_name": "vtime_guest_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "748-757",
    "snippet": "void vtime_guest_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime_account_guest(tsk, vtime);\n\ttsk->flags &= ~PF_VCPU;\n\tvtime->state = VTIME_SYS;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_account_guest",
          "args": [
            "tsk",
            "vtime"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_guest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "674-682",
          "snippet": "static void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_guest_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime_account_guest(tsk, vtime);\n\ttsk->flags &= ~PF_VCPU;\n\tvtime->state = VTIME_SYS;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "vtime_guest_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "730-745",
    "snippet": "void vtime_guest_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\t/*\n\t * The flags must be updated under the lock with\n\t * the vtime_starttime flush and update.\n\t * That enforces a right ordering and update sequence\n\t * synchronization against the reader (task_gtime())\n\t * that can thus safely catch up with a tickless delta.\n\t */\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime_account_system(tsk, vtime);\n\ttsk->flags |= PF_VCPU;\n\tvtime->state = VTIME_GUEST;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_account_system",
          "args": [
            "tsk",
            "vtime"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_system",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "664-672",
          "snippet": "static void vtime_account_system(struct task_struct *tsk,\n\t\t\t\t struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void vtime_account_system(struct task_struct *tsk,\n\t\t\t\t struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_guest_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\t/*\n\t * The flags must be updated under the lock with\n\t * the vtime_starttime flush and update.\n\t * That enforces a right ordering and update sequence\n\t * synchronization against the reader (task_gtime())\n\t * that can thus safely catch up with a tickless delta.\n\t */\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime_account_system(tsk, vtime);\n\ttsk->flags |= PF_VCPU;\n\tvtime->state = VTIME_GUEST;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "vtime_user_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "716-728",
    "snippet": "void vtime_user_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->utime += get_vtime_delta(vtime);\n\tif (vtime->utime >= TICK_NSEC) {\n\t\taccount_user_time(tsk, vtime->utime);\n\t\tvtime->utime = 0;\n\t}\n\tvtime->state = VTIME_SYS;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_user_time",
          "args": [
            "tsk",
            "vtime->utime"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "account_user_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "118-133",
          "snippet": "void account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "645-662",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_user_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->utime += get_vtime_delta(vtime);\n\tif (vtime->utime >= TICK_NSEC) {\n\t\taccount_user_time(tsk, vtime->utime);\n\t\tvtime->utime = 0;\n\t}\n\tvtime->state = VTIME_SYS;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "vtime_user_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "706-714",
    "snippet": "void vtime_user_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime_account_system(tsk, vtime);\n\tvtime->state = VTIME_USER;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_account_system",
          "args": [
            "tsk",
            "vtime"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_system",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "664-672",
          "snippet": "static void vtime_account_system(struct task_struct *tsk,\n\t\t\t\t struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void vtime_account_system(struct task_struct *tsk,\n\t\t\t\t struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_user_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime_account_system(tsk, vtime);\n\tvtime->state = VTIME_USER;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "vtime_account_kernel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "694-704",
    "snippet": "void vtime_account_kernel(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_kernel(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vtime_account_kernel",
          "args": [
            "tsk",
            "vtime"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "__vtime_account_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "684-692",
          "snippet": "static void __vtime_account_kernel(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\t/* We might have scheduled out from guest path */\n\tif (vtime->state == VTIME_GUEST)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\tvtime_account_system(tsk, vtime);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __vtime_account_kernel(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\t/* We might have scheduled out from guest path */\n\tif (vtime->state == VTIME_GUEST)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\tvtime_account_system(tsk, vtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "645-662",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_kernel(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_kernel(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "__vtime_account_kernel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "684-692",
    "snippet": "static void __vtime_account_kernel(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\t/* We might have scheduled out from guest path */\n\tif (vtime->state == VTIME_GUEST)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\tvtime_account_system(tsk, vtime);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtime_account_system",
          "args": [
            "tsk",
            "vtime"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_system",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "664-672",
          "snippet": "static void vtime_account_system(struct task_struct *tsk,\n\t\t\t\t struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void vtime_account_system(struct task_struct *tsk,\n\t\t\t\t struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_account_guest",
          "args": [
            "tsk",
            "vtime"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_guest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "674-682",
          "snippet": "static void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void __vtime_account_kernel(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\t/* We might have scheduled out from guest path */\n\tif (vtime->state == VTIME_GUEST)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\tvtime_account_system(tsk, vtime);\n}"
  },
  {
    "function_name": "vtime_account_guest",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "674-682",
    "snippet": "static void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_guest_time",
          "args": [
            "tsk",
            "vtime->gtime"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "account_guest_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "140-157",
          "snippet": "void account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\ttask_group_account_field(p, CPUTIME_NICE, cputime);\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\ttask_group_account_field(p, CPUTIME_USER, cputime);\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\ttask_group_account_field(p, CPUTIME_NICE, cputime);\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\ttask_group_account_field(p, CPUTIME_USER, cputime);\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "645-662",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}"
  },
  {
    "function_name": "vtime_account_system",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "664-672",
    "snippet": "static void vtime_account_system(struct task_struct *tsk,\n\t\t\t\t struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_system_time",
          "args": [
            "tsk",
            "irq_count()",
            "vtime->stime"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "account_system_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "185-202",
          "snippet": "void account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_count",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "645-662",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void vtime_account_system(struct task_struct *tsk,\n\t\t\t\t struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}"
  },
  {
    "function_name": "get_vtime_delta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "645-662",
    "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "vtime->state == VTIME_INACTIVE"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_other_time",
          "args": [
            "delta"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "account_other_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "256-268",
          "snippet": "static inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "645-662",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
  },
  {
    "function_name": "vtime_delta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "634-643",
    "snippet": "static u64 vtime_delta(struct vtime *vtime)\n{\n\tunsigned long long clock;\n\n\tclock = sched_clock();\n\tif (clock < vtime->starttime)\n\t\treturn 0;\n\n\treturn clock - vtime->starttime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "disable_sched_clock_irqtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "29-32",
          "snippet": "void disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define sched_clock_irqtime\t(0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 vtime_delta(struct vtime *vtime)\n{\n\tunsigned long long clock;\n\n\tclock = sched_clock();\n\tif (clock < vtime->starttime)\n\t\treturn 0;\n\n\treturn clock - vtime->starttime;\n}"
  },
  {
    "function_name": "thread_group_cputime_adjusted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "624-630",
    "snippet": "void thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\tcputime_adjust(&cputime, &p->signal->prev_cputime, ut, st);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cputime_adjust",
          "args": [
            "&cputime",
            "&p->signal->prev_cputime",
            "ut",
            "st"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "cputime_adjust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "540-610",
          "snippet": "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicity code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = mul_u64_u64_div_u64(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicity code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = mul_u64_u64_div_u64(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_cputime",
          "args": [
            "p",
            "&cputime"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "294-334",
          "snippet": "void thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\tcputime_adjust(&cputime, &p->signal->prev_cputime, ut, st);\n}"
  },
  {
    "function_name": "task_cputime_adjusted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "612-621",
    "snippet": "void task_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime = {\n\t\t.sum_exec_runtime = p->se.sum_exec_runtime,\n\t};\n\n\tif (task_cputime(p, &cputime.utime, &cputime.stime))\n\t\tcputime.sum_exec_runtime = task_sched_runtime(p);\n\tcputime_adjust(&cputime, &p->prev_cputime, ut, st);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cputime_adjust",
          "args": [
            "&cputime",
            "&p->prev_cputime",
            "ut",
            "st"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "cputime_adjust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "540-610",
          "snippet": "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicity code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = mul_u64_u64_div_u64(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicity code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = mul_u64_u64_div_u64(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_sched_runtime",
          "args": [
            "p"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "task_sched_runtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5148-5185",
          "snippet": "unsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tu64 ns;\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)\n\t/*\n\t * 64-bit doesn't need locks to atomically read a 64-bit value.\n\t * So we have a optimization chance when the task's delta_exec is 0.\n\t * Reading ->on_cpu is racy, but this is ok.\n\t *\n\t * If we race with it leaving CPU, we'll take a lock. So we're correct.\n\t * If we race with it entering CPU, unaccounted time is 0. This is\n\t * indistinguishable from the read occurring a few cycles earlier.\n\t * If we see ->on_cpu without ->on_rq, the task is leaving, and has\n\t * been accounted, so we're correct here as well.\n\t */\n\tif (!p->on_cpu || !task_on_rq_queued(p))\n\t\treturn p->se.sum_exec_runtime;\n#endif\n\n\trq = task_rq_lock(p, &rf);\n\t/*\n\t * Must be ->curr _and_ ->on_rq.  If dequeued, we would\n\t * project cycles that may never be accounted to this\n\t * thread, breaking clock_gettime().\n\t */\n\tif (task_current(rq, p) && task_on_rq_queued(p)) {\n\t\tprefetch_curr_exec_start(p);\n\t\tupdate_rq_clock(rq);\n\t\tp->sched_class->update_curr(rq);\n\t}\n\tns = p->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ns;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nunsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tu64 ns;\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)\n\t/*\n\t * 64-bit doesn't need locks to atomically read a 64-bit value.\n\t * So we have a optimization chance when the task's delta_exec is 0.\n\t * Reading ->on_cpu is racy, but this is ok.\n\t *\n\t * If we race with it leaving CPU, we'll take a lock. So we're correct.\n\t * If we race with it entering CPU, unaccounted time is 0. This is\n\t * indistinguishable from the read occurring a few cycles earlier.\n\t * If we see ->on_cpu without ->on_rq, the task is leaving, and has\n\t * been accounted, so we're correct here as well.\n\t */\n\tif (!p->on_cpu || !task_on_rq_queued(p))\n\t\treturn p->se.sum_exec_runtime;\n#endif\n\n\trq = task_rq_lock(p, &rf);\n\t/*\n\t * Must be ->curr _and_ ->on_rq.  If dequeued, we would\n\t * project cycles that may never be accounted to this\n\t * thread, breaking clock_gettime().\n\t */\n\tif (task_current(rq, p) && task_on_rq_queued(p)) {\n\t\tprefetch_curr_exec_start(p);\n\t\tupdate_rq_clock(rq);\n\t\tp->sched_class->update_curr(rq);\n\t}\n\tns = p->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "p",
            "&cputime.utime",
            "&cputime.stime"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "832-870",
          "snippet": "bool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime = {\n\t\t.sum_exec_runtime = p->se.sum_exec_runtime,\n\t};\n\n\tif (task_cputime(p, &cputime.utime, &cputime.stime))\n\t\tcputime.sum_exec_runtime = task_sched_runtime(p);\n\tcputime_adjust(&cputime, &p->prev_cputime, ut, st);\n}"
  },
  {
    "function_name": "cputime_adjust",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "540-610",
    "snippet": "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicity code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = mul_u64_u64_div_u64(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&prev->lock",
            "flags"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mul_u64_u64_div_u64",
          "args": [
            "stime",
            "rtime",
            "stime + utime"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&prev->lock",
            "flags"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicity code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = mul_u64_u64_div_u64(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}"
  },
  {
    "function_name": "account_idle_ticks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "501-518",
    "snippet": "void account_idle_ticks(unsigned long ticks)\n{\n\tu64 cputime, steal;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_idle_ticks(ticks);\n\t\treturn;\n\t}\n\n\tcputime = ticks * TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\taccount_idle_time(cputime);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define sched_clock_irqtime\t(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_idle_time",
          "args": [
            "cputime"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "account_idle_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "219-228",
          "snippet": "void account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "steal_account_process_time",
          "args": [
            "ULONG_MAX"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "steal_account_process_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "235-251",
          "snippet": "static __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqtime_account_idle_ticks",
          "args": [
            "ticks"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "irqtime_account_idle_ticks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "399-399",
          "snippet": "static inline void irqtime_account_idle_ticks(int ticks) { }",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void irqtime_account_idle_ticks(int ticks) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid account_idle_ticks(unsigned long ticks)\n{\n\tu64 cputime, steal;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_idle_ticks(ticks);\n\t\treturn;\n\t}\n\n\tcputime = ticks * TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\taccount_idle_time(cputime);\n}"
  },
  {
    "function_name": "account_process_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "469-495",
    "snippet": "void account_process_tick(struct task_struct *p, int user_tick)\n{\n\tu64 cputime, steal;\n\n\tif (vtime_accounting_enabled_this_cpu())\n\t\treturn;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_process_tick(p, user_tick, 1);\n\t\treturn;\n\t}\n\n\tcputime = TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\n\tif (user_tick)\n\t\taccount_user_time(p, cputime);\n\telse if ((p != this_rq()->idle) || (irq_count() != HARDIRQ_OFFSET))\n\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime);\n\telse\n\t\taccount_idle_time(cputime);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define sched_clock_irqtime\t(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_idle_time",
          "args": [
            "cputime"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "account_idle_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "219-228",
          "snippet": "void account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_system_time",
          "args": [
            "p",
            "HARDIRQ_OFFSET",
            "cputime"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "account_system_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "185-202",
          "snippet": "void account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_count",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_user_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "account_user_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "118-133",
          "snippet": "void account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "steal_account_process_time",
          "args": [
            "ULONG_MAX"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "steal_account_process_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "235-251",
          "snippet": "static __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqtime_account_process_tick",
          "args": [
            "p",
            "user_tick",
            "1"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "irqtime_account_process_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "400-401",
          "snippet": "static inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tint nr_ticks) { }",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tint nr_ticks) { }"
        }
      },
      {
        "call_info": {
          "callee": "vtime_accounting_enabled_this_cpu",
          "args": [],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid account_process_tick(struct task_struct *p, int user_tick)\n{\n\tu64 cputime, steal;\n\n\tif (vtime_accounting_enabled_this_cpu())\n\t\treturn;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_process_tick(p, user_tick, 1);\n\t\treturn;\n\t}\n\n\tcputime = TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\n\tif (user_tick)\n\t\taccount_user_time(p, cputime);\n\telse if ((p != this_rq()->idle) || (irq_count() != HARDIRQ_OFFSET))\n\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime);\n\telse\n\t\taccount_idle_time(cputime);\n}"
  },
  {
    "function_name": "thread_group_cputime_adjusted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "452-460",
    "snippet": "void thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\n\t*ut = cputime.utime;\n\t*st = cputime.stime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread_group_cputime",
          "args": [
            "p",
            "&cputime"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "294-334",
          "snippet": "void thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\n\t*ut = cputime.utime;\n\t*st = cputime.stime;\n}"
  },
  {
    "function_name": "task_cputime_adjusted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "445-449",
    "snippet": "void task_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\t*ut = p->utime;\n\t*st = p->stime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\t*ut = p->utime;\n\t*st = p->stime;\n}"
  },
  {
    "function_name": "cputime_adjust",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "438-443",
    "snippet": "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\t*ut = curr->utime;\n\t*st = curr->stime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\t*ut = curr->utime;\n\t*st = curr->stime;\n}"
  },
  {
    "function_name": "vtime_account_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "422-436",
    "snippet": "void vtime_account_irq(struct task_struct *tsk, unsigned int offset)\n{\n\tunsigned int pc = irq_count() - offset;\n\n\tif (pc & HARDIRQ_OFFSET) {\n\t\tvtime_account_hardirq(tsk);\n\t} else if (pc & SOFTIRQ_OFFSET) {\n\t\tvtime_account_softirq(tsk);\n\t} else if (!IS_ENABLED(CONFIG_HAVE_VIRT_CPU_ACCOUNTING_IDLE) &&\n\t\t   is_idle_task(tsk)) {\n\t\tvtime_account_idle(tsk);\n\t} else {\n\t\tvtime_account_kernel(tsk);\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtime_account_kernel",
          "args": [
            "tsk"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "694-704",
          "snippet": "void vtime_account_kernel(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_kernel(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_kernel(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_kernel(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_account_idle",
          "args": [
            "tsk"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "760-763",
          "snippet": "void vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "tsk"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HAVE_VIRT_CPU_ACCOUNTING_IDLE"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_account_softirq",
          "args": [
            "tsk"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_account_hardirq",
          "args": [
            "tsk"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_count",
          "args": [],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_irq(struct task_struct *tsk, unsigned int offset)\n{\n\tunsigned int pc = irq_count() - offset;\n\n\tif (pc & HARDIRQ_OFFSET) {\n\t\tvtime_account_hardirq(tsk);\n\t} else if (pc & SOFTIRQ_OFFSET) {\n\t\tvtime_account_softirq(tsk);\n\t} else if (!IS_ENABLED(CONFIG_HAVE_VIRT_CPU_ACCOUNTING_IDLE) &&\n\t\t   is_idle_task(tsk)) {\n\t\tvtime_account_idle(tsk);\n\t} else {\n\t\tvtime_account_kernel(tsk);\n\t}\n}"
  },
  {
    "function_name": "vtime_task_switch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "410-419",
    "snippet": "void vtime_task_switch(struct task_struct *prev)\n{\n\tif (is_idle_task(prev))\n\t\tvtime_account_idle(prev);\n\telse\n\t\tvtime_account_kernel(prev);\n\n\tvtime_flush(prev);\n\tarch_vtime_task_switch(prev);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_vtime_task_switch",
          "args": [
            "prev"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_flush",
          "args": [
            "prev"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_account_kernel",
          "args": [
            "prev"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "694-704",
          "snippet": "void vtime_account_kernel(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_kernel(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_kernel(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_kernel(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_account_idle",
          "args": [
            "prev"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "760-763",
          "snippet": "void vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "prev"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_task_switch(struct task_struct *prev)\n{\n\tif (is_idle_task(prev))\n\t\tvtime_account_idle(prev);\n\telse\n\t\tvtime_account_kernel(prev);\n\n\tvtime_flush(prev);\n\tarch_vtime_task_switch(prev);\n}"
  },
  {
    "function_name": "irqtime_account_process_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "400-401",
    "snippet": "static inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tint nr_ticks) { }",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tint nr_ticks) { }"
  },
  {
    "function_name": "irqtime_account_idle_ticks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "399-399",
    "snippet": "static inline void irqtime_account_idle_ticks(int ticks) { }",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void irqtime_account_idle_ticks(int ticks) { }"
  },
  {
    "function_name": "irqtime_account_idle_ticks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "394-397",
    "snippet": "static void irqtime_account_idle_ticks(int ticks)\n{\n\tirqtime_account_process_tick(current, 0, ticks);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqtime_account_process_tick",
          "args": [
            "current",
            "0",
            "ticks"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "irqtime_account_process_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "400-401",
          "snippet": "static inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tint nr_ticks) { }",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tint nr_ticks) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void irqtime_account_idle_ticks(int ticks)\n{\n\tirqtime_account_process_tick(current, 0, ticks);\n}"
  },
  {
    "function_name": "irqtime_account_process_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "358-392",
    "snippet": "static void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t int ticks)\n{\n\tu64 other, cputime = TICK_NSEC * ticks;\n\n\t/*\n\t * When returning from idle, many ticks can get accounted at\n\t * once, including some ticks of steal, irq, and softirq time.\n\t * Subtract those ticks from the amount of time accounted to\n\t * idle, or potentially user or system time. Due to rounding,\n\t * other time can exceed ticks occasionally.\n\t */\n\tother = account_other_time(ULONG_MAX);\n\tif (other >= cputime)\n\t\treturn;\n\n\tcputime -= other;\n\n\tif (this_cpu_ksoftirqd() == p) {\n\t\t/*\n\t\t * ksoftirqd time do not get accounted in cpu_softirq_time.\n\t\t * So, we have to handle it separately here.\n\t\t * Also, p->stime needs to be updated for ksoftirqd.\n\t\t */\n\t\taccount_system_index_time(p, cputime, CPUTIME_SOFTIRQ);\n\t} else if (user_tick) {\n\t\taccount_user_time(p, cputime);\n\t} else if (p == this_rq()->idle) {\n\t\taccount_idle_time(cputime);\n\t} else if (p->flags & PF_VCPU) { /* System time or guest time */\n\t\taccount_guest_time(p, cputime);\n\t} else {\n\t\taccount_system_index_time(p, cputime, CPUTIME_SYSTEM);\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_system_index_time",
          "args": [
            "p",
            "cputime",
            "CPUTIME_SYSTEM"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "account_system_index_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "165-177",
          "snippet": "void account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_guest_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "account_guest_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "140-157",
          "snippet": "void account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\ttask_group_account_field(p, CPUTIME_NICE, cputime);\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\ttask_group_account_field(p, CPUTIME_USER, cputime);\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\ttask_group_account_field(p, CPUTIME_NICE, cputime);\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\ttask_group_account_field(p, CPUTIME_USER, cputime);\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_idle_time",
          "args": [
            "cputime"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "account_idle_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "219-228",
          "snippet": "void account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_user_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "account_user_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "118-133",
          "snippet": "void account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ksoftirqd",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_other_time",
          "args": [
            "ULONG_MAX"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "account_other_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "256-268",
          "snippet": "static inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t int ticks)\n{\n\tu64 other, cputime = TICK_NSEC * ticks;\n\n\t/*\n\t * When returning from idle, many ticks can get accounted at\n\t * once, including some ticks of steal, irq, and softirq time.\n\t * Subtract those ticks from the amount of time accounted to\n\t * idle, or potentially user or system time. Due to rounding,\n\t * other time can exceed ticks occasionally.\n\t */\n\tother = account_other_time(ULONG_MAX);\n\tif (other >= cputime)\n\t\treturn;\n\n\tcputime -= other;\n\n\tif (this_cpu_ksoftirqd() == p) {\n\t\t/*\n\t\t * ksoftirqd time do not get accounted in cpu_softirq_time.\n\t\t * So, we have to handle it separately here.\n\t\t * Also, p->stime needs to be updated for ksoftirqd.\n\t\t */\n\t\taccount_system_index_time(p, cputime, CPUTIME_SOFTIRQ);\n\t} else if (user_tick) {\n\t\taccount_user_time(p, cputime);\n\t} else if (p == this_rq()->idle) {\n\t\taccount_idle_time(cputime);\n\t} else if (p->flags & PF_VCPU) { /* System time or guest time */\n\t\taccount_guest_time(p, cputime);\n\t} else {\n\t\taccount_system_index_time(p, cputime, CPUTIME_SYSTEM);\n\t}\n}"
  },
  {
    "function_name": "thread_group_cputime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "294-334",
    "snippet": "void thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "done_seqretry_irqrestore",
          "args": [
            "&sig->stats_lock",
            "seq",
            "flags"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_seqretry",
          "args": [
            "&sig->stats_lock",
            "seq"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_sum_exec_runtime",
          "args": [
            "t"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "read_sum_exec_runtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "276-287",
          "snippet": "static u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\tu64 ns;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(t, &rf);\n\tns = t->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, t, &rf);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\tu64 ns;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(t, &rf);\n\tns = t->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, t, &rf);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "t",
            "&utime",
            "&stime"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "832-870",
          "snippet": "bool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "tsk",
            "t"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin_or_lock_irqsave",
          "args": [
            "&sig->stats_lock",
            "&seq"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_sched_runtime",
          "args": [
            "current"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "task_sched_runtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5148-5185",
          "snippet": "unsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tu64 ns;\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)\n\t/*\n\t * 64-bit doesn't need locks to atomically read a 64-bit value.\n\t * So we have a optimization chance when the task's delta_exec is 0.\n\t * Reading ->on_cpu is racy, but this is ok.\n\t *\n\t * If we race with it leaving CPU, we'll take a lock. So we're correct.\n\t * If we race with it entering CPU, unaccounted time is 0. This is\n\t * indistinguishable from the read occurring a few cycles earlier.\n\t * If we see ->on_cpu without ->on_rq, the task is leaving, and has\n\t * been accounted, so we're correct here as well.\n\t */\n\tif (!p->on_cpu || !task_on_rq_queued(p))\n\t\treturn p->se.sum_exec_runtime;\n#endif\n\n\trq = task_rq_lock(p, &rf);\n\t/*\n\t * Must be ->curr _and_ ->on_rq.  If dequeued, we would\n\t * project cycles that may never be accounted to this\n\t * thread, breaking clock_gettime().\n\t */\n\tif (task_current(rq, p) && task_on_rq_queued(p)) {\n\t\tprefetch_curr_exec_start(p);\n\t\tupdate_rq_clock(rq);\n\t\tp->sched_class->update_curr(rq);\n\t}\n\tns = p->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ns;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nunsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tu64 ns;\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)\n\t/*\n\t * 64-bit doesn't need locks to atomically read a 64-bit value.\n\t * So we have a optimization chance when the task's delta_exec is 0.\n\t * Reading ->on_cpu is racy, but this is ok.\n\t *\n\t * If we race with it leaving CPU, we'll take a lock. So we're correct.\n\t * If we race with it entering CPU, unaccounted time is 0. This is\n\t * indistinguishable from the read occurring a few cycles earlier.\n\t * If we see ->on_cpu without ->on_rq, the task is leaving, and has\n\t * been accounted, so we're correct here as well.\n\t */\n\tif (!p->on_cpu || !task_on_rq_queued(p))\n\t\treturn p->se.sum_exec_runtime;\n#endif\n\n\trq = task_rq_lock(p, &rf);\n\t/*\n\t * Must be ->curr _and_ ->on_rq.  If dequeued, we would\n\t * project cycles that may never be accounted to this\n\t * thread, breaking clock_gettime().\n\t */\n\tif (task_current(rq, p) && task_on_rq_queued(p)) {\n\t\tprefetch_curr_exec_start(p);\n\t\tupdate_rq_clock(rq);\n\t\tp->sched_class->update_curr(rq);\n\t}\n\tns = p->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "current",
            "tsk"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "read_sum_exec_runtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "276-287",
    "snippet": "static u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\tu64 ns;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(t, &rf);\n\tns = t->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, t, &rf);\n\n\treturn ns;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "t",
            "&rf"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1586-1594",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "t",
            "&rf"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "582-619",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock(), the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock(), the address\n\t\t * dependency headed by '[L] rq = task_rq()' and the acquire\n\t\t * will pair with the WMB to ensure we then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock(), the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock(), the address\n\t\t * dependency headed by '[L] rq = task_rq()' and the acquire\n\t\t * will pair with the WMB to ensure we then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\tu64 ns;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(t, &rf);\n\tns = t->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, t, &rf);\n\n\treturn ns;\n}"
  },
  {
    "function_name": "read_sum_exec_runtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "271-274",
    "snippet": "static inline u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\treturn t->se.sum_exec_runtime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\treturn t->se.sum_exec_runtime;\n}"
  },
  {
    "function_name": "account_other_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "256-268",
    "snippet": "static inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqtime_tick_accounted",
          "args": [
            "max - accounted"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "irqtime_tick_accounted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "92-95",
          "snippet": "static u64 irqtime_tick_accounted(u64 dummy)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 irqtime_tick_accounted(u64 dummy)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "steal_account_process_time",
          "args": [
            "max"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "steal_account_process_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "235-251",
          "snippet": "static __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}"
  },
  {
    "function_name": "steal_account_process_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "235-251",
    "snippet": "static __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_steal_time",
          "args": [
            "steal"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "account_steal_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "208-213",
          "snippet": "void account_steal_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tcpustat[CPUTIME_STEAL] += cputime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_steal_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tcpustat[CPUTIME_STEAL] += cputime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "steal",
            "maxtime"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_min",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "249-252",
          "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paravirt_steal_clock",
          "args": [
            "smp_processor_id()"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_false",
          "args": [
            "&paravirt_steal_enabled"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "account_idle_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "219-228",
    "snippet": "void account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rq->nr_iowait"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}"
  },
  {
    "function_name": "account_steal_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "208-213",
    "snippet": "void account_steal_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tcpustat[CPUTIME_STEAL] += cputime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_steal_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tcpustat[CPUTIME_STEAL] += cputime;\n}"
  },
  {
    "function_name": "account_system_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "185-202",
    "snippet": "void account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_system_index_time",
          "args": [
            "p",
            "cputime",
            "index"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "account_system_index_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "165-177",
          "snippet": "void account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hardirq_count",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_guest_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "account_guest_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "140-157",
          "snippet": "void account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\ttask_group_account_field(p, CPUTIME_NICE, cputime);\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\ttask_group_account_field(p, CPUTIME_USER, cputime);\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\ttask_group_account_field(p, CPUTIME_NICE, cputime);\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\ttask_group_account_field(p, CPUTIME_USER, cputime);\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_count",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}"
  },
  {
    "function_name": "account_system_index_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "165-177",
    "snippet": "void account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "acct_account_cputime",
          "args": [
            "p"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "acct_account_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tsacct.c",
          "lines": "161-164",
          "snippet": "void acct_account_cputime(struct task_struct *tsk)\n{\n\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/acct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid acct_account_cputime(struct task_struct *tsk)\n{\n\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_group_account_field",
          "args": [
            "p",
            "index",
            "cputime"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "task_group_account_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "99-111",
          "snippet": "static inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_group_system_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}"
  },
  {
    "function_name": "account_guest_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "140-157",
    "snippet": "void account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\ttask_group_account_field(p, CPUTIME_NICE, cputime);\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\ttask_group_account_field(p, CPUTIME_USER, cputime);\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_group_account_field",
          "args": [
            "p",
            "CPUTIME_USER",
            "cputime"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "task_group_account_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "99-111",
          "snippet": "static inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_group_user_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\ttask_group_account_field(p, CPUTIME_NICE, cputime);\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\ttask_group_account_field(p, CPUTIME_USER, cputime);\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}"
  },
  {
    "function_name": "account_user_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "118-133",
    "snippet": "void account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "acct_account_cputime",
          "args": [
            "p"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "acct_account_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tsacct.c",
          "lines": "161-164",
          "snippet": "void acct_account_cputime(struct task_struct *tsk)\n{\n\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/acct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid acct_account_cputime(struct task_struct *tsk)\n{\n\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_group_account_field",
          "args": [
            "p",
            "index",
            "cputime"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "task_group_account_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "99-111",
          "snippet": "static inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_group_user_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}"
  },
  {
    "function_name": "task_group_account_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "99-111",
    "snippet": "static inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_account_cputime_field",
          "args": [
            "p",
            "index",
            "tmp"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_account_cputime_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "375-398",
          "snippet": "void __cgroup_account_cputime_field(struct cgroup *cgrp,\n\t\t\t\t    enum cpu_usage_stat index, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\n\tswitch (index) {\n\tcase CPUTIME_USER:\n\tcase CPUTIME_NICE:\n\t\trstatc->bstat.cputime.utime += delta_exec;\n\t\tbreak;\n\tcase CPUTIME_SYSTEM:\n\tcase CPUTIME_IRQ:\n\tcase CPUTIME_SOFTIRQ:\n\t\trstatc->bstat.cputime.stime += delta_exec;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid __cgroup_account_cputime_field(struct cgroup *cgrp,\n\t\t\t\t    enum cpu_usage_stat index, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\n\tswitch (index) {\n\tcase CPUTIME_USER:\n\tcase CPUTIME_NICE:\n\t\trstatc->bstat.cputime.utime += delta_exec;\n\t\tbreak;\n\tcase CPUTIME_SYSTEM:\n\tcase CPUTIME_IRQ:\n\tcase CPUTIME_SOFTIRQ:\n\t\trstatc->bstat.cputime.stime += delta_exec;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_add",
          "args": [
            "kernel_cpustat.cpustat[index]",
            "tmp"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}"
  },
  {
    "function_name": "irqtime_tick_accounted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "92-95",
    "snippet": "static u64 irqtime_tick_accounted(u64 dummy)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 irqtime_tick_accounted(u64 dummy)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "irqtime_tick_accounted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "77-86",
    "snippet": "static u64 irqtime_tick_accounted(u64 maxtime)\n{\n\tstruct irqtime *irqtime = this_cpu_ptr(&cpu_irqtime);\n\tu64 delta;\n\n\tdelta = min(irqtime->tick_delta, maxtime);\n\tirqtime->tick_delta -= delta;\n\n\treturn delta;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "irqtime->tick_delta",
            "maxtime"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_min",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "249-252",
          "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpu_irqtime"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 irqtime_tick_accounted(u64 maxtime)\n{\n\tstruct irqtime *irqtime = this_cpu_ptr(&cpu_irqtime);\n\tu64 delta;\n\n\tdelta = min(irqtime->tick_delta, maxtime);\n\tirqtime->tick_delta -= delta;\n\n\treturn delta;\n}"
  },
  {
    "function_name": "irqtime_account_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "50-75",
    "snippet": "void irqtime_account_irq(struct task_struct *curr, unsigned int offset)\n{\n\tstruct irqtime *irqtime = this_cpu_ptr(&cpu_irqtime);\n\tunsigned int pc;\n\ts64 delta;\n\tint cpu;\n\n\tif (!sched_clock_irqtime)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tdelta = sched_clock_cpu(cpu) - irqtime->irq_start_time;\n\tirqtime->irq_start_time += delta;\n\tpc = irq_count() - offset;\n\n\t/*\n\t * We do not account for softirq time from ksoftirqd here.\n\t * We want to continue accounting softirq time to ksoftirqd thread\n\t * in that case, so as not to confuse scheduler with a special task\n\t * that do not consume any time, but still wants to run.\n\t */\n\tif (pc & HARDIRQ_MASK)\n\t\tirqtime_account_delta(irqtime, delta, CPUTIME_IRQ);\n\telse if ((pc & SOFTIRQ_OFFSET) && curr != this_cpu_ksoftirqd())\n\t\tirqtime_account_delta(irqtime, delta, CPUTIME_SOFTIRQ);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define sched_clock_irqtime\t(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqtime_account_delta",
          "args": [
            "irqtime",
            "delta",
            "CPUTIME_SOFTIRQ"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "irqtime_account_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "34-44",
          "snippet": "static void irqtime_account_delta(struct irqtime *irqtime, u64 delta,\n\t\t\t\t  enum cpu_usage_stat idx)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tu64_stats_update_begin(&irqtime->sync);\n\tcpustat[idx] += delta;\n\tirqtime->total += delta;\n\tirqtime->tick_delta += delta;\n\tu64_stats_update_end(&irqtime->sync);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void irqtime_account_delta(struct irqtime *irqtime, u64 delta,\n\t\t\t\t  enum cpu_usage_stat idx)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tu64_stats_update_begin(&irqtime->sync);\n\tcpustat[idx] += delta;\n\tirqtime->total += delta;\n\tirqtime->tick_delta += delta;\n\tu64_stats_update_end(&irqtime->sync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ksoftirqd",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_count",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_cpu",
          "args": [
            "cpu"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "461-467",
          "snippet": "u64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_likely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nu64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_likely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpu_irqtime"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid irqtime_account_irq(struct task_struct *curr, unsigned int offset)\n{\n\tstruct irqtime *irqtime = this_cpu_ptr(&cpu_irqtime);\n\tunsigned int pc;\n\ts64 delta;\n\tint cpu;\n\n\tif (!sched_clock_irqtime)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tdelta = sched_clock_cpu(cpu) - irqtime->irq_start_time;\n\tirqtime->irq_start_time += delta;\n\tpc = irq_count() - offset;\n\n\t/*\n\t * We do not account for softirq time from ksoftirqd here.\n\t * We want to continue accounting softirq time to ksoftirqd thread\n\t * in that case, so as not to confuse scheduler with a special task\n\t * that do not consume any time, but still wants to run.\n\t */\n\tif (pc & HARDIRQ_MASK)\n\t\tirqtime_account_delta(irqtime, delta, CPUTIME_IRQ);\n\telse if ((pc & SOFTIRQ_OFFSET) && curr != this_cpu_ksoftirqd())\n\t\tirqtime_account_delta(irqtime, delta, CPUTIME_SOFTIRQ);\n}"
  },
  {
    "function_name": "irqtime_account_delta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "34-44",
    "snippet": "static void irqtime_account_delta(struct irqtime *irqtime, u64 delta,\n\t\t\t\t  enum cpu_usage_stat idx)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tu64_stats_update_begin(&irqtime->sync);\n\tcpustat[idx] += delta;\n\tirqtime->total += delta;\n\tirqtime->tick_delta += delta;\n\tu64_stats_update_end(&irqtime->sync);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_stats_update_end",
          "args": [
            "&irqtime->sync"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_update_begin",
          "args": [
            "&irqtime->sync"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void irqtime_account_delta(struct irqtime *irqtime, u64 delta,\n\t\t\t\t  enum cpu_usage_stat idx)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tu64_stats_update_begin(&irqtime->sync);\n\tcpustat[idx] += delta;\n\tirqtime->total += delta;\n\tirqtime->tick_delta += delta;\n\tu64_stats_update_end(&irqtime->sync);\n}"
  },
  {
    "function_name": "disable_sched_clock_irqtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "29-32",
    "snippet": "void disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define sched_clock_irqtime\t(0)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}"
  },
  {
    "function_name": "enable_sched_clock_irqtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
    "lines": "24-27",
    "snippet": "void enable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 1;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define sched_clock_irqtime\t(0)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid enable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 1;\n}"
  }
]