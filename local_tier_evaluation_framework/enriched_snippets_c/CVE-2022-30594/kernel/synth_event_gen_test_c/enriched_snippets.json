[
  {
    "function_name": "synth_event_gen_test_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
    "lines": "488-522",
    "snippet": "static void __exit synth_event_gen_test_exit(void)\n{\n\t/* Disable the event or you can't remove it */\n\tWARN_ON(trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t  \"gen_synth_test\", false));\n\n\t/* Now give the file and instance back */\n\ttrace_put_event_file(gen_synth_test);\n\n\t/* Now unregister and free the synthetic event */\n\tWARN_ON(synth_event_delete(\"gen_synth_test\"));\n\n\t/* Disable the event or you can't remove it */\n\tWARN_ON(trace_array_set_clr_event(empty_synth_test->tr,\n\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t  \"empty_synth_test\", false));\n\n\t/* Now give the file and instance back */\n\ttrace_put_event_file(empty_synth_test);\n\n\t/* Now unregister and free the synthetic event */\n\tWARN_ON(synth_event_delete(\"empty_synth_test\"));\n\n\t/* Disable the event or you can't remove it */\n\tWARN_ON(trace_array_set_clr_event(create_synth_test->tr,\n\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t  \"create_synth_test\", false));\n\n\t/* Now give the file and instance back */\n\ttrace_put_event_file(create_synth_test);\n\n\t/* Now unregister and free the synthetic event */\n\tWARN_ON(synth_event_delete(\"create_synth_test\"));\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *create_synth_test;",
      "static struct trace_event_file *empty_synth_test;",
      "static struct trace_event_file *gen_synth_test;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "synth_event_delete(\"create_synth_test\")"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_event_delete",
          "args": [
            "\"create_synth_test\""
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1395-1426",
          "snippet": "int synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_put_event_file",
          "args": [
            "create_synth_test"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "trace_put_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3031-3038",
          "snippet": "void trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trace_array_set_clr_event(create_synth_test->tr,\n\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t  \"create_synth_test\", false)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_array_set_clr_event",
          "args": [
            "create_synth_test->tr",
            "\"synthetic\"",
            "\"create_synth_test\"",
            "false"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1123-1133",
          "snippet": "int trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "synth_event_delete(\"empty_synth_test\")"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trace_array_set_clr_event(empty_synth_test->tr,\n\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t  \"empty_synth_test\", false)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "synth_event_delete(\"gen_synth_test\")"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t  \"gen_synth_test\", false)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *create_synth_test;\nstatic struct trace_event_file *empty_synth_test;\nstatic struct trace_event_file *gen_synth_test;\n\nstatic void __exit synth_event_gen_test_exit(void)\n{\n\t/* Disable the event or you can't remove it */\n\tWARN_ON(trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t  \"gen_synth_test\", false));\n\n\t/* Now give the file and instance back */\n\ttrace_put_event_file(gen_synth_test);\n\n\t/* Now unregister and free the synthetic event */\n\tWARN_ON(synth_event_delete(\"gen_synth_test\"));\n\n\t/* Disable the event or you can't remove it */\n\tWARN_ON(trace_array_set_clr_event(empty_synth_test->tr,\n\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t  \"empty_synth_test\", false));\n\n\t/* Now give the file and instance back */\n\ttrace_put_event_file(empty_synth_test);\n\n\t/* Now unregister and free the synthetic event */\n\tWARN_ON(synth_event_delete(\"empty_synth_test\"));\n\n\t/* Disable the event or you can't remove it */\n\tWARN_ON(trace_array_set_clr_event(create_synth_test->tr,\n\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t  \"create_synth_test\", false));\n\n\t/* Now give the file and instance back */\n\ttrace_put_event_file(create_synth_test);\n\n\t/* Now unregister and free the synthetic event */\n\tWARN_ON(synth_event_delete(\"create_synth_test\"));\n}"
  },
  {
    "function_name": "synth_event_gen_test_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
    "lines": "442-486",
    "snippet": "static int __init synth_event_gen_test_init(void)\n{\n\tint ret;\n\n\tret = test_gen_synth_cmd();\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_empty_synth_event();\n\tif (ret) {\n\t\tWARN_ON(trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t\t  \"gen_synth_test\", false));\n\t\ttrace_put_event_file(gen_synth_test);\n\t\tWARN_ON(synth_event_delete(\"gen_synth_test\"));\n\t\tgoto out;\n\t}\n\n\tret = test_create_synth_event();\n\tif (ret) {\n\t\tWARN_ON(trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t\t  \"gen_synth_test\", false));\n\t\ttrace_put_event_file(gen_synth_test);\n\t\tWARN_ON(synth_event_delete(\"gen_synth_test\"));\n\n\t\tWARN_ON(trace_array_set_clr_event(empty_synth_test->tr,\n\t\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t\t  \"empty_synth_test\", false));\n\t\ttrace_put_event_file(empty_synth_test);\n\t\tWARN_ON(synth_event_delete(\"empty_synth_test\"));\n\t\tgoto out;\n\t}\n\n\tret = test_add_next_synth_val();\n\tWARN_ON(ret);\n\n\tret = test_add_synth_val();\n\tWARN_ON(ret);\n\n\tret = test_trace_synth_event();\n\tWARN_ON(ret);\n out:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *empty_synth_test;",
      "static struct trace_event_file *gen_synth_test;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_trace_synth_event",
          "args": [],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "test_trace_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
          "lines": "424-440",
          "snippet": "static int __init test_trace_synth_event(void)\n{\n\tint ret;\n\n\t/* Trace some bogus values just for testing */\n\tret = synth_event_trace(create_synth_test, 9,\t/* number of values */\n\t\t\t\t(u64)444,\t\t/* next_pid_field */\n\t\t\t\t(u64)(long)\"clackers\",\t/* next_comm_field */\n\t\t\t\t(u64)1000000,\t\t/* ts_ns */\n\t\t\t\t(u64)(long)\"viewmaster\",/* dynstring_field_1 */\n\t\t\t\t(u64)1000,\t\t/* ts_ms */\n\t\t\t\t(u64)raw_smp_processor_id(), /* cpu */\n\t\t\t\t(u64)(long)\"Thneed\",\t/* my_string_field */\n\t\t\t\t(u64)(long)\"yoyos\",\t/* dynstring_field_2 */\n\t\t\t\t(u64)999);\t\t/* my_int_field */\n\treturn ret;\n}",
          "includes": [
            "#include <linux/trace_events.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_event_file *create_synth_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *create_synth_test;\n\nstatic int __init test_trace_synth_event(void)\n{\n\tint ret;\n\n\t/* Trace some bogus values just for testing */\n\tret = synth_event_trace(create_synth_test, 9,\t/* number of values */\n\t\t\t\t(u64)444,\t\t/* next_pid_field */\n\t\t\t\t(u64)(long)\"clackers\",\t/* next_comm_field */\n\t\t\t\t(u64)1000000,\t\t/* ts_ns */\n\t\t\t\t(u64)(long)\"viewmaster\",/* dynstring_field_1 */\n\t\t\t\t(u64)1000,\t\t/* ts_ms */\n\t\t\t\t(u64)raw_smp_processor_id(), /* cpu */\n\t\t\t\t(u64)(long)\"Thneed\",\t/* my_string_field */\n\t\t\t\t(u64)(long)\"yoyos\",\t/* dynstring_field_2 */\n\t\t\t\t(u64)999);\t\t/* my_int_field */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_add_synth_val",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "test_add_synth_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
          "lines": "375-419",
          "snippet": "static int __init test_add_synth_val(void)\n{\n\tstruct synth_event_trace_state trace_state;\n\tint ret;\n\n\t/* Start by reserving space in the trace buffer */\n\tret = synth_event_trace_start(gen_synth_test, &trace_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Write some bogus values into the trace buffer, using field names */\n\n\tret = synth_event_add_val(\"ts_ns\", 1000000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"ts_ms\", 1000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"cpu\", raw_smp_processor_id(), &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"next_pid_field\", 777, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"next_comm_field\", (u64)(long)\"silly putty\",\n\t\t\t\t  &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"my_string_field\", (u64)(long)\"thneed_9\",\n\t\t\t\t  &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"my_int_field\", 3999, &trace_state);\n out:\n\t/* Finally, commit the event */\n\tret = synth_event_trace_end(&trace_state);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/trace_events.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_event_file *gen_synth_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_synth_test;\n\nstatic int __init test_add_synth_val(void)\n{\n\tstruct synth_event_trace_state trace_state;\n\tint ret;\n\n\t/* Start by reserving space in the trace buffer */\n\tret = synth_event_trace_start(gen_synth_test, &trace_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Write some bogus values into the trace buffer, using field names */\n\n\tret = synth_event_add_val(\"ts_ns\", 1000000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"ts_ms\", 1000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"cpu\", raw_smp_processor_id(), &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"next_pid_field\", 777, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"next_comm_field\", (u64)(long)\"silly putty\",\n\t\t\t\t  &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"my_string_field\", (u64)(long)\"thneed_9\",\n\t\t\t\t  &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"my_int_field\", 3999, &trace_state);\n out:\n\t/* Finally, commit the event */\n\tret = synth_event_trace_end(&trace_state);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_add_next_synth_val",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "test_add_next_synth_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
          "lines": "319-368",
          "snippet": "static int __init test_add_next_synth_val(void)\n{\n\tstruct synth_event_trace_state trace_state;\n\tint ret;\n\n\t/* Start by reserving space in the trace buffer */\n\tret = synth_event_trace_start(gen_synth_test, &trace_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Write some bogus values into the trace buffer, one after another */\n\n\t/* next_pid_field */\n\tret = synth_event_add_next_val(777, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* next_comm_field */\n\tret = synth_event_add_next_val((u64)(long)\"slinky\", &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* ts_ns */\n\tret = synth_event_add_next_val(1000000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* ts_ms */\n\tret = synth_event_add_next_val(1000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* cpu */\n\tret = synth_event_add_next_val(raw_smp_processor_id(), &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* my_string_field */\n\tret = synth_event_add_next_val((u64)(long)\"thneed_2.01\", &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* my_int_field */\n\tret = synth_event_add_next_val(395, &trace_state);\n out:\n\t/* Finally, commit the event */\n\tret = synth_event_trace_end(&trace_state);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/trace_events.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_event_file *gen_synth_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_synth_test;\n\nstatic int __init test_add_next_synth_val(void)\n{\n\tstruct synth_event_trace_state trace_state;\n\tint ret;\n\n\t/* Start by reserving space in the trace buffer */\n\tret = synth_event_trace_start(gen_synth_test, &trace_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Write some bogus values into the trace buffer, one after another */\n\n\t/* next_pid_field */\n\tret = synth_event_add_next_val(777, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* next_comm_field */\n\tret = synth_event_add_next_val((u64)(long)\"slinky\", &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* ts_ns */\n\tret = synth_event_add_next_val(1000000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* ts_ms */\n\tret = synth_event_add_next_val(1000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* cpu */\n\tret = synth_event_add_next_val(raw_smp_processor_id(), &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* my_string_field */\n\tret = synth_event_add_next_val((u64)(long)\"thneed_2.01\", &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* my_int_field */\n\tret = synth_event_add_next_val(395, &trace_state);\n out:\n\t/* Finally, commit the event */\n\tret = synth_event_trace_end(&trace_state);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "synth_event_delete(\"empty_synth_test\")"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_event_delete",
          "args": [
            "\"empty_synth_test\""
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1395-1426",
          "snippet": "int synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_put_event_file",
          "args": [
            "empty_synth_test"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "trace_put_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3031-3038",
          "snippet": "void trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trace_array_set_clr_event(empty_synth_test->tr,\n\t\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t\t  \"empty_synth_test\", false)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_array_set_clr_event",
          "args": [
            "empty_synth_test->tr",
            "\"synthetic\"",
            "\"empty_synth_test\"",
            "false"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1123-1133",
          "snippet": "int trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "synth_event_delete(\"gen_synth_test\")"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t\t  \"gen_synth_test\", false)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_create_synth_event",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "test_create_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
          "lines": "257-313",
          "snippet": "static int __init test_create_synth_event(void)\n{\n\tu64 vals[9];\n\tint ret;\n\n\t/* Create the create_synth_test event with the fields above */\n\tret = synth_event_create(\"create_synth_test\",\n\t\t\t\t create_synth_test_fields,\n\t\t\t\t ARRAY_SIZE(create_synth_test_fields),\n\t\t\t\t THIS_MODULE);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Now get the create_synth_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tcreate_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t\t \"create_synth_test\");\n\tif (IS_ERR(create_synth_test)) {\n\t\tret = PTR_ERR(create_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(create_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"create_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(create_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"tiddlywinks\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = (u64)(long)\"xrayspecs\";\t/* dynstring_field_1 */\n\tvals[4] = 1000;\t\t\t/* ts_ms */\n\tvals[5] = raw_smp_processor_id(); /* cpu */\n\tvals[6] = (u64)(long)\"thneed\";\t/* my_string_field */\n\tvals[7] = (u64)(long)\"kerplunk\";\t/* dynstring_field_2 */\n\tvals[8] = 398;\t\t\t/* my_int_field */\n\n\t/* Now generate a create_synth_test event */\n\tret = synth_event_trace_array(create_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"create_synth_test\");\n\n\tgoto out;\n}",
          "includes": [
            "#include <linux/trace_events.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_event_file *create_synth_test;",
            "static struct synth_field_desc create_synth_test_fields[] = {\n\t{ .type = \"pid_t\",\t\t.name = \"next_pid_field\" },\n\t{ .type = \"char[16]\",\t\t.name = \"next_comm_field\" },\n\t{ .type = \"u64\",\t\t.name = \"ts_ns\" },\n\t{ .type = \"char[]\",\t\t.name = \"dynstring_field_1\" },\n\t{ .type = \"u64\",\t\t.name = \"ts_ms\" },\n\t{ .type = \"unsigned int\",\t.name = \"cpu\" },\n\t{ .type = \"char[64]\",\t\t.name = \"my_string_field\" },\n\t{ .type = \"char[]\",\t\t.name = \"dynstring_field_2\" },\n\t{ .type = \"int\",\t\t.name = \"my_int_field\" },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *create_synth_test;\nstatic struct synth_field_desc create_synth_test_fields[] = {\n\t{ .type = \"pid_t\",\t\t.name = \"next_pid_field\" },\n\t{ .type = \"char[16]\",\t\t.name = \"next_comm_field\" },\n\t{ .type = \"u64\",\t\t.name = \"ts_ns\" },\n\t{ .type = \"char[]\",\t\t.name = \"dynstring_field_1\" },\n\t{ .type = \"u64\",\t\t.name = \"ts_ms\" },\n\t{ .type = \"unsigned int\",\t.name = \"cpu\" },\n\t{ .type = \"char[64]\",\t\t.name = \"my_string_field\" },\n\t{ .type = \"char[]\",\t\t.name = \"dynstring_field_2\" },\n\t{ .type = \"int\",\t\t.name = \"my_int_field\" },\n};\n\nstatic int __init test_create_synth_event(void)\n{\n\tu64 vals[9];\n\tint ret;\n\n\t/* Create the create_synth_test event with the fields above */\n\tret = synth_event_create(\"create_synth_test\",\n\t\t\t\t create_synth_test_fields,\n\t\t\t\t ARRAY_SIZE(create_synth_test_fields),\n\t\t\t\t THIS_MODULE);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Now get the create_synth_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tcreate_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t\t \"create_synth_test\");\n\tif (IS_ERR(create_synth_test)) {\n\t\tret = PTR_ERR(create_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(create_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"create_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(create_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"tiddlywinks\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = (u64)(long)\"xrayspecs\";\t/* dynstring_field_1 */\n\tvals[4] = 1000;\t\t\t/* ts_ms */\n\tvals[5] = raw_smp_processor_id(); /* cpu */\n\tvals[6] = (u64)(long)\"thneed\";\t/* my_string_field */\n\tvals[7] = (u64)(long)\"kerplunk\";\t/* dynstring_field_2 */\n\tvals[8] = 398;\t\t\t/* my_int_field */\n\n\t/* Now generate a create_synth_test event */\n\tret = synth_event_trace_array(create_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"create_synth_test\");\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "synth_event_delete(\"gen_synth_test\")"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t\t  \"gen_synth_test\", false)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_empty_synth_event",
          "args": [],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "test_empty_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
          "lines": "138-239",
          "snippet": "static int __init test_empty_synth_event(void)\n{\n\tstruct dynevent_cmd cmd;\n\tu64 vals[7];\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Create the empty_synth_test synthetic event with no fields.\n\t */\n\tret = synth_event_gen_cmd_start(&cmd, \"empty_synth_test\", THIS_MODULE);\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use synth_event_add_field to add all of the fields */\n\n\tret = synth_event_add_field(&cmd, \"pid_t\", \"next_pid_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[16]\", \"next_comm_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"u64\", \"ts_ns\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"u64\", \"ts_ms\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"unsigned int\", \"cpu\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[64]\", \"my_string_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"int\", \"my_int_field\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* All fields have been added, close and register the synth event */\n\n\tret = synth_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the empty_synth_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tempty_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t\t\"empty_synth_test\");\n\tif (IS_ERR(empty_synth_test)) {\n\t\tret = PTR_ERR(empty_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(empty_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"empty_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(empty_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"tiddlywinks\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = 1000;\t\t\t/* ts_ms */\n\tvals[4] = raw_smp_processor_id(); /* cpu */\n\tvals[5] = (u64)(long)\"thneed_2.0\";\t/* my_string_field */\n\tvals[6] = 399;\t\t\t/* my_int_field */\n\n\t/* Now trace an empty_synth_test event */\n\tret = synth_event_trace_array(empty_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"empty_synth_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}",
          "includes": [
            "#include <linux/trace_events.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_event_file *empty_synth_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *empty_synth_test;\n\nstatic int __init test_empty_synth_event(void)\n{\n\tstruct dynevent_cmd cmd;\n\tu64 vals[7];\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Create the empty_synth_test synthetic event with no fields.\n\t */\n\tret = synth_event_gen_cmd_start(&cmd, \"empty_synth_test\", THIS_MODULE);\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use synth_event_add_field to add all of the fields */\n\n\tret = synth_event_add_field(&cmd, \"pid_t\", \"next_pid_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[16]\", \"next_comm_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"u64\", \"ts_ns\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"u64\", \"ts_ms\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"unsigned int\", \"cpu\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[64]\", \"my_string_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"int\", \"my_int_field\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* All fields have been added, close and register the synth event */\n\n\tret = synth_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the empty_synth_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tempty_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t\t\"empty_synth_test\");\n\tif (IS_ERR(empty_synth_test)) {\n\t\tret = PTR_ERR(empty_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(empty_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"empty_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(empty_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"tiddlywinks\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = 1000;\t\t\t/* ts_ms */\n\tvals[4] = raw_smp_processor_id(); /* cpu */\n\tvals[5] = (u64)(long)\"thneed_2.0\";\t/* my_string_field */\n\tvals[6] = 399;\t\t\t/* my_int_field */\n\n\t/* Now trace an empty_synth_test event */\n\tret = synth_event_trace_array(empty_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"empty_synth_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_gen_synth_cmd",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "test_gen_synth_cmd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
          "lines": "45-132",
          "snippet": "static int __init test_gen_synth_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tu64 vals[7];\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Create the empty gen_synth_test synthetic event with the\n\t * first 4 fields.\n\t */\n\tret = synth_event_gen_cmd_start(&cmd, \"gen_synth_test\", THIS_MODULE,\n\t\t\t\t\t\"pid_t\", \"next_pid_field\",\n\t\t\t\t\t\"char[16]\", \"next_comm_field\",\n\t\t\t\t\t\"u64\", \"ts_ns\",\n\t\t\t\t\t\"u64\", \"ts_ms\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use synth_event_add_field to add the rest of the fields */\n\n\tret = synth_event_add_field(&cmd, \"unsigned int\", \"cpu\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[64]\", \"my_string_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"int\", \"my_int_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_synth_test event file.  We need to prevent\n\t * the instance and event from disappearing from underneath\n\t * us, which trace_get_event_file() does (though in this case\n\t * we're using the top-level instance which never goes away).\n\t */\n\tgen_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t      \"gen_synth_test\");\n\tif (IS_ERR(gen_synth_test)) {\n\t\tret = PTR_ERR(gen_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"gen_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"hula hoops\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = 1000;\t\t\t/* ts_ms */\n\tvals[4] = raw_smp_processor_id(); /* cpu */\n\tvals[5] = (u64)(long)\"thneed\";\t/* my_string_field */\n\tvals[6] = 598;\t\t\t/* my_int_field */\n\n\t/* Now generate a gen_synth_test event */\n\tret = synth_event_trace_array(gen_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"gen_synth_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}",
          "includes": [
            "#include <linux/trace_events.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_event_file *gen_synth_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_synth_test;\n\nstatic int __init test_gen_synth_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tu64 vals[7];\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Create the empty gen_synth_test synthetic event with the\n\t * first 4 fields.\n\t */\n\tret = synth_event_gen_cmd_start(&cmd, \"gen_synth_test\", THIS_MODULE,\n\t\t\t\t\t\"pid_t\", \"next_pid_field\",\n\t\t\t\t\t\"char[16]\", \"next_comm_field\",\n\t\t\t\t\t\"u64\", \"ts_ns\",\n\t\t\t\t\t\"u64\", \"ts_ms\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use synth_event_add_field to add the rest of the fields */\n\n\tret = synth_event_add_field(&cmd, \"unsigned int\", \"cpu\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[64]\", \"my_string_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"int\", \"my_int_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_synth_test event file.  We need to prevent\n\t * the instance and event from disappearing from underneath\n\t * us, which trace_get_event_file() does (though in this case\n\t * we're using the top-level instance which never goes away).\n\t */\n\tgen_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t      \"gen_synth_test\");\n\tif (IS_ERR(gen_synth_test)) {\n\t\tret = PTR_ERR(gen_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"gen_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"hula hoops\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = 1000;\t\t\t/* ts_ms */\n\tvals[4] = raw_smp_processor_id(); /* cpu */\n\tvals[5] = (u64)(long)\"thneed\";\t/* my_string_field */\n\tvals[6] = 598;\t\t\t/* my_int_field */\n\n\t/* Now generate a gen_synth_test event */\n\tret = synth_event_trace_array(gen_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"gen_synth_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *empty_synth_test;\nstatic struct trace_event_file *gen_synth_test;\n\nstatic int __init synth_event_gen_test_init(void)\n{\n\tint ret;\n\n\tret = test_gen_synth_cmd();\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_empty_synth_event();\n\tif (ret) {\n\t\tWARN_ON(trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t\t  \"gen_synth_test\", false));\n\t\ttrace_put_event_file(gen_synth_test);\n\t\tWARN_ON(synth_event_delete(\"gen_synth_test\"));\n\t\tgoto out;\n\t}\n\n\tret = test_create_synth_event();\n\tif (ret) {\n\t\tWARN_ON(trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t\t  \"gen_synth_test\", false));\n\t\ttrace_put_event_file(gen_synth_test);\n\t\tWARN_ON(synth_event_delete(\"gen_synth_test\"));\n\n\t\tWARN_ON(trace_array_set_clr_event(empty_synth_test->tr,\n\t\t\t\t\t\t  \"synthetic\",\n\t\t\t\t\t\t  \"empty_synth_test\", false));\n\t\ttrace_put_event_file(empty_synth_test);\n\t\tWARN_ON(synth_event_delete(\"empty_synth_test\"));\n\t\tgoto out;\n\t}\n\n\tret = test_add_next_synth_val();\n\tWARN_ON(ret);\n\n\tret = test_add_synth_val();\n\tWARN_ON(ret);\n\n\tret = test_trace_synth_event();\n\tWARN_ON(ret);\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "test_trace_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
    "lines": "424-440",
    "snippet": "static int __init test_trace_synth_event(void)\n{\n\tint ret;\n\n\t/* Trace some bogus values just for testing */\n\tret = synth_event_trace(create_synth_test, 9,\t/* number of values */\n\t\t\t\t(u64)444,\t\t/* next_pid_field */\n\t\t\t\t(u64)(long)\"clackers\",\t/* next_comm_field */\n\t\t\t\t(u64)1000000,\t\t/* ts_ns */\n\t\t\t\t(u64)(long)\"viewmaster\",/* dynstring_field_1 */\n\t\t\t\t(u64)1000,\t\t/* ts_ms */\n\t\t\t\t(u64)raw_smp_processor_id(), /* cpu */\n\t\t\t\t(u64)(long)\"Thneed\",\t/* my_string_field */\n\t\t\t\t(u64)(long)\"yoyos\",\t/* dynstring_field_2 */\n\t\t\t\t(u64)999);\t\t/* my_int_field */\n\treturn ret;\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *create_synth_test;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synth_event_trace",
          "args": [
            "create_synth_test",
            "9",
            "/* number of values */(u64)444",
            "/* next_pid_field */(u64)(long)\"clackers\"",
            "/* next_comm_field */(u64)1000000",
            "/* ts_ns */(u64)(long)\"viewmaster\"",
            "/* dynstring_field_1 */(u64)1000",
            "/* ts_ms */(u64)raw_smp_processor_id()",
            "/* cpu */(u64)(long)\"Thneed\"",
            "/* my_string_field */(u64)(long)\"yoyos\"",
            "/* dynstring_field_2 */(u64)999"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1624-1707",
          "snippet": "int synth_event_trace(struct trace_event_file *file, unsigned int n_vals, ...)\n{\n\tunsigned int i, n_u64, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tva_list args;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tva_start(args, n_vals);\n\n\t\tfor (i = 0; i < state.event->n_fields; i++) {\n\t\t\tu64 val = va_arg(args, u64);\n\n\t\t\tif (state.event->fields[i]->is_string &&\n\t\t\t    state.event->fields[i]->is_dynamic) {\n\t\t\t\tchar *str_val = (char *)(long)val;\n\n\t\t\t\tdata_size += strlen(str_val) + 1;\n\t\t\t}\n\t\t}\n\n\t\tva_end(args);\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tva_start(args, n_vals);\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tu64 val;\n\n\t\tval = va_arg(args, u64);\n\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)val;\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\n\tva_end(args);\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace(struct trace_event_file *file, unsigned int n_vals, ...)\n{\n\tunsigned int i, n_u64, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tva_list args;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tva_start(args, n_vals);\n\n\t\tfor (i = 0; i < state.event->n_fields; i++) {\n\t\t\tu64 val = va_arg(args, u64);\n\n\t\t\tif (state.event->fields[i]->is_string &&\n\t\t\t    state.event->fields[i]->is_dynamic) {\n\t\t\t\tchar *str_val = (char *)(long)val;\n\n\t\t\t\tdata_size += strlen(str_val) + 1;\n\t\t\t}\n\t\t}\n\n\t\tva_end(args);\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tva_start(args, n_vals);\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tu64 val;\n\n\t\tval = va_arg(args, u64);\n\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)val;\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\n\tva_end(args);\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *create_synth_test;\n\nstatic int __init test_trace_synth_event(void)\n{\n\tint ret;\n\n\t/* Trace some bogus values just for testing */\n\tret = synth_event_trace(create_synth_test, 9,\t/* number of values */\n\t\t\t\t(u64)444,\t\t/* next_pid_field */\n\t\t\t\t(u64)(long)\"clackers\",\t/* next_comm_field */\n\t\t\t\t(u64)1000000,\t\t/* ts_ns */\n\t\t\t\t(u64)(long)\"viewmaster\",/* dynstring_field_1 */\n\t\t\t\t(u64)1000,\t\t/* ts_ms */\n\t\t\t\t(u64)raw_smp_processor_id(), /* cpu */\n\t\t\t\t(u64)(long)\"Thneed\",\t/* my_string_field */\n\t\t\t\t(u64)(long)\"yoyos\",\t/* dynstring_field_2 */\n\t\t\t\t(u64)999);\t\t/* my_int_field */\n\treturn ret;\n}"
  },
  {
    "function_name": "test_add_synth_val",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
    "lines": "375-419",
    "snippet": "static int __init test_add_synth_val(void)\n{\n\tstruct synth_event_trace_state trace_state;\n\tint ret;\n\n\t/* Start by reserving space in the trace buffer */\n\tret = synth_event_trace_start(gen_synth_test, &trace_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Write some bogus values into the trace buffer, using field names */\n\n\tret = synth_event_add_val(\"ts_ns\", 1000000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"ts_ms\", 1000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"cpu\", raw_smp_processor_id(), &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"next_pid_field\", 777, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"next_comm_field\", (u64)(long)\"silly putty\",\n\t\t\t\t  &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"my_string_field\", (u64)(long)\"thneed_9\",\n\t\t\t\t  &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"my_int_field\", 3999, &trace_state);\n out:\n\t/* Finally, commit the event */\n\tret = synth_event_trace_end(&trace_state);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *gen_synth_test;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synth_event_trace_end",
          "args": [
            "&trace_state"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_trace_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "2034-2042",
          "snippet": "int synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\t__synth_event_trace_end(trace_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\t__synth_event_trace_end(trace_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_add_val",
          "args": [
            "\"my_int_field\"",
            "3999",
            "&trace_state"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_add_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "2007-2011",
          "snippet": "int synth_event_add_val(const char *field_name, u64 val,\n\t\t\tstruct synth_event_trace_state *trace_state)\n{\n\treturn __synth_event_add_val(field_name, val, trace_state);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_val(const char *field_name, u64 val,\n\t\t\tstruct synth_event_trace_state *trace_state)\n{\n\treturn __synth_event_add_val(field_name, val, trace_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_event_trace_start",
          "args": [
            "gen_synth_test",
            "&trace_state"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_trace_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1830-1851",
          "snippet": "int synth_event_trace_start(struct trace_event_file *file,\n\t\t\t    struct synth_event_trace_state *trace_state)\n{\n\tint ret;\n\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\tret = __synth_event_trace_init(file, trace_state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (trace_state->event->n_dynamic_fields)\n\t\treturn -ENOTSUPP;\n\n\tret = __synth_event_trace_start(file, trace_state, 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace_start(struct trace_event_file *file,\n\t\t\t    struct synth_event_trace_state *trace_state)\n{\n\tint ret;\n\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\tret = __synth_event_trace_init(file, trace_state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (trace_state->event->n_dynamic_fields)\n\t\treturn -ENOTSUPP;\n\n\tret = __synth_event_trace_start(file, trace_state, 0);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_synth_test;\n\nstatic int __init test_add_synth_val(void)\n{\n\tstruct synth_event_trace_state trace_state;\n\tint ret;\n\n\t/* Start by reserving space in the trace buffer */\n\tret = synth_event_trace_start(gen_synth_test, &trace_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Write some bogus values into the trace buffer, using field names */\n\n\tret = synth_event_add_val(\"ts_ns\", 1000000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"ts_ms\", 1000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"cpu\", raw_smp_processor_id(), &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"next_pid_field\", 777, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"next_comm_field\", (u64)(long)\"silly putty\",\n\t\t\t\t  &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"my_string_field\", (u64)(long)\"thneed_9\",\n\t\t\t\t  &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_add_val(\"my_int_field\", 3999, &trace_state);\n out:\n\t/* Finally, commit the event */\n\tret = synth_event_trace_end(&trace_state);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "test_add_next_synth_val",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
    "lines": "319-368",
    "snippet": "static int __init test_add_next_synth_val(void)\n{\n\tstruct synth_event_trace_state trace_state;\n\tint ret;\n\n\t/* Start by reserving space in the trace buffer */\n\tret = synth_event_trace_start(gen_synth_test, &trace_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Write some bogus values into the trace buffer, one after another */\n\n\t/* next_pid_field */\n\tret = synth_event_add_next_val(777, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* next_comm_field */\n\tret = synth_event_add_next_val((u64)(long)\"slinky\", &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* ts_ns */\n\tret = synth_event_add_next_val(1000000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* ts_ms */\n\tret = synth_event_add_next_val(1000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* cpu */\n\tret = synth_event_add_next_val(raw_smp_processor_id(), &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* my_string_field */\n\tret = synth_event_add_next_val((u64)(long)\"thneed_2.01\", &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* my_int_field */\n\tret = synth_event_add_next_val(395, &trace_state);\n out:\n\t/* Finally, commit the event */\n\tret = synth_event_trace_end(&trace_state);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *gen_synth_test;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synth_event_trace_end",
          "args": [
            "&trace_state"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_trace_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "2034-2042",
          "snippet": "int synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\t__synth_event_trace_end(trace_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\t__synth_event_trace_end(trace_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_add_next_val",
          "args": [
            "395",
            "&trace_state"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_add_next_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1972-1976",
          "snippet": "int synth_event_add_next_val(u64 val,\n\t\t\t     struct synth_event_trace_state *trace_state)\n{\n\treturn __synth_event_add_val(NULL, val, trace_state);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_next_val(u64 val,\n\t\t\t     struct synth_event_trace_state *trace_state)\n{\n\treturn __synth_event_add_val(NULL, val, trace_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_event_trace_start",
          "args": [
            "gen_synth_test",
            "&trace_state"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_trace_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1830-1851",
          "snippet": "int synth_event_trace_start(struct trace_event_file *file,\n\t\t\t    struct synth_event_trace_state *trace_state)\n{\n\tint ret;\n\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\tret = __synth_event_trace_init(file, trace_state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (trace_state->event->n_dynamic_fields)\n\t\treturn -ENOTSUPP;\n\n\tret = __synth_event_trace_start(file, trace_state, 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace_start(struct trace_event_file *file,\n\t\t\t    struct synth_event_trace_state *trace_state)\n{\n\tint ret;\n\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\tret = __synth_event_trace_init(file, trace_state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (trace_state->event->n_dynamic_fields)\n\t\treturn -ENOTSUPP;\n\n\tret = __synth_event_trace_start(file, trace_state, 0);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_synth_test;\n\nstatic int __init test_add_next_synth_val(void)\n{\n\tstruct synth_event_trace_state trace_state;\n\tint ret;\n\n\t/* Start by reserving space in the trace buffer */\n\tret = synth_event_trace_start(gen_synth_test, &trace_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Write some bogus values into the trace buffer, one after another */\n\n\t/* next_pid_field */\n\tret = synth_event_add_next_val(777, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* next_comm_field */\n\tret = synth_event_add_next_val((u64)(long)\"slinky\", &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* ts_ns */\n\tret = synth_event_add_next_val(1000000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* ts_ms */\n\tret = synth_event_add_next_val(1000, &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* cpu */\n\tret = synth_event_add_next_val(raw_smp_processor_id(), &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* my_string_field */\n\tret = synth_event_add_next_val((u64)(long)\"thneed_2.01\", &trace_state);\n\tif (ret)\n\t\tgoto out;\n\n\t/* my_int_field */\n\tret = synth_event_add_next_val(395, &trace_state);\n out:\n\t/* Finally, commit the event */\n\tret = synth_event_trace_end(&trace_state);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "test_create_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
    "lines": "257-313",
    "snippet": "static int __init test_create_synth_event(void)\n{\n\tu64 vals[9];\n\tint ret;\n\n\t/* Create the create_synth_test event with the fields above */\n\tret = synth_event_create(\"create_synth_test\",\n\t\t\t\t create_synth_test_fields,\n\t\t\t\t ARRAY_SIZE(create_synth_test_fields),\n\t\t\t\t THIS_MODULE);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Now get the create_synth_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tcreate_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t\t \"create_synth_test\");\n\tif (IS_ERR(create_synth_test)) {\n\t\tret = PTR_ERR(create_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(create_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"create_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(create_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"tiddlywinks\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = (u64)(long)\"xrayspecs\";\t/* dynstring_field_1 */\n\tvals[4] = 1000;\t\t\t/* ts_ms */\n\tvals[5] = raw_smp_processor_id(); /* cpu */\n\tvals[6] = (u64)(long)\"thneed\";\t/* my_string_field */\n\tvals[7] = (u64)(long)\"kerplunk\";\t/* dynstring_field_2 */\n\tvals[8] = 398;\t\t\t/* my_int_field */\n\n\t/* Now generate a create_synth_test event */\n\tret = synth_event_trace_array(create_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"create_synth_test\");\n\n\tgoto out;\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *create_synth_test;",
      "static struct synth_field_desc create_synth_test_fields[] = {\n\t{ .type = \"pid_t\",\t\t.name = \"next_pid_field\" },\n\t{ .type = \"char[16]\",\t\t.name = \"next_comm_field\" },\n\t{ .type = \"u64\",\t\t.name = \"ts_ns\" },\n\t{ .type = \"char[]\",\t\t.name = \"dynstring_field_1\" },\n\t{ .type = \"u64\",\t\t.name = \"ts_ms\" },\n\t{ .type = \"unsigned int\",\t.name = \"cpu\" },\n\t{ .type = \"char[64]\",\t\t.name = \"my_string_field\" },\n\t{ .type = \"char[]\",\t\t.name = \"dynstring_field_2\" },\n\t{ .type = \"int\",\t\t.name = \"my_int_field\" },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synth_event_delete",
          "args": [
            "\"create_synth_test\""
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1395-1426",
          "snippet": "int synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_trace_array",
          "args": [
            "create_synth_test",
            "vals",
            "ARRAY_SIZE(vals)"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1728-1799",
          "snippet": "int synth_event_trace_array(struct trace_event_file *file, u64 *vals,\n\t\t\t    unsigned int n_vals)\n{\n\tunsigned int i, n_u64, field_pos, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tchar *str_val;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tfor (i = 0; i < state.event->n_dynamic_fields; i++) {\n\t\t\tfield_pos = state.event->dynamic_fields[i]->field_pos;\n\t\t\tstr_val = (char *)(long)vals[field_pos];\n\t\t\tlen = strlen(str_val) + 1;\n\t\t\tdata_size += len;\n\t\t}\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)vals[i];\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\t\t\tu64 val = vals[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace_array(struct trace_event_file *file, u64 *vals,\n\t\t\t    unsigned int n_vals)\n{\n\tunsigned int i, n_u64, field_pos, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tchar *str_val;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tfor (i = 0; i < state.event->n_dynamic_fields; i++) {\n\t\t\tfield_pos = state.event->dynamic_fields[i]->field_pos;\n\t\t\tstr_val = (char *)(long)vals[field_pos];\n\t\t\tlen = strlen(str_val) + 1;\n\t\t\tdata_size += len;\n\t\t}\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)vals[i];\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\t\t\tu64 val = vals[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vals"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_put_event_file",
          "args": [
            "create_synth_test"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "trace_put_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3031-3038",
          "snippet": "void trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_set_clr_event",
          "args": [
            "create_synth_test->tr",
            "\"synthetic\"",
            "\"create_synth_test\"",
            "true"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1123-1133",
          "snippet": "int trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "create_synth_test"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "create_synth_test"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_event_file",
          "args": [
            "NULL",
            "\"synthetic\"",
            "\"create_synth_test\""
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2976-3019",
          "snippet": "struct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_create",
          "args": [
            "\"create_synth_test\"",
            "create_synth_test_fields",
            "ARRAY_SIZE(create_synth_test_fields)",
            "THIS_MODULE"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1342-1365",
          "snippet": "int synth_event_create(const char *name, struct synth_field_desc *fields,\n\t\t       unsigned int n_fields, struct module *mod)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\tret = synth_event_gen_cmd_array_start(&cmd, name, mod,\n\t\t\t\t\t      fields, n_fields);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_gen_cmd_end(&cmd);\n out:\n\tkfree(buf);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_create(const char *name, struct synth_field_desc *fields,\n\t\t       unsigned int n_fields, struct module *mod)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\tret = synth_event_gen_cmd_array_start(&cmd, name, mod,\n\t\t\t\t\t      fields, n_fields);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_gen_cmd_end(&cmd);\n out:\n\tkfree(buf);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "create_synth_test_fields"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *create_synth_test;\nstatic struct synth_field_desc create_synth_test_fields[] = {\n\t{ .type = \"pid_t\",\t\t.name = \"next_pid_field\" },\n\t{ .type = \"char[16]\",\t\t.name = \"next_comm_field\" },\n\t{ .type = \"u64\",\t\t.name = \"ts_ns\" },\n\t{ .type = \"char[]\",\t\t.name = \"dynstring_field_1\" },\n\t{ .type = \"u64\",\t\t.name = \"ts_ms\" },\n\t{ .type = \"unsigned int\",\t.name = \"cpu\" },\n\t{ .type = \"char[64]\",\t\t.name = \"my_string_field\" },\n\t{ .type = \"char[]\",\t\t.name = \"dynstring_field_2\" },\n\t{ .type = \"int\",\t\t.name = \"my_int_field\" },\n};\n\nstatic int __init test_create_synth_event(void)\n{\n\tu64 vals[9];\n\tint ret;\n\n\t/* Create the create_synth_test event with the fields above */\n\tret = synth_event_create(\"create_synth_test\",\n\t\t\t\t create_synth_test_fields,\n\t\t\t\t ARRAY_SIZE(create_synth_test_fields),\n\t\t\t\t THIS_MODULE);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Now get the create_synth_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tcreate_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t\t \"create_synth_test\");\n\tif (IS_ERR(create_synth_test)) {\n\t\tret = PTR_ERR(create_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(create_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"create_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(create_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"tiddlywinks\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = (u64)(long)\"xrayspecs\";\t/* dynstring_field_1 */\n\tvals[4] = 1000;\t\t\t/* ts_ms */\n\tvals[5] = raw_smp_processor_id(); /* cpu */\n\tvals[6] = (u64)(long)\"thneed\";\t/* my_string_field */\n\tvals[7] = (u64)(long)\"kerplunk\";\t/* dynstring_field_2 */\n\tvals[8] = 398;\t\t\t/* my_int_field */\n\n\t/* Now generate a create_synth_test event */\n\tret = synth_event_trace_array(create_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"create_synth_test\");\n\n\tgoto out;\n}"
  },
  {
    "function_name": "test_empty_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
    "lines": "138-239",
    "snippet": "static int __init test_empty_synth_event(void)\n{\n\tstruct dynevent_cmd cmd;\n\tu64 vals[7];\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Create the empty_synth_test synthetic event with no fields.\n\t */\n\tret = synth_event_gen_cmd_start(&cmd, \"empty_synth_test\", THIS_MODULE);\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use synth_event_add_field to add all of the fields */\n\n\tret = synth_event_add_field(&cmd, \"pid_t\", \"next_pid_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[16]\", \"next_comm_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"u64\", \"ts_ns\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"u64\", \"ts_ms\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"unsigned int\", \"cpu\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[64]\", \"my_string_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"int\", \"my_int_field\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* All fields have been added, close and register the synth event */\n\n\tret = synth_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the empty_synth_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tempty_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t\t\"empty_synth_test\");\n\tif (IS_ERR(empty_synth_test)) {\n\t\tret = PTR_ERR(empty_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(empty_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"empty_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(empty_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"tiddlywinks\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = 1000;\t\t\t/* ts_ms */\n\tvals[4] = raw_smp_processor_id(); /* cpu */\n\tvals[5] = (u64)(long)\"thneed_2.0\";\t/* my_string_field */\n\tvals[6] = 399;\t\t\t/* my_int_field */\n\n\t/* Now trace an empty_synth_test event */\n\tret = synth_event_trace_array(empty_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"empty_synth_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *empty_synth_test;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_delete",
          "args": [
            "\"empty_synth_test\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1395-1426",
          "snippet": "int synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_trace_array",
          "args": [
            "empty_synth_test",
            "vals",
            "ARRAY_SIZE(vals)"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1728-1799",
          "snippet": "int synth_event_trace_array(struct trace_event_file *file, u64 *vals,\n\t\t\t    unsigned int n_vals)\n{\n\tunsigned int i, n_u64, field_pos, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tchar *str_val;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tfor (i = 0; i < state.event->n_dynamic_fields; i++) {\n\t\t\tfield_pos = state.event->dynamic_fields[i]->field_pos;\n\t\t\tstr_val = (char *)(long)vals[field_pos];\n\t\t\tlen = strlen(str_val) + 1;\n\t\t\tdata_size += len;\n\t\t}\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)vals[i];\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\t\t\tu64 val = vals[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace_array(struct trace_event_file *file, u64 *vals,\n\t\t\t    unsigned int n_vals)\n{\n\tunsigned int i, n_u64, field_pos, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tchar *str_val;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tfor (i = 0; i < state.event->n_dynamic_fields; i++) {\n\t\t\tfield_pos = state.event->dynamic_fields[i]->field_pos;\n\t\t\tstr_val = (char *)(long)vals[field_pos];\n\t\t\tlen = strlen(str_val) + 1;\n\t\t\tdata_size += len;\n\t\t}\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)vals[i];\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\t\t\tu64 val = vals[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vals"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_put_event_file",
          "args": [
            "empty_synth_test"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "trace_put_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3031-3038",
          "snippet": "void trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_set_clr_event",
          "args": [
            "empty_synth_test->tr",
            "\"synthetic\"",
            "\"empty_synth_test\"",
            "true"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1123-1133",
          "snippet": "int trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "empty_synth_test"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "empty_synth_test"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_event_file",
          "args": [
            "NULL",
            "\"synthetic\"",
            "\"empty_synth_test\""
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2976-3019",
          "snippet": "struct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_gen_cmd_end",
          "args": [
            "&cmd"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_event_add_field",
          "args": [
            "&cmd",
            "\"int\"",
            "\"my_int_field\""
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_add_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1023-1042",
          "snippet": "int synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_gen_cmd_start",
          "args": [
            "&cmd",
            "\"empty_synth_test\"",
            "THIS_MODULE"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_gen_cmd_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1073-1115",
          "snippet": "int __synth_event_gen_cmd_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\tstruct module *mod, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, mod);\n\tfor (;;) {\n\t\tconst char *type, *name;\n\n\t\ttype = va_arg(args, const char *);\n\t\tif (!type)\n\t\t\tbreak;\n\t\tname = va_arg(args, const char *);\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > SYNTH_FIELDS_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, type, name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint __synth_event_gen_cmd_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\tstruct module *mod, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, mod);\n\tfor (;;) {\n\t\tconst char *type, *name;\n\n\t\ttype = va_arg(args, const char *);\n\t\tif (!type)\n\t\t\tbreak;\n\t\tname = va_arg(args, const char *);\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > SYNTH_FIELDS_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, type, name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_cmd_init",
          "args": [
            "&cmd",
            "buf",
            "MAX_DYNEVENT_CMD_LEN"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_cmd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1531-1535",
          "snippet": "void synth_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_SYNTH,\n\t\t\t  synth_event_run_command);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nvoid synth_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_SYNTH,\n\t\t\t  synth_event_run_command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "MAX_DYNEVENT_CMD_LEN",
            "GFP_KERNEL"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *empty_synth_test;\n\nstatic int __init test_empty_synth_event(void)\n{\n\tstruct dynevent_cmd cmd;\n\tu64 vals[7];\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Create the empty_synth_test synthetic event with no fields.\n\t */\n\tret = synth_event_gen_cmd_start(&cmd, \"empty_synth_test\", THIS_MODULE);\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use synth_event_add_field to add all of the fields */\n\n\tret = synth_event_add_field(&cmd, \"pid_t\", \"next_pid_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[16]\", \"next_comm_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"u64\", \"ts_ns\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"u64\", \"ts_ms\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"unsigned int\", \"cpu\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[64]\", \"my_string_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"int\", \"my_int_field\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* All fields have been added, close and register the synth event */\n\n\tret = synth_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the empty_synth_test event file.  We need to\n\t * prevent the instance and event from disappearing from\n\t * underneath us, which trace_get_event_file() does (though in\n\t * this case we're using the top-level instance which never\n\t * goes away).\n\t */\n\tempty_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t\t\"empty_synth_test\");\n\tif (IS_ERR(empty_synth_test)) {\n\t\tret = PTR_ERR(empty_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(empty_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"empty_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(empty_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"tiddlywinks\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = 1000;\t\t\t/* ts_ms */\n\tvals[4] = raw_smp_processor_id(); /* cpu */\n\tvals[5] = (u64)(long)\"thneed_2.0\";\t/* my_string_field */\n\tvals[6] = 399;\t\t\t/* my_int_field */\n\n\t/* Now trace an empty_synth_test event */\n\tret = synth_event_trace_array(empty_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"empty_synth_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}"
  },
  {
    "function_name": "test_gen_synth_cmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/synth_event_gen_test.c",
    "lines": "45-132",
    "snippet": "static int __init test_gen_synth_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tu64 vals[7];\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Create the empty gen_synth_test synthetic event with the\n\t * first 4 fields.\n\t */\n\tret = synth_event_gen_cmd_start(&cmd, \"gen_synth_test\", THIS_MODULE,\n\t\t\t\t\t\"pid_t\", \"next_pid_field\",\n\t\t\t\t\t\"char[16]\", \"next_comm_field\",\n\t\t\t\t\t\"u64\", \"ts_ns\",\n\t\t\t\t\t\"u64\", \"ts_ms\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use synth_event_add_field to add the rest of the fields */\n\n\tret = synth_event_add_field(&cmd, \"unsigned int\", \"cpu\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[64]\", \"my_string_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"int\", \"my_int_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_synth_test event file.  We need to prevent\n\t * the instance and event from disappearing from underneath\n\t * us, which trace_get_event_file() does (though in this case\n\t * we're using the top-level instance which never goes away).\n\t */\n\tgen_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t      \"gen_synth_test\");\n\tif (IS_ERR(gen_synth_test)) {\n\t\tret = PTR_ERR(gen_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"gen_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"hula hoops\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = 1000;\t\t\t/* ts_ms */\n\tvals[4] = raw_smp_processor_id(); /* cpu */\n\tvals[5] = (u64)(long)\"thneed\";\t/* my_string_field */\n\tvals[6] = 598;\t\t\t/* my_int_field */\n\n\t/* Now generate a gen_synth_test event */\n\tret = synth_event_trace_array(gen_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"gen_synth_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}",
    "includes": [
      "#include <linux/trace_events.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_file *gen_synth_test;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_delete",
          "args": [
            "\"gen_synth_test\""
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1395-1426",
          "snippet": "int synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_trace_array",
          "args": [
            "gen_synth_test",
            "vals",
            "ARRAY_SIZE(vals)"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1728-1799",
          "snippet": "int synth_event_trace_array(struct trace_event_file *file, u64 *vals,\n\t\t\t    unsigned int n_vals)\n{\n\tunsigned int i, n_u64, field_pos, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tchar *str_val;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tfor (i = 0; i < state.event->n_dynamic_fields; i++) {\n\t\t\tfield_pos = state.event->dynamic_fields[i]->field_pos;\n\t\t\tstr_val = (char *)(long)vals[field_pos];\n\t\t\tlen = strlen(str_val) + 1;\n\t\t\tdata_size += len;\n\t\t}\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)vals[i];\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\t\t\tu64 val = vals[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace_array(struct trace_event_file *file, u64 *vals,\n\t\t\t    unsigned int n_vals)\n{\n\tunsigned int i, n_u64, field_pos, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tchar *str_val;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tfor (i = 0; i < state.event->n_dynamic_fields; i++) {\n\t\t\tfield_pos = state.event->dynamic_fields[i]->field_pos;\n\t\t\tstr_val = (char *)(long)vals[field_pos];\n\t\t\tlen = strlen(str_val) + 1;\n\t\t\tdata_size += len;\n\t\t}\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)vals[i];\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\t\t\tu64 val = vals[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vals"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_put_event_file",
          "args": [
            "gen_synth_test"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "trace_put_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3031-3038",
          "snippet": "void trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_set_clr_event",
          "args": [
            "gen_synth_test->tr",
            "\"synthetic\"",
            "\"gen_synth_test\"",
            "true"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1123-1133",
          "snippet": "int trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "gen_synth_test"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "gen_synth_test"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_event_file",
          "args": [
            "NULL",
            "\"synthetic\"",
            "\"gen_synth_test\""
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2976-3019",
          "snippet": "struct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_gen_cmd_end",
          "args": [
            "&cmd"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_event_add_field",
          "args": [
            "&cmd",
            "\"int\"",
            "\"my_int_field\""
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_add_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1023-1042",
          "snippet": "int synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_gen_cmd_start",
          "args": [
            "&cmd",
            "\"gen_synth_test\"",
            "THIS_MODULE",
            "\"pid_t\"",
            "\"next_pid_field\"",
            "\"char[16]\"",
            "\"next_comm_field\"",
            "\"u64\"",
            "\"ts_ns\"",
            "\"u64\"",
            "\"ts_ms\""
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_gen_cmd_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1073-1115",
          "snippet": "int __synth_event_gen_cmd_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\tstruct module *mod, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, mod);\n\tfor (;;) {\n\t\tconst char *type, *name;\n\n\t\ttype = va_arg(args, const char *);\n\t\tif (!type)\n\t\t\tbreak;\n\t\tname = va_arg(args, const char *);\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > SYNTH_FIELDS_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, type, name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint __synth_event_gen_cmd_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\tstruct module *mod, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, mod);\n\tfor (;;) {\n\t\tconst char *type, *name;\n\n\t\ttype = va_arg(args, const char *);\n\t\tif (!type)\n\t\t\tbreak;\n\t\tname = va_arg(args, const char *);\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > SYNTH_FIELDS_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, type, name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_cmd_init",
          "args": [
            "&cmd",
            "buf",
            "MAX_DYNEVENT_CMD_LEN"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_cmd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1531-1535",
          "snippet": "void synth_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_SYNTH,\n\t\t\t  synth_event_run_command);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nvoid synth_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_SYNTH,\n\t\t\t  synth_event_run_command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "MAX_DYNEVENT_CMD_LEN",
            "GFP_KERNEL"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/trace_events.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *gen_synth_test;\n\nstatic int __init test_gen_synth_cmd(void)\n{\n\tstruct dynevent_cmd cmd;\n\tu64 vals[7];\n\tchar *buf;\n\tint ret;\n\n\t/* Create a buffer to hold the generated command */\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* Before generating the command, initialize the cmd object */\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\t/*\n\t * Create the empty gen_synth_test synthetic event with the\n\t * first 4 fields.\n\t */\n\tret = synth_event_gen_cmd_start(&cmd, \"gen_synth_test\", THIS_MODULE,\n\t\t\t\t\t\"pid_t\", \"next_pid_field\",\n\t\t\t\t\t\"char[16]\", \"next_comm_field\",\n\t\t\t\t\t\"u64\", \"ts_ns\",\n\t\t\t\t\t\"u64\", \"ts_ms\");\n\tif (ret)\n\t\tgoto free;\n\n\t/* Use synth_event_add_field to add the rest of the fields */\n\n\tret = synth_event_add_field(&cmd, \"unsigned int\", \"cpu\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"char[64]\", \"my_string_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_add_field(&cmd, \"int\", \"my_int_field\");\n\tif (ret)\n\t\tgoto free;\n\n\tret = synth_event_gen_cmd_end(&cmd);\n\tif (ret)\n\t\tgoto free;\n\n\t/*\n\t * Now get the gen_synth_test event file.  We need to prevent\n\t * the instance and event from disappearing from underneath\n\t * us, which trace_get_event_file() does (though in this case\n\t * we're using the top-level instance which never goes away).\n\t */\n\tgen_synth_test = trace_get_event_file(NULL, \"synthetic\",\n\t\t\t\t\t      \"gen_synth_test\");\n\tif (IS_ERR(gen_synth_test)) {\n\t\tret = PTR_ERR(gen_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Enable the event or you won't see anything */\n\tret = trace_array_set_clr_event(gen_synth_test->tr,\n\t\t\t\t\t\"synthetic\", \"gen_synth_test\", true);\n\tif (ret) {\n\t\ttrace_put_event_file(gen_synth_test);\n\t\tgoto delete;\n\t}\n\n\t/* Create some bogus values just for testing */\n\n\tvals[0] = 777;\t\t\t/* next_pid_field */\n\tvals[1] = (u64)(long)\"hula hoops\";\t/* next_comm_field */\n\tvals[2] = 1000000;\t\t/* ts_ns */\n\tvals[3] = 1000;\t\t\t/* ts_ms */\n\tvals[4] = raw_smp_processor_id(); /* cpu */\n\tvals[5] = (u64)(long)\"thneed\";\t/* my_string_field */\n\tvals[6] = 598;\t\t\t/* my_int_field */\n\n\t/* Now generate a gen_synth_test event */\n\tret = synth_event_trace_array(gen_synth_test, vals, ARRAY_SIZE(vals));\n out:\n\treturn ret;\n delete:\n\t/* We got an error after creating the event, delete it */\n\tsynth_event_delete(\"gen_synth_test\");\n free:\n\tkfree(buf);\n\n\tgoto out;\n}"
  }
]