[
  {
    "function_name": "audit_tree_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "1071-1085",
    "snippet": "static int __init audit_tree_init(void)\n{\n\tint i;\n\n\taudit_tree_mark_cachep = KMEM_CACHE(audit_tree_mark, SLAB_PANIC);\n\n\taudit_tree_group = fsnotify_alloc_group(&audit_tree_ops);\n\tif (IS_ERR(audit_tree_group))\n\t\taudit_panic(\"cannot initialize fsnotify group for rectree watches\");\n\n\tfor (i = 0; i < HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&chunk_hash_heads[i]);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_tree_group;",
      "static struct kmem_cache *audit_tree_mark_cachep",
      "static struct list_head chunk_hash_heads[HASH_SIZE];",
      "static const struct fsnotify_ops audit_tree_ops = {\n\t.handle_inode_event = audit_tree_handle_event,\n\t.freeing_mark = audit_tree_freeing_mark,\n\t.free_mark = audit_tree_destroy_watch,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&chunk_hash_heads[i]"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"cannot initialize fsnotify group for rectree watches\""
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "302-315",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "audit_tree_group"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_alloc_group",
          "args": [
            "&audit_tree_ops"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "audit_tree_mark",
            "SLAB_PANIC"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic struct kmem_cache *audit_tree_mark_cachep;\nstatic struct list_head chunk_hash_heads[HASH_SIZE];\nstatic const struct fsnotify_ops audit_tree_ops = {\n\t.handle_inode_event = audit_tree_handle_event,\n\t.freeing_mark = audit_tree_freeing_mark,\n\t.free_mark = audit_tree_destroy_watch,\n};\n\nstatic int __init audit_tree_init(void)\n{\n\tint i;\n\n\taudit_tree_mark_cachep = KMEM_CACHE(audit_tree_mark, SLAB_PANIC);\n\n\taudit_tree_group = fsnotify_alloc_group(&audit_tree_ops);\n\tif (IS_ERR(audit_tree_group))\n\t\taudit_panic(\"cannot initialize fsnotify group for rectree watches\");\n\n\tfor (i = 0; i < HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&chunk_hash_heads[i]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_tree_freeing_mark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "1042-1063",
    "snippet": "static void audit_tree_freeing_mark(struct fsnotify_mark *mark,\n\t\t\t\t    struct fsnotify_group *group)\n{\n\tstruct audit_chunk *chunk;\n\n\tmutex_lock(&mark->group->mark_mutex);\n\tspin_lock(&hash_lock);\n\tchunk = mark_chunk(mark);\n\treplace_mark_chunk(mark, NULL);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&mark->group->mark_mutex);\n\tif (chunk) {\n\t\tevict_chunk(chunk);\n\t\taudit_mark_put_chunk(chunk);\n\t}\n\n\t/*\n\t * We are guaranteed to have at least one reference to the mark from\n\t * either the inode or the caller of fsnotify_destroy_mark().\n\t */\n\tBUG_ON(refcount_read(&mark->refcnt) < 1);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "refcount_read(&mark->refcnt) < 1"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&mark->refcnt"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_mark_put_chunk",
          "args": [
            "chunk"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark_put_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "156-159",
          "snippet": "static void audit_mark_put_chunk(struct audit_chunk *chunk)\n{\n\tcall_rcu(&chunk->head, __put_chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void audit_mark_put_chunk(struct audit_chunk *chunk)\n{\n\tcall_rcu(&chunk->head, __put_chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "evict_chunk",
          "args": [
            "chunk"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "evict_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "1001-1033",
          "snippet": "static void evict_chunk(struct audit_chunk *chunk)\n{\n\tstruct audit_tree *owner;\n\tstruct list_head *postponed = audit_killed_trees();\n\tint need_prune = 0;\n\tint n;\n\n\tmutex_lock(&audit_filter_mutex);\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&chunk->trees)) {\n\t\towner = list_entry(chunk->trees.next,\n\t\t\t\t   struct audit_tree, same_root);\n\t\towner->goner = 1;\n\t\towner->root = NULL;\n\t\tlist_del_init(&owner->same_root);\n\t\tspin_unlock(&hash_lock);\n\t\tif (!postponed) {\n\t\t\tkill_rules(audit_context(), owner);\n\t\t\tlist_move(&owner->list, &prune_list);\n\t\t\tneed_prune = 1;\n\t\t} else {\n\t\t\tlist_move(&owner->list, postponed);\n\t\t}\n\t\tspin_lock(&hash_lock);\n\t}\n\tlist_del_rcu(&chunk->hash);\n\tfor (n = 0; n < chunk->count; n++)\n\t\tlist_del_init(&chunk->owners[n].list);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_filter_mutex);\n\tif (need_prune)\n\t\taudit_schedule_prune();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(prune_list);",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(prune_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\nstatic void audit_schedule_prune(void);\n\nstatic void evict_chunk(struct audit_chunk *chunk)\n{\n\tstruct audit_tree *owner;\n\tstruct list_head *postponed = audit_killed_trees();\n\tint need_prune = 0;\n\tint n;\n\n\tmutex_lock(&audit_filter_mutex);\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&chunk->trees)) {\n\t\towner = list_entry(chunk->trees.next,\n\t\t\t\t   struct audit_tree, same_root);\n\t\towner->goner = 1;\n\t\towner->root = NULL;\n\t\tlist_del_init(&owner->same_root);\n\t\tspin_unlock(&hash_lock);\n\t\tif (!postponed) {\n\t\t\tkill_rules(audit_context(), owner);\n\t\t\tlist_move(&owner->list, &prune_list);\n\t\t\tneed_prune = 1;\n\t\t} else {\n\t\t\tlist_move(&owner->list, postponed);\n\t\t}\n\t\tspin_lock(&hash_lock);\n\t}\n\tlist_del_rcu(&chunk->hash);\n\tfor (n = 0; n < chunk->count; n++)\n\t\tlist_del_init(&chunk->owners[n].list);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_filter_mutex);\n\tif (need_prune)\n\t\taudit_schedule_prune();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mark->group->mark_mutex"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_mark_chunk",
          "args": [
            "mark",
            "NULL"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "replace_mark_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "279-291",
          "snippet": "static void replace_mark_chunk(struct fsnotify_mark *mark,\n\t\t\t       struct audit_chunk *chunk)\n{\n\tstruct audit_chunk *old;\n\n\tassert_spin_locked(&hash_lock);\n\told = mark_chunk(mark);\n\taudit_mark(mark)->chunk = chunk;\n\tif (chunk)\n\t\tchunk->mark = mark;\n\tif (old)\n\t\told->mark = NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void replace_mark_chunk(struct fsnotify_mark *mark,\n\t\t\t       struct audit_chunk *chunk)\n{\n\tstruct audit_chunk *old;\n\n\tassert_spin_locked(&hash_lock);\n\told = mark_chunk(mark);\n\taudit_mark(mark)->chunk = chunk;\n\tif (chunk)\n\t\tchunk->mark = mark;\n\tif (old)\n\t\told->mark = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_chunk",
          "args": [
            "mark"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "mark_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "166-169",
          "snippet": "static struct audit_chunk *mark_chunk(struct fsnotify_mark *mark)\n{\n\treturn audit_mark(mark)->chunk;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *mark_chunk(struct fsnotify_mark *mark)\n{\n\treturn audit_mark(mark)->chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mark->group->mark_mutex"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void audit_tree_freeing_mark(struct fsnotify_mark *mark,\n\t\t\t\t    struct fsnotify_group *group)\n{\n\tstruct audit_chunk *chunk;\n\n\tmutex_lock(&mark->group->mark_mutex);\n\tspin_lock(&hash_lock);\n\tchunk = mark_chunk(mark);\n\treplace_mark_chunk(mark, NULL);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&mark->group->mark_mutex);\n\tif (chunk) {\n\t\tevict_chunk(chunk);\n\t\taudit_mark_put_chunk(chunk);\n\t}\n\n\t/*\n\t * We are guaranteed to have at least one reference to the mark from\n\t * either the inode or the caller of fsnotify_destroy_mark().\n\t */\n\tBUG_ON(refcount_read(&mark->refcnt) < 1);\n}"
  },
  {
    "function_name": "audit_tree_handle_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "1035-1040",
    "snippet": "static int audit_tree_handle_event(struct fsnotify_mark *mark, u32 mask,\n\t\t\t\t   struct inode *inode, struct inode *dir,\n\t\t\t\t   const struct qstr *file_name, u32 cookie)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic int audit_tree_handle_event(struct fsnotify_mark *mark, u32 mask,\n\t\t\t\t   struct inode *inode, struct inode *dir,\n\t\t\t\t   const struct qstr *file_name, u32 cookie)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "evict_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "1001-1033",
    "snippet": "static void evict_chunk(struct audit_chunk *chunk)\n{\n\tstruct audit_tree *owner;\n\tstruct list_head *postponed = audit_killed_trees();\n\tint need_prune = 0;\n\tint n;\n\n\tmutex_lock(&audit_filter_mutex);\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&chunk->trees)) {\n\t\towner = list_entry(chunk->trees.next,\n\t\t\t\t   struct audit_tree, same_root);\n\t\towner->goner = 1;\n\t\towner->root = NULL;\n\t\tlist_del_init(&owner->same_root);\n\t\tspin_unlock(&hash_lock);\n\t\tif (!postponed) {\n\t\t\tkill_rules(audit_context(), owner);\n\t\t\tlist_move(&owner->list, &prune_list);\n\t\t\tneed_prune = 1;\n\t\t} else {\n\t\t\tlist_move(&owner->list, postponed);\n\t\t}\n\t\tspin_lock(&hash_lock);\n\t}\n\tlist_del_rcu(&chunk->hash);\n\tfor (n = 0; n < chunk->count; n++)\n\t\tlist_del_init(&chunk->owners[n].list);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_filter_mutex);\n\tif (need_prune)\n\t\taudit_schedule_prune();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(prune_list);",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);",
      "static void audit_schedule_prune(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_schedule_prune",
          "args": [],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&chunk->owners[n].list"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&chunk->hash"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&owner->list",
            "postponed"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&owner->list",
            "&prune_list"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_rules",
          "args": [
            "audit_context()",
            "owner"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "kill_rules",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "542-562",
          "snippet": "static void kill_rules(struct audit_context *context, struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(context, rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void kill_rules(struct audit_context *context, struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(context, rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&owner->same_root"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "chunk->trees.next",
            "structaudit_tree",
            "same_root"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&chunk->trees"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_killed_trees",
          "args": [],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "audit_killed_trees",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2991-2997",
          "snippet": "struct list_head *audit_killed_trees(void)\n{\n\tstruct audit_context *ctx = audit_context();\n\tif (likely(!ctx || ctx->context == AUDIT_CTX_UNUSED))\n\t\treturn NULL;\n\treturn &ctx->killed_trees;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstruct list_head *audit_killed_trees(void)\n{\n\tstruct audit_context *ctx = audit_context();\n\tif (likely(!ctx || ctx->context == AUDIT_CTX_UNUSED))\n\t\treturn NULL;\n\treturn &ctx->killed_trees;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(prune_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\nstatic void audit_schedule_prune(void);\n\nstatic void evict_chunk(struct audit_chunk *chunk)\n{\n\tstruct audit_tree *owner;\n\tstruct list_head *postponed = audit_killed_trees();\n\tint need_prune = 0;\n\tint n;\n\n\tmutex_lock(&audit_filter_mutex);\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&chunk->trees)) {\n\t\towner = list_entry(chunk->trees.next,\n\t\t\t\t   struct audit_tree, same_root);\n\t\towner->goner = 1;\n\t\towner->root = NULL;\n\t\tlist_del_init(&owner->same_root);\n\t\tspin_unlock(&hash_lock);\n\t\tif (!postponed) {\n\t\t\tkill_rules(audit_context(), owner);\n\t\t\tlist_move(&owner->list, &prune_list);\n\t\t\tneed_prune = 1;\n\t\t} else {\n\t\t\tlist_move(&owner->list, postponed);\n\t\t}\n\t\tspin_lock(&hash_lock);\n\t}\n\tlist_del_rcu(&chunk->hash);\n\tfor (n = 0; n < chunk->count; n++)\n\t\tlist_del_init(&chunk->owners[n].list);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_filter_mutex);\n\tif (need_prune)\n\t\taudit_schedule_prune();\n}"
  },
  {
    "function_name": "audit_kill_trees",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "972-995",
    "snippet": "void audit_kill_trees(struct audit_context *context)\n{\n\tstruct list_head *list = &context->killed_trees;\n\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(context, victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_ctl_unlock",
          "args": [],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "243-247",
          "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_one",
          "args": [
            "victim"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "prune_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "601-605",
          "snippet": "static void prune_one(struct audit_tree *victim)\n{\n\tprune_tree_chunks(victim, false);\n\tput_tree(victim);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void prune_one(struct audit_tree *victim)\n{\n\tprune_tree_chunks(victim, false);\n\tput_tree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&victim->list"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_rules",
          "args": [
            "context",
            "victim"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "kill_rules",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "542-562",
          "snippet": "static void kill_rules(struct audit_context *context, struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(context, rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void kill_rules(struct audit_context *context, struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(context, rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list->next",
            "structaudit_tree",
            "list"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ctl_lock",
          "args": [],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "234-238",
          "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_kill_trees(struct audit_context *context)\n{\n\tstruct list_head *list = &context->killed_trees;\n\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(context, victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}"
  },
  {
    "function_name": "audit_schedule_prune",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "963-966",
    "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *prune_thread;",
      "static void audit_schedule_prune(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "prune_thread"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
  },
  {
    "function_name": "audit_tag_tree",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "870-960",
    "snippet": "int audit_tag_tree(char *old, char *new)\n{\n\tstruct list_head cursor, barrier;\n\tint failed = 0;\n\tstruct path path1, path2;\n\tstruct vfsmount *tagged;\n\tint err;\n\n\terr = kern_path(new, 0, &path2);\n\tif (err)\n\t\treturn err;\n\ttagged = collect_mounts(&path2);\n\tpath_put(&path2);\n\tif (IS_ERR(tagged))\n\t\treturn PTR_ERR(tagged);\n\n\terr = kern_path(old, 0, &path1);\n\tif (err) {\n\t\tdrop_collected_mounts(tagged);\n\t\treturn err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&barrier, &tree_list);\n\tlist_add(&cursor, &barrier);\n\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tint good_one = 0;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path2);\n\t\tif (!err) {\n\t\t\tgood_one = path_is_under(&path1, &path2);\n\t\t\tpath_put(&path2);\n\t\t}\n\n\t\tif (!good_one) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfailed = iterate_mounts(tag_mount, tree, tagged);\n\t\tif (failed) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tspin_lock(&hash_lock);\n\t\tif (!tree->goner) {\n\t\t\tlist_move(&tree->list, &tree_list);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\tput_tree(tree);\n\t}\n\n\twhile (barrier.prev != &tree_list) {\n\t\tstruct audit_tree *tree;\n\n\t\ttree = container_of(barrier.prev, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&tree->list, &barrier);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tif (!failed) {\n\t\t\tstruct audit_node *node;\n\t\t\tspin_lock(&hash_lock);\n\t\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t\tspin_unlock(&hash_lock);\n\t\t} else {\n\t\t\ttrim_marked(tree);\n\t\t}\n\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&barrier);\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n\tpath_put(&path1);\n\tdrop_collected_mounts(tagged);\n\treturn failed;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tree_list);",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_collected_mounts",
          "args": [
            "tagged"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path1"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cursor"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "tree"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "740-743",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim_marked",
          "args": [
            "tree"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "trim_marked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "609-642",
          "snippet": "static void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tprune_tree_chunks(tree, true);\n\n\tspin_lock(&hash_lock);\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(audit_context(), tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tprune_tree_chunks(tree, true);\n\n\tspin_lock(&hash_lock);\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(audit_context(), tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&tree->chunks",
            "list"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&tree->list",
            "&barrier"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "tree"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "111-114",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "barrier.prev",
            "structaudit_tree",
            "list"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&tree->list",
            "&tree_list"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_mounts",
          "args": [
            "tag_mount",
            "tree",
            "tagged"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path2"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_is_under",
          "args": [
            "&path1",
            "&path2"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "tree->pathname",
            "0",
            "&path2"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&cursor",
            "&tree->list"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cursor.next",
            "structaudit_tree",
            "list"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cursor",
            "&barrier"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_collected_mounts",
          "args": [
            "tagged"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "old",
            "0",
            "&path1"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tagged"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tagged"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path2"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_mounts",
          "args": [
            "&path2"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "new",
            "0",
            "&path2"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nint audit_tag_tree(char *old, char *new)\n{\n\tstruct list_head cursor, barrier;\n\tint failed = 0;\n\tstruct path path1, path2;\n\tstruct vfsmount *tagged;\n\tint err;\n\n\terr = kern_path(new, 0, &path2);\n\tif (err)\n\t\treturn err;\n\ttagged = collect_mounts(&path2);\n\tpath_put(&path2);\n\tif (IS_ERR(tagged))\n\t\treturn PTR_ERR(tagged);\n\n\terr = kern_path(old, 0, &path1);\n\tif (err) {\n\t\tdrop_collected_mounts(tagged);\n\t\treturn err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&barrier, &tree_list);\n\tlist_add(&cursor, &barrier);\n\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tint good_one = 0;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path2);\n\t\tif (!err) {\n\t\t\tgood_one = path_is_under(&path1, &path2);\n\t\t\tpath_put(&path2);\n\t\t}\n\n\t\tif (!good_one) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfailed = iterate_mounts(tag_mount, tree, tagged);\n\t\tif (failed) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tspin_lock(&hash_lock);\n\t\tif (!tree->goner) {\n\t\t\tlist_move(&tree->list, &tree_list);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\tput_tree(tree);\n\t}\n\n\twhile (barrier.prev != &tree_list) {\n\t\tstruct audit_tree *tree;\n\n\t\ttree = container_of(barrier.prev, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&tree->list, &barrier);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tif (!failed) {\n\t\t\tstruct audit_node *node;\n\t\t\tspin_lock(&hash_lock);\n\t\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t\tspin_unlock(&hash_lock);\n\t\t} else {\n\t\t\ttrim_marked(tree);\n\t\t}\n\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&barrier);\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n\tpath_put(&path1);\n\tdrop_collected_mounts(tagged);\n\treturn failed;\n}"
  },
  {
    "function_name": "audit_add_tree_rule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "800-868",
    "snippet": "int audit_add_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *seed = rule->tree, *tree;\n\tstruct path path;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\trule->tree = NULL;\n\tlist_for_each_entry(tree, &tree_list, list) {\n\t\tif (!strcmp(seed->pathname, tree->pathname)) {\n\t\t\tput_tree(seed);\n\t\t\trule->tree = tree;\n\t\t\tlist_add(&rule->rlist, &tree->rules);\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttree = seed;\n\tlist_add(&tree->list, &tree_list);\n\tlist_add(&rule->rlist, &tree->rules);\n\t/* do not set rule->tree yet */\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (unlikely(!prune_thread)) {\n\t\terr = audit_launch_prune();\n\t\tif (err)\n\t\t\tgoto Err;\n\t}\n\n\terr = kern_path(tree->pathname, 0, &path);\n\tif (err)\n\t\tgoto Err;\n\tmnt = collect_mounts(&path);\n\tpath_put(&path);\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto Err;\n\t}\n\n\tget_tree(tree);\n\terr = iterate_mounts(tag_mount, tree, mnt);\n\tdrop_collected_mounts(mnt);\n\n\tif (!err) {\n\t\tstruct audit_node *node;\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\tnode->index &= ~(1U<<31);\n\t\tspin_unlock(&hash_lock);\n\t} else {\n\t\ttrim_marked(tree);\n\t\tgoto Err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tif (list_empty(&rule->rlist)) {\n\t\tput_tree(tree);\n\t\treturn -ENOENT;\n\t}\n\trule->tree = tree;\n\tput_tree(tree);\n\n\treturn 0;\nErr:\n\tmutex_lock(&audit_filter_mutex);\n\tlist_del_init(&tree->list);\n\tlist_del_init(&tree->rules);\n\tput_tree(tree);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tree_list);",
      "static struct task_struct *prune_thread;",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "tree"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "740-743",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tree->rules"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tree->list"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rule->rlist"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim_marked",
          "args": [
            "tree"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "trim_marked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "609-642",
          "snippet": "static void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tprune_tree_chunks(tree, true);\n\n\tspin_lock(&hash_lock);\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(audit_context(), tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tprune_tree_chunks(tree, true);\n\n\tspin_lock(&hash_lock);\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(audit_context(), tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&tree->chunks",
            "list"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_collected_mounts",
          "args": [
            "mnt"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_mounts",
          "args": [
            "tag_mount",
            "tree",
            "mnt"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "tree"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "111-114",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mnt"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_mounts",
          "args": [
            "&path"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "tree->pathname",
            "0",
            "&path"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_launch_prune",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "audit_launch_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "785-797",
          "snippet": "static int audit_launch_prune(void)\n{\n\tif (prune_thread)\n\t\treturn 0;\n\tprune_thread = kthread_run(prune_tree_thread, NULL,\n\t\t\t\t\"audit_prune_tree\");\n\tif (IS_ERR(prune_thread)) {\n\t\tpr_err(\"cannot start thread audit_prune_tree\");\n\t\tprune_thread = NULL;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\n\nstatic int audit_launch_prune(void)\n{\n\tif (prune_thread)\n\t\treturn 0;\n\tprune_thread = kthread_run(prune_tree_thread, NULL,\n\t\t\t\t\"audit_prune_tree\");\n\tif (IS_ERR(prune_thread)) {\n\t\tpr_err(\"cannot start thread audit_prune_tree\");\n\t\tprune_thread = NULL;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!prune_thread"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&rule->rlist",
            "&tree->rules"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "seed->pathname",
            "tree->pathname"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tree",
            "&tree_list",
            "list"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic struct task_struct *prune_thread;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nint audit_add_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *seed = rule->tree, *tree;\n\tstruct path path;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\trule->tree = NULL;\n\tlist_for_each_entry(tree, &tree_list, list) {\n\t\tif (!strcmp(seed->pathname, tree->pathname)) {\n\t\t\tput_tree(seed);\n\t\t\trule->tree = tree;\n\t\t\tlist_add(&rule->rlist, &tree->rules);\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttree = seed;\n\tlist_add(&tree->list, &tree_list);\n\tlist_add(&rule->rlist, &tree->rules);\n\t/* do not set rule->tree yet */\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (unlikely(!prune_thread)) {\n\t\terr = audit_launch_prune();\n\t\tif (err)\n\t\t\tgoto Err;\n\t}\n\n\terr = kern_path(tree->pathname, 0, &path);\n\tif (err)\n\t\tgoto Err;\n\tmnt = collect_mounts(&path);\n\tpath_put(&path);\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto Err;\n\t}\n\n\tget_tree(tree);\n\terr = iterate_mounts(tag_mount, tree, mnt);\n\tdrop_collected_mounts(mnt);\n\n\tif (!err) {\n\t\tstruct audit_node *node;\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\tnode->index &= ~(1U<<31);\n\t\tspin_unlock(&hash_lock);\n\t} else {\n\t\ttrim_marked(tree);\n\t\tgoto Err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tif (list_empty(&rule->rlist)) {\n\t\tput_tree(tree);\n\t\treturn -ENOENT;\n\t}\n\trule->tree = tree;\n\tput_tree(tree);\n\n\treturn 0;\nErr:\n\tmutex_lock(&audit_filter_mutex);\n\tlist_del_init(&tree->list);\n\tlist_del_init(&tree->rules);\n\tput_tree(tree);\n\treturn err;\n}"
  },
  {
    "function_name": "audit_launch_prune",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "785-797",
    "snippet": "static int audit_launch_prune(void)\n{\n\tif (prune_thread)\n\t\treturn 0;\n\tprune_thread = kthread_run(prune_tree_thread, NULL,\n\t\t\t\t\"audit_prune_tree\");\n\tif (IS_ERR(prune_thread)) {\n\t\tpr_err(\"cannot start thread audit_prune_tree\");\n\t\tprune_thread = NULL;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *prune_thread;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cannot start thread audit_prune_tree\""
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prune_thread"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "prune_tree_thread",
            "NULL",
            "\"audit_prune_tree\""
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\n\nstatic int audit_launch_prune(void)\n{\n\tif (prune_thread)\n\t\treturn 0;\n\tprune_thread = kthread_run(prune_tree_thread, NULL,\n\t\t\t\t\"audit_prune_tree\");\n\tif (IS_ERR(prune_thread)) {\n\t\tpr_err(\"cannot start thread audit_prune_tree\");\n\t\tprune_thread = NULL;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "prune_tree_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "754-783",
    "snippet": "static int prune_tree_thread(void *unused)\n{\n\tfor (;;) {\n\t\tif (list_empty(&prune_list)) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule();\n\t\t}\n\n\t\taudit_ctl_lock();\n\t\tmutex_lock(&audit_filter_mutex);\n\n\t\twhile (!list_empty(&prune_list)) {\n\t\t\tstruct audit_tree *victim;\n\n\t\t\tvictim = list_entry(prune_list.next,\n\t\t\t\t\tstruct audit_tree, list);\n\t\t\tlist_del_init(&victim->list);\n\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\t\tprune_one(victim);\n\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t}\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\taudit_ctl_unlock();\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(prune_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_ctl_unlock",
          "args": [],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "243-247",
          "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_one",
          "args": [
            "victim"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "prune_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "601-605",
          "snippet": "static void prune_one(struct audit_tree *victim)\n{\n\tprune_tree_chunks(victim, false);\n\tput_tree(victim);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void prune_one(struct audit_tree *victim)\n{\n\tprune_tree_chunks(victim, false);\n\tput_tree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&victim->list"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "prune_list.next",
            "structaudit_tree",
            "list"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&prune_list"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ctl_lock",
          "args": [],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "234-238",
          "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(prune_list);\n\nstatic int prune_tree_thread(void *unused)\n{\n\tfor (;;) {\n\t\tif (list_empty(&prune_list)) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule();\n\t\t}\n\n\t\taudit_ctl_lock();\n\t\tmutex_lock(&audit_filter_mutex);\n\n\t\twhile (!list_empty(&prune_list)) {\n\t\t\tstruct audit_tree *victim;\n\n\t\t\tvictim = list_entry(prune_list.next,\n\t\t\t\t\tstruct audit_tree, list);\n\t\t\tlist_del_init(&victim->list);\n\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\t\tprune_one(victim);\n\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t}\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\taudit_ctl_unlock();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "tag_mount",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "745-748",
    "snippet": "static int tag_mount(struct vfsmount *mnt, void *arg)\n{\n\treturn tag_chunk(d_backing_inode(mnt->mnt_root), arg);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tag_chunk",
          "args": [
            "d_backing_inode(mnt->mnt_root)",
            "arg"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "tag_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "458-523",
          "snippet": "static int tag_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct audit_chunk *chunk, *old;\n\tstruct audit_node *p;\n\tint n;\n\n\tmutex_lock(&audit_tree_group->mark_mutex);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_tree_group);\n\tif (!mark)\n\t\treturn create_chunk(inode, tree);\n\n\t/*\n\t * Found mark is guaranteed to be attached and mark_mutex protects mark\n\t * from getting detached and thus it makes sure there is chunk attached\n\t * to the mark.\n\t */\n\t/* are we already there? */\n\tspin_lock(&hash_lock);\n\told = mark_chunk(mark);\n\tfor (n = 0; n < old->count; n++) {\n\t\tif (old->owners[n].owner == tree) {\n\t\t\tspin_unlock(&hash_lock);\n\t\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\t\tfsnotify_put_mark(mark);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tchunk = alloc_chunk(old->count + 1);\n\tif (!chunk) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn 0;\n\t}\n\tp = &chunk->owners[chunk->count - 1];\n\tp->index = (chunk->count - 1) | (1U<<31);\n\tp->owner = tree;\n\tget_tree(tree);\n\tlist_add(&p->list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\t/*\n\t * This has to go last when updating chunk as once replace_chunk() is\n\t * called, new RCU readers can see the new chunk.\n\t */\n\treplace_chunk(chunk, old);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\tfsnotify_put_mark(mark); /* pair to fsnotify_find_mark */\n\taudit_mark_put_chunk(old);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_tree_group;",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic int tag_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct audit_chunk *chunk, *old;\n\tstruct audit_node *p;\n\tint n;\n\n\tmutex_lock(&audit_tree_group->mark_mutex);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_tree_group);\n\tif (!mark)\n\t\treturn create_chunk(inode, tree);\n\n\t/*\n\t * Found mark is guaranteed to be attached and mark_mutex protects mark\n\t * from getting detached and thus it makes sure there is chunk attached\n\t * to the mark.\n\t */\n\t/* are we already there? */\n\tspin_lock(&hash_lock);\n\told = mark_chunk(mark);\n\tfor (n = 0; n < old->count; n++) {\n\t\tif (old->owners[n].owner == tree) {\n\t\t\tspin_unlock(&hash_lock);\n\t\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\t\tfsnotify_put_mark(mark);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tchunk = alloc_chunk(old->count + 1);\n\tif (!chunk) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn 0;\n\t}\n\tp = &chunk->owners[chunk->count - 1];\n\tp->index = (chunk->count - 1) | (1U<<31);\n\tp->owner = tree;\n\tget_tree(tree);\n\tlist_add(&p->list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\t/*\n\t * This has to go last when updating chunk as once replace_chunk() is\n\t * called, new RCU readers can see the new chunk.\n\t */\n\treplace_chunk(chunk, old);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\tfsnotify_put_mark(mark); /* pair to fsnotify_find_mark */\n\taudit_mark_put_chunk(old);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "mnt->mnt_root"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic int tag_mount(struct vfsmount *mnt, void *arg)\n{\n\treturn tag_chunk(d_backing_inode(mnt->mnt_root), arg);\n}"
  },
  {
    "function_name": "audit_put_tree",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "740-743",
    "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "tree"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "740-743",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
  },
  {
    "function_name": "audit_make_tree",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "725-738",
    "snippet": "int audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)\n{\n\n\tif (pathname[0] != '/' ||\n\t    (rule->listnr != AUDIT_FILTER_EXIT &&\n\t     rule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    op != Audit_equal ||\n\t    rule->inode_f || rule->watch || rule->tree)\n\t\treturn -EINVAL;\n\trule->tree = alloc_tree(pathname);\n\tif (!rule->tree)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_tree",
          "args": [
            "pathname"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "93-109",
          "snippet": "static struct audit_tree *alloc_tree(const char *s)\n{\n\tstruct audit_tree *tree;\n\n\ttree = kmalloc(struct_size(tree, pathname, strlen(s) + 1), GFP_KERNEL);\n\tif (tree) {\n\t\trefcount_set(&tree->count, 1);\n\t\ttree->goner = 0;\n\t\tINIT_LIST_HEAD(&tree->chunks);\n\t\tINIT_LIST_HEAD(&tree->rules);\n\t\tINIT_LIST_HEAD(&tree->list);\n\t\tINIT_LIST_HEAD(&tree->same_root);\n\t\ttree->root = NULL;\n\t\tstrcpy(tree->pathname, s);\n\t}\n\treturn tree;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_tree *alloc_tree(const char *s)\n{\n\tstruct audit_tree *tree;\n\n\ttree = kmalloc(struct_size(tree, pathname, strlen(s) + 1), GFP_KERNEL);\n\tif (tree) {\n\t\trefcount_set(&tree->count, 1);\n\t\ttree->goner = 0;\n\t\tINIT_LIST_HEAD(&tree->chunks);\n\t\tINIT_LIST_HEAD(&tree->rules);\n\t\tINIT_LIST_HEAD(&tree->list);\n\t\tINIT_LIST_HEAD(&tree->same_root);\n\t\ttree->root = NULL;\n\t\tstrcpy(tree->pathname, s);\n\t}\n\treturn tree;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nint audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)\n{\n\n\tif (pathname[0] != '/' ||\n\t    (rule->listnr != AUDIT_FILTER_EXIT &&\n\t     rule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    op != Audit_equal ||\n\t    rule->inode_f || rule->watch || rule->tree)\n\t\treturn -EINVAL;\n\trule->tree = alloc_tree(pathname);\n\tif (!rule->tree)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_trim_trees",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "677-723",
    "snippet": "void audit_trim_trees(void)\n{\n\tstruct list_head cursor;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&cursor, &tree_list);\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tstruct path path;\n\t\tstruct vfsmount *root_mnt;\n\t\tstruct audit_node *node;\n\t\tint err;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path);\n\t\tif (err)\n\t\t\tgoto skip_it;\n\n\t\troot_mnt = collect_mounts(&path);\n\t\tpath_put(&path);\n\t\tif (IS_ERR(root_mnt))\n\t\t\tgoto skip_it;\n\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list) {\n\t\t\tstruct audit_chunk *chunk = find_chunk(node);\n\t\t\t/* this could be NULL if the watch is dying else where... */\n\t\t\tnode->index |= 1U<<31;\n\t\t\tif (iterate_mounts(compare_root,\n\t\t\t\t\t   (void *)(chunk->key),\n\t\t\t\t\t   root_mnt))\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\ttrim_marked(tree);\n\t\tdrop_collected_mounts(root_mnt);\nskip_it:\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tree_list);",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cursor"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "tree"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "740-743",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_collected_mounts",
          "args": [
            "root_mnt"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trim_marked",
          "args": [
            "tree"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "trim_marked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "609-642",
          "snippet": "static void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tprune_tree_chunks(tree, true);\n\n\tspin_lock(&hash_lock);\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(audit_context(), tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tprune_tree_chunks(tree, true);\n\n\tspin_lock(&hash_lock);\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(audit_context(), tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_mounts",
          "args": [
            "compare_root",
            "(void *)(chunk->key)",
            "root_mnt"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_chunk",
          "args": [
            "node"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "find_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "272-277",
          "snippet": "static struct audit_chunk *find_chunk(struct audit_node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *find_chunk(struct audit_node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&tree->chunks",
            "list"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root_mnt"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_mounts",
          "args": [
            "&path"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "tree->pathname",
            "0",
            "&path"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&cursor",
            "&tree->list"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "tree"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "111-114",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cursor.next",
            "structaudit_tree",
            "list"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cursor",
            "&tree_list"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nvoid audit_trim_trees(void)\n{\n\tstruct list_head cursor;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&cursor, &tree_list);\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tstruct path path;\n\t\tstruct vfsmount *root_mnt;\n\t\tstruct audit_node *node;\n\t\tint err;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_move(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path);\n\t\tif (err)\n\t\t\tgoto skip_it;\n\n\t\troot_mnt = collect_mounts(&path);\n\t\tpath_put(&path);\n\t\tif (IS_ERR(root_mnt))\n\t\t\tgoto skip_it;\n\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list) {\n\t\t\tstruct audit_chunk *chunk = find_chunk(node);\n\t\t\t/* this could be NULL if the watch is dying else where... */\n\t\t\tnode->index |= 1U<<31;\n\t\t\tif (iterate_mounts(compare_root,\n\t\t\t\t\t   (void *)(chunk->key),\n\t\t\t\t\t   root_mnt))\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\ttrim_marked(tree);\n\t\tdrop_collected_mounts(root_mnt);\nskip_it:\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n}"
  },
  {
    "function_name": "compare_root",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "671-675",
    "snippet": "static int compare_root(struct vfsmount *mnt, void *arg)\n{\n\treturn inode_to_key(d_backing_inode(mnt->mnt_root)) ==\n\t       (unsigned long)arg;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_to_key",
          "args": [
            "d_backing_inode(mnt->mnt_root)"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "213-217",
          "snippet": "static unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "mnt->mnt_root"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic int compare_root(struct vfsmount *mnt, void *arg)\n{\n\treturn inode_to_key(d_backing_inode(mnt->mnt_root)) ==\n\t       (unsigned long)arg;\n}"
  },
  {
    "function_name": "audit_remove_tree_rule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "647-669",
    "snippet": "int audit_remove_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *tree;\n\ttree = rule->tree;\n\tif (tree) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&rule->rlist);\n\t\tif (list_empty(&tree->rules) && !tree->goner) {\n\t\t\ttree->root = NULL;\n\t\t\tlist_del_init(&tree->same_root);\n\t\t\ttree->goner = 1;\n\t\t\tlist_move(&tree->list, &prune_list);\n\t\t\trule->tree = NULL;\n\t\t\tspin_unlock(&hash_lock);\n\t\t\taudit_schedule_prune();\n\t\t\treturn 1;\n\t\t}\n\t\trule->tree = NULL;\n\t\tspin_unlock(&hash_lock);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(prune_list);",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);",
      "static void audit_schedule_prune(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_schedule_prune",
          "args": [],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&tree->list",
            "&prune_list"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tree->same_root"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tree->rules"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rule->rlist"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(prune_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\nstatic void audit_schedule_prune(void);\n\nint audit_remove_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *tree;\n\ttree = rule->tree;\n\tif (tree) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&rule->rlist);\n\t\tif (list_empty(&tree->rules) && !tree->goner) {\n\t\t\ttree->root = NULL;\n\t\t\tlist_del_init(&tree->same_root);\n\t\t\ttree->goner = 1;\n\t\t\tlist_move(&tree->list, &prune_list);\n\t\t\trule->tree = NULL;\n\t\t\tspin_unlock(&hash_lock);\n\t\t\taudit_schedule_prune();\n\t\t\treturn 1;\n\t\t}\n\t\trule->tree = NULL;\n\t\tspin_unlock(&hash_lock);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "trim_marked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "609-642",
    "snippet": "static void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tprune_tree_chunks(tree, true);\n\n\tspin_lock(&hash_lock);\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(audit_context(), tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_one",
          "args": [
            "tree"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "prune_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "601-605",
          "snippet": "static void prune_one(struct audit_tree *victim)\n{\n\tprune_tree_chunks(victim, false);\n\tput_tree(victim);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void prune_one(struct audit_tree *victim)\n{\n\tprune_tree_chunks(victim, false);\n\tput_tree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tree->list"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_rules",
          "args": [
            "audit_context()",
            "tree"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "kill_rules",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "542-562",
          "snippet": "static void kill_rules(struct audit_context *context, struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(context, rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void kill_rules(struct audit_context *context, struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(context, rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_tree_chunks",
          "args": [
            "tree",
            "true"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "prune_tree_chunks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "569-596",
          "snippet": "static void prune_tree_chunks(struct audit_tree *victim, bool tagged)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct audit_node *p;\n\t\tstruct audit_chunk *chunk;\n\t\tstruct fsnotify_mark *mark;\n\n\t\tp = list_first_entry(&victim->chunks, struct audit_node, list);\n\t\t/* have we run out of marked? */\n\t\tif (tagged && !(p->index & (1U<<31)))\n\t\t\tbreak;\n\t\tchunk = find_chunk(p);\n\t\tmark = chunk->mark;\n\t\tremove_chunk_node(chunk, p);\n\t\t/* Racing with audit_tree_freeing_mark()? */\n\t\tif (!mark)\n\t\t\tcontinue;\n\t\tfsnotify_get_mark(mark);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, mark);\n\t\tfsnotify_put_mark(mark);\n\n\t\tspin_lock(&hash_lock);\n\t}\n\tspin_unlock(&hash_lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void prune_tree_chunks(struct audit_tree *victim, bool tagged)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct audit_node *p;\n\t\tstruct audit_chunk *chunk;\n\t\tstruct fsnotify_mark *mark;\n\n\t\tp = list_first_entry(&victim->chunks, struct audit_node, list);\n\t\t/* have we run out of marked? */\n\t\tif (tagged && !(p->index & (1U<<31)))\n\t\t\tbreak;\n\t\tchunk = find_chunk(p);\n\t\tmark = chunk->mark;\n\t\tremove_chunk_node(chunk, p);\n\t\t/* Racing with audit_tree_freeing_mark()? */\n\t\tif (!mark)\n\t\t\tcontinue;\n\t\tfsnotify_get_mark(mark);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, mark);\n\t\tfsnotify_put_mark(mark);\n\n\t\tspin_lock(&hash_lock);\n\t}\n\tspin_unlock(&hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "p",
            "&tree->chunks"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "p"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structaudit_node",
            "list"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct audit_node *node = list_entry(p, struct audit_node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tprune_tree_chunks(tree, true);\n\n\tspin_lock(&hash_lock);\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(audit_context(), tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}"
  },
  {
    "function_name": "prune_one",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "601-605",
    "snippet": "static void prune_one(struct audit_tree *victim)\n{\n\tprune_tree_chunks(victim, false);\n\tput_tree(victim);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "victim"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "740-743",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_tree_chunks",
          "args": [
            "victim",
            "false"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "prune_tree_chunks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "569-596",
          "snippet": "static void prune_tree_chunks(struct audit_tree *victim, bool tagged)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct audit_node *p;\n\t\tstruct audit_chunk *chunk;\n\t\tstruct fsnotify_mark *mark;\n\n\t\tp = list_first_entry(&victim->chunks, struct audit_node, list);\n\t\t/* have we run out of marked? */\n\t\tif (tagged && !(p->index & (1U<<31)))\n\t\t\tbreak;\n\t\tchunk = find_chunk(p);\n\t\tmark = chunk->mark;\n\t\tremove_chunk_node(chunk, p);\n\t\t/* Racing with audit_tree_freeing_mark()? */\n\t\tif (!mark)\n\t\t\tcontinue;\n\t\tfsnotify_get_mark(mark);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, mark);\n\t\tfsnotify_put_mark(mark);\n\n\t\tspin_lock(&hash_lock);\n\t}\n\tspin_unlock(&hash_lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void prune_tree_chunks(struct audit_tree *victim, bool tagged)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct audit_node *p;\n\t\tstruct audit_chunk *chunk;\n\t\tstruct fsnotify_mark *mark;\n\n\t\tp = list_first_entry(&victim->chunks, struct audit_node, list);\n\t\t/* have we run out of marked? */\n\t\tif (tagged && !(p->index & (1U<<31)))\n\t\t\tbreak;\n\t\tchunk = find_chunk(p);\n\t\tmark = chunk->mark;\n\t\tremove_chunk_node(chunk, p);\n\t\t/* Racing with audit_tree_freeing_mark()? */\n\t\tif (!mark)\n\t\t\tcontinue;\n\t\tfsnotify_get_mark(mark);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, mark);\n\t\tfsnotify_put_mark(mark);\n\n\t\tspin_lock(&hash_lock);\n\t}\n\tspin_unlock(&hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void prune_one(struct audit_tree *victim)\n{\n\tprune_tree_chunks(victim, false);\n\tput_tree(victim);\n}"
  },
  {
    "function_name": "prune_tree_chunks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "569-596",
    "snippet": "static void prune_tree_chunks(struct audit_tree *victim, bool tagged)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct audit_node *p;\n\t\tstruct audit_chunk *chunk;\n\t\tstruct fsnotify_mark *mark;\n\n\t\tp = list_first_entry(&victim->chunks, struct audit_node, list);\n\t\t/* have we run out of marked? */\n\t\tif (tagged && !(p->index & (1U<<31)))\n\t\t\tbreak;\n\t\tchunk = find_chunk(p);\n\t\tmark = chunk->mark;\n\t\tremove_chunk_node(chunk, p);\n\t\t/* Racing with audit_tree_freeing_mark()? */\n\t\tif (!mark)\n\t\t\tcontinue;\n\t\tfsnotify_get_mark(mark);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, mark);\n\t\tfsnotify_put_mark(mark);\n\n\t\tspin_lock(&hash_lock);\n\t}\n\tspin_unlock(&hash_lock);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untag_chunk",
          "args": [
            "chunk",
            "mark"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "untag_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "349-394",
          "snippet": "static void untag_chunk(struct audit_chunk *chunk, struct fsnotify_mark *mark)\n{\n\tstruct audit_chunk *new;\n\tint size;\n\n\tmutex_lock(&audit_tree_group->mark_mutex);\n\t/*\n\t * mark_mutex stabilizes chunk attached to the mark so we can check\n\t * whether it didn't change while we've dropped hash_lock.\n\t */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) ||\n\t    mark_chunk(mark) != chunk)\n\t\tgoto out_mutex;\n\n\tsize = chunk_count_trees(chunk);\n\tif (!size) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tlist_del_rcu(&chunk->hash);\n\t\treplace_mark_chunk(mark, NULL);\n\t\tspin_unlock(&hash_lock);\n\t\tfsnotify_detach_mark(mark);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\taudit_mark_put_chunk(chunk);\n\t\tfsnotify_free_mark(mark);\n\t\treturn;\n\t}\n\n\tnew = alloc_chunk(size);\n\tif (!new)\n\t\tgoto out_mutex;\n\n\tspin_lock(&hash_lock);\n\t/*\n\t * This has to go last when updating chunk as once replace_chunk() is\n\t * called, new RCU readers can see the new chunk.\n\t */\n\treplace_chunk(new, chunk);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\taudit_mark_put_chunk(chunk);\n\treturn;\n\nout_mutex:\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_tree_group;",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void untag_chunk(struct audit_chunk *chunk, struct fsnotify_mark *mark)\n{\n\tstruct audit_chunk *new;\n\tint size;\n\n\tmutex_lock(&audit_tree_group->mark_mutex);\n\t/*\n\t * mark_mutex stabilizes chunk attached to the mark so we can check\n\t * whether it didn't change while we've dropped hash_lock.\n\t */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) ||\n\t    mark_chunk(mark) != chunk)\n\t\tgoto out_mutex;\n\n\tsize = chunk_count_trees(chunk);\n\tif (!size) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tlist_del_rcu(&chunk->hash);\n\t\treplace_mark_chunk(mark, NULL);\n\t\tspin_unlock(&hash_lock);\n\t\tfsnotify_detach_mark(mark);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\taudit_mark_put_chunk(chunk);\n\t\tfsnotify_free_mark(mark);\n\t\treturn;\n\t}\n\n\tnew = alloc_chunk(size);\n\tif (!new)\n\t\tgoto out_mutex;\n\n\tspin_lock(&hash_lock);\n\t/*\n\t * This has to go last when updating chunk as once replace_chunk() is\n\t * called, new RCU readers can see the new chunk.\n\t */\n\treplace_chunk(new, chunk);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\taudit_mark_put_chunk(chunk);\n\treturn;\n\nout_mutex:\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_get_mark",
          "args": [
            "mark"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_chunk_node",
          "args": [
            "chunk",
            "p"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "remove_chunk_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "325-336",
          "snippet": "static void remove_chunk_node(struct audit_chunk *chunk, struct audit_node *p)\n{\n\tstruct audit_tree *owner = p->owner;\n\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void remove_chunk_node(struct audit_chunk *chunk, struct audit_node *p)\n{\n\tstruct audit_tree *owner = p->owner;\n\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_chunk",
          "args": [
            "p"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "find_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "272-277",
          "snippet": "static struct audit_chunk *find_chunk(struct audit_node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *find_chunk(struct audit_node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&victim->chunks",
            "structaudit_node",
            "list"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&victim->chunks"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void prune_tree_chunks(struct audit_tree *victim, bool tagged)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct audit_node *p;\n\t\tstruct audit_chunk *chunk;\n\t\tstruct fsnotify_mark *mark;\n\n\t\tp = list_first_entry(&victim->chunks, struct audit_node, list);\n\t\t/* have we run out of marked? */\n\t\tif (tagged && !(p->index & (1U<<31)))\n\t\t\tbreak;\n\t\tchunk = find_chunk(p);\n\t\tmark = chunk->mark;\n\t\tremove_chunk_node(chunk, p);\n\t\t/* Racing with audit_tree_freeing_mark()? */\n\t\tif (!mark)\n\t\t\tcontinue;\n\t\tfsnotify_get_mark(mark);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, mark);\n\t\tfsnotify_put_mark(mark);\n\n\t\tspin_lock(&hash_lock);\n\t}\n\tspin_unlock(&hash_lock);\n}"
  },
  {
    "function_name": "kill_rules",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "542-562",
    "snippet": "static void kill_rules(struct audit_context *context, struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(context, rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&entry->rcu",
            "audit_free_rule_rcu"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->rule.list"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&entry->list"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "entry->rule.exe"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "138-143",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_tree_log_remove_rule",
          "args": [
            "context",
            "rule"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_log_remove_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "525-540",
          "snippet": "static void audit_tree_log_remove_rule(struct audit_context *context,\n\t\t\t\t       struct audit_krule *rule)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"op=remove_rule dir=\");\n\taudit_log_untrustedstring(ab, rule->tree->pathname);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void audit_tree_log_remove_rule(struct audit_context *context,\n\t\t\t\t       struct audit_krule *rule)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"op=remove_rule dir=\");\n\taudit_log_untrustedstring(ab, rule->tree->pathname);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rule->rlist"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rule",
            "structaudit_entry",
            "rule"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rule",
            "next",
            "&tree->rules",
            "rlist"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void kill_rules(struct audit_context *context, struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(context, rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "audit_tree_log_remove_rule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "525-540",
    "snippet": "static void audit_tree_log_remove_rule(struct audit_context *context,\n\t\t\t\t       struct audit_krule *rule)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"op=remove_rule dir=\");\n\taudit_log_untrustedstring(ab, rule->tree->pathname);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" list=%d res=1\"",
            "rule->listnr"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_key",
          "args": [
            "ab",
            "rule->filterkey"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2134-2141",
          "snippet": "void audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "rule->tree->pathname"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void audit_tree_log_remove_rule(struct audit_context *context,\n\t\t\t\t       struct audit_krule *rule)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"op=remove_rule dir=\");\n\taudit_log_untrustedstring(ab, rule->tree->pathname);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "tag_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "458-523",
    "snippet": "static int tag_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct audit_chunk *chunk, *old;\n\tstruct audit_node *p;\n\tint n;\n\n\tmutex_lock(&audit_tree_group->mark_mutex);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_tree_group);\n\tif (!mark)\n\t\treturn create_chunk(inode, tree);\n\n\t/*\n\t * Found mark is guaranteed to be attached and mark_mutex protects mark\n\t * from getting detached and thus it makes sure there is chunk attached\n\t * to the mark.\n\t */\n\t/* are we already there? */\n\tspin_lock(&hash_lock);\n\told = mark_chunk(mark);\n\tfor (n = 0; n < old->count; n++) {\n\t\tif (old->owners[n].owner == tree) {\n\t\t\tspin_unlock(&hash_lock);\n\t\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\t\tfsnotify_put_mark(mark);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tchunk = alloc_chunk(old->count + 1);\n\tif (!chunk) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn 0;\n\t}\n\tp = &chunk->owners[chunk->count - 1];\n\tp->index = (chunk->count - 1) | (1U<<31);\n\tp->owner = tree;\n\tget_tree(tree);\n\tlist_add(&p->list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\t/*\n\t * This has to go last when updating chunk as once replace_chunk() is\n\t * called, new RCU readers can see the new chunk.\n\t */\n\treplace_chunk(chunk, old);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\tfsnotify_put_mark(mark); /* pair to fsnotify_find_mark */\n\taudit_mark_put_chunk(old);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_tree_group;",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_mark_put_chunk",
          "args": [
            "old"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark_put_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "156-159",
          "snippet": "static void audit_mark_put_chunk(struct audit_chunk *chunk)\n{\n\tcall_rcu(&chunk->head, __put_chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void audit_mark_put_chunk(struct audit_chunk *chunk)\n{\n\tcall_rcu(&chunk->head, __put_chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_tree_group->mark_mutex"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_chunk",
          "args": [
            "chunk",
            "old"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "replace_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "293-323",
          "snippet": "static void replace_chunk(struct audit_chunk *new, struct audit_chunk *old)\n{\n\tstruct audit_tree *owner;\n\tint i, j;\n\n\tnew->key = old->key;\n\tlist_splice_init(&old->trees, &new->trees);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tfor (i = j = 0; j < old->count; i++, j++) {\n\t\tif (!old->owners[j].owner) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\towner = old->owners[j].owner;\n\t\tnew->owners[i].owner = owner;\n\t\tnew->owners[i].index = old->owners[j].index - j + i;\n\t\tif (!owner) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(owner);\n\t\tlist_replace_init(&old->owners[j].list, &new->owners[i].list);\n\t}\n\treplace_mark_chunk(old->mark, new);\n\t/*\n\t * Make sure chunk is fully initialized before making it visible in the\n\t * hash. Pairs with a data dependency barrier in READ_ONCE() in\n\t * audit_tree_lookup().\n\t */\n\tsmp_wmb();\n\tlist_replace_rcu(&old->hash, &new->hash);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void replace_chunk(struct audit_chunk *new, struct audit_chunk *old)\n{\n\tstruct audit_tree *owner;\n\tint i, j;\n\n\tnew->key = old->key;\n\tlist_splice_init(&old->trees, &new->trees);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tfor (i = j = 0; j < old->count; i++, j++) {\n\t\tif (!old->owners[j].owner) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\towner = old->owners[j].owner;\n\t\tnew->owners[i].owner = owner;\n\t\tnew->owners[i].index = old->owners[j].index - j + i;\n\t\tif (!owner) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(owner);\n\t\tlist_replace_init(&old->owners[j].list, &new->owners[i].list);\n\t}\n\treplace_mark_chunk(old->mark, new);\n\t/*\n\t * Make sure chunk is fully initialized before making it visible in the\n\t * hash. Pairs with a data dependency barrier in READ_ONCE() in\n\t * audit_tree_lookup().\n\t */\n\tsmp_wmb();\n\tlist_replace_rcu(&old->hash, &new->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tree->same_root",
            "&chunk->trees"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "tree"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "111-114",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "chunk"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_chunk",
          "args": [
            "old->count + 1"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "188-206",
          "snippet": "static struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tint i;\n\n\tchunk = kzalloc(struct_size(chunk, owners, count), GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\treturn chunk;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tint i;\n\n\tchunk = kzalloc(struct_size(chunk, owners, count), GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\treturn chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_chunk",
          "args": [
            "mark"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "mark_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "166-169",
          "snippet": "static struct audit_chunk *mark_chunk(struct fsnotify_mark *mark)\n{\n\treturn audit_mark(mark)->chunk;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *mark_chunk(struct fsnotify_mark *mark)\n{\n\treturn audit_mark(mark)->chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_chunk",
          "args": [
            "inode",
            "tree"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "create_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "397-455",
          "snippet": "static int create_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct audit_chunk *chunk = alloc_chunk(1);\n\n\tif (!chunk) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tmark = alloc_mark();\n\tif (!mark) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tkfree(chunk);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (fsnotify_add_inode_mark_locked(mark, inode, 0)) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tfsnotify_detach_mark(mark);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_free_mark(mark);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn 0;\n\t}\n\treplace_mark_chunk(mark, chunk);\n\tchunk->owners[0].index = (1U << 31);\n\tchunk->owners[0].owner = tree;\n\tget_tree(tree);\n\tlist_add(&chunk->owners[0].list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tchunk->key = inode_to_key(inode);\n\t/*\n\t * Inserting into the hash table has to go last as once we do that RCU\n\t * readers can see the chunk.\n\t */\n\tinsert_hash(chunk);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t/*\n\t * Drop our initial reference. When mark we point to is getting freed,\n\t * we get notification through ->freeing_mark callback and cleanup\n\t * chunk pointing to this mark.\n\t */\n\tfsnotify_put_mark(mark);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_tree_group;",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic int create_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct audit_chunk *chunk = alloc_chunk(1);\n\n\tif (!chunk) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tmark = alloc_mark();\n\tif (!mark) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tkfree(chunk);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (fsnotify_add_inode_mark_locked(mark, inode, 0)) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tfsnotify_detach_mark(mark);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_free_mark(mark);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn 0;\n\t}\n\treplace_mark_chunk(mark, chunk);\n\tchunk->owners[0].index = (1U << 31);\n\tchunk->owners[0].owner = tree;\n\tget_tree(tree);\n\tlist_add(&chunk->owners[0].list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tchunk->key = inode_to_key(inode);\n\t/*\n\t * Inserting into the hash table has to go last as once we do that RCU\n\t * readers can see the chunk.\n\t */\n\tinsert_hash(chunk);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t/*\n\t * Drop our initial reference. When mark we point to is getting freed,\n\t * we get notification through ->freeing_mark callback and cleanup\n\t * chunk pointing to this mark.\n\t */\n\tfsnotify_put_mark(mark);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_find_mark",
          "args": [
            "&inode->i_fsnotify_marks",
            "audit_tree_group"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_tree_group->mark_mutex"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic int tag_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct audit_chunk *chunk, *old;\n\tstruct audit_node *p;\n\tint n;\n\n\tmutex_lock(&audit_tree_group->mark_mutex);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_tree_group);\n\tif (!mark)\n\t\treturn create_chunk(inode, tree);\n\n\t/*\n\t * Found mark is guaranteed to be attached and mark_mutex protects mark\n\t * from getting detached and thus it makes sure there is chunk attached\n\t * to the mark.\n\t */\n\t/* are we already there? */\n\tspin_lock(&hash_lock);\n\told = mark_chunk(mark);\n\tfor (n = 0; n < old->count; n++) {\n\t\tif (old->owners[n].owner == tree) {\n\t\t\tspin_unlock(&hash_lock);\n\t\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\t\tfsnotify_put_mark(mark);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tchunk = alloc_chunk(old->count + 1);\n\tif (!chunk) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn 0;\n\t}\n\tp = &chunk->owners[chunk->count - 1];\n\tp->index = (chunk->count - 1) | (1U<<31);\n\tp->owner = tree;\n\tget_tree(tree);\n\tlist_add(&p->list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\t/*\n\t * This has to go last when updating chunk as once replace_chunk() is\n\t * called, new RCU readers can see the new chunk.\n\t */\n\treplace_chunk(chunk, old);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\tfsnotify_put_mark(mark); /* pair to fsnotify_find_mark */\n\taudit_mark_put_chunk(old);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "create_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "397-455",
    "snippet": "static int create_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct audit_chunk *chunk = alloc_chunk(1);\n\n\tif (!chunk) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tmark = alloc_mark();\n\tif (!mark) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tkfree(chunk);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (fsnotify_add_inode_mark_locked(mark, inode, 0)) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tfsnotify_detach_mark(mark);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_free_mark(mark);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn 0;\n\t}\n\treplace_mark_chunk(mark, chunk);\n\tchunk->owners[0].index = (1U << 31);\n\tchunk->owners[0].owner = tree;\n\tget_tree(tree);\n\tlist_add(&chunk->owners[0].list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tchunk->key = inode_to_key(inode);\n\t/*\n\t * Inserting into the hash table has to go last as once we do that RCU\n\t * readers can see the chunk.\n\t */\n\tinsert_hash(chunk);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t/*\n\t * Drop our initial reference. When mark we point to is getting freed,\n\t * we get notification through ->freeing_mark callback and cleanup\n\t * chunk pointing to this mark.\n\t */\n\tfsnotify_put_mark(mark);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_tree_group;",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_tree_group->mark_mutex"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_hash",
          "args": [
            "chunk"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "insert_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "226-239",
          "snippet": "static void insert_hash(struct audit_chunk *chunk)\n{\n\tstruct list_head *list;\n\n\t/*\n\t * Make sure chunk is fully initialized before making it visible in the\n\t * hash. Pairs with a data dependency barrier in READ_ONCE() in\n\t * audit_tree_lookup().\n\t */\n\tsmp_wmb();\n\tWARN_ON_ONCE(!chunk->key);\n\tlist = chunk_hash(chunk->key);\n\tlist_add_rcu(&chunk->hash, list);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void insert_hash(struct audit_chunk *chunk)\n{\n\tstruct list_head *list;\n\n\t/*\n\t * Make sure chunk is fully initialized before making it visible in the\n\t * hash. Pairs with a data dependency barrier in READ_ONCE() in\n\t * audit_tree_lookup().\n\t */\n\tsmp_wmb();\n\tWARN_ON_ONCE(!chunk->key);\n\tlist = chunk_hash(chunk->key);\n\tlist_add_rcu(&chunk->hash, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_key",
          "args": [
            "inode"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "213-217",
          "snippet": "static unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tree->same_root",
            "&chunk->trees"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "tree"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "111-114",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_mark_chunk",
          "args": [
            "mark",
            "chunk"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "replace_mark_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "279-291",
          "snippet": "static void replace_mark_chunk(struct fsnotify_mark *mark,\n\t\t\t       struct audit_chunk *chunk)\n{\n\tstruct audit_chunk *old;\n\n\tassert_spin_locked(&hash_lock);\n\told = mark_chunk(mark);\n\taudit_mark(mark)->chunk = chunk;\n\tif (chunk)\n\t\tchunk->mark = mark;\n\tif (old)\n\t\told->mark = NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void replace_mark_chunk(struct fsnotify_mark *mark,\n\t\t\t       struct audit_chunk *chunk)\n{\n\tstruct audit_chunk *old;\n\n\tassert_spin_locked(&hash_lock);\n\told = mark_chunk(mark);\n\taudit_mark(mark)->chunk = chunk;\n\tif (chunk)\n\t\tchunk->mark = mark;\n\tif (old)\n\t\told->mark = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "chunk"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_free_mark",
          "args": [
            "mark"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "audit_fsnotify_free_mark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "47-53",
          "snippet": "static void audit_fsnotify_free_mark(struct fsnotify_mark *mark)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\taudit_mark = container_of(mark, struct audit_fsnotify_mark, mark);\n\taudit_fsnotify_mark_free(audit_mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic void audit_fsnotify_free_mark(struct fsnotify_mark *mark)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\taudit_mark = container_of(mark, struct audit_fsnotify_mark, mark);\n\taudit_fsnotify_mark_free(audit_mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_detach_mark",
          "args": [
            "mark"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_add_inode_mark_locked",
          "args": [
            "mark",
            "inode",
            "0"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_mark",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_mark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "176-186",
          "snippet": "static struct fsnotify_mark *alloc_mark(void)\n{\n\tstruct audit_tree_mark *amark;\n\n\tamark = kmem_cache_zalloc(audit_tree_mark_cachep, GFP_KERNEL);\n\tif (!amark)\n\t\treturn NULL;\n\tfsnotify_init_mark(&amark->mark, audit_tree_group);\n\tamark->mark.mask = FS_IN_IGNORED;\n\treturn &amark->mark;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_tree_group;",
            "static struct kmem_cache *audit_tree_mark_cachep"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic struct kmem_cache *audit_tree_mark_cachep;\n\nstatic struct fsnotify_mark *alloc_mark(void)\n{\n\tstruct audit_tree_mark *amark;\n\n\tamark = kmem_cache_zalloc(audit_tree_mark_cachep, GFP_KERNEL);\n\tif (!amark)\n\t\treturn NULL;\n\tfsnotify_init_mark(&amark->mark, audit_tree_group);\n\tamark->mark.mask = FS_IN_IGNORED;\n\treturn &amark->mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_chunk",
          "args": [
            "1"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "188-206",
          "snippet": "static struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tint i;\n\n\tchunk = kzalloc(struct_size(chunk, owners, count), GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\treturn chunk;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tint i;\n\n\tchunk = kzalloc(struct_size(chunk, owners, count), GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\treturn chunk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic int create_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct audit_chunk *chunk = alloc_chunk(1);\n\n\tif (!chunk) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tmark = alloc_mark();\n\tif (!mark) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tkfree(chunk);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (fsnotify_add_inode_mark_locked(mark, inode, 0)) {\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tfsnotify_detach_mark(mark);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\tfsnotify_free_mark(mark);\n\t\tfsnotify_put_mark(mark);\n\t\tkfree(chunk);\n\t\treturn 0;\n\t}\n\treplace_mark_chunk(mark, chunk);\n\tchunk->owners[0].index = (1U << 31);\n\tchunk->owners[0].owner = tree;\n\tget_tree(tree);\n\tlist_add(&chunk->owners[0].list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tchunk->key = inode_to_key(inode);\n\t/*\n\t * Inserting into the hash table has to go last as once we do that RCU\n\t * readers can see the chunk.\n\t */\n\tinsert_hash(chunk);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t/*\n\t * Drop our initial reference. When mark we point to is getting freed,\n\t * we get notification through ->freeing_mark callback and cleanup\n\t * chunk pointing to this mark.\n\t */\n\tfsnotify_put_mark(mark);\n\treturn 0;\n}"
  },
  {
    "function_name": "untag_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "349-394",
    "snippet": "static void untag_chunk(struct audit_chunk *chunk, struct fsnotify_mark *mark)\n{\n\tstruct audit_chunk *new;\n\tint size;\n\n\tmutex_lock(&audit_tree_group->mark_mutex);\n\t/*\n\t * mark_mutex stabilizes chunk attached to the mark so we can check\n\t * whether it didn't change while we've dropped hash_lock.\n\t */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) ||\n\t    mark_chunk(mark) != chunk)\n\t\tgoto out_mutex;\n\n\tsize = chunk_count_trees(chunk);\n\tif (!size) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tlist_del_rcu(&chunk->hash);\n\t\treplace_mark_chunk(mark, NULL);\n\t\tspin_unlock(&hash_lock);\n\t\tfsnotify_detach_mark(mark);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\taudit_mark_put_chunk(chunk);\n\t\tfsnotify_free_mark(mark);\n\t\treturn;\n\t}\n\n\tnew = alloc_chunk(size);\n\tif (!new)\n\t\tgoto out_mutex;\n\n\tspin_lock(&hash_lock);\n\t/*\n\t * This has to go last when updating chunk as once replace_chunk() is\n\t * called, new RCU readers can see the new chunk.\n\t */\n\treplace_chunk(new, chunk);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\taudit_mark_put_chunk(chunk);\n\treturn;\n\nout_mutex:\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_tree_group;",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_tree_group->mark_mutex"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_mark_put_chunk",
          "args": [
            "chunk"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark_put_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "156-159",
          "snippet": "static void audit_mark_put_chunk(struct audit_chunk *chunk)\n{\n\tcall_rcu(&chunk->head, __put_chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void audit_mark_put_chunk(struct audit_chunk *chunk)\n{\n\tcall_rcu(&chunk->head, __put_chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_chunk",
          "args": [
            "new",
            "chunk"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "replace_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "293-323",
          "snippet": "static void replace_chunk(struct audit_chunk *new, struct audit_chunk *old)\n{\n\tstruct audit_tree *owner;\n\tint i, j;\n\n\tnew->key = old->key;\n\tlist_splice_init(&old->trees, &new->trees);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tfor (i = j = 0; j < old->count; i++, j++) {\n\t\tif (!old->owners[j].owner) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\towner = old->owners[j].owner;\n\t\tnew->owners[i].owner = owner;\n\t\tnew->owners[i].index = old->owners[j].index - j + i;\n\t\tif (!owner) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(owner);\n\t\tlist_replace_init(&old->owners[j].list, &new->owners[i].list);\n\t}\n\treplace_mark_chunk(old->mark, new);\n\t/*\n\t * Make sure chunk is fully initialized before making it visible in the\n\t * hash. Pairs with a data dependency barrier in READ_ONCE() in\n\t * audit_tree_lookup().\n\t */\n\tsmp_wmb();\n\tlist_replace_rcu(&old->hash, &new->hash);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void replace_chunk(struct audit_chunk *new, struct audit_chunk *old)\n{\n\tstruct audit_tree *owner;\n\tint i, j;\n\n\tnew->key = old->key;\n\tlist_splice_init(&old->trees, &new->trees);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tfor (i = j = 0; j < old->count; i++, j++) {\n\t\tif (!old->owners[j].owner) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\towner = old->owners[j].owner;\n\t\tnew->owners[i].owner = owner;\n\t\tnew->owners[i].index = old->owners[j].index - j + i;\n\t\tif (!owner) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(owner);\n\t\tlist_replace_init(&old->owners[j].list, &new->owners[i].list);\n\t}\n\treplace_mark_chunk(old->mark, new);\n\t/*\n\t * Make sure chunk is fully initialized before making it visible in the\n\t * hash. Pairs with a data dependency barrier in READ_ONCE() in\n\t * audit_tree_lookup().\n\t */\n\tsmp_wmb();\n\tlist_replace_rcu(&old->hash, &new->hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_chunk",
          "args": [
            "size"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "188-206",
          "snippet": "static struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tint i;\n\n\tchunk = kzalloc(struct_size(chunk, owners, count), GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\treturn chunk;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tint i;\n\n\tchunk = kzalloc(struct_size(chunk, owners, count), GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\treturn chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_free_mark",
          "args": [
            "mark"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "audit_fsnotify_free_mark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "47-53",
          "snippet": "static void audit_fsnotify_free_mark(struct fsnotify_mark *mark)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\taudit_mark = container_of(mark, struct audit_fsnotify_mark, mark);\n\taudit_fsnotify_mark_free(audit_mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic void audit_fsnotify_free_mark(struct fsnotify_mark *mark)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\taudit_mark = container_of(mark, struct audit_fsnotify_mark, mark);\n\taudit_fsnotify_mark_free(audit_mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_detach_mark",
          "args": [
            "mark"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_mark_chunk",
          "args": [
            "mark",
            "NULL"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "replace_mark_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "279-291",
          "snippet": "static void replace_mark_chunk(struct fsnotify_mark *mark,\n\t\t\t       struct audit_chunk *chunk)\n{\n\tstruct audit_chunk *old;\n\n\tassert_spin_locked(&hash_lock);\n\told = mark_chunk(mark);\n\taudit_mark(mark)->chunk = chunk;\n\tif (chunk)\n\t\tchunk->mark = mark;\n\tif (old)\n\t\told->mark = NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void replace_mark_chunk(struct fsnotify_mark *mark,\n\t\t\t       struct audit_chunk *chunk)\n{\n\tstruct audit_chunk *old;\n\n\tassert_spin_locked(&hash_lock);\n\told = mark_chunk(mark);\n\taudit_mark(mark)->chunk = chunk;\n\tif (chunk)\n\t\tchunk->mark = mark;\n\tif (old)\n\t\told->mark = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&chunk->hash"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&chunk->trees"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chunk_count_trees",
          "args": [
            "chunk"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_count_trees",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "338-347",
          "snippet": "static int chunk_count_trees(struct audit_chunk *chunk)\n{\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < chunk->count; i++)\n\t\tif (chunk->owners[i].owner)\n\t\t\tret++;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic int chunk_count_trees(struct audit_chunk *chunk)\n{\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < chunk->count; i++)\n\t\tif (chunk->owners[i].owner)\n\t\t\tret++;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_chunk",
          "args": [
            "mark"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "mark_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "166-169",
          "snippet": "static struct audit_chunk *mark_chunk(struct fsnotify_mark *mark)\n{\n\treturn audit_mark(mark)->chunk;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *mark_chunk(struct fsnotify_mark *mark)\n{\n\treturn audit_mark(mark)->chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_tree_group->mark_mutex"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void untag_chunk(struct audit_chunk *chunk, struct fsnotify_mark *mark)\n{\n\tstruct audit_chunk *new;\n\tint size;\n\n\tmutex_lock(&audit_tree_group->mark_mutex);\n\t/*\n\t * mark_mutex stabilizes chunk attached to the mark so we can check\n\t * whether it didn't change while we've dropped hash_lock.\n\t */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED) ||\n\t    mark_chunk(mark) != chunk)\n\t\tgoto out_mutex;\n\n\tsize = chunk_count_trees(chunk);\n\tif (!size) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tlist_del_rcu(&chunk->hash);\n\t\treplace_mark_chunk(mark, NULL);\n\t\tspin_unlock(&hash_lock);\n\t\tfsnotify_detach_mark(mark);\n\t\tmutex_unlock(&audit_tree_group->mark_mutex);\n\t\taudit_mark_put_chunk(chunk);\n\t\tfsnotify_free_mark(mark);\n\t\treturn;\n\t}\n\n\tnew = alloc_chunk(size);\n\tif (!new)\n\t\tgoto out_mutex;\n\n\tspin_lock(&hash_lock);\n\t/*\n\t * This has to go last when updating chunk as once replace_chunk() is\n\t * called, new RCU readers can see the new chunk.\n\t */\n\treplace_chunk(new, chunk);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n\taudit_mark_put_chunk(chunk);\n\treturn;\n\nout_mutex:\n\tmutex_unlock(&audit_tree_group->mark_mutex);\n}"
  },
  {
    "function_name": "chunk_count_trees",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "338-347",
    "snippet": "static int chunk_count_trees(struct audit_chunk *chunk)\n{\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < chunk->count; i++)\n\t\tif (chunk->owners[i].owner)\n\t\t\tret++;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic int chunk_count_trees(struct audit_chunk *chunk)\n{\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < chunk->count; i++)\n\t\tif (chunk->owners[i].owner)\n\t\t\tret++;\n\treturn ret;\n}"
  },
  {
    "function_name": "remove_chunk_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "325-336",
    "snippet": "static void remove_chunk_node(struct audit_chunk *chunk, struct audit_node *p)\n{\n\tstruct audit_tree *owner = p->owner;\n\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "owner"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "740-743",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->list"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&owner->same_root"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void remove_chunk_node(struct audit_chunk *chunk, struct audit_node *p)\n{\n\tstruct audit_tree *owner = p->owner;\n\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n}"
  },
  {
    "function_name": "replace_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "293-323",
    "snippet": "static void replace_chunk(struct audit_chunk *new, struct audit_chunk *old)\n{\n\tstruct audit_tree *owner;\n\tint i, j;\n\n\tnew->key = old->key;\n\tlist_splice_init(&old->trees, &new->trees);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tfor (i = j = 0; j < old->count; i++, j++) {\n\t\tif (!old->owners[j].owner) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\towner = old->owners[j].owner;\n\t\tnew->owners[i].owner = owner;\n\t\tnew->owners[i].index = old->owners[j].index - j + i;\n\t\tif (!owner) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(owner);\n\t\tlist_replace_init(&old->owners[j].list, &new->owners[i].list);\n\t}\n\treplace_mark_chunk(old->mark, new);\n\t/*\n\t * Make sure chunk is fully initialized before making it visible in the\n\t * hash. Pairs with a data dependency barrier in READ_ONCE() in\n\t * audit_tree_lookup().\n\t */\n\tsmp_wmb();\n\tlist_replace_rcu(&old->hash, &new->hash);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_replace_rcu",
          "args": [
            "&old->hash",
            "&new->hash"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_mark_chunk",
          "args": [
            "old->mark",
            "new"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "replace_mark_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "279-291",
          "snippet": "static void replace_mark_chunk(struct fsnotify_mark *mark,\n\t\t\t       struct audit_chunk *chunk)\n{\n\tstruct audit_chunk *old;\n\n\tassert_spin_locked(&hash_lock);\n\told = mark_chunk(mark);\n\taudit_mark(mark)->chunk = chunk;\n\tif (chunk)\n\t\tchunk->mark = mark;\n\tif (old)\n\t\told->mark = NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void replace_mark_chunk(struct fsnotify_mark *mark,\n\t\t\t       struct audit_chunk *chunk)\n{\n\tstruct audit_chunk *old;\n\n\tassert_spin_locked(&hash_lock);\n\told = mark_chunk(mark);\n\taudit_mark(mark)->chunk = chunk;\n\tif (chunk)\n\t\tchunk->mark = mark;\n\tif (old)\n\t\told->mark = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&old->owners[j].list",
            "&new->owners[i].list"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "owner"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "111-114",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "owner",
            "&new->trees",
            "same_root"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&old->trees",
            "&new->trees"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void replace_chunk(struct audit_chunk *new, struct audit_chunk *old)\n{\n\tstruct audit_tree *owner;\n\tint i, j;\n\n\tnew->key = old->key;\n\tlist_splice_init(&old->trees, &new->trees);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tfor (i = j = 0; j < old->count; i++, j++) {\n\t\tif (!old->owners[j].owner) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\towner = old->owners[j].owner;\n\t\tnew->owners[i].owner = owner;\n\t\tnew->owners[i].index = old->owners[j].index - j + i;\n\t\tif (!owner) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(owner);\n\t\tlist_replace_init(&old->owners[j].list, &new->owners[i].list);\n\t}\n\treplace_mark_chunk(old->mark, new);\n\t/*\n\t * Make sure chunk is fully initialized before making it visible in the\n\t * hash. Pairs with a data dependency barrier in READ_ONCE() in\n\t * audit_tree_lookup().\n\t */\n\tsmp_wmb();\n\tlist_replace_rcu(&old->hash, &new->hash);\n}"
  },
  {
    "function_name": "replace_mark_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "279-291",
    "snippet": "static void replace_mark_chunk(struct fsnotify_mark *mark,\n\t\t\t       struct audit_chunk *chunk)\n{\n\tstruct audit_chunk *old;\n\n\tassert_spin_locked(&hash_lock);\n\told = mark_chunk(mark);\n\taudit_mark(mark)->chunk = chunk;\n\tif (chunk)\n\t\tchunk->mark = mark;\n\tif (old)\n\t\told->mark = NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_mark",
          "args": [
            "mark"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "161-164",
          "snippet": "static inline struct audit_tree_mark *audit_mark(struct fsnotify_mark *mark)\n{\n\treturn container_of(mark, struct audit_tree_mark, mark);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline struct audit_tree_mark *audit_mark(struct fsnotify_mark *mark)\n{\n\treturn container_of(mark, struct audit_tree_mark, mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_chunk",
          "args": [
            "mark"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "mark_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "166-169",
          "snippet": "static struct audit_chunk *mark_chunk(struct fsnotify_mark *mark)\n{\n\treturn audit_mark(mark)->chunk;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *mark_chunk(struct fsnotify_mark *mark)\n{\n\treturn audit_mark(mark)->chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&hash_lock"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void replace_mark_chunk(struct fsnotify_mark *mark,\n\t\t\t       struct audit_chunk *chunk)\n{\n\tstruct audit_chunk *old;\n\n\tassert_spin_locked(&hash_lock);\n\told = mark_chunk(mark);\n\taudit_mark(mark)->chunk = chunk;\n\tif (chunk)\n\t\tchunk->mark = mark;\n\tif (old)\n\t\told->mark = NULL;\n}"
  },
  {
    "function_name": "find_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "272-277",
    "snippet": "static struct audit_chunk *find_chunk(struct audit_node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structaudit_chunk",
            "owners[0]"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *find_chunk(struct audit_node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}"
  },
  {
    "function_name": "audit_tree_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "261-268",
    "snippet": "bool audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)\n{\n\tint n;\n\tfor (n = 0; n < chunk->count; n++)\n\t\tif (chunk->owners[n].owner == tree)\n\t\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nbool audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)\n{\n\tint n;\n\tfor (n = 0; n < chunk->count; n++)\n\t\tif (chunk->owners[n].owner == tree)\n\t\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "audit_tree_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "242-259",
    "snippet": "struct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\t/*\n\t\t * We use a data dependency barrier in READ_ONCE() to make sure\n\t\t * the chunk we see is fully initialized.\n\t\t */\n\t\tif (READ_ONCE(p->key) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&p->refs"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->key"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "p",
            "list",
            "hash"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chunk_hash",
          "args": [
            "key"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "219-223",
          "snippet": "static inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head chunk_hash_heads[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct list_head chunk_hash_heads[HASH_SIZE];\n\nstatic inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_key",
          "args": [
            "inode"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "213-217",
          "snippet": "static unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstruct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\t/*\n\t\t * We use a data dependency barrier in READ_ONCE() to make sure\n\t\t * the chunk we see is fully initialized.\n\t\t */\n\t\tif (READ_ONCE(p->key) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "insert_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "226-239",
    "snippet": "static void insert_hash(struct audit_chunk *chunk)\n{\n\tstruct list_head *list;\n\n\t/*\n\t * Make sure chunk is fully initialized before making it visible in the\n\t * hash. Pairs with a data dependency barrier in READ_ONCE() in\n\t * audit_tree_lookup().\n\t */\n\tsmp_wmb();\n\tWARN_ON_ONCE(!chunk->key);\n\tlist = chunk_hash(chunk->key);\n\tlist_add_rcu(&chunk->hash, list);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&chunk->hash",
            "list"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chunk_hash",
          "args": [
            "chunk->key"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "219-223",
          "snippet": "static inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head chunk_hash_heads[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct list_head chunk_hash_heads[HASH_SIZE];\n\nstatic inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!chunk->key"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void insert_hash(struct audit_chunk *chunk)\n{\n\tstruct list_head *list;\n\n\t/*\n\t * Make sure chunk is fully initialized before making it visible in the\n\t * hash. Pairs with a data dependency barrier in READ_ONCE() in\n\t * audit_tree_lookup().\n\t */\n\tsmp_wmb();\n\tWARN_ON_ONCE(!chunk->key);\n\tlist = chunk_hash(chunk->key);\n\tlist_add_rcu(&chunk->hash, list);\n}"
  },
  {
    "function_name": "chunk_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "219-223",
    "snippet": "static inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head chunk_hash_heads[HASH_SIZE];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct list_head chunk_hash_heads[HASH_SIZE];\n\nstatic inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}"
  },
  {
    "function_name": "inode_to_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "213-217",
    "snippet": "static unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}"
  },
  {
    "function_name": "alloc_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "188-206",
    "snippet": "static struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tint i;\n\n\tchunk = kzalloc(struct_size(chunk, owners, count), GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\treturn chunk;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&chunk->owners[i].list"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&chunk->refs",
            "1"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&chunk->trees"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&chunk->hash"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "struct_size(chunk, owners, count)",
            "GFP_KERNEL"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "chunk",
            "owners",
            "count"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tint i;\n\n\tchunk = kzalloc(struct_size(chunk, owners, count), GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\treturn chunk;\n}"
  },
  {
    "function_name": "alloc_mark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "176-186",
    "snippet": "static struct fsnotify_mark *alloc_mark(void)\n{\n\tstruct audit_tree_mark *amark;\n\n\tamark = kmem_cache_zalloc(audit_tree_mark_cachep, GFP_KERNEL);\n\tif (!amark)\n\t\treturn NULL;\n\tfsnotify_init_mark(&amark->mark, audit_tree_group);\n\tamark->mark.mask = FS_IN_IGNORED;\n\treturn &amark->mark;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_tree_group;",
      "static struct kmem_cache *audit_tree_mark_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_init_mark",
          "args": [
            "&amark->mark",
            "audit_tree_group"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "audit_tree_mark_cachep",
            "GFP_KERNEL"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic struct kmem_cache *audit_tree_mark_cachep;\n\nstatic struct fsnotify_mark *alloc_mark(void)\n{\n\tstruct audit_tree_mark *amark;\n\n\tamark = kmem_cache_zalloc(audit_tree_mark_cachep, GFP_KERNEL);\n\tif (!amark)\n\t\treturn NULL;\n\tfsnotify_init_mark(&amark->mark, audit_tree_group);\n\tamark->mark.mask = FS_IN_IGNORED;\n\treturn &amark->mark;\n}"
  },
  {
    "function_name": "audit_tree_destroy_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "171-174",
    "snippet": "static void audit_tree_destroy_watch(struct fsnotify_mark *mark)\n{\n\tkmem_cache_free(audit_tree_mark_cachep, audit_mark(mark));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *audit_tree_mark_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "audit_tree_mark_cachep",
            "audit_mark(mark)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_mark",
          "args": [
            "mark"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "161-164",
          "snippet": "static inline struct audit_tree_mark *audit_mark(struct fsnotify_mark *mark)\n{\n\treturn container_of(mark, struct audit_tree_mark, mark);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline struct audit_tree_mark *audit_mark(struct fsnotify_mark *mark)\n{\n\treturn container_of(mark, struct audit_tree_mark, mark);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct kmem_cache *audit_tree_mark_cachep;\n\nstatic void audit_tree_destroy_watch(struct fsnotify_mark *mark)\n{\n\tkmem_cache_free(audit_tree_mark_cachep, audit_mark(mark));\n}"
  },
  {
    "function_name": "mark_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "166-169",
    "snippet": "static struct audit_chunk *mark_chunk(struct fsnotify_mark *mark)\n{\n\treturn audit_mark(mark)->chunk;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_mark",
          "args": [
            "mark"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "161-164",
          "snippet": "static inline struct audit_tree_mark *audit_mark(struct fsnotify_mark *mark)\n{\n\treturn container_of(mark, struct audit_tree_mark, mark);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline struct audit_tree_mark *audit_mark(struct fsnotify_mark *mark)\n{\n\treturn container_of(mark, struct audit_tree_mark, mark);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *mark_chunk(struct fsnotify_mark *mark)\n{\n\treturn audit_mark(mark)->chunk;\n}"
  },
  {
    "function_name": "audit_mark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "161-164",
    "snippet": "static inline struct audit_tree_mark *audit_mark(struct fsnotify_mark *mark)\n{\n\treturn container_of(mark, struct audit_tree_mark, mark);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "mark",
            "structaudit_tree_mark",
            "mark"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline struct audit_tree_mark *audit_mark(struct fsnotify_mark *mark)\n{\n\treturn container_of(mark, struct audit_tree_mark, mark);\n}"
  },
  {
    "function_name": "audit_mark_put_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "156-159",
    "snippet": "static void audit_mark_put_chunk(struct audit_chunk *chunk)\n{\n\tcall_rcu(&chunk->head, __put_chunk);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&chunk->head",
            "__put_chunk"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void audit_mark_put_chunk(struct audit_chunk *chunk)\n{\n\tcall_rcu(&chunk->head, __put_chunk);\n}"
  },
  {
    "function_name": "__put_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "145-149",
    "snippet": "static void __put_chunk(struct rcu_head *rcu)\n{\n\tstruct audit_chunk *chunk = container_of(rcu, struct audit_chunk, head);\n\taudit_put_chunk(chunk);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_chunk",
          "args": [
            "chunk"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "139-143",
          "snippet": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structaudit_chunk",
            "head"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void __put_chunk(struct rcu_head *rcu)\n{\n\tstruct audit_chunk *chunk = container_of(rcu, struct audit_chunk, head);\n\taudit_put_chunk(chunk);\n}"
  },
  {
    "function_name": "audit_put_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "139-143",
    "snippet": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_chunk",
          "args": [
            "chunk"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "free_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "128-137",
          "snippet": "static void free_chunk(struct audit_chunk *chunk)\n{\n\tint i;\n\n\tfor (i = 0; i < chunk->count; i++) {\n\t\tif (chunk->owners[i].owner)\n\t\t\tput_tree(chunk->owners[i].owner);\n\t}\n\tkfree(chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void free_chunk(struct audit_chunk *chunk)\n{\n\tint i;\n\n\tfor (i = 0; i < chunk->count; i++) {\n\t\tif (chunk->owners[i].owner)\n\t\t\tput_tree(chunk->owners[i].owner);\n\t}\n\tkfree(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_dec_and_test",
          "args": [
            "&chunk->refs"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}"
  },
  {
    "function_name": "free_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "128-137",
    "snippet": "static void free_chunk(struct audit_chunk *chunk)\n{\n\tint i;\n\n\tfor (i = 0; i < chunk->count; i++) {\n\t\tif (chunk->owners[i].owner)\n\t\t\tput_tree(chunk->owners[i].owner);\n\t}\n\tkfree(chunk);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "chunk"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "chunk->owners[i].owner"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "740-743",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void free_chunk(struct audit_chunk *chunk)\n{\n\tint i;\n\n\tfor (i = 0; i < chunk->count; i++) {\n\t\tif (chunk->owners[i].owner)\n\t\t\tput_tree(chunk->owners[i].owner);\n\t}\n\tkfree(chunk);\n}"
  },
  {
    "function_name": "audit_tree_path",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "123-126",
    "snippet": "const char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nconst char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}"
  },
  {
    "function_name": "put_tree",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "116-120",
    "snippet": "static inline void put_tree(struct audit_tree *tree)\n{\n\tif (refcount_dec_and_test(&tree->count))\n\t\tkfree_rcu(tree, head);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "tree",
            "head"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&tree->count"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void put_tree(struct audit_tree *tree)\n{\n\tif (refcount_dec_and_test(&tree->count))\n\t\tkfree_rcu(tree, head);\n}"
  },
  {
    "function_name": "get_tree",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "111-114",
    "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&tree->count"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
  },
  {
    "function_name": "alloc_tree",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
    "lines": "93-109",
    "snippet": "static struct audit_tree *alloc_tree(const char *s)\n{\n\tstruct audit_tree *tree;\n\n\ttree = kmalloc(struct_size(tree, pathname, strlen(s) + 1), GFP_KERNEL);\n\tif (tree) {\n\t\trefcount_set(&tree->count, 1);\n\t\ttree->goner = 0;\n\t\tINIT_LIST_HEAD(&tree->chunks);\n\t\tINIT_LIST_HEAD(&tree->rules);\n\t\tINIT_LIST_HEAD(&tree->list);\n\t\tINIT_LIST_HEAD(&tree->same_root);\n\t\ttree->root = NULL;\n\t\tstrcpy(tree->pathname, s);\n\t}\n\treturn tree;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tree->pathname",
            "s"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tree->same_root"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tree->list"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tree->rules"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tree->chunks"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&tree->count",
            "1"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "struct_size(tree, pathname, strlen(s) + 1)",
            "GFP_KERNEL"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "tree",
            "pathname",
            "strlen(s) + 1"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_tree *alloc_tree(const char *s)\n{\n\tstruct audit_tree *tree;\n\n\ttree = kmalloc(struct_size(tree, pathname, strlen(s) + 1), GFP_KERNEL);\n\tif (tree) {\n\t\trefcount_set(&tree->count, 1);\n\t\ttree->goner = 0;\n\t\tINIT_LIST_HEAD(&tree->chunks);\n\t\tINIT_LIST_HEAD(&tree->rules);\n\t\tINIT_LIST_HEAD(&tree->list);\n\t\tINIT_LIST_HEAD(&tree->same_root);\n\t\ttree->root = NULL;\n\t\tstrcpy(tree->pathname, s);\n\t}\n\treturn tree;\n}"
  }
]