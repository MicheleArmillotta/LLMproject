[
  {
    "function_name": "klp_shadow_free_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
    "lines": "283-298",
    "snippet": "void klp_shadow_free_all(unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tstruct klp_shadow *shadow;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\n\t/* Delete all <_, id> from hash */\n\thash_for_each(klp_shadow_hash, i, shadow, node) {\n\t\tif (klp_shadow_match(shadow, shadow->obj, id))\n\t\t\tklp_shadow_free_struct(shadow, dtor);\n\t}\n\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(klp_shadow_hash, 12);",
      "static DEFINE_SPINLOCK(klp_shadow_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_shadow_free_struct",
          "args": [
            "shadow",
            "dtor"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_free_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
          "lines": "234-241",
          "snippet": "static void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_shadow_match",
          "args": [
            "shadow",
            "shadow->obj",
            "id"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
          "lines": "70-74",
          "snippet": "static inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "klp_shadow_hash",
            "i",
            "shadow",
            "node"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\nstatic DEFINE_SPINLOCK(klp_shadow_lock);\n\nvoid klp_shadow_free_all(unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tstruct klp_shadow *shadow;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\n\t/* Delete all <_, id> from hash */\n\thash_for_each(klp_shadow_hash, i, shadow, node) {\n\t\tif (klp_shadow_match(shadow, shadow->obj, id))\n\t\t\tklp_shadow_free_struct(shadow, dtor);\n\t}\n\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n}"
  },
  {
    "function_name": "klp_shadow_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
    "lines": "253-271",
    "snippet": "void klp_shadow_free(void *obj, unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tstruct klp_shadow *shadow;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\n\t/* Delete <obj, id> from hash */\n\thash_for_each_possible(klp_shadow_hash, shadow, node,\n\t\t\t       (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\tklp_shadow_free_struct(shadow, dtor);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(klp_shadow_hash, 12);",
      "static DEFINE_SPINLOCK(klp_shadow_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_shadow_free_struct",
          "args": [
            "shadow",
            "dtor"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_free_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
          "lines": "234-241",
          "snippet": "static void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_shadow_match",
          "args": [
            "shadow",
            "obj",
            "id"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
          "lines": "70-74",
          "snippet": "static inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "klp_shadow_hash",
            "shadow",
            "node",
            "(unsigned long)obj"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\nstatic DEFINE_SPINLOCK(klp_shadow_lock);\n\nvoid klp_shadow_free(void *obj, unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tstruct klp_shadow *shadow;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\n\t/* Delete <obj, id> from hash */\n\thash_for_each_possible(klp_shadow_hash, shadow, node,\n\t\t\t       (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\tklp_shadow_free_struct(shadow, dtor);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n}"
  },
  {
    "function_name": "klp_shadow_free_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
    "lines": "234-241",
    "snippet": "static void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "shadow",
            "rcu_head"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtor",
          "args": [
            "shadow->obj",
            "shadow->data"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_del_rcu",
          "args": [
            "&shadow->node"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}"
  },
  {
    "function_name": "klp_shadow_get_or_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
    "lines": "225-231",
    "snippet": "void *klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t      size_t size, gfp_t gfp_flags,\n\t\t\t      klp_shadow_ctor_t ctor, void *ctor_data)\n{\n\treturn __klp_shadow_get_or_alloc(obj, id, size, gfp_flags,\n\t\t\t\t\t ctor, ctor_data, false);\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__klp_shadow_get_or_alloc",
          "args": [
            "obj",
            "id",
            "size",
            "gfp_flags",
            "ctor",
            "ctor_data",
            "false"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_shadow_get_or_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
          "lines": "104-170",
          "snippet": "static void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(klp_shadow_hash, 12);",
            "static DEFINE_SPINLOCK(klp_shadow_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\nstatic DEFINE_SPINLOCK(klp_shadow_lock);\n\nstatic void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nvoid *klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t      size_t size, gfp_t gfp_flags,\n\t\t\t      klp_shadow_ctor_t ctor, void *ctor_data)\n{\n\treturn __klp_shadow_get_or_alloc(obj, id, size, gfp_flags,\n\t\t\t\t\t ctor, ctor_data, false);\n}"
  },
  {
    "function_name": "klp_shadow_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
    "lines": "196-202",
    "snippet": "void *klp_shadow_alloc(void *obj, unsigned long id,\n\t\t       size_t size, gfp_t gfp_flags,\n\t\t       klp_shadow_ctor_t ctor, void *ctor_data)\n{\n\treturn __klp_shadow_get_or_alloc(obj, id, size, gfp_flags,\n\t\t\t\t\t ctor, ctor_data, true);\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__klp_shadow_get_or_alloc",
          "args": [
            "obj",
            "id",
            "size",
            "gfp_flags",
            "ctor",
            "ctor_data",
            "true"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_shadow_get_or_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
          "lines": "104-170",
          "snippet": "static void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(klp_shadow_hash, 12);",
            "static DEFINE_SPINLOCK(klp_shadow_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\nstatic DEFINE_SPINLOCK(klp_shadow_lock);\n\nstatic void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nvoid *klp_shadow_alloc(void *obj, unsigned long id,\n\t\t       size_t size, gfp_t gfp_flags,\n\t\t       klp_shadow_ctor_t ctor, void *ctor_data)\n{\n\treturn __klp_shadow_get_or_alloc(obj, id, size, gfp_flags,\n\t\t\t\t\t ctor, ctor_data, true);\n}"
  },
  {
    "function_name": "__klp_shadow_get_or_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
    "lines": "104-170",
    "snippet": "static void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(klp_shadow_hash, 12);",
      "static DEFINE_SPINLOCK(klp_shadow_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Duplicate shadow variable <%p, %lx>\\n\"",
            "obj",
            "id"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_add_rcu",
          "args": [
            "klp_shadow_hash",
            "&new_shadow->node",
            "(unsigned long)new_shadow->obj"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to construct shadow variable <%p, %lx> (%d)\\n\"",
            "obj",
            "id",
            "err"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_shadow"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctor",
          "args": [
            "obj",
            "new_shadow->data",
            "ctor_data"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "irq_calc_affinity_vectors",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/affinity.c",
          "lines": "496-514",
          "snippet": "unsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,\n\t\t\t\t       const struct irq_affinity *affd)\n{\n\tunsigned int resv = affd->pre_vectors + affd->post_vectors;\n\tunsigned int set_vecs;\n\n\tif (resv > minvec)\n\t\treturn 0;\n\n\tif (affd->calc_sets) {\n\t\tset_vecs = maxvec - resv;\n\t} else {\n\t\tcpus_read_lock();\n\t\tset_vecs = cpumask_weight(cpu_possible_mask);\n\t\tcpus_read_unlock();\n\t}\n\n\treturn resv + min(set_vecs, maxvec - resv);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nunsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,\n\t\t\t\t       const struct irq_affinity *affd)\n{\n\tunsigned int resv = affd->pre_vectors + affd->post_vectors;\n\tunsigned int set_vecs;\n\n\tif (resv > minvec)\n\t\treturn 0;\n\n\tif (affd->calc_sets) {\n\t\tset_vecs = maxvec - resv;\n\t} else {\n\t\tcpus_read_lock();\n\t\tset_vecs = cpumask_weight(cpu_possible_mask);\n\t\tcpus_read_unlock();\n\t}\n\n\treturn resv + min(set_vecs, maxvec - resv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "shadow_data"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_shadow_get",
          "args": [
            "obj",
            "id"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
          "lines": "83-101",
          "snippet": "void *klp_shadow_get(void *obj, unsigned long id)\n{\n\tstruct klp_shadow *shadow;\n\n\trcu_read_lock();\n\n\thash_for_each_possible_rcu(klp_shadow_hash, shadow, node,\n\t\t\t\t   (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn shadow->data;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(klp_shadow_hash, 12);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\n\nvoid *klp_shadow_get(void *obj, unsigned long id)\n{\n\tstruct klp_shadow *shadow;\n\n\trcu_read_lock();\n\n\thash_for_each_possible_rcu(klp_shadow_hash, shadow, node,\n\t\t\t\t   (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn shadow->data;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&klp_shadow_lock",
            "flags"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + sizeof(*new_shadow)",
            "gfp_flags"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\nstatic DEFINE_SPINLOCK(klp_shadow_lock);\n\nstatic void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t/* Check if the shadow variable already exists */\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t/*\n\t * Allocate a new shadow variable.  Fill it with zeroes by default.\n\t * More complex setting can be done by @ctor function.  But it is\n\t * called only when the buffer is really used (under klp_shadow_lock).\n\t */\n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t/* Look for <obj, id> again under the lock */\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t/*\n\t\t * Shadow variable was found, throw away speculative\n\t\t * allocation.\n\t\t */\n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* No <obj, id> found, so attach the newly allocated one */\n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}"
  },
  {
    "function_name": "klp_shadow_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
    "lines": "83-101",
    "snippet": "void *klp_shadow_get(void *obj, unsigned long id)\n{\n\tstruct klp_shadow *shadow;\n\n\trcu_read_lock();\n\n\thash_for_each_possible_rcu(klp_shadow_hash, shadow, node,\n\t\t\t\t   (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn shadow->data;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(klp_shadow_hash, 12);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_shadow_match",
          "args": [
            "shadow",
            "obj",
            "id"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "klp_shadow_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
          "lines": "70-74",
          "snippet": "static inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}",
          "includes": [
            "#include <linux/livepatch.h>",
            "#include <linux/slab.h>",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible_rcu",
          "args": [
            "klp_shadow_hash",
            "shadow",
            "node",
            "(unsigned long)obj"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\n\nvoid *klp_shadow_get(void *obj, unsigned long id)\n{\n\tstruct klp_shadow *shadow;\n\n\trcu_read_lock();\n\n\thash_for_each_possible_rcu(klp_shadow_hash, shadow, node,\n\t\t\t\t   (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn shadow->data;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "klp_shadow_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/shadow.c",
    "lines": "70-74",
    "snippet": "static inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}",
    "includes": [
      "#include <linux/livepatch.h>",
      "#include <linux/slab.h>",
      "#include <linux/hashtable.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/livepatch.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n\nstatic inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}"
  }
]