[
  {
    "function_name": "trace_boot_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "646-666",
    "snippet": "static int __init trace_boot_init(void)\n{\n\tstruct xbc_node *trace_node;\n\tstruct trace_array *tr;\n\n\ttrace_node = xbc_find_node(\"ftrace\");\n\tif (!trace_node)\n\t\treturn 0;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn 0;\n\n\t/* Global trace array is also one instance */\n\ttrace_boot_init_one_instance(tr, trace_node);\n\ttrace_boot_init_instances(trace_node);\n\n\tdisable_tracing_selftest(\"running boot-time tracing\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_tracing_selftest",
          "args": [
            "\"running boot-time tracing\""
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "disable_tracing_selftest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "78-84",
          "snippet": "void __init disable_tracing_selftest(const char *reason)\n{\n\tif (!tracing_selftest_disabled) {\n\t\ttracing_selftest_disabled = true;\n\t\tpr_info(\"Ftrace startup test is disabled due to %s\\n\", reason);\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nvoid __init disable_tracing_selftest(const char *reason)\n{\n\tif (!tracing_selftest_disabled) {\n\t\ttracing_selftest_disabled = true;\n\t\tpr_info(\"Ftrace startup test is disabled due to %s\\n\", reason);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_boot_init_instances",
          "args": [
            "trace_node"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_init_instances",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "620-644",
          "snippet": "static void __init\ntrace_boot_init_instances(struct xbc_node *node)\n{\n\tstruct xbc_node *inode;\n\tstruct trace_array *tr;\n\tconst char *p;\n\n\tnode = xbc_node_find_subkey(node, \"instance\");\n\tif (!node)\n\t\treturn;\n\n\txbc_node_for_each_subkey(node, inode) {\n\t\tp = xbc_node_get_data(inode);\n\t\tif (!p || *p == '\\0')\n\t\t\tcontinue;\n\n\t\ttr = trace_array_get_by_name(p);\n\t\tif (!tr) {\n\t\t\tpr_err(\"Failed to get trace instance %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_boot_init_one_instance(tr, inode);\n\t\ttrace_array_put(tr);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_init_instances(struct xbc_node *node)\n{\n\tstruct xbc_node *inode;\n\tstruct trace_array *tr;\n\tconst char *p;\n\n\tnode = xbc_node_find_subkey(node, \"instance\");\n\tif (!node)\n\t\treturn;\n\n\txbc_node_for_each_subkey(node, inode) {\n\t\tp = xbc_node_get_data(inode);\n\t\tif (!p || *p == '\\0')\n\t\t\tcontinue;\n\n\t\ttr = trace_array_get_by_name(p);\n\t\tif (!tr) {\n\t\t\tpr_err(\"Failed to get trace instance %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_boot_init_one_instance(tr, inode);\n\t\ttrace_array_put(tr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_boot_init_one_instance",
          "args": [
            "tr",
            "trace_node"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_init_one_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "611-618",
          "snippet": "static void __init\ntrace_boot_init_one_instance(struct trace_array *tr, struct xbc_node *node)\n{\n\ttrace_boot_set_instance_options(tr, node);\n\ttrace_boot_init_events(tr, node);\n\ttrace_boot_enable_events(tr, node);\n\ttrace_boot_enable_tracer(tr, node);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_init_one_instance(struct trace_array *tr, struct xbc_node *node)\n{\n\ttrace_boot_set_instance_options(tr, node);\n\ttrace_boot_init_events(tr, node);\n\ttrace_boot_enable_events(tr, node);\n\ttrace_boot_enable_tracer(tr, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "411-422",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_find_node",
          "args": [
            "\"ftrace\""
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic int __init trace_boot_init(void)\n{\n\tstruct xbc_node *trace_node;\n\tstruct trace_array *tr;\n\n\ttrace_node = xbc_find_node(\"ftrace\");\n\tif (!trace_node)\n\t\treturn 0;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn 0;\n\n\t/* Global trace array is also one instance */\n\ttrace_boot_init_one_instance(tr, trace_node);\n\ttrace_boot_init_instances(trace_node);\n\n\tdisable_tracing_selftest(\"running boot-time tracing\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_boot_init_instances",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "620-644",
    "snippet": "static void __init\ntrace_boot_init_instances(struct xbc_node *node)\n{\n\tstruct xbc_node *inode;\n\tstruct trace_array *tr;\n\tconst char *p;\n\n\tnode = xbc_node_find_subkey(node, \"instance\");\n\tif (!node)\n\t\treturn;\n\n\txbc_node_for_each_subkey(node, inode) {\n\t\tp = xbc_node_get_data(inode);\n\t\tif (!p || *p == '\\0')\n\t\t\tcontinue;\n\n\t\ttr = trace_array_get_by_name(p);\n\t\tif (!tr) {\n\t\t\tpr_err(\"Failed to get trace instance %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_boot_init_one_instance(tr, inode);\n\t\ttrace_array_put(tr);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_boot_init_one_instance",
          "args": [
            "tr",
            "inode"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_init_one_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "611-618",
          "snippet": "static void __init\ntrace_boot_init_one_instance(struct trace_array *tr, struct xbc_node *node)\n{\n\ttrace_boot_set_instance_options(tr, node);\n\ttrace_boot_init_events(tr, node);\n\ttrace_boot_enable_events(tr, node);\n\ttrace_boot_enable_tracer(tr, node);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_init_one_instance(struct trace_array *tr, struct xbc_node *node)\n{\n\ttrace_boot_set_instance_options(tr, node);\n\ttrace_boot_init_events(tr, node);\n\ttrace_boot_enable_events(tr, node);\n\ttrace_boot_enable_tracer(tr, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to get trace instance %s\\n\"",
            "p"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_array_get_by_name",
          "args": [
            "p"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_get_by_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9283-9306",
          "snippet": "struct trace_array *trace_array_get_by_name(const char *name)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttr = trace_array_create(name);\n\n\tif (IS_ERR(tr))\n\t\ttr = NULL;\nout_unlock:\n\tif (tr)\n\t\ttr->ref++;\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct trace_array *trace_array_get_by_name(const char *name)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttr = trace_array_create(name);\n\n\tif (IS_ERR(tr))\n\t\ttr = NULL;\nout_unlock:\n\tif (tr)\n\t\ttr->ref++;\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "inode"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_subkey",
          "args": [
            "node",
            "inode"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "node",
            "\"instance\""
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_init_instances(struct xbc_node *node)\n{\n\tstruct xbc_node *inode;\n\tstruct trace_array *tr;\n\tconst char *p;\n\n\tnode = xbc_node_find_subkey(node, \"instance\");\n\tif (!node)\n\t\treturn;\n\n\txbc_node_for_each_subkey(node, inode) {\n\t\tp = xbc_node_get_data(inode);\n\t\tif (!p || *p == '\\0')\n\t\t\tcontinue;\n\n\t\ttr = trace_array_get_by_name(p);\n\t\tif (!tr) {\n\t\t\tpr_err(\"Failed to get trace instance %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_boot_init_one_instance(tr, inode);\n\t\ttrace_array_put(tr);\n\t}\n}"
  },
  {
    "function_name": "trace_boot_init_one_instance",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "611-618",
    "snippet": "static void __init\ntrace_boot_init_one_instance(struct trace_array *tr, struct xbc_node *node)\n{\n\ttrace_boot_set_instance_options(tr, node);\n\ttrace_boot_init_events(tr, node);\n\ttrace_boot_enable_events(tr, node);\n\ttrace_boot_enable_tracer(tr, node);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_boot_enable_tracer",
          "args": [
            "tr",
            "node"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_enable_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "591-609",
          "snippet": "static void __init\ntrace_boot_enable_tracer(struct trace_array *tr, struct xbc_node *node)\n{\n\tconst char *p;\n\n\ttrace_boot_set_ftrace_filter(tr, node);\n\n\tp = xbc_node_find_value(node, \"tracer\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (tracing_set_tracer(tr, p) < 0)\n\t\t\tpr_err(\"Failed to set given tracer: %s\\n\", p);\n\t}\n\n\t/* Since tracer can free snapshot buffer, allocate snapshot here.*/\n\tif (xbc_node_find_value(node, \"alloc_snapshot\", NULL)) {\n\t\tif (tracing_alloc_snapshot_instance(tr) < 0)\n\t\t\tpr_err(\"Failed to allocate snapshot buffer\\n\");\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_enable_tracer(struct trace_array *tr, struct xbc_node *node)\n{\n\tconst char *p;\n\n\ttrace_boot_set_ftrace_filter(tr, node);\n\n\tp = xbc_node_find_value(node, \"tracer\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (tracing_set_tracer(tr, p) < 0)\n\t\t\tpr_err(\"Failed to set given tracer: %s\\n\", p);\n\t}\n\n\t/* Since tracer can free snapshot buffer, allocate snapshot here.*/\n\tif (xbc_node_find_value(node, \"alloc_snapshot\", NULL)) {\n\t\tif (tracing_alloc_snapshot_instance(tr) < 0)\n\t\t\tpr_err(\"Failed to allocate snapshot buffer\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_boot_enable_events",
          "args": [
            "tr",
            "node"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_enable_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "82-98",
          "snippet": "static void __init\ntrace_boot_enable_events(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p;\n\n\txbc_node_for_each_array_value(node, \"events\", anode, p) {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf)) {\n\t\t\tpr_err(\"String is too long: %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ftrace_set_clr_event(tr, buf, 1) < 0)\n\t\t\tpr_err(\"Failed to enable event: %s\\n\", p);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [
            "#define MAX_BUF_LEN 256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\n#define MAX_BUF_LEN 256\n\nstatic void __init\ntrace_boot_enable_events(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p;\n\n\txbc_node_for_each_array_value(node, \"events\", anode, p) {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf)) {\n\t\t\tpr_err(\"String is too long: %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ftrace_set_clr_event(tr, buf, 1) < 0)\n\t\t\tpr_err(\"Failed to enable event: %s\\n\", p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_boot_init_events",
          "args": [
            "tr",
            "node"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_init_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "517-552",
          "snippet": "static void __init\ntrace_boot_init_events(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *gnode, *enode;\n\tbool enable, enable_all = false;\n\tconst char *data;\n\n\tnode = xbc_node_find_subkey(node, \"event\");\n\tif (!node)\n\t\treturn;\n\t/* per-event key starts with \"event.GROUP.EVENT\" */\n\txbc_node_for_each_subkey(node, gnode) {\n\t\tdata = xbc_node_get_data(gnode);\n\t\tif (!strcmp(data, \"enable\")) {\n\t\t\tenable_all = true;\n\t\t\tcontinue;\n\t\t}\n\t\tenable = false;\n\t\txbc_node_for_each_subkey(gnode, enode) {\n\t\t\tdata = xbc_node_get_data(enode);\n\t\t\tif (!strcmp(data, \"enable\")) {\n\t\t\t\tenable = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrace_boot_init_one_event(tr, gnode, enode);\n\t\t}\n\t\t/* Event enablement must be done after event settings */\n\t\tif (enable) {\n\t\t\tdata = xbc_node_get_data(gnode);\n\t\t\ttrace_array_set_clr_event(tr, data, NULL, true);\n\t\t}\n\t}\n\t/* Ditto */\n\tif (enable_all)\n\t\ttrace_array_set_clr_event(tr, NULL, NULL, true);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_init_events(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *gnode, *enode;\n\tbool enable, enable_all = false;\n\tconst char *data;\n\n\tnode = xbc_node_find_subkey(node, \"event\");\n\tif (!node)\n\t\treturn;\n\t/* per-event key starts with \"event.GROUP.EVENT\" */\n\txbc_node_for_each_subkey(node, gnode) {\n\t\tdata = xbc_node_get_data(gnode);\n\t\tif (!strcmp(data, \"enable\")) {\n\t\t\tenable_all = true;\n\t\t\tcontinue;\n\t\t}\n\t\tenable = false;\n\t\txbc_node_for_each_subkey(gnode, enode) {\n\t\t\tdata = xbc_node_get_data(enode);\n\t\t\tif (!strcmp(data, \"enable\")) {\n\t\t\t\tenable = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrace_boot_init_one_event(tr, gnode, enode);\n\t\t}\n\t\t/* Event enablement must be done after event settings */\n\t\tif (enable) {\n\t\t\tdata = xbc_node_get_data(gnode);\n\t\t\ttrace_array_set_clr_event(tr, data, NULL, true);\n\t\t}\n\t}\n\t/* Ditto */\n\tif (enable_all)\n\t\ttrace_array_set_clr_event(tr, NULL, NULL, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_boot_set_instance_options",
          "args": [
            "tr",
            "node"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_set_instance_options",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "24-79",
          "snippet": "static void __init\ntrace_boot_set_instance_options(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar buf[MAX_BUF_LEN];\n\tunsigned long v = 0;\n\n\t/* Common ftrace options */\n\txbc_node_for_each_array_value(node, \"options\", anode, p) {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf)) {\n\t\t\tpr_err(\"String is too long: %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (trace_set_options(tr, buf) < 0)\n\t\t\tpr_err(\"Failed to set option: %s\\n\", buf);\n\t}\n\n\tp = xbc_node_find_value(node, \"tracing_on\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (kstrtoul(p, 10, &v))\n\t\t\tpr_err(\"Failed to set tracing on: %s\\n\", p);\n\t\tif (v)\n\t\t\ttracer_tracing_on(tr);\n\t\telse\n\t\t\ttracer_tracing_off(tr);\n\t}\n\n\tp = xbc_node_find_value(node, \"trace_clock\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (tracing_set_clock(tr, p) < 0)\n\t\t\tpr_err(\"Failed to set trace clock: %s\\n\", p);\n\t}\n\n\tp = xbc_node_find_value(node, \"buffer_size\", NULL);\n\tif (p && *p != '\\0') {\n\t\tv = memparse(p, NULL);\n\t\tif (v < PAGE_SIZE)\n\t\t\tpr_err(\"Buffer size is too small: %s\\n\", p);\n\t\tif (tracing_resize_ring_buffer(tr, v, RING_BUFFER_ALL_CPUS) < 0)\n\t\t\tpr_err(\"Failed to resize trace buffer to %s\\n\", p);\n\t}\n\n\tp = xbc_node_find_value(node, \"cpumask\", NULL);\n\tif (p && *p != '\\0') {\n\t\tcpumask_var_t new_mask;\n\n\t\tif (alloc_cpumask_var(&new_mask, GFP_KERNEL)) {\n\t\t\tif (cpumask_parse(p, new_mask) < 0 ||\n\t\t\t    tracing_set_cpumask(tr, new_mask) < 0)\n\t\t\t\tpr_err(\"Failed to set new CPU mask %s\\n\", p);\n\t\t\tfree_cpumask_var(new_mask);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [
            "#define MAX_BUF_LEN 256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\n#define MAX_BUF_LEN 256\n\nstatic void __init\ntrace_boot_set_instance_options(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar buf[MAX_BUF_LEN];\n\tunsigned long v = 0;\n\n\t/* Common ftrace options */\n\txbc_node_for_each_array_value(node, \"options\", anode, p) {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf)) {\n\t\t\tpr_err(\"String is too long: %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (trace_set_options(tr, buf) < 0)\n\t\t\tpr_err(\"Failed to set option: %s\\n\", buf);\n\t}\n\n\tp = xbc_node_find_value(node, \"tracing_on\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (kstrtoul(p, 10, &v))\n\t\t\tpr_err(\"Failed to set tracing on: %s\\n\", p);\n\t\tif (v)\n\t\t\ttracer_tracing_on(tr);\n\t\telse\n\t\t\ttracer_tracing_off(tr);\n\t}\n\n\tp = xbc_node_find_value(node, \"trace_clock\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (tracing_set_clock(tr, p) < 0)\n\t\t\tpr_err(\"Failed to set trace clock: %s\\n\", p);\n\t}\n\n\tp = xbc_node_find_value(node, \"buffer_size\", NULL);\n\tif (p && *p != '\\0') {\n\t\tv = memparse(p, NULL);\n\t\tif (v < PAGE_SIZE)\n\t\t\tpr_err(\"Buffer size is too small: %s\\n\", p);\n\t\tif (tracing_resize_ring_buffer(tr, v, RING_BUFFER_ALL_CPUS) < 0)\n\t\t\tpr_err(\"Failed to resize trace buffer to %s\\n\", p);\n\t}\n\n\tp = xbc_node_find_value(node, \"cpumask\", NULL);\n\tif (p && *p != '\\0') {\n\t\tcpumask_var_t new_mask;\n\n\t\tif (alloc_cpumask_var(&new_mask, GFP_KERNEL)) {\n\t\t\tif (cpumask_parse(p, new_mask) < 0 ||\n\t\t\t    tracing_set_cpumask(tr, new_mask) < 0)\n\t\t\t\tpr_err(\"Failed to set new CPU mask %s\\n\", p);\n\t\t\tfree_cpumask_var(new_mask);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_init_one_instance(struct trace_array *tr, struct xbc_node *node)\n{\n\ttrace_boot_set_instance_options(tr, node);\n\ttrace_boot_init_events(tr, node);\n\ttrace_boot_enable_events(tr, node);\n\ttrace_boot_enable_tracer(tr, node);\n}"
  },
  {
    "function_name": "trace_boot_enable_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "591-609",
    "snippet": "static void __init\ntrace_boot_enable_tracer(struct trace_array *tr, struct xbc_node *node)\n{\n\tconst char *p;\n\n\ttrace_boot_set_ftrace_filter(tr, node);\n\n\tp = xbc_node_find_value(node, \"tracer\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (tracing_set_tracer(tr, p) < 0)\n\t\t\tpr_err(\"Failed to set given tracer: %s\\n\", p);\n\t}\n\n\t/* Since tracer can free snapshot buffer, allocate snapshot here.*/\n\tif (xbc_node_find_value(node, \"alloc_snapshot\", NULL)) {\n\t\tif (tracing_alloc_snapshot_instance(tr) < 0)\n\t\t\tpr_err(\"Failed to allocate snapshot buffer\\n\");\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate snapshot buffer\\n\""
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_alloc_snapshot_instance",
          "args": [
            "tr"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_alloc_snapshot_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1195-1211",
          "snippet": "int tracing_alloc_snapshot_instance(struct trace_array *tr)\n{\n\tint ret;\n\n\tif (!tr->allocated_snapshot) {\n\n\t\t/* allocate spare buffer */\n\t\tret = resize_buffer_duplicate_size(&tr->max_buffer,\n\t\t\t\t   &tr->array_buffer, RING_BUFFER_ALL_CPUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttr->allocated_snapshot = true;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_alloc_snapshot_instance(struct trace_array *tr)\n{\n\tint ret;\n\n\tif (!tr->allocated_snapshot) {\n\n\t\t/* allocate spare buffer */\n\t\tret = resize_buffer_duplicate_size(&tr->max_buffer,\n\t\t\t\t   &tr->array_buffer, RING_BUFFER_ALL_CPUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttr->allocated_snapshot = true;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "node",
            "\"alloc_snapshot\"",
            "NULL"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to set given tracer: %s\\n\"",
            "p"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_set_tracer",
          "args": [
            "tr",
            "p"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_set_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6323-6428",
          "snippet": "int tracing_set_tracer(struct trace_array *tr, const char *buf)\n{\n\tstruct tracer *t;\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbool had_max_tr;\n#endif\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (!ring_buffer_expanded) {\n\t\tret = __tracing_resize_ring_buffer(tr, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(t->name, buf) == 0)\n\t\t\tbreak;\n\t}\n\tif (!t) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (t == tr->current_trace)\n\t\tgoto out;\n\n#ifdef CONFIG_TRACER_SNAPSHOT\n\tif (t->use_max_tr) {\n\t\tarch_spin_lock(&tr->max_lock);\n\t\tif (tr->cond_snapshot)\n\t\t\tret = -EBUSY;\n\t\tarch_spin_unlock(&tr->max_lock);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\t/* Some tracers won't work on kernel command line */\n\tif (system_state < SYSTEM_RUNNING && t->noboot) {\n\t\tpr_warn(\"Tracer '%s' is not allowed on command line, ignored\\n\",\n\t\t\tt->name);\n\t\tgoto out;\n\t}\n\n\t/* Some tracers are only allowed for the top level buffer */\n\tif (!trace_ok_for_array(t, tr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* If trace pipe files are being read, we can't change the tracer */\n\tif (tr->trace_ref) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\ttrace_branch_disable();\n\n\ttr->current_trace->enabled--;\n\n\tif (tr->current_trace->reset)\n\t\ttr->current_trace->reset(tr);\n\n\t/* Current trace needs to be nop_trace before synchronize_rcu */\n\ttr->current_trace = &nop_trace;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\thad_max_tr = tr->allocated_snapshot;\n\n\tif (had_max_tr && !t->use_max_tr) {\n\t\t/*\n\t\t * We need to make sure that the update_max_tr sees that\n\t\t * current_trace changed to nop_trace to keep it from\n\t\t * swapping the buffers after we resize it.\n\t\t * The update_max_tr is called from interrupts disabled\n\t\t * so a synchronized_sched() is sufficient.\n\t\t */\n\t\tsynchronize_rcu();\n\t\tfree_snapshot(tr);\n\t}\n#endif\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (t->use_max_tr && !had_max_tr) {\n\t\tret = tracing_alloc_snapshot_instance(tr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (t->init) {\n\t\tret = tracer_init(t, tr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\ttr->current_trace = t;\n\ttr->current_trace->enabled++;\n\ttrace_branch_enable(tr);\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool ring_buffer_expanded;",
            "int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nbool ring_buffer_expanded;\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf)\n{\n\tstruct tracer *t;\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbool had_max_tr;\n#endif\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (!ring_buffer_expanded) {\n\t\tret = __tracing_resize_ring_buffer(tr, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(t->name, buf) == 0)\n\t\t\tbreak;\n\t}\n\tif (!t) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (t == tr->current_trace)\n\t\tgoto out;\n\n#ifdef CONFIG_TRACER_SNAPSHOT\n\tif (t->use_max_tr) {\n\t\tarch_spin_lock(&tr->max_lock);\n\t\tif (tr->cond_snapshot)\n\t\t\tret = -EBUSY;\n\t\tarch_spin_unlock(&tr->max_lock);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\t/* Some tracers won't work on kernel command line */\n\tif (system_state < SYSTEM_RUNNING && t->noboot) {\n\t\tpr_warn(\"Tracer '%s' is not allowed on command line, ignored\\n\",\n\t\t\tt->name);\n\t\tgoto out;\n\t}\n\n\t/* Some tracers are only allowed for the top level buffer */\n\tif (!trace_ok_for_array(t, tr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* If trace pipe files are being read, we can't change the tracer */\n\tif (tr->trace_ref) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\ttrace_branch_disable();\n\n\ttr->current_trace->enabled--;\n\n\tif (tr->current_trace->reset)\n\t\ttr->current_trace->reset(tr);\n\n\t/* Current trace needs to be nop_trace before synchronize_rcu */\n\ttr->current_trace = &nop_trace;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\thad_max_tr = tr->allocated_snapshot;\n\n\tif (had_max_tr && !t->use_max_tr) {\n\t\t/*\n\t\t * We need to make sure that the update_max_tr sees that\n\t\t * current_trace changed to nop_trace to keep it from\n\t\t * swapping the buffers after we resize it.\n\t\t * The update_max_tr is called from interrupts disabled\n\t\t * so a synchronized_sched() is sufficient.\n\t\t */\n\t\tsynchronize_rcu();\n\t\tfree_snapshot(tr);\n\t}\n#endif\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (t->use_max_tr && !had_max_tr) {\n\t\tret = tracing_alloc_snapshot_instance(tr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (t->init) {\n\t\tret = tracer_init(t, tr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\ttr->current_trace = t;\n\ttr->current_trace->enabled++;\n\ttrace_branch_enable(tr);\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "node",
            "\"tracer\"",
            "NULL"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_boot_set_ftrace_filter",
          "args": [
            "tr",
            "node"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_set_ftrace_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "559-586",
          "snippet": "static void __init\ntrace_boot_set_ftrace_filter(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar *q;\n\n\txbc_node_for_each_array_value(node, \"ftrace.filters\", anode, p) {\n\t\tq = kstrdup(p, GFP_KERNEL);\n\t\tif (!q)\n\t\t\treturn;\n\t\tif (ftrace_set_filter(tr->ops, q, strlen(q), 0) < 0)\n\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);\n\t\telse\n\t\t\tftrace_filter_param = true;\n\t\tkfree(q);\n\t}\n\txbc_node_for_each_array_value(node, \"ftrace.notraces\", anode, p) {\n\t\tq = kstrdup(p, GFP_KERNEL);\n\t\tif (!q)\n\t\t\treturn;\n\t\tif (ftrace_set_notrace(tr->ops, q, strlen(q), 0) < 0)\n\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);\n\t\telse\n\t\t\tftrace_filter_param = true;\n\t\tkfree(q);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_set_ftrace_filter(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar *q;\n\n\txbc_node_for_each_array_value(node, \"ftrace.filters\", anode, p) {\n\t\tq = kstrdup(p, GFP_KERNEL);\n\t\tif (!q)\n\t\t\treturn;\n\t\tif (ftrace_set_filter(tr->ops, q, strlen(q), 0) < 0)\n\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);\n\t\telse\n\t\t\tftrace_filter_param = true;\n\t\tkfree(q);\n\t}\n\txbc_node_for_each_array_value(node, \"ftrace.notraces\", anode, p) {\n\t\tq = kstrdup(p, GFP_KERNEL);\n\t\tif (!q)\n\t\t\treturn;\n\t\tif (ftrace_set_notrace(tr->ops, q, strlen(q), 0) < 0)\n\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);\n\t\telse\n\t\t\tftrace_filter_param = true;\n\t\tkfree(q);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_enable_tracer(struct trace_array *tr, struct xbc_node *node)\n{\n\tconst char *p;\n\n\ttrace_boot_set_ftrace_filter(tr, node);\n\n\tp = xbc_node_find_value(node, \"tracer\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (tracing_set_tracer(tr, p) < 0)\n\t\t\tpr_err(\"Failed to set given tracer: %s\\n\", p);\n\t}\n\n\t/* Since tracer can free snapshot buffer, allocate snapshot here.*/\n\tif (xbc_node_find_value(node, \"alloc_snapshot\", NULL)) {\n\t\tif (tracing_alloc_snapshot_instance(tr) < 0)\n\t\t\tpr_err(\"Failed to allocate snapshot buffer\\n\");\n\t}\n}"
  },
  {
    "function_name": "trace_boot_set_ftrace_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "559-586",
    "snippet": "static void __init\ntrace_boot_set_ftrace_filter(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar *q;\n\n\txbc_node_for_each_array_value(node, \"ftrace.filters\", anode, p) {\n\t\tq = kstrdup(p, GFP_KERNEL);\n\t\tif (!q)\n\t\t\treturn;\n\t\tif (ftrace_set_filter(tr->ops, q, strlen(q), 0) < 0)\n\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);\n\t\telse\n\t\t\tftrace_filter_param = true;\n\t\tkfree(q);\n\t}\n\txbc_node_for_each_array_value(node, \"ftrace.notraces\", anode, p) {\n\t\tq = kstrdup(p, GFP_KERNEL);\n\t\tif (!q)\n\t\t\treturn;\n\t\tif (ftrace_set_notrace(tr->ops, q, strlen(q), 0) < 0)\n\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);\n\t\telse\n\t\t\tftrace_filter_param = true;\n\t\tkfree(q);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "q"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to add %s to ftrace filter\\n\"",
            "p"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_notrace",
          "args": [
            "tr->ops",
            "q",
            "strlen(q)",
            "0"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_notrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5694-5699",
          "snippet": "int ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "q"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "p",
            "GFP_KERNEL"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_array_value",
          "args": [
            "node",
            "\"ftrace.notraces\"",
            "anode",
            "p"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to add %s to ftrace filter\\n\"",
            "p"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter",
          "args": [
            "tr->ops",
            "q",
            "strlen(q)",
            "0"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5675-5680",
          "snippet": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "p",
            "GFP_KERNEL"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_array_value",
          "args": [
            "node",
            "\"ftrace.filters\"",
            "anode",
            "p"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_set_ftrace_filter(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar *q;\n\n\txbc_node_for_each_array_value(node, \"ftrace.filters\", anode, p) {\n\t\tq = kstrdup(p, GFP_KERNEL);\n\t\tif (!q)\n\t\t\treturn;\n\t\tif (ftrace_set_filter(tr->ops, q, strlen(q), 0) < 0)\n\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);\n\t\telse\n\t\t\tftrace_filter_param = true;\n\t\tkfree(q);\n\t}\n\txbc_node_for_each_array_value(node, \"ftrace.notraces\", anode, p) {\n\t\tq = kstrdup(p, GFP_KERNEL);\n\t\tif (!q)\n\t\t\treturn;\n\t\tif (ftrace_set_notrace(tr->ops, q, strlen(q), 0) < 0)\n\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);\n\t\telse\n\t\t\tftrace_filter_param = true;\n\t\tkfree(q);\n\t}\n}"
  },
  {
    "function_name": "trace_boot_init_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "517-552",
    "snippet": "static void __init\ntrace_boot_init_events(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *gnode, *enode;\n\tbool enable, enable_all = false;\n\tconst char *data;\n\n\tnode = xbc_node_find_subkey(node, \"event\");\n\tif (!node)\n\t\treturn;\n\t/* per-event key starts with \"event.GROUP.EVENT\" */\n\txbc_node_for_each_subkey(node, gnode) {\n\t\tdata = xbc_node_get_data(gnode);\n\t\tif (!strcmp(data, \"enable\")) {\n\t\t\tenable_all = true;\n\t\t\tcontinue;\n\t\t}\n\t\tenable = false;\n\t\txbc_node_for_each_subkey(gnode, enode) {\n\t\t\tdata = xbc_node_get_data(enode);\n\t\t\tif (!strcmp(data, \"enable\")) {\n\t\t\t\tenable = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrace_boot_init_one_event(tr, gnode, enode);\n\t\t}\n\t\t/* Event enablement must be done after event settings */\n\t\tif (enable) {\n\t\t\tdata = xbc_node_get_data(gnode);\n\t\t\ttrace_array_set_clr_event(tr, data, NULL, true);\n\t\t}\n\t}\n\t/* Ditto */\n\tif (enable_all)\n\t\ttrace_array_set_clr_event(tr, NULL, NULL, true);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_set_clr_event",
          "args": [
            "tr",
            "NULL",
            "NULL",
            "true"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1123-1133",
          "snippet": "int trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "gnode"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_boot_init_one_event",
          "args": [
            "tr",
            "gnode",
            "enode"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_init_one_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "461-515",
          "snippet": "static void __init\ntrace_boot_init_one_event(struct trace_array *tr, struct xbc_node *gnode,\n\t\t\t  struct xbc_node *enode)\n{\n\tstruct trace_event_file *file;\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p, *group, *event;\n\n\tgroup = xbc_node_get_data(gnode);\n\tevent = xbc_node_get_data(enode);\n\n\tif (!strcmp(group, \"kprobes\"))\n\t\tif (trace_boot_add_kprobe_event(enode, event) < 0)\n\t\t\treturn;\n\tif (!strcmp(group, \"synthetic\"))\n\t\tif (trace_boot_add_synth_event(enode, event) < 0)\n\t\t\treturn;\n\n\tmutex_lock(&event_mutex);\n\tfile = find_event_file(tr, group, event);\n\tif (!file) {\n\t\tpr_err(\"Failed to find event: %s:%s\\n\", group, event);\n\t\tgoto out;\n\t}\n\n\tp = xbc_node_find_value(enode, \"filter\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf))\n\t\t\tpr_err(\"filter string is too long: %s\\n\", p);\n\t\telse if (apply_event_filter(file, buf) < 0)\n\t\t\tpr_err(\"Failed to apply filter: %s\\n\", buf);\n\t}\n\n\tif (IS_ENABLED(CONFIG_HIST_TRIGGERS)) {\n\t\txbc_node_for_each_array_value(enode, \"actions\", anode, p) {\n\t\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf))\n\t\t\t\tpr_err(\"action string is too long: %s\\n\", p);\n\t\t\telse if (trigger_process_regex(file, buf) < 0)\n\t\t\t\tpr_err(\"Failed to apply an action: %s\\n\", p);\n\t\t}\n\t\tanode = xbc_node_find_subkey(enode, \"hist\");\n\t\tif (anode)\n\t\t\ttrace_boot_init_histograms(file, anode, buf, ARRAY_SIZE(buf));\n\t} else if (xbc_node_find_value(enode, \"actions\", NULL))\n\t\tpr_err(\"Failed to apply event actions because CONFIG_HIST_TRIGGERS is not set.\\n\");\n\n\tif (xbc_node_find_value(enode, \"enable\", NULL)) {\n\t\tif (trace_event_enable_disable(file, 1, 0) < 0)\n\t\t\tpr_err(\"Failed to enable event node: %s:%s\\n\",\n\t\t\t\tgroup, event);\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [
            "#define MAX_BUF_LEN 256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\n#define MAX_BUF_LEN 256\n\nstatic void __init\ntrace_boot_init_one_event(struct trace_array *tr, struct xbc_node *gnode,\n\t\t\t  struct xbc_node *enode)\n{\n\tstruct trace_event_file *file;\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p, *group, *event;\n\n\tgroup = xbc_node_get_data(gnode);\n\tevent = xbc_node_get_data(enode);\n\n\tif (!strcmp(group, \"kprobes\"))\n\t\tif (trace_boot_add_kprobe_event(enode, event) < 0)\n\t\t\treturn;\n\tif (!strcmp(group, \"synthetic\"))\n\t\tif (trace_boot_add_synth_event(enode, event) < 0)\n\t\t\treturn;\n\n\tmutex_lock(&event_mutex);\n\tfile = find_event_file(tr, group, event);\n\tif (!file) {\n\t\tpr_err(\"Failed to find event: %s:%s\\n\", group, event);\n\t\tgoto out;\n\t}\n\n\tp = xbc_node_find_value(enode, \"filter\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf))\n\t\t\tpr_err(\"filter string is too long: %s\\n\", p);\n\t\telse if (apply_event_filter(file, buf) < 0)\n\t\t\tpr_err(\"Failed to apply filter: %s\\n\", buf);\n\t}\n\n\tif (IS_ENABLED(CONFIG_HIST_TRIGGERS)) {\n\t\txbc_node_for_each_array_value(enode, \"actions\", anode, p) {\n\t\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf))\n\t\t\t\tpr_err(\"action string is too long: %s\\n\", p);\n\t\t\telse if (trigger_process_regex(file, buf) < 0)\n\t\t\t\tpr_err(\"Failed to apply an action: %s\\n\", p);\n\t\t}\n\t\tanode = xbc_node_find_subkey(enode, \"hist\");\n\t\tif (anode)\n\t\t\ttrace_boot_init_histograms(file, anode, buf, ARRAY_SIZE(buf));\n\t} else if (xbc_node_find_value(enode, \"actions\", NULL))\n\t\tpr_err(\"Failed to apply event actions because CONFIG_HIST_TRIGGERS is not set.\\n\");\n\n\tif (xbc_node_find_value(enode, \"enable\", NULL)) {\n\t\tif (trace_event_enable_disable(file, 1, 0) < 0)\n\t\t\tpr_err(\"Failed to enable event node: %s:%s\\n\",\n\t\t\t\tgroup, event);\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data",
            "\"enable\""
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "enode"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_subkey",
          "args": [
            "gnode",
            "enode"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "gnode"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_subkey",
          "args": [
            "node",
            "gnode"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "node",
            "\"event\""
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_init_events(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *gnode, *enode;\n\tbool enable, enable_all = false;\n\tconst char *data;\n\n\tnode = xbc_node_find_subkey(node, \"event\");\n\tif (!node)\n\t\treturn;\n\t/* per-event key starts with \"event.GROUP.EVENT\" */\n\txbc_node_for_each_subkey(node, gnode) {\n\t\tdata = xbc_node_get_data(gnode);\n\t\tif (!strcmp(data, \"enable\")) {\n\t\t\tenable_all = true;\n\t\t\tcontinue;\n\t\t}\n\t\tenable = false;\n\t\txbc_node_for_each_subkey(gnode, enode) {\n\t\t\tdata = xbc_node_get_data(enode);\n\t\t\tif (!strcmp(data, \"enable\")) {\n\t\t\t\tenable = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrace_boot_init_one_event(tr, gnode, enode);\n\t\t}\n\t\t/* Event enablement must be done after event settings */\n\t\tif (enable) {\n\t\t\tdata = xbc_node_get_data(gnode);\n\t\t\ttrace_array_set_clr_event(tr, data, NULL, true);\n\t\t}\n\t}\n\t/* Ditto */\n\tif (enable_all)\n\t\ttrace_array_set_clr_event(tr, NULL, NULL, true);\n}"
  },
  {
    "function_name": "trace_boot_init_one_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "461-515",
    "snippet": "static void __init\ntrace_boot_init_one_event(struct trace_array *tr, struct xbc_node *gnode,\n\t\t\t  struct xbc_node *enode)\n{\n\tstruct trace_event_file *file;\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p, *group, *event;\n\n\tgroup = xbc_node_get_data(gnode);\n\tevent = xbc_node_get_data(enode);\n\n\tif (!strcmp(group, \"kprobes\"))\n\t\tif (trace_boot_add_kprobe_event(enode, event) < 0)\n\t\t\treturn;\n\tif (!strcmp(group, \"synthetic\"))\n\t\tif (trace_boot_add_synth_event(enode, event) < 0)\n\t\t\treturn;\n\n\tmutex_lock(&event_mutex);\n\tfile = find_event_file(tr, group, event);\n\tif (!file) {\n\t\tpr_err(\"Failed to find event: %s:%s\\n\", group, event);\n\t\tgoto out;\n\t}\n\n\tp = xbc_node_find_value(enode, \"filter\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf))\n\t\t\tpr_err(\"filter string is too long: %s\\n\", p);\n\t\telse if (apply_event_filter(file, buf) < 0)\n\t\t\tpr_err(\"Failed to apply filter: %s\\n\", buf);\n\t}\n\n\tif (IS_ENABLED(CONFIG_HIST_TRIGGERS)) {\n\t\txbc_node_for_each_array_value(enode, \"actions\", anode, p) {\n\t\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf))\n\t\t\t\tpr_err(\"action string is too long: %s\\n\", p);\n\t\t\telse if (trigger_process_regex(file, buf) < 0)\n\t\t\t\tpr_err(\"Failed to apply an action: %s\\n\", p);\n\t\t}\n\t\tanode = xbc_node_find_subkey(enode, \"hist\");\n\t\tif (anode)\n\t\t\ttrace_boot_init_histograms(file, anode, buf, ARRAY_SIZE(buf));\n\t} else if (xbc_node_find_value(enode, \"actions\", NULL))\n\t\tpr_err(\"Failed to apply event actions because CONFIG_HIST_TRIGGERS is not set.\\n\");\n\n\tif (xbc_node_find_value(enode, \"enable\", NULL)) {\n\t\tif (trace_event_enable_disable(file, 1, 0) < 0)\n\t\t\tpr_err(\"Failed to enable event node: %s:%s\\n\",\n\t\t\t\tgroup, event);\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [
      "#define MAX_BUF_LEN 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to enable event node: %s:%s\\n\"",
            "group",
            "event"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_enable_disable",
          "args": [
            "file",
            "1",
            "0"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "694-698",
          "snippet": "int trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nint trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "enode",
            "\"enable\"",
            "NULL"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to apply event actions because CONFIG_HIST_TRIGGERS is not set.\\n\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "enode",
            "\"actions\"",
            "NULL"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_boot_init_histograms",
          "args": [
            "file",
            "anode",
            "buf",
            "ARRAY_SIZE(buf)"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_init_histograms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "453-458",
          "snippet": "static void __init\ntrace_boot_init_histograms(struct trace_event_file *file,\n\t\t\t   struct xbc_node *hnode, char *buf, size_t size)\n{\n\t/* do nothing */\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_init_histograms(struct trace_event_file *file,\n\t\t\t   struct xbc_node *hnode, char *buf, size_t size)\n{\n\t/* do nothing */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "enode",
            "\"hist\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to apply an action: %s\\n\"",
            "p"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trigger_process_regex",
          "args": [
            "file",
            "buf"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_process_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "230-256",
          "snippet": "int trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tnext = buff = skip_spaces(buff);\n\tcommand = strsep(&next, \": \\t\");\n\tif (next) {\n\t\tnext = skip_spaces(next);\n\t\tif (!*next)\n\t\t\tnext = NULL;\n\t}\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->parse(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\nint trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tnext = buff = skip_spaces(buff);\n\tcommand = strsep(&next, \": \\t\");\n\tif (next) {\n\t\tnext = skip_spaces(next);\n\t\tif (!*next)\n\t\t\tnext = NULL;\n\t}\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->parse(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"action string is too long: %s\\n\"",
            "p"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "p",
            "ARRAY_SIZE(buf)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_array_value",
          "args": [
            "enode",
            "\"actions\"",
            "anode",
            "p"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HIST_TRIGGERS"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to apply filter: %s\\n\"",
            "buf"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_event_filter",
          "args": [
            "file",
            "buf"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "apply_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1897-1946",
          "snippet": "int apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(file->tr, call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nint apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(file->tr, call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"filter string is too long: %s\\n\"",
            "p"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "p",
            "ARRAY_SIZE(buf)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "enode",
            "\"filter\"",
            "NULL"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to find event: %s:%s\\n\"",
            "group",
            "event"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_event_file",
          "args": [
            "tr",
            "group",
            "event"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2943-2954",
          "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_boot_add_synth_event",
          "args": [
            "enode",
            "event"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_add_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "166-171",
          "snippet": "static inline int __init\ntrace_boot_add_synth_event(struct xbc_node *node, const char *event)\n{\n\tpr_err(\"Synthetic event is not supported.\\n\");\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic inline int __init\ntrace_boot_add_synth_event(struct xbc_node *node, const char *event)\n{\n\tpr_err(\"Synthetic event is not supported.\\n\");\n\treturn -ENOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "group",
            "\"synthetic\""
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_boot_add_kprobe_event",
          "args": [
            "enode",
            "event"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_add_kprobe_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "129-134",
          "snippet": "static inline int __init\ntrace_boot_add_kprobe_event(struct xbc_node *node, const char *event)\n{\n\tpr_err(\"Kprobe event is not supported.\\n\");\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic inline int __init\ntrace_boot_add_kprobe_event(struct xbc_node *node, const char *event)\n{\n\tpr_err(\"Kprobe event is not supported.\\n\");\n\treturn -ENOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "enode"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "gnode"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\n#define MAX_BUF_LEN 256\n\nstatic void __init\ntrace_boot_init_one_event(struct trace_array *tr, struct xbc_node *gnode,\n\t\t\t  struct xbc_node *enode)\n{\n\tstruct trace_event_file *file;\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p, *group, *event;\n\n\tgroup = xbc_node_get_data(gnode);\n\tevent = xbc_node_get_data(enode);\n\n\tif (!strcmp(group, \"kprobes\"))\n\t\tif (trace_boot_add_kprobe_event(enode, event) < 0)\n\t\t\treturn;\n\tif (!strcmp(group, \"synthetic\"))\n\t\tif (trace_boot_add_synth_event(enode, event) < 0)\n\t\t\treturn;\n\n\tmutex_lock(&event_mutex);\n\tfile = find_event_file(tr, group, event);\n\tif (!file) {\n\t\tpr_err(\"Failed to find event: %s:%s\\n\", group, event);\n\t\tgoto out;\n\t}\n\n\tp = xbc_node_find_value(enode, \"filter\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf))\n\t\t\tpr_err(\"filter string is too long: %s\\n\", p);\n\t\telse if (apply_event_filter(file, buf) < 0)\n\t\t\tpr_err(\"Failed to apply filter: %s\\n\", buf);\n\t}\n\n\tif (IS_ENABLED(CONFIG_HIST_TRIGGERS)) {\n\t\txbc_node_for_each_array_value(enode, \"actions\", anode, p) {\n\t\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf))\n\t\t\t\tpr_err(\"action string is too long: %s\\n\", p);\n\t\t\telse if (trigger_process_regex(file, buf) < 0)\n\t\t\t\tpr_err(\"Failed to apply an action: %s\\n\", p);\n\t\t}\n\t\tanode = xbc_node_find_subkey(enode, \"hist\");\n\t\tif (anode)\n\t\t\ttrace_boot_init_histograms(file, anode, buf, ARRAY_SIZE(buf));\n\t} else if (xbc_node_find_value(enode, \"actions\", NULL))\n\t\tpr_err(\"Failed to apply event actions because CONFIG_HIST_TRIGGERS is not set.\\n\");\n\n\tif (xbc_node_find_value(enode, \"enable\", NULL)) {\n\t\tif (trace_event_enable_disable(file, 1, 0) < 0)\n\t\t\tpr_err(\"Failed to enable event node: %s:%s\\n\",\n\t\t\t\tgroup, event);\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "trace_boot_init_histograms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "453-458",
    "snippet": "static void __init\ntrace_boot_init_histograms(struct trace_event_file *file,\n\t\t\t   struct xbc_node *hnode, char *buf, size_t size)\n{\n\t/* do nothing */\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_init_histograms(struct trace_event_file *file,\n\t\t\t   struct xbc_node *hnode, char *buf, size_t size)\n{\n\t/* do nothing */\n}"
  },
  {
    "function_name": "trace_boot_init_histograms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "418-451",
    "snippet": "static void __init\ntrace_boot_init_histograms(struct trace_event_file *file,\n\t\t\t   struct xbc_node *hnode, char *buf, size_t size)\n{\n\tstruct xbc_node *node;\n\tconst char *p;\n\tchar *tmp;\n\n\txbc_node_for_each_subkey(hnode, node) {\n\t\tp = xbc_node_get_data(node);\n\t\tif (!isdigit(p[0]))\n\t\t\tcontinue;\n\t\t/* All digit started node should be instances. */\n\t\tif (trace_boot_compose_hist_cmd(node, buf, size) == 0) {\n\t\t\ttmp = kstrdup(buf, GFP_KERNEL);\n\t\t\tif (!tmp)\n\t\t\t\treturn;\n\t\t\tif (trigger_process_regex(file, buf) < 0)\n\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);\n\t\t\tkfree(tmp);\n\t\t}\n\t}\n\n\tif (xbc_node_find_subkey(hnode, \"keys\")) {\n\t\tif (trace_boot_compose_hist_cmd(hnode, buf, size) == 0) {\n\t\t\ttmp = kstrdup(buf, GFP_KERNEL);\n\t\t\tif (!tmp)\n\t\t\t\treturn;\n\t\t\tif (trigger_process_regex(file, buf) < 0)\n\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);\n\t\t\tkfree(tmp);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to apply hist trigger: %s\\n\"",
            "tmp"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trigger_process_regex",
          "args": [
            "file",
            "buf"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_process_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "230-256",
          "snippet": "int trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tnext = buff = skip_spaces(buff);\n\tcommand = strsep(&next, \": \\t\");\n\tif (next) {\n\t\tnext = skip_spaces(next);\n\t\tif (!*next)\n\t\t\tnext = NULL;\n\t}\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->parse(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\nint trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tnext = buff = skip_spaces(buff);\n\tcommand = strsep(&next, \": \\t\");\n\tif (next) {\n\t\tnext = skip_spaces(next);\n\t\tif (!*next)\n\t\t\tnext = NULL;\n\t}\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->parse(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "buf",
            "GFP_KERNEL"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_boot_compose_hist_cmd",
          "args": [
            "hnode",
            "buf",
            "size"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_compose_hist_cmd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "345-416",
          "snippet": "static int __init\ntrace_boot_compose_hist_cmd(struct xbc_node *hnode, char *buf, size_t size)\n{\n\tstruct xbc_node *node, *knode;\n\tchar *end = buf + size;\n\tconst char *p;\n\tint ret = 0;\n\n\tappend_printf(&buf, end, \"hist\");\n\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"keys\");\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tpr_err(\"hist requires keys.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"values\");\n\tif (ret == -EINVAL)\n\t\treturn ret;\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"sort\");\n\tif (ret == -EINVAL)\n\t\treturn ret;\n\n\tp = xbc_node_find_value(hnode, \"size\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \":size=%s\", p);\n\n\tp = xbc_node_find_value(hnode, \"name\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \":name=%s\", p);\n\n\tnode = xbc_node_find_subkey(hnode, \"var\");\n\tif (node) {\n\t\txbc_node_for_each_key_value(node, knode, p) {\n\t\t\t/* Expression must not include spaces. */\n\t\t\tappend_printf(&buf, end, \":%s=\",\n\t\t\t\t      xbc_node_get_data(knode));\n\t\t\tappend_str_nospace(&buf, end, p);\n\t\t}\n\t}\n\n\t/* Histogram control attributes (mutual exclusive) */\n\tif (xbc_node_find_value(hnode, \"pause\", NULL))\n\t\tappend_printf(&buf, end, \":pause\");\n\telse if (xbc_node_find_value(hnode, \"continue\", NULL))\n\t\tappend_printf(&buf, end, \":continue\");\n\telse if (xbc_node_find_value(hnode, \"clear\", NULL))\n\t\tappend_printf(&buf, end, \":clear\");\n\n\t/* Histogram handler and actions */\n\tnode = xbc_node_find_subkey(hnode, \"onmax\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)\n\t\treturn -EINVAL;\n\tnode = xbc_node_find_subkey(hnode, \"onchange\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)\n\t\treturn -EINVAL;\n\tnode = xbc_node_find_subkey(hnode, \"onmatch\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"event\") < 0)\n\t\treturn -EINVAL;\n\n\tp = xbc_node_find_value(hnode, \"filter\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \" if %s\", p);\n\n\tif (buf == end) {\n\t\tpr_err(\"hist exceeds the max command length.\\n\");\n\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic int __init\ntrace_boot_compose_hist_cmd(struct xbc_node *hnode, char *buf, size_t size)\n{\n\tstruct xbc_node *node, *knode;\n\tchar *end = buf + size;\n\tconst char *p;\n\tint ret = 0;\n\n\tappend_printf(&buf, end, \"hist\");\n\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"keys\");\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tpr_err(\"hist requires keys.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"values\");\n\tif (ret == -EINVAL)\n\t\treturn ret;\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"sort\");\n\tif (ret == -EINVAL)\n\t\treturn ret;\n\n\tp = xbc_node_find_value(hnode, \"size\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \":size=%s\", p);\n\n\tp = xbc_node_find_value(hnode, \"name\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \":name=%s\", p);\n\n\tnode = xbc_node_find_subkey(hnode, \"var\");\n\tif (node) {\n\t\txbc_node_for_each_key_value(node, knode, p) {\n\t\t\t/* Expression must not include spaces. */\n\t\t\tappend_printf(&buf, end, \":%s=\",\n\t\t\t\t      xbc_node_get_data(knode));\n\t\t\tappend_str_nospace(&buf, end, p);\n\t\t}\n\t}\n\n\t/* Histogram control attributes (mutual exclusive) */\n\tif (xbc_node_find_value(hnode, \"pause\", NULL))\n\t\tappend_printf(&buf, end, \":pause\");\n\telse if (xbc_node_find_value(hnode, \"continue\", NULL))\n\t\tappend_printf(&buf, end, \":continue\");\n\telse if (xbc_node_find_value(hnode, \"clear\", NULL))\n\t\tappend_printf(&buf, end, \":clear\");\n\n\t/* Histogram handler and actions */\n\tnode = xbc_node_find_subkey(hnode, \"onmax\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)\n\t\treturn -EINVAL;\n\tnode = xbc_node_find_subkey(hnode, \"onchange\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)\n\t\treturn -EINVAL;\n\tnode = xbc_node_find_subkey(hnode, \"onmatch\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"event\") < 0)\n\t\treturn -EINVAL;\n\n\tp = xbc_node_find_value(hnode, \"filter\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \" if %s\", p);\n\n\tif (buf == end) {\n\t\tpr_err(\"hist exceeds the max command length.\\n\");\n\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "hnode",
            "\"keys\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to apply hist trigger: %s\\n\"",
            "tmp"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "buf",
            "GFP_KERNEL"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "p[0]"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "node"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_subkey",
          "args": [
            "hnode",
            "node"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic void __init\ntrace_boot_init_histograms(struct trace_event_file *file,\n\t\t\t   struct xbc_node *hnode, char *buf, size_t size)\n{\n\tstruct xbc_node *node;\n\tconst char *p;\n\tchar *tmp;\n\n\txbc_node_for_each_subkey(hnode, node) {\n\t\tp = xbc_node_get_data(node);\n\t\tif (!isdigit(p[0]))\n\t\t\tcontinue;\n\t\t/* All digit started node should be instances. */\n\t\tif (trace_boot_compose_hist_cmd(node, buf, size) == 0) {\n\t\t\ttmp = kstrdup(buf, GFP_KERNEL);\n\t\t\tif (!tmp)\n\t\t\t\treturn;\n\t\t\tif (trigger_process_regex(file, buf) < 0)\n\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);\n\t\t\tkfree(tmp);\n\t\t}\n\t}\n\n\tif (xbc_node_find_subkey(hnode, \"keys\")) {\n\t\tif (trace_boot_compose_hist_cmd(hnode, buf, size) == 0) {\n\t\t\ttmp = kstrdup(buf, GFP_KERNEL);\n\t\t\tif (!tmp)\n\t\t\t\treturn;\n\t\t\tif (trigger_process_regex(file, buf) < 0)\n\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);\n\t\t\tkfree(tmp);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "trace_boot_compose_hist_cmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "345-416",
    "snippet": "static int __init\ntrace_boot_compose_hist_cmd(struct xbc_node *hnode, char *buf, size_t size)\n{\n\tstruct xbc_node *node, *knode;\n\tchar *end = buf + size;\n\tconst char *p;\n\tint ret = 0;\n\n\tappend_printf(&buf, end, \"hist\");\n\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"keys\");\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tpr_err(\"hist requires keys.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"values\");\n\tif (ret == -EINVAL)\n\t\treturn ret;\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"sort\");\n\tif (ret == -EINVAL)\n\t\treturn ret;\n\n\tp = xbc_node_find_value(hnode, \"size\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \":size=%s\", p);\n\n\tp = xbc_node_find_value(hnode, \"name\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \":name=%s\", p);\n\n\tnode = xbc_node_find_subkey(hnode, \"var\");\n\tif (node) {\n\t\txbc_node_for_each_key_value(node, knode, p) {\n\t\t\t/* Expression must not include spaces. */\n\t\t\tappend_printf(&buf, end, \":%s=\",\n\t\t\t\t      xbc_node_get_data(knode));\n\t\t\tappend_str_nospace(&buf, end, p);\n\t\t}\n\t}\n\n\t/* Histogram control attributes (mutual exclusive) */\n\tif (xbc_node_find_value(hnode, \"pause\", NULL))\n\t\tappend_printf(&buf, end, \":pause\");\n\telse if (xbc_node_find_value(hnode, \"continue\", NULL))\n\t\tappend_printf(&buf, end, \":continue\");\n\telse if (xbc_node_find_value(hnode, \"clear\", NULL))\n\t\tappend_printf(&buf, end, \":clear\");\n\n\t/* Histogram handler and actions */\n\tnode = xbc_node_find_subkey(hnode, \"onmax\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)\n\t\treturn -EINVAL;\n\tnode = xbc_node_find_subkey(hnode, \"onchange\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)\n\t\treturn -EINVAL;\n\tnode = xbc_node_find_subkey(hnode, \"onmatch\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"event\") < 0)\n\t\treturn -EINVAL;\n\n\tp = xbc_node_find_value(hnode, \"filter\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \" if %s\", p);\n\n\tif (buf == end) {\n\t\tpr_err(\"hist exceeds the max command length.\\n\");\n\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"hist exceeds the max command length.\\n\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "&buf",
            "end",
            "\" if %s\"",
            "p"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "hnode",
            "\"filter\"",
            "NULL"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_boot_hist_add_handlers",
          "args": [
            "node",
            "&buf",
            "end",
            "\"event\""
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_hist_add_handlers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "297-321",
          "snippet": "static int __init\ntrace_boot_hist_add_handlers(struct xbc_node *hnode, char **bufp,\n\t\t\t     char *end, const char *param)\n{\n\tstruct xbc_node *node;\n\tconst char *p, *handler;\n\tint ret;\n\n\thandler = xbc_node_get_data(hnode);\n\n\txbc_node_for_each_subkey(hnode, node) {\n\t\tp = xbc_node_get_data(node);\n\t\tif (!isdigit(p[0]))\n\t\t\tcontinue;\n\t\t/* All digit started node should be instances. */\n\t\tret = trace_boot_hist_add_one_handler(node, bufp, end, handler, param);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (xbc_node_find_subkey(hnode, param))\n\t\tret = trace_boot_hist_add_one_handler(hnode, bufp, end, handler, param);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic int __init\ntrace_boot_hist_add_handlers(struct xbc_node *hnode, char **bufp,\n\t\t\t     char *end, const char *param)\n{\n\tstruct xbc_node *node;\n\tconst char *p, *handler;\n\tint ret;\n\n\thandler = xbc_node_get_data(hnode);\n\n\txbc_node_for_each_subkey(hnode, node) {\n\t\tp = xbc_node_get_data(node);\n\t\tif (!isdigit(p[0]))\n\t\t\tcontinue;\n\t\t/* All digit started node should be instances. */\n\t\tret = trace_boot_hist_add_one_handler(node, bufp, end, handler, param);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (xbc_node_find_subkey(hnode, param))\n\t\tret = trace_boot_hist_add_one_handler(hnode, bufp, end, handler, param);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "hnode",
            "\"onmatch\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "hnode",
            "\"onchange\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "hnode",
            "\"onmax\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "&buf",
            "end",
            "\":clear\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "hnode",
            "\"clear\"",
            "NULL"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "&buf",
            "end",
            "\":continue\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "hnode",
            "\"continue\"",
            "NULL"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "&buf",
            "end",
            "\":pause\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "hnode",
            "\"pause\"",
            "NULL"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_str_nospace",
          "args": [
            "&buf",
            "end",
            "p"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "&buf",
            "end",
            "\":%s=\"",
            "xbc_node_get_data(knode)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "knode"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_key_value",
          "args": [
            "node",
            "knode",
            "p"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "hnode",
            "\"var\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "&buf",
            "end",
            "\":name=%s\"",
            "p"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "hnode",
            "\"name\"",
            "NULL"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "&buf",
            "end",
            "\":size=%s\"",
            "p"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "hnode",
            "\"size\"",
            "NULL"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_boot_hist_add_array",
          "args": [
            "hnode",
            "&buf",
            "end",
            "\"sort\""
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_hist_add_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "218-244",
          "snippet": "static int __init\ntrace_boot_hist_add_array(struct xbc_node *hnode, char **bufp,\n\t\t\t  char *end, const char *key)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar sep;\n\n\tp = xbc_node_find_value(hnode, key, &anode);\n\tif (p) {\n\t\tif (!anode) {\n\t\t\tpr_err(\"hist.%s requires value(s).\\n\", key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tappend_printf(bufp, end, \":%s\", key);\n\t\tsep = '=';\n\t\txbc_array_for_each_value(anode, p) {\n\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);\n\t\t\tif (sep == '=')\n\t\t\t\tsep = ',';\n\t\t}\n\t} else\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic int __init\ntrace_boot_hist_add_array(struct xbc_node *hnode, char **bufp,\n\t\t\t  char *end, const char *key)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar sep;\n\n\tp = xbc_node_find_value(hnode, key, &anode);\n\tif (p) {\n\t\tif (!anode) {\n\t\t\tpr_err(\"hist.%s requires value(s).\\n\", key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tappend_printf(bufp, end, \":%s\", key);\n\t\tsep = '=';\n\t\txbc_array_for_each_value(anode, p) {\n\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);\n\t\t\tif (sep == '=')\n\t\t\t\tsep = ',';\n\t\t}\n\t} else\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"hist requires keys.\\n\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "&buf",
            "end",
            "\"hist\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic int __init\ntrace_boot_compose_hist_cmd(struct xbc_node *hnode, char *buf, size_t size)\n{\n\tstruct xbc_node *node, *knode;\n\tchar *end = buf + size;\n\tconst char *p;\n\tint ret = 0;\n\n\tappend_printf(&buf, end, \"hist\");\n\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"keys\");\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tpr_err(\"hist requires keys.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"values\");\n\tif (ret == -EINVAL)\n\t\treturn ret;\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"sort\");\n\tif (ret == -EINVAL)\n\t\treturn ret;\n\n\tp = xbc_node_find_value(hnode, \"size\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \":size=%s\", p);\n\n\tp = xbc_node_find_value(hnode, \"name\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \":name=%s\", p);\n\n\tnode = xbc_node_find_subkey(hnode, \"var\");\n\tif (node) {\n\t\txbc_node_for_each_key_value(node, knode, p) {\n\t\t\t/* Expression must not include spaces. */\n\t\t\tappend_printf(&buf, end, \":%s=\",\n\t\t\t\t      xbc_node_get_data(knode));\n\t\t\tappend_str_nospace(&buf, end, p);\n\t\t}\n\t}\n\n\t/* Histogram control attributes (mutual exclusive) */\n\tif (xbc_node_find_value(hnode, \"pause\", NULL))\n\t\tappend_printf(&buf, end, \":pause\");\n\telse if (xbc_node_find_value(hnode, \"continue\", NULL))\n\t\tappend_printf(&buf, end, \":continue\");\n\telse if (xbc_node_find_value(hnode, \"clear\", NULL))\n\t\tappend_printf(&buf, end, \":clear\");\n\n\t/* Histogram handler and actions */\n\tnode = xbc_node_find_subkey(hnode, \"onmax\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)\n\t\treturn -EINVAL;\n\tnode = xbc_node_find_subkey(hnode, \"onchange\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)\n\t\treturn -EINVAL;\n\tnode = xbc_node_find_subkey(hnode, \"onmatch\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"event\") < 0)\n\t\treturn -EINVAL;\n\n\tp = xbc_node_find_value(hnode, \"filter\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \" if %s\", p);\n\n\tif (buf == end) {\n\t\tpr_err(\"hist exceeds the max command length.\\n\");\n\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_boot_hist_add_handlers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "297-321",
    "snippet": "static int __init\ntrace_boot_hist_add_handlers(struct xbc_node *hnode, char **bufp,\n\t\t\t     char *end, const char *param)\n{\n\tstruct xbc_node *node;\n\tconst char *p, *handler;\n\tint ret;\n\n\thandler = xbc_node_get_data(hnode);\n\n\txbc_node_for_each_subkey(hnode, node) {\n\t\tp = xbc_node_get_data(node);\n\t\tif (!isdigit(p[0]))\n\t\t\tcontinue;\n\t\t/* All digit started node should be instances. */\n\t\tret = trace_boot_hist_add_one_handler(node, bufp, end, handler, param);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (xbc_node_find_subkey(hnode, param))\n\t\tret = trace_boot_hist_add_one_handler(hnode, bufp, end, handler, param);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_boot_hist_add_one_handler",
          "args": [
            "hnode",
            "bufp",
            "end",
            "handler",
            "param"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "trace_boot_hist_add_one_handler",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
          "lines": "246-295",
          "snippet": "static int __init\ntrace_boot_hist_add_one_handler(struct xbc_node *hnode, char **bufp,\n\t\t\t\tchar *end, const char *handler,\n\t\t\t\tconst char *param)\n{\n\tstruct xbc_node *knode, *anode;\n\tconst char *p;\n\tchar sep;\n\n\t/* Compose 'handler' parameter */\n\tp = xbc_node_find_value(hnode, param, NULL);\n\tif (!p) {\n\t\tpr_err(\"hist.%s requires '%s' option.\\n\",\n\t\t       xbc_node_get_data(hnode), param);\n\t\treturn -EINVAL;\n\t}\n\tappend_printf(bufp, end, \":%s(%s)\", handler, p);\n\n\t/* Compose 'action' parameter */\n\tknode = xbc_node_find_subkey(hnode, \"trace\");\n\tif (!knode)\n\t\tknode = xbc_node_find_subkey(hnode, \"save\");\n\n\tif (knode) {\n\t\tanode = xbc_node_get_child(knode);\n\t\tif (!anode || !xbc_node_is_value(anode)) {\n\t\t\tpr_err(\"hist.%s.%s requires value(s).\\n\",\n\t\t\t       xbc_node_get_data(hnode),\n\t\t\t       xbc_node_get_data(knode));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tappend_printf(bufp, end, \".%s\", xbc_node_get_data(knode));\n\t\tsep = '(';\n\t\txbc_array_for_each_value(anode, p) {\n\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);\n\t\t\tif (sep == '(')\n\t\t\t\tsep = ',';\n\t\t}\n\t\tappend_printf(bufp, end, \")\");\n\t} else if (xbc_node_find_subkey(hnode, \"snapshot\")) {\n\t\tappend_printf(bufp, end, \".snapshot()\");\n\t} else {\n\t\tpr_err(\"hist.%s requires an action.\\n\",\n\t\t       xbc_node_get_data(hnode));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/trace_events.h>",
            "#include <linux/trace.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bootconfig.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic int __init\ntrace_boot_hist_add_one_handler(struct xbc_node *hnode, char **bufp,\n\t\t\t\tchar *end, const char *handler,\n\t\t\t\tconst char *param)\n{\n\tstruct xbc_node *knode, *anode;\n\tconst char *p;\n\tchar sep;\n\n\t/* Compose 'handler' parameter */\n\tp = xbc_node_find_value(hnode, param, NULL);\n\tif (!p) {\n\t\tpr_err(\"hist.%s requires '%s' option.\\n\",\n\t\t       xbc_node_get_data(hnode), param);\n\t\treturn -EINVAL;\n\t}\n\tappend_printf(bufp, end, \":%s(%s)\", handler, p);\n\n\t/* Compose 'action' parameter */\n\tknode = xbc_node_find_subkey(hnode, \"trace\");\n\tif (!knode)\n\t\tknode = xbc_node_find_subkey(hnode, \"save\");\n\n\tif (knode) {\n\t\tanode = xbc_node_get_child(knode);\n\t\tif (!anode || !xbc_node_is_value(anode)) {\n\t\t\tpr_err(\"hist.%s.%s requires value(s).\\n\",\n\t\t\t       xbc_node_get_data(hnode),\n\t\t\t       xbc_node_get_data(knode));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tappend_printf(bufp, end, \".%s\", xbc_node_get_data(knode));\n\t\tsep = '(';\n\t\txbc_array_for_each_value(anode, p) {\n\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);\n\t\t\tif (sep == '(')\n\t\t\t\tsep = ',';\n\t\t}\n\t\tappend_printf(bufp, end, \")\");\n\t} else if (xbc_node_find_subkey(hnode, \"snapshot\")) {\n\t\tappend_printf(bufp, end, \".snapshot()\");\n\t} else {\n\t\tpr_err(\"hist.%s requires an action.\\n\",\n\t\t       xbc_node_get_data(hnode));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "hnode",
            "param"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "p[0]"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "node"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_subkey",
          "args": [
            "hnode",
            "node"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "hnode"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic int __init\ntrace_boot_hist_add_handlers(struct xbc_node *hnode, char **bufp,\n\t\t\t     char *end, const char *param)\n{\n\tstruct xbc_node *node;\n\tconst char *p, *handler;\n\tint ret;\n\n\thandler = xbc_node_get_data(hnode);\n\n\txbc_node_for_each_subkey(hnode, node) {\n\t\tp = xbc_node_get_data(node);\n\t\tif (!isdigit(p[0]))\n\t\t\tcontinue;\n\t\t/* All digit started node should be instances. */\n\t\tret = trace_boot_hist_add_one_handler(node, bufp, end, handler, param);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (xbc_node_find_subkey(hnode, param))\n\t\tret = trace_boot_hist_add_one_handler(hnode, bufp, end, handler, param);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_boot_hist_add_one_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "246-295",
    "snippet": "static int __init\ntrace_boot_hist_add_one_handler(struct xbc_node *hnode, char **bufp,\n\t\t\t\tchar *end, const char *handler,\n\t\t\t\tconst char *param)\n{\n\tstruct xbc_node *knode, *anode;\n\tconst char *p;\n\tchar sep;\n\n\t/* Compose 'handler' parameter */\n\tp = xbc_node_find_value(hnode, param, NULL);\n\tif (!p) {\n\t\tpr_err(\"hist.%s requires '%s' option.\\n\",\n\t\t       xbc_node_get_data(hnode), param);\n\t\treturn -EINVAL;\n\t}\n\tappend_printf(bufp, end, \":%s(%s)\", handler, p);\n\n\t/* Compose 'action' parameter */\n\tknode = xbc_node_find_subkey(hnode, \"trace\");\n\tif (!knode)\n\t\tknode = xbc_node_find_subkey(hnode, \"save\");\n\n\tif (knode) {\n\t\tanode = xbc_node_get_child(knode);\n\t\tif (!anode || !xbc_node_is_value(anode)) {\n\t\t\tpr_err(\"hist.%s.%s requires value(s).\\n\",\n\t\t\t       xbc_node_get_data(hnode),\n\t\t\t       xbc_node_get_data(knode));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tappend_printf(bufp, end, \".%s\", xbc_node_get_data(knode));\n\t\tsep = '(';\n\t\txbc_array_for_each_value(anode, p) {\n\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);\n\t\t\tif (sep == '(')\n\t\t\t\tsep = ',';\n\t\t}\n\t\tappend_printf(bufp, end, \")\");\n\t} else if (xbc_node_find_subkey(hnode, \"snapshot\")) {\n\t\tappend_printf(bufp, end, \".snapshot()\");\n\t} else {\n\t\tpr_err(\"hist.%s requires an action.\\n\",\n\t\t       xbc_node_get_data(hnode));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"hist.%s requires an action.\\n\"",
            "xbc_node_get_data(hnode)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "hnode"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "bufp",
            "end",
            "\".snapshot()\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "hnode",
            "\"snapshot\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "bufp",
            "end",
            "\")\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "bufp",
            "end",
            "\"%c%s\"",
            "sep",
            "p"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_array_for_each_value",
          "args": [
            "anode",
            "p"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "bufp",
            "end",
            "\".%s\"",
            "xbc_node_get_data(knode)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "knode"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"hist.%s.%s requires value(s).\\n\"",
            "xbc_node_get_data(hnode)",
            "xbc_node_get_data(knode)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "knode"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "hnode"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_is_value",
          "args": [
            "anode"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_child",
          "args": [
            "knode"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "hnode",
            "\"save\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_subkey",
          "args": [
            "hnode",
            "\"trace\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "bufp",
            "end",
            "\":%s(%s)\"",
            "handler",
            "p"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"hist.%s requires '%s' option.\\n\"",
            "xbc_node_get_data(hnode)",
            "param"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_get_data",
          "args": [
            "hnode"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "hnode",
            "param",
            "NULL"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic int __init\ntrace_boot_hist_add_one_handler(struct xbc_node *hnode, char **bufp,\n\t\t\t\tchar *end, const char *handler,\n\t\t\t\tconst char *param)\n{\n\tstruct xbc_node *knode, *anode;\n\tconst char *p;\n\tchar sep;\n\n\t/* Compose 'handler' parameter */\n\tp = xbc_node_find_value(hnode, param, NULL);\n\tif (!p) {\n\t\tpr_err(\"hist.%s requires '%s' option.\\n\",\n\t\t       xbc_node_get_data(hnode), param);\n\t\treturn -EINVAL;\n\t}\n\tappend_printf(bufp, end, \":%s(%s)\", handler, p);\n\n\t/* Compose 'action' parameter */\n\tknode = xbc_node_find_subkey(hnode, \"trace\");\n\tif (!knode)\n\t\tknode = xbc_node_find_subkey(hnode, \"save\");\n\n\tif (knode) {\n\t\tanode = xbc_node_get_child(knode);\n\t\tif (!anode || !xbc_node_is_value(anode)) {\n\t\t\tpr_err(\"hist.%s.%s requires value(s).\\n\",\n\t\t\t       xbc_node_get_data(hnode),\n\t\t\t       xbc_node_get_data(knode));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tappend_printf(bufp, end, \".%s\", xbc_node_get_data(knode));\n\t\tsep = '(';\n\t\txbc_array_for_each_value(anode, p) {\n\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);\n\t\t\tif (sep == '(')\n\t\t\t\tsep = ',';\n\t\t}\n\t\tappend_printf(bufp, end, \")\");\n\t} else if (xbc_node_find_subkey(hnode, \"snapshot\")) {\n\t\tappend_printf(bufp, end, \".snapshot()\");\n\t} else {\n\t\tpr_err(\"hist.%s requires an action.\\n\",\n\t\t       xbc_node_get_data(hnode));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_boot_hist_add_array",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "218-244",
    "snippet": "static int __init\ntrace_boot_hist_add_array(struct xbc_node *hnode, char **bufp,\n\t\t\t  char *end, const char *key)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar sep;\n\n\tp = xbc_node_find_value(hnode, key, &anode);\n\tif (p) {\n\t\tif (!anode) {\n\t\t\tpr_err(\"hist.%s requires value(s).\\n\", key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tappend_printf(bufp, end, \":%s\", key);\n\t\tsep = '=';\n\t\txbc_array_for_each_value(anode, p) {\n\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);\n\t\t\tif (sep == '=')\n\t\t\t\tsep = ',';\n\t\t}\n\t} else\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "bufp",
            "end",
            "\"%c%s\"",
            "sep",
            "p"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_array_for_each_value",
          "args": [
            "anode",
            "p"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_printf",
          "args": [
            "bufp",
            "end",
            "\":%s\"",
            "key"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"hist.%s requires value(s).\\n\"",
            "key"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "hnode",
            "key",
            "&anode"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic int __init\ntrace_boot_hist_add_array(struct xbc_node *hnode, char **bufp,\n\t\t\t  char *end, const char *key)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar sep;\n\n\tp = xbc_node_find_value(hnode, key, &anode);\n\tif (p) {\n\t\tif (!anode) {\n\t\t\tpr_err(\"hist.%s requires value(s).\\n\", key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tappend_printf(bufp, end, \":%s\", key);\n\t\tsep = '=';\n\t\txbc_array_for_each_value(anode, p) {\n\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);\n\t\t\tif (sep == '=')\n\t\t\t\tsep = ',';\n\t\t}\n\t} else\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_boot_add_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "166-171",
    "snippet": "static inline int __init\ntrace_boot_add_synth_event(struct xbc_node *node, const char *event)\n{\n\tpr_err(\"Synthetic event is not supported.\\n\");\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Synthetic event is not supported.\\n\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic inline int __init\ntrace_boot_add_synth_event(struct xbc_node *node, const char *event)\n{\n\tpr_err(\"Synthetic event is not supported.\\n\");\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "trace_boot_add_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "138-164",
    "snippet": "static int __init\ntrace_boot_add_synth_event(struct xbc_node *node, const char *event)\n{\n\tstruct dynevent_cmd cmd;\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p;\n\tint ret;\n\n\tsynth_event_cmd_init(&cmd, buf, MAX_BUF_LEN);\n\n\tret = synth_event_gen_cmd_start(&cmd, event, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\txbc_node_for_each_array_value(node, \"fields\", anode, p) {\n\t\tret = synth_event_add_field_str(&cmd, p);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = synth_event_gen_cmd_end(&cmd);\n\tif (ret < 0)\n\t\tpr_err(\"Failed to add synthetic event: %s\\n\", buf);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [
      "#define MAX_BUF_LEN 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to add synthetic event: %s\\n\"",
            "buf"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_event_gen_cmd_end",
          "args": [
            "&cmd"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_event_add_field_str",
          "args": [
            "&cmd",
            "p"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_add_field_str",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "980-1003",
          "snippet": "int synth_event_add_field_str(struct dynevent_cmd *cmd, const char *type_name)\n{\n\tstruct dynevent_arg arg;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (!type_name)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, ';');\n\n\targ.str = type_name;\n\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (++cmd->n_fields > SYNTH_FIELDS_MAX)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_field_str(struct dynevent_cmd *cmd, const char *type_name)\n{\n\tstruct dynevent_arg arg;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (!type_name)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, ';');\n\n\targ.str = type_name;\n\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (++cmd->n_fields > SYNTH_FIELDS_MAX)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_array_value",
          "args": [
            "node",
            "\"fields\"",
            "anode",
            "p"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_event_gen_cmd_start",
          "args": [
            "&cmd",
            "event",
            "NULL"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_gen_cmd_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1073-1115",
          "snippet": "int __synth_event_gen_cmd_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\tstruct module *mod, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, mod);\n\tfor (;;) {\n\t\tconst char *type, *name;\n\n\t\ttype = va_arg(args, const char *);\n\t\tif (!type)\n\t\t\tbreak;\n\t\tname = va_arg(args, const char *);\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > SYNTH_FIELDS_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, type, name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint __synth_event_gen_cmd_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\tstruct module *mod, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, mod);\n\tfor (;;) {\n\t\tconst char *type, *name;\n\n\t\ttype = va_arg(args, const char *);\n\t\tif (!type)\n\t\t\tbreak;\n\t\tname = va_arg(args, const char *);\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > SYNTH_FIELDS_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, type, name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_cmd_init",
          "args": [
            "&cmd",
            "buf",
            "MAX_BUF_LEN"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_cmd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1531-1535",
          "snippet": "void synth_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_SYNTH,\n\t\t\t  synth_event_run_command);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nvoid synth_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_SYNTH,\n\t\t\t  synth_event_run_command);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\n#define MAX_BUF_LEN 256\n\nstatic int __init\ntrace_boot_add_synth_event(struct xbc_node *node, const char *event)\n{\n\tstruct dynevent_cmd cmd;\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p;\n\tint ret;\n\n\tsynth_event_cmd_init(&cmd, buf, MAX_BUF_LEN);\n\n\tret = synth_event_gen_cmd_start(&cmd, event, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\txbc_node_for_each_array_value(node, \"fields\", anode, p) {\n\t\tret = synth_event_add_field_str(&cmd, p);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = synth_event_gen_cmd_end(&cmd);\n\tif (ret < 0)\n\t\tpr_err(\"Failed to add synthetic event: %s\\n\", buf);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_boot_add_kprobe_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "129-134",
    "snippet": "static inline int __init\ntrace_boot_add_kprobe_event(struct xbc_node *node, const char *event)\n{\n\tpr_err(\"Kprobe event is not supported.\\n\");\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Kprobe event is not supported.\\n\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\nstatic inline int __init\ntrace_boot_add_kprobe_event(struct xbc_node *node, const char *event)\n{\n\tpr_err(\"Kprobe event is not supported.\\n\");\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "trace_boot_add_kprobe_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "101-127",
    "snippet": "static int __init\ntrace_boot_add_kprobe_event(struct xbc_node *node, const char *event)\n{\n\tstruct dynevent_cmd cmd;\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *val;\n\tint ret = 0;\n\n\txbc_node_for_each_array_value(node, \"probes\", anode, val) {\n\t\tkprobe_event_cmd_init(&cmd, buf, MAX_BUF_LEN);\n\n\t\tret = kprobe_event_gen_cmd_start(&cmd, event, val);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to generate probe: %s\\n\", buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = kprobe_event_gen_cmd_end(&cmd);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to add probe: %s\\n\", buf);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [
      "#define MAX_BUF_LEN 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to add probe: %s\\n\"",
            "buf"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_event_gen_cmd_end",
          "args": [
            "&cmd"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to generate probe: %s\\n\"",
            "buf"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_event_gen_cmd_start",
          "args": [
            "&cmd",
            "event",
            "val"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_event_cmd_init",
          "args": [
            "&cmd",
            "buf",
            "MAX_BUF_LEN"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_event_cmd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "930-934",
          "snippet": "void kprobe_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_KPROBE,\n\t\t\t  trace_kprobe_run_command);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nvoid kprobe_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_KPROBE,\n\t\t\t  trace_kprobe_run_command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_array_value",
          "args": [
            "node",
            "\"probes\"",
            "anode",
            "val"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\n#define MAX_BUF_LEN 256\n\nstatic int __init\ntrace_boot_add_kprobe_event(struct xbc_node *node, const char *event)\n{\n\tstruct dynevent_cmd cmd;\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *val;\n\tint ret = 0;\n\n\txbc_node_for_each_array_value(node, \"probes\", anode, val) {\n\t\tkprobe_event_cmd_init(&cmd, buf, MAX_BUF_LEN);\n\n\t\tret = kprobe_event_gen_cmd_start(&cmd, event, val);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to generate probe: %s\\n\", buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = kprobe_event_gen_cmd_end(&cmd);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to add probe: %s\\n\", buf);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_boot_enable_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "82-98",
    "snippet": "static void __init\ntrace_boot_enable_events(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p;\n\n\txbc_node_for_each_array_value(node, \"events\", anode, p) {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf)) {\n\t\t\tpr_err(\"String is too long: %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ftrace_set_clr_event(tr, buf, 1) < 0)\n\t\t\tpr_err(\"Failed to enable event: %s\\n\", p);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [
      "#define MAX_BUF_LEN 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to enable event: %s\\n\"",
            "p"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_clr_event",
          "args": [
            "tr",
            "buf",
            "1"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1047-1085",
          "snippet": "int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"String is too long: %s\\n\"",
            "p"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "p",
            "ARRAY_SIZE(buf)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_array_value",
          "args": [
            "node",
            "\"events\"",
            "anode",
            "p"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\n#define MAX_BUF_LEN 256\n\nstatic void __init\ntrace_boot_enable_events(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p;\n\n\txbc_node_for_each_array_value(node, \"events\", anode, p) {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf)) {\n\t\t\tpr_err(\"String is too long: %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ftrace_set_clr_event(tr, buf, 1) < 0)\n\t\t\tpr_err(\"Failed to enable event: %s\\n\", p);\n\t}\n}"
  },
  {
    "function_name": "trace_boot_set_instance_options",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_boot.c",
    "lines": "24-79",
    "snippet": "static void __init\ntrace_boot_set_instance_options(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar buf[MAX_BUF_LEN];\n\tunsigned long v = 0;\n\n\t/* Common ftrace options */\n\txbc_node_for_each_array_value(node, \"options\", anode, p) {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf)) {\n\t\t\tpr_err(\"String is too long: %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (trace_set_options(tr, buf) < 0)\n\t\t\tpr_err(\"Failed to set option: %s\\n\", buf);\n\t}\n\n\tp = xbc_node_find_value(node, \"tracing_on\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (kstrtoul(p, 10, &v))\n\t\t\tpr_err(\"Failed to set tracing on: %s\\n\", p);\n\t\tif (v)\n\t\t\ttracer_tracing_on(tr);\n\t\telse\n\t\t\ttracer_tracing_off(tr);\n\t}\n\n\tp = xbc_node_find_value(node, \"trace_clock\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (tracing_set_clock(tr, p) < 0)\n\t\t\tpr_err(\"Failed to set trace clock: %s\\n\", p);\n\t}\n\n\tp = xbc_node_find_value(node, \"buffer_size\", NULL);\n\tif (p && *p != '\\0') {\n\t\tv = memparse(p, NULL);\n\t\tif (v < PAGE_SIZE)\n\t\t\tpr_err(\"Buffer size is too small: %s\\n\", p);\n\t\tif (tracing_resize_ring_buffer(tr, v, RING_BUFFER_ALL_CPUS) < 0)\n\t\t\tpr_err(\"Failed to resize trace buffer to %s\\n\", p);\n\t}\n\n\tp = xbc_node_find_value(node, \"cpumask\", NULL);\n\tif (p && *p != '\\0') {\n\t\tcpumask_var_t new_mask;\n\n\t\tif (alloc_cpumask_var(&new_mask, GFP_KERNEL)) {\n\t\t\tif (cpumask_parse(p, new_mask) < 0 ||\n\t\t\t    tracing_set_cpumask(tr, new_mask) < 0)\n\t\t\t\tpr_err(\"Failed to set new CPU mask %s\\n\", p);\n\t\t\tfree_cpumask_var(new_mask);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/trace_events.h>",
      "#include <linux/trace.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/bootconfig.h>"
    ],
    "macros_used": [
      "#define MAX_BUF_LEN 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "new_mask"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to set new CPU mask %s\\n\"",
            "p"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_set_cpumask",
          "args": [
            "tr",
            "new_mask"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_set_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "5122-5154",
          "snippet": "int tracing_set_cpumask(struct trace_array *tr,\n\t\t\tcpumask_var_t tracing_cpumask_new)\n{\n\tint cpu;\n\n\tif (!tr)\n\t\treturn -EINVAL;\n\n\tlocal_irq_disable();\n\tarch_spin_lock(&tr->max_lock);\n\tfor_each_tracing_cpu(cpu) {\n\t\t/*\n\t\t * Increase/decrease the disabled counter if we are\n\t\t * about to flip a bit in the cpumask:\n\t\t */\n\t\tif (cpumask_test_cpu(cpu, tr->tracing_cpumask) &&\n\t\t\t\t!cpumask_test_cpu(cpu, tracing_cpumask_new)) {\n\t\t\tatomic_inc(&per_cpu_ptr(tr->array_buffer.data, cpu)->disabled);\n\t\t\tring_buffer_record_disable_cpu(tr->array_buffer.buffer, cpu);\n\t\t}\n\t\tif (!cpumask_test_cpu(cpu, tr->tracing_cpumask) &&\n\t\t\t\tcpumask_test_cpu(cpu, tracing_cpumask_new)) {\n\t\t\tatomic_dec(&per_cpu_ptr(tr->array_buffer.data, cpu)->disabled);\n\t\t\tring_buffer_record_enable_cpu(tr->array_buffer.buffer, cpu);\n\t\t}\n\t}\n\tarch_spin_unlock(&tr->max_lock);\n\tlocal_irq_enable();\n\n\tcpumask_copy(tr->tracing_cpumask, tracing_cpumask_new);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_set_cpumask(struct trace_array *tr,\n\t\t\tcpumask_var_t tracing_cpumask_new)\n{\n\tint cpu;\n\n\tif (!tr)\n\t\treturn -EINVAL;\n\n\tlocal_irq_disable();\n\tarch_spin_lock(&tr->max_lock);\n\tfor_each_tracing_cpu(cpu) {\n\t\t/*\n\t\t * Increase/decrease the disabled counter if we are\n\t\t * about to flip a bit in the cpumask:\n\t\t */\n\t\tif (cpumask_test_cpu(cpu, tr->tracing_cpumask) &&\n\t\t\t\t!cpumask_test_cpu(cpu, tracing_cpumask_new)) {\n\t\t\tatomic_inc(&per_cpu_ptr(tr->array_buffer.data, cpu)->disabled);\n\t\t\tring_buffer_record_disable_cpu(tr->array_buffer.buffer, cpu);\n\t\t}\n\t\tif (!cpumask_test_cpu(cpu, tr->tracing_cpumask) &&\n\t\t\t\tcpumask_test_cpu(cpu, tracing_cpumask_new)) {\n\t\t\tatomic_dec(&per_cpu_ptr(tr->array_buffer.data, cpu)->disabled);\n\t\t\tring_buffer_record_enable_cpu(tr->array_buffer.buffer, cpu);\n\t\t}\n\t}\n\tarch_spin_unlock(&tr->max_lock);\n\tlocal_irq_enable();\n\n\tcpumask_copy(tr->tracing_cpumask, tracing_cpumask_new);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_parse",
          "args": [
            "p",
            "new_mask"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&new_mask",
            "GFP_KERNEL"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "node",
            "\"cpumask\"",
            "NULL"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to resize trace buffer to %s\\n\"",
            "p"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_resize_ring_buffer",
          "args": [
            "tr",
            "v",
            "RING_BUFFER_ALL_CPUS"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_resize_ring_buffer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6243-6266",
          "snippet": "ssize_t tracing_resize_ring_buffer(struct trace_array *tr,\n\t\t\t\t  unsigned long size, int cpu_id)\n{\n\tint ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (cpu_id != RING_BUFFER_ALL_CPUS) {\n\t\t/* make sure, this cpu is enabled in the mask */\n\t\tif (!cpumask_test_cpu(cpu_id, tracing_buffer_mask)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = __tracing_resize_ring_buffer(tr, size, cpu_id);\n\tif (ret < 0)\n\t\tret = -ENOMEM;\n\nout:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nssize_t tracing_resize_ring_buffer(struct trace_array *tr,\n\t\t\t\t  unsigned long size, int cpu_id)\n{\n\tint ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (cpu_id != RING_BUFFER_ALL_CPUS) {\n\t\t/* make sure, this cpu is enabled in the mask */\n\t\tif (!cpumask_test_cpu(cpu_id, tracing_buffer_mask)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = __tracing_resize_ring_buffer(tr, size, cpu_id);\n\tif (ret < 0)\n\t\tret = -ENOMEM;\n\nout:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Buffer size is too small: %s\\n\"",
            "p"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "p",
            "NULL"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "node",
            "\"buffer_size\"",
            "NULL"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to set trace clock: %s\\n\"",
            "p"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_set_clock",
          "args": [
            "tr",
            "p"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_set_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "7203-7235",
          "snippet": "int tracing_set_clock(struct trace_array *tr, const char *clockstr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(trace_clocks); i++) {\n\t\tif (strcmp(trace_clocks[i].name, clockstr) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(trace_clocks))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->clock_id = i;\n\n\tring_buffer_set_clock(tr->array_buffer.buffer, trace_clocks[i].func);\n\n\t/*\n\t * New clock may not be consistent with the previous clock.\n\t * Reset the buffer so that it doesn't have incomparable timestamps.\n\t */\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_clock(tr->max_buffer.buffer, trace_clocks[i].func);\n\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracing_set_clock(struct trace_array *tr, const char *clockstr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(trace_clocks); i++) {\n\t\tif (strcmp(trace_clocks[i].name, clockstr) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(trace_clocks))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->clock_id = i;\n\n\tring_buffer_set_clock(tr->array_buffer.buffer, trace_clocks[i].func);\n\n\t/*\n\t * New clock may not be consistent with the previous clock.\n\t * Reset the buffer so that it doesn't have incomparable timestamps.\n\t */\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_clock(tr->max_buffer.buffer, trace_clocks[i].func);\n\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "node",
            "\"trace_clock\"",
            "NULL"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_tracing_off",
          "args": [
            "tr"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1404-1419",
          "snippet": "void tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_off(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_off(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_tracing_on",
          "args": [
            "tr"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_tracing_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "942-957",
          "snippet": "void tracer_tracing_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_on(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 0;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid tracer_tracing_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_on(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 0;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to set tracing on: %s\\n\"",
            "p"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "p",
            "10",
            "&v"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_find_value",
          "args": [
            "node",
            "\"tracing_on\"",
            "NULL"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to set option: %s\\n\"",
            "buf"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_set_options",
          "args": [
            "tr",
            "buf"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "trace_set_options",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "5335-5372",
          "snippet": "int trace_set_options(struct trace_array *tr, char *option)\n{\n\tchar *cmp;\n\tint neg = 0;\n\tint ret;\n\tsize_t orig_len = strlen(option);\n\tint len;\n\n\tcmp = strstrip(option);\n\n\tlen = str_has_prefix(cmp, \"no\");\n\tif (len)\n\t\tneg = 1;\n\n\tcmp += len;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = match_string(trace_options, -1, cmp);\n\t/* If no option could be set, test the specific tracer options */\n\tif (ret < 0)\n\t\tret = set_tracer_option(tr, cmp, neg);\n\telse\n\t\tret = set_tracer_flag(tr, 1 << ret, !neg);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\t/*\n\t * If the first trailing whitespace is replaced with '\\0' by strstrip,\n\t * turn it back into a space.\n\t */\n\tif (orig_len > strlen(option))\n\t\toption[strlen(option)] = ' ';\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static const char *trace_options[] = {\n\tTRACE_FLAGS\n\tNULL\n};",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic const char *trace_options[] = {\n\tTRACE_FLAGS\n\tNULL\n};\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint trace_set_options(struct trace_array *tr, char *option)\n{\n\tchar *cmp;\n\tint neg = 0;\n\tint ret;\n\tsize_t orig_len = strlen(option);\n\tint len;\n\n\tcmp = strstrip(option);\n\n\tlen = str_has_prefix(cmp, \"no\");\n\tif (len)\n\t\tneg = 1;\n\n\tcmp += len;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = match_string(trace_options, -1, cmp);\n\t/* If no option could be set, test the specific tracer options */\n\tif (ret < 0)\n\t\tret = set_tracer_option(tr, cmp, neg);\n\telse\n\t\tret = set_tracer_flag(tr, 1 << ret, !neg);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\t/*\n\t * If the first trailing whitespace is replaced with '\\0' by strstrip,\n\t * turn it back into a space.\n\t */\n\tif (orig_len > strlen(option))\n\t\toption[strlen(option)] = ' ';\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"String is too long: %s\\n\"",
            "p"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "p",
            "ARRAY_SIZE(buf)"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xbc_node_for_each_array_value",
          "args": [
            "node",
            "\"options\"",
            "anode",
            "p"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ftrace.h>\n#include <linux/cpumask.h>\n#include <linux/bootconfig.h>\n\n#define MAX_BUF_LEN 256\n\nstatic void __init\ntrace_boot_set_instance_options(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar buf[MAX_BUF_LEN];\n\tunsigned long v = 0;\n\n\t/* Common ftrace options */\n\txbc_node_for_each_array_value(node, \"options\", anode, p) {\n\t\tif (strlcpy(buf, p, ARRAY_SIZE(buf)) >= ARRAY_SIZE(buf)) {\n\t\t\tpr_err(\"String is too long: %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (trace_set_options(tr, buf) < 0)\n\t\t\tpr_err(\"Failed to set option: %s\\n\", buf);\n\t}\n\n\tp = xbc_node_find_value(node, \"tracing_on\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (kstrtoul(p, 10, &v))\n\t\t\tpr_err(\"Failed to set tracing on: %s\\n\", p);\n\t\tif (v)\n\t\t\ttracer_tracing_on(tr);\n\t\telse\n\t\t\ttracer_tracing_off(tr);\n\t}\n\n\tp = xbc_node_find_value(node, \"trace_clock\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (tracing_set_clock(tr, p) < 0)\n\t\t\tpr_err(\"Failed to set trace clock: %s\\n\", p);\n\t}\n\n\tp = xbc_node_find_value(node, \"buffer_size\", NULL);\n\tif (p && *p != '\\0') {\n\t\tv = memparse(p, NULL);\n\t\tif (v < PAGE_SIZE)\n\t\t\tpr_err(\"Buffer size is too small: %s\\n\", p);\n\t\tif (tracing_resize_ring_buffer(tr, v, RING_BUFFER_ALL_CPUS) < 0)\n\t\t\tpr_err(\"Failed to resize trace buffer to %s\\n\", p);\n\t}\n\n\tp = xbc_node_find_value(node, \"cpumask\", NULL);\n\tif (p && *p != '\\0') {\n\t\tcpumask_var_t new_mask;\n\n\t\tif (alloc_cpumask_var(&new_mask, GFP_KERNEL)) {\n\t\t\tif (cpumask_parse(p, new_mask) < 0 ||\n\t\t\t    tracing_set_cpumask(tr, new_mask) < 0)\n\t\t\t\tpr_err(\"Failed to set new CPU mask %s\\n\", p);\n\t\t\tfree_cpumask_var(new_mask);\n\t\t}\n\t}\n}"
  }
]