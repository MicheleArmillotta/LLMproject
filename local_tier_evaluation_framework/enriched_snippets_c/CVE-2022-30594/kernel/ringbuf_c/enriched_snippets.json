[
  {
    "function_name": "bpf_ringbuf_commit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "370-396",
    "snippet": "static void bpf_ringbuf_commit(void *sample, u64 flags, bool discard)\n{\n\tunsigned long rec_pos, cons_pos;\n\tstruct bpf_ringbuf_hdr *hdr;\n\tstruct bpf_ringbuf *rb;\n\tu32 new_len;\n\n\thdr = sample - BPF_RINGBUF_HDR_SZ;\n\trb = bpf_ringbuf_restore_from_rec(hdr);\n\tnew_len = hdr->len ^ BPF_RINGBUF_BUSY_BIT;\n\tif (discard)\n\t\tnew_len |= BPF_RINGBUF_DISCARD_BIT;\n\n\t/* update record header with correct final size prefix */\n\txchg(&hdr->len, new_len);\n\n\t/* if consumer caught up and is waiting for our record, notify about\n\t * new data availability\n\t */\n\trec_pos = (void *)hdr - (void *)rb->data;\n\tcons_pos = smp_load_acquire(&rb->consumer_pos) & rb->mask;\n\n\tif (flags & BPF_RB_FORCE_WAKEUP)\n\t\tirq_work_queue(&rb->work);\n\telse if (cons_pos == rec_pos && !(flags & BPF_RB_NO_WAKEUP))\n\t\tirq_work_queue(&rb->work);\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&rb->work"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "106-118",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rb->consumer_pos"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&hdr->len",
            "new_len"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_ringbuf_restore_from_rec",
          "args": [
            "hdr"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_ringbuf_restore_from_rec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
          "lines": "296-303",
          "snippet": "static struct bpf_ringbuf *\nbpf_ringbuf_restore_from_rec(struct bpf_ringbuf_hdr *hdr)\n{\n\tunsigned long addr = (unsigned long)(void *)hdr;\n\tunsigned long off = (unsigned long)hdr->pg_off << PAGE_SHIFT;\n\n\treturn (void*)((addr & PAGE_MASK) - off);\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/poll.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_ringbuf *\nbpf_ringbuf_restore_from_rec(struct bpf_ringbuf_hdr *hdr)\n{\n\tunsigned long addr = (unsigned long)(void *)hdr;\n\tunsigned long off = (unsigned long)hdr->pg_off << PAGE_SHIFT;\n\n\treturn (void*)((addr & PAGE_MASK) - off);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_ringbuf_commit(void *sample, u64 flags, bool discard)\n{\n\tunsigned long rec_pos, cons_pos;\n\tstruct bpf_ringbuf_hdr *hdr;\n\tstruct bpf_ringbuf *rb;\n\tu32 new_len;\n\n\thdr = sample - BPF_RINGBUF_HDR_SZ;\n\trb = bpf_ringbuf_restore_from_rec(hdr);\n\tnew_len = hdr->len ^ BPF_RINGBUF_BUSY_BIT;\n\tif (discard)\n\t\tnew_len |= BPF_RINGBUF_DISCARD_BIT;\n\n\t/* update record header with correct final size prefix */\n\txchg(&hdr->len, new_len);\n\n\t/* if consumer caught up and is waiting for our record, notify about\n\t * new data availability\n\t */\n\trec_pos = (void *)hdr - (void *)rb->data;\n\tcons_pos = smp_load_acquire(&rb->consumer_pos) & rb->mask;\n\n\tif (flags & BPF_RB_FORCE_WAKEUP)\n\t\tirq_work_queue(&rb->work);\n\telse if (cons_pos == rec_pos && !(flags & BPF_RB_NO_WAKEUP))\n\t\tirq_work_queue(&rb->work);\n}"
  },
  {
    "function_name": "__bpf_ringbuf_reserve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "305-349",
    "snippet": "static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size)\n{\n\tunsigned long cons_pos, prod_pos, new_prod_pos, flags;\n\tu32 len, pg_off;\n\tstruct bpf_ringbuf_hdr *hdr;\n\n\tif (unlikely(size > RINGBUF_MAX_RECORD_SZ))\n\t\treturn NULL;\n\n\tlen = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n\tif (len > rb->mask + 1)\n\t\treturn NULL;\n\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\n\tif (in_nmi()) {\n\t\tif (!spin_trylock_irqsave(&rb->spinlock, flags))\n\t\t\treturn NULL;\n\t} else {\n\t\tspin_lock_irqsave(&rb->spinlock, flags);\n\t}\n\n\tprod_pos = rb->producer_pos;\n\tnew_prod_pos = prod_pos + len;\n\n\t/* check for out of ringbuf space by ensuring producer position\n\t * doesn't advance more than (ringbuf_size - 1) ahead\n\t */\n\tif (new_prod_pos - cons_pos > rb->mask) {\n\t\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\t\treturn NULL;\n\t}\n\n\thdr = (void *)rb->data + (prod_pos & rb->mask);\n\tpg_off = bpf_ringbuf_rec_pg_off(rb, hdr);\n\thdr->len = size | BPF_RINGBUF_BUSY_BIT;\n\thdr->pg_off = pg_off;\n\n\t/* pairs with consumer's smp_load_acquire() */\n\tsmp_store_release(&rb->producer_pos, new_prod_pos);\n\n\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\n\treturn (void *)hdr + BPF_RINGBUF_HDR_SZ;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define RINGBUF_MAX_RECORD_SZ (UINT_MAX/4)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rb->spinlock",
            "flags"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&rb->producer_pos",
            "new_prod_pos"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ringbuf_rec_pg_off",
          "args": [
            "rb",
            "hdr"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_ringbuf_rec_pg_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
          "lines": "287-291",
          "snippet": "static size_t bpf_ringbuf_rec_pg_off(struct bpf_ringbuf *rb,\n\t\t\t\t     struct bpf_ringbuf_hdr *hdr)\n{\n\treturn ((void *)hdr - (void *)rb) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/poll.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t bpf_ringbuf_rec_pg_off(struct bpf_ringbuf *rb,\n\t\t\t\t     struct bpf_ringbuf_hdr *hdr)\n{\n\treturn ((void *)hdr - (void *)rb) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rb->spinlock",
            "flags"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_trylock_irqsave",
          "args": [
            "&rb->spinlock",
            "flags"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rb->consumer_pos"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "size + BPF_RINGBUF_HDR_SZ",
            "8"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size > RINGBUF_MAX_RECORD_SZ"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define RINGBUF_MAX_RECORD_SZ (UINT_MAX/4)\n\nstatic void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size)\n{\n\tunsigned long cons_pos, prod_pos, new_prod_pos, flags;\n\tu32 len, pg_off;\n\tstruct bpf_ringbuf_hdr *hdr;\n\n\tif (unlikely(size > RINGBUF_MAX_RECORD_SZ))\n\t\treturn NULL;\n\n\tlen = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n\tif (len > rb->mask + 1)\n\t\treturn NULL;\n\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\n\tif (in_nmi()) {\n\t\tif (!spin_trylock_irqsave(&rb->spinlock, flags))\n\t\t\treturn NULL;\n\t} else {\n\t\tspin_lock_irqsave(&rb->spinlock, flags);\n\t}\n\n\tprod_pos = rb->producer_pos;\n\tnew_prod_pos = prod_pos + len;\n\n\t/* check for out of ringbuf space by ensuring producer position\n\t * doesn't advance more than (ringbuf_size - 1) ahead\n\t */\n\tif (new_prod_pos - cons_pos > rb->mask) {\n\t\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\t\treturn NULL;\n\t}\n\n\thdr = (void *)rb->data + (prod_pos & rb->mask);\n\tpg_off = bpf_ringbuf_rec_pg_off(rb, hdr);\n\thdr->len = size | BPF_RINGBUF_BUSY_BIT;\n\thdr->pg_off = pg_off;\n\n\t/* pairs with consumer's smp_load_acquire() */\n\tsmp_store_release(&rb->producer_pos, new_prod_pos);\n\n\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\n\treturn (void *)hdr + BPF_RINGBUF_HDR_SZ;\n}"
  },
  {
    "function_name": "bpf_ringbuf_restore_from_rec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "296-303",
    "snippet": "static struct bpf_ringbuf *\nbpf_ringbuf_restore_from_rec(struct bpf_ringbuf_hdr *hdr)\n{\n\tunsigned long addr = (unsigned long)(void *)hdr;\n\tunsigned long off = (unsigned long)hdr->pg_off << PAGE_SHIFT;\n\n\treturn (void*)((addr & PAGE_MASK) - off);\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_ringbuf *\nbpf_ringbuf_restore_from_rec(struct bpf_ringbuf_hdr *hdr)\n{\n\tunsigned long addr = (unsigned long)(void *)hdr;\n\tunsigned long off = (unsigned long)hdr->pg_off << PAGE_SHIFT;\n\n\treturn (void*)((addr & PAGE_MASK) - off);\n}"
  },
  {
    "function_name": "bpf_ringbuf_rec_pg_off",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "287-291",
    "snippet": "static size_t bpf_ringbuf_rec_pg_off(struct bpf_ringbuf *rb,\n\t\t\t\t     struct bpf_ringbuf_hdr *hdr)\n{\n\treturn ((void *)hdr - (void *)rb) >> PAGE_SHIFT;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t bpf_ringbuf_rec_pg_off(struct bpf_ringbuf *rb,\n\t\t\t\t     struct bpf_ringbuf_hdr *hdr)\n{\n\treturn ((void *)hdr - (void *)rb) >> PAGE_SHIFT;\n}"
  },
  {
    "function_name": "ringbuf_map_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "253-264",
    "snippet": "static __poll_t ringbuf_map_poll(struct bpf_map *map, struct file *filp,\n\t\t\t\t struct poll_table_struct *pts)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\tpoll_wait(filp, &rb_map->rb->waitq, pts);\n\n\tif (ringbuf_avail_data_sz(rb_map->rb))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ringbuf_avail_data_sz",
          "args": [
            "rb_map->rb"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "ringbuf_avail_data_sz",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
          "lines": "244-251",
          "snippet": "static unsigned long ringbuf_avail_data_sz(struct bpf_ringbuf *rb)\n{\n\tunsigned long cons_pos, prod_pos;\n\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\tprod_pos = smp_load_acquire(&rb->producer_pos);\n\treturn prod_pos - cons_pos;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/poll.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic unsigned long ringbuf_avail_data_sz(struct bpf_ringbuf *rb)\n{\n\tunsigned long cons_pos, prod_pos;\n\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\tprod_pos = smp_load_acquire(&rb->producer_pos);\n\treturn prod_pos - cons_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "filp",
            "&rb_map->rb->waitq",
            "pts"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_ringbuf_map",
            "map"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic __poll_t ringbuf_map_poll(struct bpf_map *map, struct file *filp,\n\t\t\t\t struct poll_table_struct *pts)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\tpoll_wait(filp, &rb_map->rb->waitq, pts);\n\n\tif (ringbuf_avail_data_sz(rb_map->rb))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}"
  },
  {
    "function_name": "ringbuf_avail_data_sz",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "244-251",
    "snippet": "static unsigned long ringbuf_avail_data_sz(struct bpf_ringbuf *rb)\n{\n\tunsigned long cons_pos, prod_pos;\n\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\tprod_pos = smp_load_acquire(&rb->producer_pos);\n\treturn prod_pos - cons_pos;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rb->producer_pos"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rb->consumer_pos"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic unsigned long ringbuf_avail_data_sz(struct bpf_ringbuf *rb)\n{\n\tunsigned long cons_pos, prod_pos;\n\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\tprod_pos = smp_load_acquire(&rb->producer_pos);\n\treturn prod_pos - cons_pos;\n}"
  },
  {
    "function_name": "ringbuf_map_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "226-242",
    "snippet": "static int ringbuf_map_mmap(struct bpf_map *map, struct vm_area_struct *vma)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\n\tif (vma->vm_flags & VM_WRITE) {\n\t\t/* allow writable mapping for the consumer_pos only */\n\t\tif (vma->vm_pgoff != 0 || vma->vm_end - vma->vm_start != PAGE_SIZE)\n\t\t\treturn -EPERM;\n\t} else {\n\t\tvma->vm_flags &= ~VM_MAYWRITE;\n\t}\n\t/* remap_vmalloc_range() checks size and offset constraints */\n\treturn remap_vmalloc_range(vma, rb_map->rb,\n\t\t\t\t   vma->vm_pgoff + RINGBUF_PGOFF);\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define RINGBUF_PGOFF \\\n\t(offsetof(struct bpf_ringbuf, consumer_pos) >> PAGE_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_vmalloc_range",
          "args": [
            "vma",
            "rb_map->rb",
            "vma->vm_pgoff + RINGBUF_PGOFF"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_ringbuf_map",
            "map"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define RINGBUF_PGOFF \\\n\t(offsetof(struct bpf_ringbuf, consumer_pos) >> PAGE_SHIFT)\n\nstatic int ringbuf_map_mmap(struct bpf_map *map, struct vm_area_struct *vma)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\n\tif (vma->vm_flags & VM_WRITE) {\n\t\t/* allow writable mapping for the consumer_pos only */\n\t\tif (vma->vm_pgoff != 0 || vma->vm_end - vma->vm_start != PAGE_SIZE)\n\t\t\treturn -EPERM;\n\t} else {\n\t\tvma->vm_flags &= ~VM_MAYWRITE;\n\t}\n\t/* remap_vmalloc_range() checks size and offset constraints */\n\treturn remap_vmalloc_range(vma, rb_map->rb,\n\t\t\t\t   vma->vm_pgoff + RINGBUF_PGOFF);\n}"
  },
  {
    "function_name": "ringbuf_map_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "220-224",
    "snippet": "static int ringbuf_map_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t    void *next_key)\n{\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int ringbuf_map_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t    void *next_key)\n{\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "ringbuf_map_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "215-218",
    "snippet": "static int ringbuf_map_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int ringbuf_map_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "ringbuf_map_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "209-213",
    "snippet": "static int ringbuf_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\t   u64 flags)\n{\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int ringbuf_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\t   u64 flags)\n{\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "ringbuf_map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "204-207",
    "snippet": "static void *ringbuf_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-ENOTSUPP);\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTSUPP"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *ringbuf_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-ENOTSUPP);\n}"
  },
  {
    "function_name": "ringbuf_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "195-202",
    "snippet": "static void ringbuf_map_free(struct bpf_map *map)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\tbpf_ringbuf_free(rb_map->rb);\n\tkfree(rb_map);\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb_map"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_ringbuf_free",
          "args": [
            "rb_map->rb"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_ringbuf_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
          "lines": "181-193",
          "snippet": "static void bpf_ringbuf_free(struct bpf_ringbuf *rb)\n{\n\t/* copy pages pointer and nr_pages to local variable, as we are going\n\t * to unmap rb itself with vunmap() below\n\t */\n\tstruct page **pages = rb->pages;\n\tint i, nr_pages = rb->nr_pages;\n\n\tvunmap(rb);\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tkvfree(pages);\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/poll.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_ringbuf_free(struct bpf_ringbuf *rb)\n{\n\t/* copy pages pointer and nr_pages to local variable, as we are going\n\t * to unmap rb itself with vunmap() below\n\t */\n\tstruct page **pages = rb->pages;\n\tint i, nr_pages = rb->nr_pages;\n\n\tvunmap(rb);\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tkvfree(pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_ringbuf_map",
            "map"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void ringbuf_map_free(struct bpf_map *map)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\tbpf_ringbuf_free(rb_map->rb);\n\tkfree(rb_map);\n}"
  },
  {
    "function_name": "bpf_ringbuf_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "181-193",
    "snippet": "static void bpf_ringbuf_free(struct bpf_ringbuf *rb)\n{\n\t/* copy pages pointer and nr_pages to local variable, as we are going\n\t * to unmap rb itself with vunmap() below\n\t */\n\tstruct page **pages = rb->pages;\n\tint i, nr_pages = rb->nr_pages;\n\n\tvunmap(rb);\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tkvfree(pages);\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "pages"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pages[i]"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vunmap",
          "args": [
            "rb"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_ringbuf_free(struct bpf_ringbuf *rb)\n{\n\t/* copy pages pointer and nr_pages to local variable, as we are going\n\t * to unmap rb itself with vunmap() below\n\t */\n\tstruct page **pages = rb->pages;\n\tint i, nr_pages = rb->nr_pages;\n\n\tvunmap(rb);\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tkvfree(pages);\n}"
  },
  {
    "function_name": "ringbuf_map_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "148-179",
    "snippet": "static struct bpf_map *ringbuf_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\tif (attr->map_flags & ~RINGBUF_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->key_size || attr->value_size ||\n\t    !is_power_of_2(attr->max_entries) ||\n\t    !PAGE_ALIGNED(attr->max_entries))\n\t\treturn ERR_PTR(-EINVAL);\n\n#ifdef CONFIG_64BIT\n\t/* on 32-bit arch, it's impossible to overflow record's hdr->pgoff */\n\tif (attr->max_entries > RINGBUF_MAX_DATA_SZ)\n\t\treturn ERR_PTR(-E2BIG);\n#endif\n\n\trb_map = kzalloc(sizeof(*rb_map), GFP_USER | __GFP_ACCOUNT);\n\tif (!rb_map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&rb_map->map, attr);\n\n\trb_map->rb = bpf_ringbuf_alloc(attr->max_entries, rb_map->map.numa_node);\n\tif (!rb_map->rb) {\n\t\tkfree(rb_map);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn &rb_map->map;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define RINGBUF_MAX_DATA_SZ \\\n\t(((1ULL << 24) - RINGBUF_POS_PAGES - RINGBUF_PGOFF) * PAGE_SIZE)",
      "#define RINGBUF_CREATE_FLAG_MASK (BPF_F_NUMA_NODE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb_map"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_ringbuf_alloc",
          "args": [
            "attr->max_entries",
            "rb_map->map.numa_node"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_ringbuf_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
          "lines": "129-146",
          "snippet": "static struct bpf_ringbuf *bpf_ringbuf_alloc(size_t data_sz, int numa_node)\n{\n\tstruct bpf_ringbuf *rb;\n\n\trb = bpf_ringbuf_area_alloc(data_sz, numa_node);\n\tif (!rb)\n\t\treturn NULL;\n\n\tspin_lock_init(&rb->spinlock);\n\tinit_waitqueue_head(&rb->waitq);\n\tinit_irq_work(&rb->work, bpf_ringbuf_notify);\n\n\trb->mask = data_sz - 1;\n\trb->consumer_pos = 0;\n\trb->producer_pos = 0;\n\n\treturn rb;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/poll.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_ringbuf *bpf_ringbuf_alloc(size_t data_sz, int numa_node)\n{\n\tstruct bpf_ringbuf *rb;\n\n\trb = bpf_ringbuf_area_alloc(data_sz, numa_node);\n\tif (!rb)\n\t\treturn NULL;\n\n\tspin_lock_init(&rb->spinlock);\n\tinit_waitqueue_head(&rb->waitq);\n\tinit_irq_work(&rb->work, bpf_ringbuf_notify);\n\n\trb->mask = data_sz - 1;\n\trb->consumer_pos = 0;\n\trb->producer_pos = 0;\n\n\treturn rb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&rb_map->map",
            "attr"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "361-370",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rb_map)",
            "GFP_USER | __GFP_ACCOUNT"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-E2BIG"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGNED",
          "args": [
            "attr->max_entries"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "attr->max_entries"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define RINGBUF_MAX_DATA_SZ \\\n\t(((1ULL << 24) - RINGBUF_POS_PAGES - RINGBUF_PGOFF) * PAGE_SIZE)\n#define RINGBUF_CREATE_FLAG_MASK (BPF_F_NUMA_NODE)\n\nstatic struct bpf_map *ringbuf_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\tif (attr->map_flags & ~RINGBUF_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->key_size || attr->value_size ||\n\t    !is_power_of_2(attr->max_entries) ||\n\t    !PAGE_ALIGNED(attr->max_entries))\n\t\treturn ERR_PTR(-EINVAL);\n\n#ifdef CONFIG_64BIT\n\t/* on 32-bit arch, it's impossible to overflow record's hdr->pgoff */\n\tif (attr->max_entries > RINGBUF_MAX_DATA_SZ)\n\t\treturn ERR_PTR(-E2BIG);\n#endif\n\n\trb_map = kzalloc(sizeof(*rb_map), GFP_USER | __GFP_ACCOUNT);\n\tif (!rb_map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&rb_map->map, attr);\n\n\trb_map->rb = bpf_ringbuf_alloc(attr->max_entries, rb_map->map.numa_node);\n\tif (!rb_map->rb) {\n\t\tkfree(rb_map);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn &rb_map->map;\n}"
  },
  {
    "function_name": "bpf_ringbuf_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "129-146",
    "snippet": "static struct bpf_ringbuf *bpf_ringbuf_alloc(size_t data_sz, int numa_node)\n{\n\tstruct bpf_ringbuf *rb;\n\n\trb = bpf_ringbuf_area_alloc(data_sz, numa_node);\n\tif (!rb)\n\t\treturn NULL;\n\n\tspin_lock_init(&rb->spinlock);\n\tinit_waitqueue_head(&rb->waitq);\n\tinit_irq_work(&rb->work, bpf_ringbuf_notify);\n\n\trb->mask = data_sz - 1;\n\trb->consumer_pos = 0;\n\trb->producer_pos = 0;\n\n\treturn rb;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&rb->work",
            "bpf_ringbuf_notify"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rb->waitq"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&rb->spinlock"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_ringbuf_area_alloc",
          "args": [
            "data_sz",
            "numa_node"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_ringbuf_area_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
          "lines": "61-120",
          "snippet": "static struct bpf_ringbuf *bpf_ringbuf_area_alloc(size_t data_sz, int numa_node)\n{\n\tconst gfp_t flags = GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL |\n\t\t\t    __GFP_NOWARN | __GFP_ZERO;\n\tint nr_meta_pages = RINGBUF_PGOFF + RINGBUF_POS_PAGES;\n\tint nr_data_pages = data_sz >> PAGE_SHIFT;\n\tint nr_pages = nr_meta_pages + nr_data_pages;\n\tstruct page **pages, *page;\n\tstruct bpf_ringbuf *rb;\n\tsize_t array_size;\n\tint i;\n\n\t/* Each data page is mapped twice to allow \"virtual\"\n\t * continuous read of samples wrapping around the end of ring\n\t * buffer area:\n\t * ------------------------------------------------------\n\t * | meta pages |  real data pages  |  same data pages  |\n\t * ------------------------------------------------------\n\t * |            | 1 2 3 4 5 6 7 8 9 | 1 2 3 4 5 6 7 8 9 |\n\t * ------------------------------------------------------\n\t * |            | TA             DA | TA             DA |\n\t * ------------------------------------------------------\n\t *                               ^^^^^^^\n\t *                                  |\n\t * Here, no need to worry about special handling of wrapped-around\n\t * data due to double-mapped data pages. This works both in kernel and\n\t * when mmap()'ed in user-space, simplifying both kernel and\n\t * user-space implementations significantly.\n\t */\n\tarray_size = (nr_meta_pages + 2 * nr_data_pages) * sizeof(*pages);\n\tpages = bpf_map_area_alloc(array_size, numa_node);\n\tif (!pages)\n\t\treturn NULL;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_pages_node(numa_node, flags, 0);\n\t\tif (!page) {\n\t\t\tnr_pages = i;\n\t\t\tgoto err_free_pages;\n\t\t}\n\t\tpages[i] = page;\n\t\tif (i >= nr_meta_pages)\n\t\t\tpages[nr_data_pages + i] = page;\n\t}\n\n\trb = vmap(pages, nr_meta_pages + 2 * nr_data_pages,\n\t\t  VM_ALLOC | VM_USERMAP, PAGE_KERNEL);\n\tif (rb) {\n\t\tkmemleak_not_leak(pages);\n\t\trb->pages = pages;\n\t\trb->nr_pages = nr_pages;\n\t\treturn rb;\n\t}\n\nerr_free_pages:\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tkvfree(pages);\n\treturn NULL;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/poll.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define RINGBUF_POS_PAGES 2",
            "#define RINGBUF_PGOFF \\\n\t(offsetof(struct bpf_ringbuf, consumer_pos) >> PAGE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define RINGBUF_POS_PAGES 2\n#define RINGBUF_PGOFF \\\n\t(offsetof(struct bpf_ringbuf, consumer_pos) >> PAGE_SHIFT)\n\nstatic struct bpf_ringbuf *bpf_ringbuf_area_alloc(size_t data_sz, int numa_node)\n{\n\tconst gfp_t flags = GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL |\n\t\t\t    __GFP_NOWARN | __GFP_ZERO;\n\tint nr_meta_pages = RINGBUF_PGOFF + RINGBUF_POS_PAGES;\n\tint nr_data_pages = data_sz >> PAGE_SHIFT;\n\tint nr_pages = nr_meta_pages + nr_data_pages;\n\tstruct page **pages, *page;\n\tstruct bpf_ringbuf *rb;\n\tsize_t array_size;\n\tint i;\n\n\t/* Each data page is mapped twice to allow \"virtual\"\n\t * continuous read of samples wrapping around the end of ring\n\t * buffer area:\n\t * ------------------------------------------------------\n\t * | meta pages |  real data pages  |  same data pages  |\n\t * ------------------------------------------------------\n\t * |            | 1 2 3 4 5 6 7 8 9 | 1 2 3 4 5 6 7 8 9 |\n\t * ------------------------------------------------------\n\t * |            | TA             DA | TA             DA |\n\t * ------------------------------------------------------\n\t *                               ^^^^^^^\n\t *                                  |\n\t * Here, no need to worry about special handling of wrapped-around\n\t * data due to double-mapped data pages. This works both in kernel and\n\t * when mmap()'ed in user-space, simplifying both kernel and\n\t * user-space implementations significantly.\n\t */\n\tarray_size = (nr_meta_pages + 2 * nr_data_pages) * sizeof(*pages);\n\tpages = bpf_map_area_alloc(array_size, numa_node);\n\tif (!pages)\n\t\treturn NULL;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_pages_node(numa_node, flags, 0);\n\t\tif (!page) {\n\t\t\tnr_pages = i;\n\t\t\tgoto err_free_pages;\n\t\t}\n\t\tpages[i] = page;\n\t\tif (i >= nr_meta_pages)\n\t\t\tpages[nr_data_pages + i] = page;\n\t}\n\n\trb = vmap(pages, nr_meta_pages + 2 * nr_data_pages,\n\t\t  VM_ALLOC | VM_USERMAP, PAGE_KERNEL);\n\tif (rb) {\n\t\tkmemleak_not_leak(pages);\n\t\trb->pages = pages;\n\t\trb->nr_pages = nr_pages;\n\t\treturn rb;\n\t}\n\nerr_free_pages:\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tkvfree(pages);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_ringbuf *bpf_ringbuf_alloc(size_t data_sz, int numa_node)\n{\n\tstruct bpf_ringbuf *rb;\n\n\trb = bpf_ringbuf_area_alloc(data_sz, numa_node);\n\tif (!rb)\n\t\treturn NULL;\n\n\tspin_lock_init(&rb->spinlock);\n\tinit_waitqueue_head(&rb->waitq);\n\tinit_irq_work(&rb->work, bpf_ringbuf_notify);\n\n\trb->mask = data_sz - 1;\n\trb->consumer_pos = 0;\n\trb->producer_pos = 0;\n\n\treturn rb;\n}"
  },
  {
    "function_name": "bpf_ringbuf_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "122-127",
    "snippet": "static void bpf_ringbuf_notify(struct irq_work *work)\n{\n\tstruct bpf_ringbuf *rb = container_of(work, struct bpf_ringbuf, work);\n\n\twake_up_all(&rb->waitq);\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&rb->waitq"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/swait.c",
          "lines": "62-82",
          "snippet": "void swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbpf_ringbuf",
            "work"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_ringbuf_notify(struct irq_work *work)\n{\n\tstruct bpf_ringbuf *rb = container_of(work, struct bpf_ringbuf, work);\n\n\twake_up_all(&rb->waitq);\n}"
  },
  {
    "function_name": "bpf_ringbuf_area_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/ringbuf.c",
    "lines": "61-120",
    "snippet": "static struct bpf_ringbuf *bpf_ringbuf_area_alloc(size_t data_sz, int numa_node)\n{\n\tconst gfp_t flags = GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL |\n\t\t\t    __GFP_NOWARN | __GFP_ZERO;\n\tint nr_meta_pages = RINGBUF_PGOFF + RINGBUF_POS_PAGES;\n\tint nr_data_pages = data_sz >> PAGE_SHIFT;\n\tint nr_pages = nr_meta_pages + nr_data_pages;\n\tstruct page **pages, *page;\n\tstruct bpf_ringbuf *rb;\n\tsize_t array_size;\n\tint i;\n\n\t/* Each data page is mapped twice to allow \"virtual\"\n\t * continuous read of samples wrapping around the end of ring\n\t * buffer area:\n\t * ------------------------------------------------------\n\t * | meta pages |  real data pages  |  same data pages  |\n\t * ------------------------------------------------------\n\t * |            | 1 2 3 4 5 6 7 8 9 | 1 2 3 4 5 6 7 8 9 |\n\t * ------------------------------------------------------\n\t * |            | TA             DA | TA             DA |\n\t * ------------------------------------------------------\n\t *                               ^^^^^^^\n\t *                                  |\n\t * Here, no need to worry about special handling of wrapped-around\n\t * data due to double-mapped data pages. This works both in kernel and\n\t * when mmap()'ed in user-space, simplifying both kernel and\n\t * user-space implementations significantly.\n\t */\n\tarray_size = (nr_meta_pages + 2 * nr_data_pages) * sizeof(*pages);\n\tpages = bpf_map_area_alloc(array_size, numa_node);\n\tif (!pages)\n\t\treturn NULL;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_pages_node(numa_node, flags, 0);\n\t\tif (!page) {\n\t\t\tnr_pages = i;\n\t\t\tgoto err_free_pages;\n\t\t}\n\t\tpages[i] = page;\n\t\tif (i >= nr_meta_pages)\n\t\t\tpages[nr_data_pages + i] = page;\n\t}\n\n\trb = vmap(pages, nr_meta_pages + 2 * nr_data_pages,\n\t\t  VM_ALLOC | VM_USERMAP, PAGE_KERNEL);\n\tif (rb) {\n\t\tkmemleak_not_leak(pages);\n\t\trb->pages = pages;\n\t\trb->nr_pages = nr_pages;\n\t\treturn rb;\n\t}\n\nerr_free_pages:\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tkvfree(pages);\n\treturn NULL;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/poll.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define RINGBUF_POS_PAGES 2",
      "#define RINGBUF_PGOFF \\\n\t(offsetof(struct bpf_ringbuf, consumer_pos) >> PAGE_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "pages"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pages[i]"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_not_leak",
          "args": [
            "pages"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmap",
          "args": [
            "pages",
            "nr_meta_pages + 2 * nr_data_pages",
            "VM_ALLOC | VM_USERMAP",
            "PAGE_KERNEL"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "numa_node",
            "flags",
            "0"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "array_size",
            "numa_node"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "334-337",
          "snippet": "void *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <linux/kmemleak.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define RINGBUF_POS_PAGES 2\n#define RINGBUF_PGOFF \\\n\t(offsetof(struct bpf_ringbuf, consumer_pos) >> PAGE_SHIFT)\n\nstatic struct bpf_ringbuf *bpf_ringbuf_area_alloc(size_t data_sz, int numa_node)\n{\n\tconst gfp_t flags = GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL |\n\t\t\t    __GFP_NOWARN | __GFP_ZERO;\n\tint nr_meta_pages = RINGBUF_PGOFF + RINGBUF_POS_PAGES;\n\tint nr_data_pages = data_sz >> PAGE_SHIFT;\n\tint nr_pages = nr_meta_pages + nr_data_pages;\n\tstruct page **pages, *page;\n\tstruct bpf_ringbuf *rb;\n\tsize_t array_size;\n\tint i;\n\n\t/* Each data page is mapped twice to allow \"virtual\"\n\t * continuous read of samples wrapping around the end of ring\n\t * buffer area:\n\t * ------------------------------------------------------\n\t * | meta pages |  real data pages  |  same data pages  |\n\t * ------------------------------------------------------\n\t * |            | 1 2 3 4 5 6 7 8 9 | 1 2 3 4 5 6 7 8 9 |\n\t * ------------------------------------------------------\n\t * |            | TA             DA | TA             DA |\n\t * ------------------------------------------------------\n\t *                               ^^^^^^^\n\t *                                  |\n\t * Here, no need to worry about special handling of wrapped-around\n\t * data due to double-mapped data pages. This works both in kernel and\n\t * when mmap()'ed in user-space, simplifying both kernel and\n\t * user-space implementations significantly.\n\t */\n\tarray_size = (nr_meta_pages + 2 * nr_data_pages) * sizeof(*pages);\n\tpages = bpf_map_area_alloc(array_size, numa_node);\n\tif (!pages)\n\t\treturn NULL;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_pages_node(numa_node, flags, 0);\n\t\tif (!page) {\n\t\t\tnr_pages = i;\n\t\t\tgoto err_free_pages;\n\t\t}\n\t\tpages[i] = page;\n\t\tif (i >= nr_meta_pages)\n\t\t\tpages[nr_data_pages + i] = page;\n\t}\n\n\trb = vmap(pages, nr_meta_pages + 2 * nr_data_pages,\n\t\t  VM_ALLOC | VM_USERMAP, PAGE_KERNEL);\n\tif (rb) {\n\t\tkmemleak_not_leak(pages);\n\t\trb->pages = pages;\n\t\trb->nr_pages = nr_pages;\n\t\treturn rb;\n\t}\n\nerr_free_pages:\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tkvfree(pages);\n\treturn NULL;\n}"
  }
]