[
  {
    "function_name": "map_benchmark_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
    "lines": "371-375",
    "snippet": "static void __exit map_benchmark_cleanup(void)\n{\n\tplatform_driver_unregister(&map_benchmark_platform_driver);\n\tpci_unregister_driver(&map_benchmark_pci_driver);\n}",
    "includes": [
      "#include <linux/timekeeping.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct platform_driver map_benchmark_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"dma_map_benchmark\",\n\t},\n\t.probe = map_benchmark_platform_probe,\n};",
      "static struct pci_driver map_benchmark_pci_driver = {\n\t.name\t= \"dma_map_benchmark\",\n\t.probe\t= map_benchmark_pci_probe,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_unregister_driver",
          "args": [
            "&map_benchmark_pci_driver"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_driver_unregister",
          "args": [
            "&map_benchmark_platform_driver"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic struct platform_driver map_benchmark_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"dma_map_benchmark\",\n\t},\n\t.probe = map_benchmark_platform_probe,\n};\nstatic struct pci_driver map_benchmark_pci_driver = {\n\t.name\t= \"dma_map_benchmark\",\n\t.probe\t= map_benchmark_pci_probe,\n};\n\nstatic void __exit map_benchmark_cleanup(void)\n{\n\tplatform_driver_unregister(&map_benchmark_platform_driver);\n\tpci_unregister_driver(&map_benchmark_pci_driver);\n}"
  },
  {
    "function_name": "map_benchmark_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
    "lines": "354-369",
    "snippet": "static int __init map_benchmark_init(void)\n{\n\tint ret;\n\n\tret = pci_register_driver(&map_benchmark_pci_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&map_benchmark_platform_driver);\n\tif (ret) {\n\t\tpci_unregister_driver(&map_benchmark_pci_driver);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/timekeeping.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct platform_driver map_benchmark_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"dma_map_benchmark\",\n\t},\n\t.probe = map_benchmark_platform_probe,\n};",
      "static struct pci_driver map_benchmark_pci_driver = {\n\t.name\t= \"dma_map_benchmark\",\n\t.probe\t= map_benchmark_pci_probe,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_unregister_driver",
          "args": [
            "&map_benchmark_pci_driver"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_driver_register",
          "args": [
            "&map_benchmark_platform_driver"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_register_driver",
          "args": [
            "&map_benchmark_pci_driver"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic struct platform_driver map_benchmark_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"dma_map_benchmark\",\n\t},\n\t.probe = map_benchmark_platform_probe,\n};\nstatic struct pci_driver map_benchmark_pci_driver = {\n\t.name\t= \"dma_map_benchmark\",\n\t.probe\t= map_benchmark_pci_probe,\n};\n\nstatic int __init map_benchmark_init(void)\n{\n\tint ret;\n\n\tret = pci_register_driver(&map_benchmark_pci_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&map_benchmark_platform_driver);\n\tif (ret) {\n\t\tpci_unregister_driver(&map_benchmark_pci_driver);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "map_benchmark_pci_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
    "lines": "343-347",
    "snippet": "static int\nmap_benchmark_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\treturn __map_benchmark_probe(&pdev->dev);\n}",
    "includes": [
      "#include <linux/timekeeping.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__map_benchmark_probe",
          "args": [
            "&pdev->dev"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "__map_benchmark_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
          "lines": "301-329",
          "snippet": "static int __map_benchmark_probe(struct device *dev)\n{\n\tstruct dentry *entry;\n\tstruct map_benchmark_data *map;\n\tint ret;\n\n\tmap = devm_kzalloc(dev, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\tmap->dev = dev;\n\n\tret = devm_add_action(dev, map_benchmark_remove_debugfs, map);\n\tif (ret) {\n\t\tpr_err(\"Can't add debugfs remove action\\n\");\n\t\treturn ret;\n\t}\n\n\t/*\n\t * we only permit a device bound with this driver, 2nd probe\n\t * will fail\n\t */\n\tentry = debugfs_create_file(\"dma_map_benchmark\", 0600, NULL, map,\n\t\t\t&map_benchmark_fops);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\tmap->debugfs = entry;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/timekeeping.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>",
            "#include <linux/delay.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations map_benchmark_fops = {\n\t.open\t\t\t= simple_open,\n\t.unlocked_ioctl\t\t= map_benchmark_ioctl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic const struct file_operations map_benchmark_fops = {\n\t.open\t\t\t= simple_open,\n\t.unlocked_ioctl\t\t= map_benchmark_ioctl,\n};\n\nstatic int __map_benchmark_probe(struct device *dev)\n{\n\tstruct dentry *entry;\n\tstruct map_benchmark_data *map;\n\tint ret;\n\n\tmap = devm_kzalloc(dev, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\tmap->dev = dev;\n\n\tret = devm_add_action(dev, map_benchmark_remove_debugfs, map);\n\tif (ret) {\n\t\tpr_err(\"Can't add debugfs remove action\\n\");\n\t\treturn ret;\n\t}\n\n\t/*\n\t * we only permit a device bound with this driver, 2nd probe\n\t * will fail\n\t */\n\tentry = debugfs_create_file(\"dma_map_benchmark\", 0600, NULL, map,\n\t\t\t&map_benchmark_fops);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\tmap->debugfs = entry;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic int\nmap_benchmark_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\treturn __map_benchmark_probe(&pdev->dev);\n}"
  },
  {
    "function_name": "map_benchmark_platform_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
    "lines": "331-334",
    "snippet": "static int map_benchmark_platform_probe(struct platform_device *pdev)\n{\n\treturn __map_benchmark_probe(&pdev->dev);\n}",
    "includes": [
      "#include <linux/timekeeping.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__map_benchmark_probe",
          "args": [
            "&pdev->dev"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__map_benchmark_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
          "lines": "301-329",
          "snippet": "static int __map_benchmark_probe(struct device *dev)\n{\n\tstruct dentry *entry;\n\tstruct map_benchmark_data *map;\n\tint ret;\n\n\tmap = devm_kzalloc(dev, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\tmap->dev = dev;\n\n\tret = devm_add_action(dev, map_benchmark_remove_debugfs, map);\n\tif (ret) {\n\t\tpr_err(\"Can't add debugfs remove action\\n\");\n\t\treturn ret;\n\t}\n\n\t/*\n\t * we only permit a device bound with this driver, 2nd probe\n\t * will fail\n\t */\n\tentry = debugfs_create_file(\"dma_map_benchmark\", 0600, NULL, map,\n\t\t\t&map_benchmark_fops);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\tmap->debugfs = entry;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/timekeeping.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>",
            "#include <linux/delay.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations map_benchmark_fops = {\n\t.open\t\t\t= simple_open,\n\t.unlocked_ioctl\t\t= map_benchmark_ioctl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic const struct file_operations map_benchmark_fops = {\n\t.open\t\t\t= simple_open,\n\t.unlocked_ioctl\t\t= map_benchmark_ioctl,\n};\n\nstatic int __map_benchmark_probe(struct device *dev)\n{\n\tstruct dentry *entry;\n\tstruct map_benchmark_data *map;\n\tint ret;\n\n\tmap = devm_kzalloc(dev, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\tmap->dev = dev;\n\n\tret = devm_add_action(dev, map_benchmark_remove_debugfs, map);\n\tif (ret) {\n\t\tpr_err(\"Can't add debugfs remove action\\n\");\n\t\treturn ret;\n\t}\n\n\t/*\n\t * we only permit a device bound with this driver, 2nd probe\n\t * will fail\n\t */\n\tentry = debugfs_create_file(\"dma_map_benchmark\", 0600, NULL, map,\n\t\t\t&map_benchmark_fops);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\tmap->debugfs = entry;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic int map_benchmark_platform_probe(struct platform_device *pdev)\n{\n\treturn __map_benchmark_probe(&pdev->dev);\n}"
  },
  {
    "function_name": "__map_benchmark_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
    "lines": "301-329",
    "snippet": "static int __map_benchmark_probe(struct device *dev)\n{\n\tstruct dentry *entry;\n\tstruct map_benchmark_data *map;\n\tint ret;\n\n\tmap = devm_kzalloc(dev, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\tmap->dev = dev;\n\n\tret = devm_add_action(dev, map_benchmark_remove_debugfs, map);\n\tif (ret) {\n\t\tpr_err(\"Can't add debugfs remove action\\n\");\n\t\treturn ret;\n\t}\n\n\t/*\n\t * we only permit a device bound with this driver, 2nd probe\n\t * will fail\n\t */\n\tentry = debugfs_create_file(\"dma_map_benchmark\", 0600, NULL, map,\n\t\t\t&map_benchmark_fops);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\tmap->debugfs = entry;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/timekeeping.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations map_benchmark_fops = {\n\t.open\t\t\t= simple_open,\n\t.unlocked_ioctl\t\t= map_benchmark_ioctl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "entry"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "entry"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"dma_map_benchmark\"",
            "0600",
            "NULL",
            "map",
            "&map_benchmark_fops"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Can't add debugfs remove action\\n\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devm_add_action",
          "args": [
            "dev",
            "map_benchmark_remove_debugfs",
            "map"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devm_kzalloc",
          "args": [
            "dev",
            "sizeof(*map)",
            "GFP_KERNEL"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic const struct file_operations map_benchmark_fops = {\n\t.open\t\t\t= simple_open,\n\t.unlocked_ioctl\t\t= map_benchmark_ioctl,\n};\n\nstatic int __map_benchmark_probe(struct device *dev)\n{\n\tstruct dentry *entry;\n\tstruct map_benchmark_data *map;\n\tint ret;\n\n\tmap = devm_kzalloc(dev, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\tmap->dev = dev;\n\n\tret = devm_add_action(dev, map_benchmark_remove_debugfs, map);\n\tif (ret) {\n\t\tpr_err(\"Can't add debugfs remove action\\n\");\n\t\treturn ret;\n\t}\n\n\t/*\n\t * we only permit a device bound with this driver, 2nd probe\n\t * will fail\n\t */\n\tentry = debugfs_create_file(\"dma_map_benchmark\", 0600, NULL, map,\n\t\t\t&map_benchmark_fops);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\tmap->debugfs = entry;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "map_benchmark_remove_debugfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
    "lines": "294-299",
    "snippet": "static void map_benchmark_remove_debugfs(void *data)\n{\n\tstruct map_benchmark_data *map = (struct map_benchmark_data *)data;\n\n\tdebugfs_remove(map->debugfs);\n}",
    "includes": [
      "#include <linux/timekeeping.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "map->debugfs"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "164-170",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic void map_benchmark_remove_debugfs(void *data)\n{\n\tstruct map_benchmark_data *map = (struct map_benchmark_data *)data;\n\n\tdebugfs_remove(map->debugfs);\n}"
  },
  {
    "function_name": "map_benchmark_ioctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
    "lines": "203-287",
    "snippet": "static long map_benchmark_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct map_benchmark_data *map = file->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 old_dma_mask;\n\tint ret;\n\n\tif (copy_from_user(&map->bparam, argp, sizeof(map->bparam)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase DMA_MAP_BENCHMARK:\n\t\tif (map->bparam.threads == 0 ||\n\t\t    map->bparam.threads > DMA_MAP_MAX_THREADS) {\n\t\t\tpr_err(\"invalid thread number\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.seconds == 0 ||\n\t\t    map->bparam.seconds > DMA_MAP_MAX_SECONDS) {\n\t\t\tpr_err(\"invalid duration seconds\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.dma_trans_ns > DMA_MAP_MAX_TRANS_DELAY) {\n\t\t\tpr_err(\"invalid transmission delay\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.node != NUMA_NO_NODE &&\n\t\t    !node_possible(map->bparam.node)) {\n\t\t\tpr_err(\"invalid numa node\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.granule < 1 || map->bparam.granule > 1024) {\n\t\t\tpr_err(\"invalid granule size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (map->bparam.dma_dir) {\n\t\tcase DMA_MAP_BIDIRECTIONAL:\n\t\t\tmap->dir = DMA_BIDIRECTIONAL;\n\t\t\tbreak;\n\t\tcase DMA_MAP_FROM_DEVICE:\n\t\t\tmap->dir = DMA_FROM_DEVICE;\n\t\t\tbreak;\n\t\tcase DMA_MAP_TO_DEVICE:\n\t\t\tmap->dir = DMA_TO_DEVICE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"invalid DMA direction\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\told_dma_mask = dma_get_mask(map->dev);\n\n\t\tret = dma_set_mask(map->dev,\n\t\t\t\t   DMA_BIT_MASK(map->bparam.dma_bits));\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set dma_mask on device %s\\n\",\n\t\t\t\tdev_name(map->dev));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = do_map_benchmark(map);\n\n\t\t/*\n\t\t * restore the original dma_mask as many devices' dma_mask are\n\t\t * set by architectures, acpi, busses. When we bind them back\n\t\t * to their original drivers, those drivers shouldn't see\n\t\t * dma_mask changed by benchmark\n\t\t */\n\t\tdma_set_mask(map->dev, old_dma_mask);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_to_user(argp, &map->bparam, sizeof(map->bparam)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/timekeeping.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [
      "#define DMA_MAP_FROM_DEVICE\t2",
      "#define DMA_MAP_TO_DEVICE\t1",
      "#define DMA_MAP_BIDIRECTIONAL\t0",
      "#define DMA_MAP_MAX_TRANS_DELAY\t(10 * NSEC_PER_MSEC)",
      "#define DMA_MAP_MAX_SECONDS\t300",
      "#define DMA_MAP_MAX_THREADS\t1024",
      "#define DMA_MAP_BENCHMARK\t_IOWR('d', 1, struct map_benchmark)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&map->bparam",
            "sizeof(map->bparam)"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_set_mask",
          "args": [
            "map->dev",
            "old_dma_mask"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "dma_set_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "731-745",
          "snippet": "int dma_set_mask(struct device *dev, u64 mask)\n{\n\t/*\n\t * Truncate the mask to the actually supported dma_addr_t width to\n\t * avoid generating unsupportable addresses.\n\t */\n\tmask = (dma_addr_t)mask;\n\n\tif (!dev->dma_mask || !dma_supported(dev, mask))\n\t\treturn -EIO;\n\n\tarch_dma_set_mask(dev, mask);\n\t*dev->dma_mask = mask;\n\treturn 0;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_set_mask(struct device *dev, u64 mask)\n{\n\t/*\n\t * Truncate the mask to the actually supported dma_addr_t width to\n\t * avoid generating unsupportable addresses.\n\t */\n\tmask = (dma_addr_t)mask;\n\n\tif (!dev->dma_mask || !dma_supported(dev, mask))\n\t\treturn -EIO;\n\n\tarch_dma_set_mask(dev, mask);\n\t*dev->dma_mask = mask;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_map_benchmark",
          "args": [
            "map"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "do_map_benchmark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
          "lines": "122-201",
          "snippet": "static int do_map_benchmark(struct map_benchmark_data *map)\n{\n\tstruct task_struct **tsk;\n\tint threads = map->bparam.threads;\n\tint node = map->bparam.node;\n\tconst cpumask_t *cpu_mask = cpumask_of_node(node);\n\tu64 loops;\n\tint ret = 0;\n\tint i;\n\n\ttsk = kmalloc_array(threads, sizeof(*tsk), GFP_KERNEL);\n\tif (!tsk)\n\t\treturn -ENOMEM;\n\n\tget_device(map->dev);\n\n\tfor (i = 0; i < threads; i++) {\n\t\ttsk[i] = kthread_create_on_node(map_benchmark_thread, map,\n\t\t\t\tmap->bparam.node, \"dma-map-benchmark/%d\", i);\n\t\tif (IS_ERR(tsk[i])) {\n\t\t\tpr_err(\"create dma_map thread failed\\n\");\n\t\t\tret = PTR_ERR(tsk[i]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (node != NUMA_NO_NODE)\n\t\t\tkthread_bind_mask(tsk[i], cpu_mask);\n\t}\n\n\t/* clear the old value in the previous benchmark */\n\tatomic64_set(&map->sum_map_100ns, 0);\n\tatomic64_set(&map->sum_unmap_100ns, 0);\n\tatomic64_set(&map->sum_sq_map, 0);\n\tatomic64_set(&map->sum_sq_unmap, 0);\n\tatomic64_set(&map->loops, 0);\n\n\tfor (i = 0; i < threads; i++) {\n\t\tget_task_struct(tsk[i]);\n\t\twake_up_process(tsk[i]);\n\t}\n\n\tmsleep_interruptible(map->bparam.seconds * 1000);\n\n\t/* wait for the completion of benchmark threads */\n\tfor (i = 0; i < threads; i++) {\n\t\tret = kthread_stop(tsk[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tloops = atomic64_read(&map->loops);\n\tif (likely(loops > 0)) {\n\t\tu64 map_variance, unmap_variance;\n\t\tu64 sum_map = atomic64_read(&map->sum_map_100ns);\n\t\tu64 sum_unmap = atomic64_read(&map->sum_unmap_100ns);\n\t\tu64 sum_sq_map = atomic64_read(&map->sum_sq_map);\n\t\tu64 sum_sq_unmap = atomic64_read(&map->sum_sq_unmap);\n\n\t\t/* average latency */\n\t\tmap->bparam.avg_map_100ns = div64_u64(sum_map, loops);\n\t\tmap->bparam.avg_unmap_100ns = div64_u64(sum_unmap, loops);\n\n\t\t/* standard deviation of latency */\n\t\tmap_variance = div64_u64(sum_sq_map, loops) -\n\t\t\t\tmap->bparam.avg_map_100ns *\n\t\t\t\tmap->bparam.avg_map_100ns;\n\t\tunmap_variance = div64_u64(sum_sq_unmap, loops) -\n\t\t\t\tmap->bparam.avg_unmap_100ns *\n\t\t\t\tmap->bparam.avg_unmap_100ns;\n\t\tmap->bparam.map_stddev = int_sqrt64(map_variance);\n\t\tmap->bparam.unmap_stddev = int_sqrt64(unmap_variance);\n\t}\n\nout:\n\tfor (i = 0; i < threads; i++)\n\t\tput_task_struct(tsk[i]);\n\tput_device(map->dev);\n\tkfree(tsk);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/timekeeping.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/device.h>",
            "#include <linux/delay.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic int do_map_benchmark(struct map_benchmark_data *map)\n{\n\tstruct task_struct **tsk;\n\tint threads = map->bparam.threads;\n\tint node = map->bparam.node;\n\tconst cpumask_t *cpu_mask = cpumask_of_node(node);\n\tu64 loops;\n\tint ret = 0;\n\tint i;\n\n\ttsk = kmalloc_array(threads, sizeof(*tsk), GFP_KERNEL);\n\tif (!tsk)\n\t\treturn -ENOMEM;\n\n\tget_device(map->dev);\n\n\tfor (i = 0; i < threads; i++) {\n\t\ttsk[i] = kthread_create_on_node(map_benchmark_thread, map,\n\t\t\t\tmap->bparam.node, \"dma-map-benchmark/%d\", i);\n\t\tif (IS_ERR(tsk[i])) {\n\t\t\tpr_err(\"create dma_map thread failed\\n\");\n\t\t\tret = PTR_ERR(tsk[i]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (node != NUMA_NO_NODE)\n\t\t\tkthread_bind_mask(tsk[i], cpu_mask);\n\t}\n\n\t/* clear the old value in the previous benchmark */\n\tatomic64_set(&map->sum_map_100ns, 0);\n\tatomic64_set(&map->sum_unmap_100ns, 0);\n\tatomic64_set(&map->sum_sq_map, 0);\n\tatomic64_set(&map->sum_sq_unmap, 0);\n\tatomic64_set(&map->loops, 0);\n\n\tfor (i = 0; i < threads; i++) {\n\t\tget_task_struct(tsk[i]);\n\t\twake_up_process(tsk[i]);\n\t}\n\n\tmsleep_interruptible(map->bparam.seconds * 1000);\n\n\t/* wait for the completion of benchmark threads */\n\tfor (i = 0; i < threads; i++) {\n\t\tret = kthread_stop(tsk[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tloops = atomic64_read(&map->loops);\n\tif (likely(loops > 0)) {\n\t\tu64 map_variance, unmap_variance;\n\t\tu64 sum_map = atomic64_read(&map->sum_map_100ns);\n\t\tu64 sum_unmap = atomic64_read(&map->sum_unmap_100ns);\n\t\tu64 sum_sq_map = atomic64_read(&map->sum_sq_map);\n\t\tu64 sum_sq_unmap = atomic64_read(&map->sum_sq_unmap);\n\n\t\t/* average latency */\n\t\tmap->bparam.avg_map_100ns = div64_u64(sum_map, loops);\n\t\tmap->bparam.avg_unmap_100ns = div64_u64(sum_unmap, loops);\n\n\t\t/* standard deviation of latency */\n\t\tmap_variance = div64_u64(sum_sq_map, loops) -\n\t\t\t\tmap->bparam.avg_map_100ns *\n\t\t\t\tmap->bparam.avg_map_100ns;\n\t\tunmap_variance = div64_u64(sum_sq_unmap, loops) -\n\t\t\t\tmap->bparam.avg_unmap_100ns *\n\t\t\t\tmap->bparam.avg_unmap_100ns;\n\t\tmap->bparam.map_stddev = int_sqrt64(map_variance);\n\t\tmap->bparam.unmap_stddev = int_sqrt64(unmap_variance);\n\t}\n\nout:\n\tfor (i = 0; i < threads; i++)\n\t\tput_task_struct(tsk[i]);\n\tput_device(map->dev);\n\tkfree(tsk);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to set dma_mask on device %s\\n\"",
            "dev_name(map->dev)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "map->dev"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "map->bparam.dma_bits"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_get_mask",
          "args": [
            "map->dev"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid DMA direction\\n\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid granule size\\n\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid numa node\\n\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_possible",
          "args": [
            "map->bparam.node"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid transmission delay\\n\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid duration seconds\\n\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid thread number\\n\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&map->bparam",
            "argp",
            "sizeof(map->bparam)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\n#define DMA_MAP_FROM_DEVICE\t2\n#define DMA_MAP_TO_DEVICE\t1\n#define DMA_MAP_BIDIRECTIONAL\t0\n#define DMA_MAP_MAX_TRANS_DELAY\t(10 * NSEC_PER_MSEC)\n#define DMA_MAP_MAX_SECONDS\t300\n#define DMA_MAP_MAX_THREADS\t1024\n#define DMA_MAP_BENCHMARK\t_IOWR('d', 1, struct map_benchmark)\n\nstatic long map_benchmark_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct map_benchmark_data *map = file->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 old_dma_mask;\n\tint ret;\n\n\tif (copy_from_user(&map->bparam, argp, sizeof(map->bparam)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase DMA_MAP_BENCHMARK:\n\t\tif (map->bparam.threads == 0 ||\n\t\t    map->bparam.threads > DMA_MAP_MAX_THREADS) {\n\t\t\tpr_err(\"invalid thread number\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.seconds == 0 ||\n\t\t    map->bparam.seconds > DMA_MAP_MAX_SECONDS) {\n\t\t\tpr_err(\"invalid duration seconds\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.dma_trans_ns > DMA_MAP_MAX_TRANS_DELAY) {\n\t\t\tpr_err(\"invalid transmission delay\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.node != NUMA_NO_NODE &&\n\t\t    !node_possible(map->bparam.node)) {\n\t\t\tpr_err(\"invalid numa node\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.granule < 1 || map->bparam.granule > 1024) {\n\t\t\tpr_err(\"invalid granule size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (map->bparam.dma_dir) {\n\t\tcase DMA_MAP_BIDIRECTIONAL:\n\t\t\tmap->dir = DMA_BIDIRECTIONAL;\n\t\t\tbreak;\n\t\tcase DMA_MAP_FROM_DEVICE:\n\t\t\tmap->dir = DMA_FROM_DEVICE;\n\t\t\tbreak;\n\t\tcase DMA_MAP_TO_DEVICE:\n\t\t\tmap->dir = DMA_TO_DEVICE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"invalid DMA direction\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\told_dma_mask = dma_get_mask(map->dev);\n\n\t\tret = dma_set_mask(map->dev,\n\t\t\t\t   DMA_BIT_MASK(map->bparam.dma_bits));\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set dma_mask on device %s\\n\",\n\t\t\t\tdev_name(map->dev));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = do_map_benchmark(map);\n\n\t\t/*\n\t\t * restore the original dma_mask as many devices' dma_mask are\n\t\t * set by architectures, acpi, busses. When we bind them back\n\t\t * to their original drivers, those drivers shouldn't see\n\t\t * dma_mask changed by benchmark\n\t\t */\n\t\tdma_set_mask(map->dev, old_dma_mask);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_to_user(argp, &map->bparam, sizeof(map->bparam)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_map_benchmark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
    "lines": "122-201",
    "snippet": "static int do_map_benchmark(struct map_benchmark_data *map)\n{\n\tstruct task_struct **tsk;\n\tint threads = map->bparam.threads;\n\tint node = map->bparam.node;\n\tconst cpumask_t *cpu_mask = cpumask_of_node(node);\n\tu64 loops;\n\tint ret = 0;\n\tint i;\n\n\ttsk = kmalloc_array(threads, sizeof(*tsk), GFP_KERNEL);\n\tif (!tsk)\n\t\treturn -ENOMEM;\n\n\tget_device(map->dev);\n\n\tfor (i = 0; i < threads; i++) {\n\t\ttsk[i] = kthread_create_on_node(map_benchmark_thread, map,\n\t\t\t\tmap->bparam.node, \"dma-map-benchmark/%d\", i);\n\t\tif (IS_ERR(tsk[i])) {\n\t\t\tpr_err(\"create dma_map thread failed\\n\");\n\t\t\tret = PTR_ERR(tsk[i]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (node != NUMA_NO_NODE)\n\t\t\tkthread_bind_mask(tsk[i], cpu_mask);\n\t}\n\n\t/* clear the old value in the previous benchmark */\n\tatomic64_set(&map->sum_map_100ns, 0);\n\tatomic64_set(&map->sum_unmap_100ns, 0);\n\tatomic64_set(&map->sum_sq_map, 0);\n\tatomic64_set(&map->sum_sq_unmap, 0);\n\tatomic64_set(&map->loops, 0);\n\n\tfor (i = 0; i < threads; i++) {\n\t\tget_task_struct(tsk[i]);\n\t\twake_up_process(tsk[i]);\n\t}\n\n\tmsleep_interruptible(map->bparam.seconds * 1000);\n\n\t/* wait for the completion of benchmark threads */\n\tfor (i = 0; i < threads; i++) {\n\t\tret = kthread_stop(tsk[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tloops = atomic64_read(&map->loops);\n\tif (likely(loops > 0)) {\n\t\tu64 map_variance, unmap_variance;\n\t\tu64 sum_map = atomic64_read(&map->sum_map_100ns);\n\t\tu64 sum_unmap = atomic64_read(&map->sum_unmap_100ns);\n\t\tu64 sum_sq_map = atomic64_read(&map->sum_sq_map);\n\t\tu64 sum_sq_unmap = atomic64_read(&map->sum_sq_unmap);\n\n\t\t/* average latency */\n\t\tmap->bparam.avg_map_100ns = div64_u64(sum_map, loops);\n\t\tmap->bparam.avg_unmap_100ns = div64_u64(sum_unmap, loops);\n\n\t\t/* standard deviation of latency */\n\t\tmap_variance = div64_u64(sum_sq_map, loops) -\n\t\t\t\tmap->bparam.avg_map_100ns *\n\t\t\t\tmap->bparam.avg_map_100ns;\n\t\tunmap_variance = div64_u64(sum_sq_unmap, loops) -\n\t\t\t\tmap->bparam.avg_unmap_100ns *\n\t\t\t\tmap->bparam.avg_unmap_100ns;\n\t\tmap->bparam.map_stddev = int_sqrt64(map_variance);\n\t\tmap->bparam.unmap_stddev = int_sqrt64(unmap_variance);\n\t}\n\nout:\n\tfor (i = 0; i < threads; i++)\n\t\tput_task_struct(tsk[i]);\n\tput_device(map->dev);\n\tkfree(tsk);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/timekeeping.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tsk"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_device",
          "args": [
            "map->dev"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "tsk[i]"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "int_sqrt64",
          "args": [
            "unmap_variance"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_sqrt64",
          "args": [
            "map_variance"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "sum_sq_unmap",
            "loops"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "sum_sq_map",
            "loops"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "sum_unmap",
            "loops"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "sum_map",
            "loops"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&map->sum_sq_unmap"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&map->sum_sq_map"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&map->sum_unmap_100ns"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&map->sum_map_100ns"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "loops > 0"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&map->loops"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "tsk[i]"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep_interruptible",
          "args": [
            "map->bparam.seconds * 1000"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "tsk[i]"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "tsk[i]"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&map->loops",
            "0"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&map->sum_sq_unmap",
            "0"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&map->sum_sq_map",
            "0"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&map->sum_unmap_100ns",
            "0"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&map->sum_map_100ns",
            "0"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_bind_mask",
          "args": [
            "tsk[i]",
            "cpu_mask"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_bind_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "541-544",
          "snippet": "void kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tsk[i]"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"create dma_map thread failed\\n\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tsk[i]"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create_on_node",
          "args": [
            "map_benchmark_thread",
            "map",
            "map->bparam.node",
            "\"dma-map-benchmark/%d\"",
            "i"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_on_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "504-517",
          "snippet": "struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;",
            "struct task_struct *task;",
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\nstruct task_struct *task;\nint node = NUMA_NO_NODE;\n\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_device",
          "args": [
            "map->dev"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "rdmacg_get_device_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rdma.c",
          "lines": "412-423",
          "snippet": "static struct rdmacg_device *rdmacg_get_device_locked(const char *name)\n{\n\tstruct rdmacg_device *device;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(device, &rdmacg_devices, dev_node)\n\t\tif (!strcmp(name, device->name))\n\t\t\treturn device;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_rdma.h>",
            "#include <linux/parser.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(rdmacg_mutex);",
            "static LIST_HEAD(rdmacg_devices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_rdma.h>\n#include <linux/parser.h>\n#include <linux/cgroup.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic DEFINE_MUTEX(rdmacg_mutex);\nstatic LIST_HEAD(rdmacg_devices);\n\nstatic struct rdmacg_device *rdmacg_get_device_locked(const char *name)\n{\n\tstruct rdmacg_device *device;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(device, &rdmacg_devices, dev_node)\n\t\tif (!strcmp(name, device->name))\n\t\t\treturn device;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "threads",
            "sizeof(*tsk)",
            "GFP_KERNEL"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "node"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic int do_map_benchmark(struct map_benchmark_data *map)\n{\n\tstruct task_struct **tsk;\n\tint threads = map->bparam.threads;\n\tint node = map->bparam.node;\n\tconst cpumask_t *cpu_mask = cpumask_of_node(node);\n\tu64 loops;\n\tint ret = 0;\n\tint i;\n\n\ttsk = kmalloc_array(threads, sizeof(*tsk), GFP_KERNEL);\n\tif (!tsk)\n\t\treturn -ENOMEM;\n\n\tget_device(map->dev);\n\n\tfor (i = 0; i < threads; i++) {\n\t\ttsk[i] = kthread_create_on_node(map_benchmark_thread, map,\n\t\t\t\tmap->bparam.node, \"dma-map-benchmark/%d\", i);\n\t\tif (IS_ERR(tsk[i])) {\n\t\t\tpr_err(\"create dma_map thread failed\\n\");\n\t\t\tret = PTR_ERR(tsk[i]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (node != NUMA_NO_NODE)\n\t\t\tkthread_bind_mask(tsk[i], cpu_mask);\n\t}\n\n\t/* clear the old value in the previous benchmark */\n\tatomic64_set(&map->sum_map_100ns, 0);\n\tatomic64_set(&map->sum_unmap_100ns, 0);\n\tatomic64_set(&map->sum_sq_map, 0);\n\tatomic64_set(&map->sum_sq_unmap, 0);\n\tatomic64_set(&map->loops, 0);\n\n\tfor (i = 0; i < threads; i++) {\n\t\tget_task_struct(tsk[i]);\n\t\twake_up_process(tsk[i]);\n\t}\n\n\tmsleep_interruptible(map->bparam.seconds * 1000);\n\n\t/* wait for the completion of benchmark threads */\n\tfor (i = 0; i < threads; i++) {\n\t\tret = kthread_stop(tsk[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tloops = atomic64_read(&map->loops);\n\tif (likely(loops > 0)) {\n\t\tu64 map_variance, unmap_variance;\n\t\tu64 sum_map = atomic64_read(&map->sum_map_100ns);\n\t\tu64 sum_unmap = atomic64_read(&map->sum_unmap_100ns);\n\t\tu64 sum_sq_map = atomic64_read(&map->sum_sq_map);\n\t\tu64 sum_sq_unmap = atomic64_read(&map->sum_sq_unmap);\n\n\t\t/* average latency */\n\t\tmap->bparam.avg_map_100ns = div64_u64(sum_map, loops);\n\t\tmap->bparam.avg_unmap_100ns = div64_u64(sum_unmap, loops);\n\n\t\t/* standard deviation of latency */\n\t\tmap_variance = div64_u64(sum_sq_map, loops) -\n\t\t\t\tmap->bparam.avg_map_100ns *\n\t\t\t\tmap->bparam.avg_map_100ns;\n\t\tunmap_variance = div64_u64(sum_sq_unmap, loops) -\n\t\t\t\tmap->bparam.avg_unmap_100ns *\n\t\t\t\tmap->bparam.avg_unmap_100ns;\n\t\tmap->bparam.map_stddev = int_sqrt64(map_variance);\n\t\tmap->bparam.unmap_stddev = int_sqrt64(unmap_variance);\n\t}\n\nout:\n\tfor (i = 0; i < threads; i++)\n\t\tput_task_struct(tsk[i]);\n\tput_device(map->dev);\n\tkfree(tsk);\n\treturn ret;\n}"
  },
  {
    "function_name": "map_benchmark_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/map_benchmark.c",
    "lines": "57-120",
    "snippet": "static int map_benchmark_thread(void *data)\n{\n\tvoid *buf;\n\tdma_addr_t dma_addr;\n\tstruct map_benchmark_data *map = data;\n\tint npages = map->bparam.granule;\n\tu64 size = npages * PAGE_SIZE;\n\tint ret = 0;\n\n\tbuf = alloc_pages_exact(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (!kthread_should_stop())  {\n\t\tu64 map_100ns, unmap_100ns, map_sq, unmap_sq;\n\t\tktime_t map_stime, map_etime, unmap_stime, unmap_etime;\n\t\tktime_t map_delta, unmap_delta;\n\n\t\t/*\n\t\t * for a non-coherent device, if we don't stain them in the\n\t\t * cache, this will give an underestimate of the real-world\n\t\t * overhead of BIDIRECTIONAL or TO_DEVICE mappings;\n\t\t * 66 means evertything goes well! 66 is lucky.\n\t\t */\n\t\tif (map->dir != DMA_FROM_DEVICE)\n\t\t\tmemset(buf, 0x66, size);\n\n\t\tmap_stime = ktime_get();\n\t\tdma_addr = dma_map_single(map->dev, buf, size, map->dir);\n\t\tif (unlikely(dma_mapping_error(map->dev, dma_addr))) {\n\t\t\tpr_err(\"dma_map_single failed on %s\\n\",\n\t\t\t\tdev_name(map->dev));\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmap_etime = ktime_get();\n\t\tmap_delta = ktime_sub(map_etime, map_stime);\n\n\t\t/* Pretend DMA is transmitting */\n\t\tndelay(map->bparam.dma_trans_ns);\n\n\t\tunmap_stime = ktime_get();\n\t\tdma_unmap_single(map->dev, dma_addr, size, map->dir);\n\t\tunmap_etime = ktime_get();\n\t\tunmap_delta = ktime_sub(unmap_etime, unmap_stime);\n\n\t\t/* calculate sum and sum of squares */\n\n\t\tmap_100ns = div64_ul(map_delta,  100);\n\t\tunmap_100ns = div64_ul(unmap_delta, 100);\n\t\tmap_sq = map_100ns * map_100ns;\n\t\tunmap_sq = unmap_100ns * unmap_100ns;\n\n\t\tatomic64_add(map_100ns, &map->sum_map_100ns);\n\t\tatomic64_add(unmap_100ns, &map->sum_unmap_100ns);\n\t\tatomic64_add(map_sq, &map->sum_sq_map);\n\t\tatomic64_add(unmap_sq, &map->sum_sq_unmap);\n\t\tatomic64_inc(&map->loops);\n\t}\n\nout:\n\tfree_pages_exact(buf, size);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/timekeeping.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/math64.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/device.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages_exact",
          "args": [
            "buf",
            "size"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->loops"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "unmap_sq",
            "&map->sum_sq_unmap"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "map_sq",
            "&map->sum_sq_map"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "unmap_100ns",
            "&map->sum_unmap_100ns"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "map_100ns",
            "&map->sum_map_100ns"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_ul",
          "args": [
            "unmap_delta",
            "100"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_ul",
          "args": [
            "map_delta",
            "100"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "unmap_etime",
            "unmap_stime"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_unmap_single",
          "args": [
            "map->dev",
            "dma_addr",
            "size",
            "map->dir"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndelay",
          "args": [
            "map->bparam.dma_trans_ns"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "map_etime",
            "map_stime"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"dma_map_single failed on %s\\n\"",
            "dev_name(map->dev)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "map->dev"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_mapping_error(map->dev, dma_addr)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_mapping_error",
          "args": [
            "map->dev",
            "dma_addr"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_mapping_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1229-1264",
          "snippet": "void debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_map_single",
          "args": [
            "map->dev",
            "buf",
            "size",
            "map->dir"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0x66",
            "size"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_exact",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/timekeeping.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic int map_benchmark_thread(void *data)\n{\n\tvoid *buf;\n\tdma_addr_t dma_addr;\n\tstruct map_benchmark_data *map = data;\n\tint npages = map->bparam.granule;\n\tu64 size = npages * PAGE_SIZE;\n\tint ret = 0;\n\n\tbuf = alloc_pages_exact(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (!kthread_should_stop())  {\n\t\tu64 map_100ns, unmap_100ns, map_sq, unmap_sq;\n\t\tktime_t map_stime, map_etime, unmap_stime, unmap_etime;\n\t\tktime_t map_delta, unmap_delta;\n\n\t\t/*\n\t\t * for a non-coherent device, if we don't stain them in the\n\t\t * cache, this will give an underestimate of the real-world\n\t\t * overhead of BIDIRECTIONAL or TO_DEVICE mappings;\n\t\t * 66 means evertything goes well! 66 is lucky.\n\t\t */\n\t\tif (map->dir != DMA_FROM_DEVICE)\n\t\t\tmemset(buf, 0x66, size);\n\n\t\tmap_stime = ktime_get();\n\t\tdma_addr = dma_map_single(map->dev, buf, size, map->dir);\n\t\tif (unlikely(dma_mapping_error(map->dev, dma_addr))) {\n\t\t\tpr_err(\"dma_map_single failed on %s\\n\",\n\t\t\t\tdev_name(map->dev));\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmap_etime = ktime_get();\n\t\tmap_delta = ktime_sub(map_etime, map_stime);\n\n\t\t/* Pretend DMA is transmitting */\n\t\tndelay(map->bparam.dma_trans_ns);\n\n\t\tunmap_stime = ktime_get();\n\t\tdma_unmap_single(map->dev, dma_addr, size, map->dir);\n\t\tunmap_etime = ktime_get();\n\t\tunmap_delta = ktime_sub(unmap_etime, unmap_stime);\n\n\t\t/* calculate sum and sum of squares */\n\n\t\tmap_100ns = div64_ul(map_delta,  100);\n\t\tunmap_100ns = div64_ul(unmap_delta, 100);\n\t\tmap_sq = map_100ns * map_100ns;\n\t\tunmap_sq = unmap_100ns * unmap_100ns;\n\n\t\tatomic64_add(map_100ns, &map->sum_map_100ns);\n\t\tatomic64_add(unmap_100ns, &map->sum_unmap_100ns);\n\t\tatomic64_add(map_sq, &map->sum_sq_map);\n\t\tatomic64_add(unmap_sq, &map->sum_sq_unmap);\n\t\tatomic64_inc(&map->loops);\n\t}\n\nout:\n\tfree_pages_exact(buf, size);\n\treturn ret;\n}"
  }
]