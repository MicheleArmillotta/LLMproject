[
  {
    "function_name": "dma_debug_driver_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1576-1592",
    "snippet": "static int __init dma_debug_driver_setup(char *str)\n{\n\tint i;\n\n\tfor (i = 0; i < NAME_MAX_LEN - 1; ++i, ++str) {\n\t\tcurrent_driver_name[i] = *str;\n\t\tif (*str == 0)\n\t\t\tbreak;\n\t}\n\n\tif (current_driver_name[0])\n\t\tpr_info(\"enable driver filter for driver [%s]\\n\",\n\t\t\tcurrent_driver_name);\n\n\n\treturn 1;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define NAME_MAX_LEN\t64"
    ],
    "globals_used": [
      "static char                  current_driver_name[NAME_MAX_LEN]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"enable driver filter for driver [%s]\\n\"",
            "current_driver_name"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define NAME_MAX_LEN\t64\n\nstatic char                  current_driver_name[NAME_MAX_LEN];\n\nstatic int __init dma_debug_driver_setup(char *str)\n{\n\tint i;\n\n\tfor (i = 0; i < NAME_MAX_LEN - 1; ++i, ++str) {\n\t\tcurrent_driver_name[i] = *str;\n\t\tif (*str == 0)\n\t\t\tbreak;\n\t}\n\n\tif (current_driver_name[0])\n\t\tpr_info(\"enable driver filter for driver [%s]\\n\",\n\t\t\tcurrent_driver_name);\n\n\n\treturn 1;\n}"
  },
  {
    "function_name": "debug_dma_sync_sg_for_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1545-1574",
    "snippet": "void debug_dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,\n\t\t\t\t  int nelems, int direction)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = direction,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tif (i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tcheck_sync(dev, &ref, false);\n\t}\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_sync",
          "args": [
            "dev",
            "&ref",
            "false"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "check_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1076-1149",
          "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_mapped_entries",
          "args": [
            "dev",
            "&ref"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_mapped_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1321-1338",
          "snippet": "static int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, flags);\n\n\treturn mapped_ents;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, flags);\n\n\treturn mapped_ents;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "s"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "s"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "sg_page(s)"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sg",
            "s",
            "nelems",
            "i"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,\n\t\t\t\t  int nelems, int direction)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = direction,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tif (i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tcheck_sync(dev, &ref, false);\n\t}\n}"
  },
  {
    "function_name": "debug_dma_sync_sg_for_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1513-1543",
    "snippet": "void debug_dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,\n\t\t\t       int nelems, int direction)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = direction,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tif (i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tcheck_sync(dev, &ref, true);\n\t}\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_sync",
          "args": [
            "dev",
            "&ref",
            "true"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "check_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1076-1149",
          "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_mapped_entries",
          "args": [
            "dev",
            "&ref"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_mapped_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1321-1338",
          "snippet": "static int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, flags);\n\n\treturn mapped_ents;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, flags);\n\n\treturn mapped_ents;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "s"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "s"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "sg_page(s)"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sg",
            "s",
            "nelems",
            "i"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,\n\t\t\t       int nelems, int direction)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = direction,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tif (i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tcheck_sync(dev, &ref, true);\n\t}\n}"
  },
  {
    "function_name": "debug_dma_sync_single_for_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1494-1511",
    "snippet": "void debug_dma_sync_single_for_device(struct device *dev,\n\t\t\t\t      dma_addr_t dma_handle, size_t size,\n\t\t\t\t      int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, false);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_sync",
          "args": [
            "dev",
            "&ref",
            "false"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "check_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1076-1149",
          "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_sync_single_for_device(struct device *dev,\n\t\t\t\t      dma_addr_t dma_handle, size_t size,\n\t\t\t\t      int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, false);\n}"
  },
  {
    "function_name": "debug_dma_sync_single_for_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1476-1492",
    "snippet": "void debug_dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,\n\t\t\t\t   size_t size, int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, true);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_sync",
          "args": [
            "dev",
            "&ref",
            "true"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "check_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1076-1149",
          "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,\n\t\t\t\t   size_t size, int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, true);\n}"
  },
  {
    "function_name": "debug_dma_unmap_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1459-1474",
    "snippet": "void debug_dma_unmap_resource(struct device *dev, dma_addr_t dma_addr,\n\t\t\t      size_t size, int direction)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_resource,\n\t\t.dev            = dev,\n\t\t.dev_addr       = dma_addr,\n\t\t.size           = size,\n\t\t.direction      = direction,\n\t};\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tcheck_unmap(&ref);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_unmap",
          "args": [
            "&ref"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "check_unmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "945-1039",
          "snippet": "static void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/core-api/dma-api.rst.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};",
            "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/core-api/dma-api.rst.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_unmap_resource(struct device *dev, dma_addr_t dma_addr,\n\t\t\t      size_t size, int direction)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_resource,\n\t\t.dev            = dev,\n\t\t.dev_addr       = dma_addr,\n\t\t.size           = size,\n\t\t.direction      = direction,\n\t};\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tcheck_unmap(&ref);\n}"
  },
  {
    "function_name": "debug_dma_map_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1434-1457",
    "snippet": "void debug_dma_map_resource(struct device *dev, phys_addr_t addr, size_t size,\n\t\t\t    int direction, dma_addr_t dma_addr,\n\t\t\t    unsigned long attrs)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->type\t\t= dma_debug_resource;\n\tentry->dev\t\t= dev;\n\tentry->pfn\t\t= PHYS_PFN(addr);\n\tentry->offset\t\t= offset_in_page(addr);\n\tentry->size\t\t= size;\n\tentry->dev_addr\t\t= dma_addr;\n\tentry->direction\t= direction;\n\tentry->map_err_type\t= MAP_ERR_NOT_CHECKED;\n\n\tadd_dma_entry(entry, attrs);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_dma_entry",
          "args": [
            "entry",
            "attrs"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "add_dma_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "555-573",
          "snippet": "static void add_dma_entry(struct dma_debug_entry *entry, unsigned long attrs)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t} else if (rc == -EEXIST && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {\n\t\terr_printk(entry->dev, entry,\n\t\t\t\"cacheline tracking EEXIST, overlapping mappings aren't supported\\n\");\n\t}\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic void add_dma_entry(struct dma_debug_entry *entry, unsigned long attrs)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t} else if (rc == -EEXIST && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {\n\t\terr_printk(entry->dev, entry,\n\t\t\t\"cacheline tracking EEXIST, overlapping mappings aren't supported\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "addr"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "addr"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_entry_alloc",
          "args": [],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "dma_entry_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "625-651",
          "snippet": "static struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tif (num_free_entries == 0) {\n\t\tif (dma_debug_create_entries(GFP_ATOMIC)) {\n\t\t\tglobal_disable = true;\n\t\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\t\tpr_err(\"debugging out of memory - disabling\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t__dma_entry_alloc_check_leak();\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stack_len = stack_trace_save(entry->stack_entries,\n\t\t\t\t\t    ARRAY_SIZE(entry->stack_entries),\n\t\t\t\t\t    1);\n#endif\n\treturn entry;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;",
            "static DEFINE_SPINLOCK(free_entries_lock);",
            "static bool global_disable",
            "static u32 num_free_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstruct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic bool global_disable;\nstatic u32 num_free_entries;\n\nstatic struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tif (num_free_entries == 0) {\n\t\tif (dma_debug_create_entries(GFP_ATOMIC)) {\n\t\t\tglobal_disable = true;\n\t\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\t\tpr_err(\"debugging out of memory - disabling\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t__dma_entry_alloc_check_leak();\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stack_len = stack_trace_save(entry->stack_entries,\n\t\t\t\t\t    ARRAY_SIZE(entry->stack_entries),\n\t\t\t\t\t    1);\n#endif\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_map_resource(struct device *dev, phys_addr_t addr, size_t size,\n\t\t\t    int direction, dma_addr_t dma_addr,\n\t\t\t    unsigned long attrs)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->type\t\t= dma_debug_resource;\n\tentry->dev\t\t= dev;\n\tentry->pfn\t\t= PHYS_PFN(addr);\n\tentry->offset\t\t= offset_in_page(addr);\n\tentry->size\t\t= size;\n\tentry->dev_addr\t\t= dma_addr;\n\tentry->direction\t= direction;\n\tentry->map_err_type\t= MAP_ERR_NOT_CHECKED;\n\n\tadd_dma_entry(entry, attrs);\n}"
  },
  {
    "function_name": "debug_dma_free_coherent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1407-1432",
    "snippet": "void debug_dma_free_coherent(struct device *dev, size_t size,\n\t\t\t void *virt, dma_addr_t addr)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_coherent,\n\t\t.dev            = dev,\n\t\t.offset\t\t= offset_in_page(virt),\n\t\t.dev_addr       = addr,\n\t\t.size           = size,\n\t\t.direction      = DMA_BIDIRECTIONAL,\n\t};\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tif (is_vmalloc_addr(virt))\n\t\tref.pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tref.pfn = page_to_pfn(virt_to_page(virt));\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tcheck_unmap(&ref);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_unmap",
          "args": [
            "&ref"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "check_unmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "945-1039",
          "snippet": "static void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/core-api/dma-api.rst.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};",
            "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/core-api/dma-api.rst.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "virt_to_page(virt)"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "virt"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_pfn",
          "args": [
            "virt"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "virt"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_addr_valid",
          "args": [
            "virt"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "virt"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "virt"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_free_coherent(struct device *dev, size_t size,\n\t\t\t void *virt, dma_addr_t addr)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_coherent,\n\t\t.dev            = dev,\n\t\t.offset\t\t= offset_in_page(virt),\n\t\t.dev_addr       = addr,\n\t\t.size           = size,\n\t\t.direction      = DMA_BIDIRECTIONAL,\n\t};\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tif (is_vmalloc_addr(virt))\n\t\tref.pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tref.pfn = page_to_pfn(virt_to_page(virt));\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tcheck_unmap(&ref);\n}"
  },
  {
    "function_name": "debug_dma_alloc_coherent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1372-1405",
    "snippet": "void debug_dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t      dma_addr_t dma_addr, void *virt,\n\t\t\t      unsigned long attrs)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (unlikely(virt == NULL))\n\t\treturn;\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->type      = dma_debug_coherent;\n\tentry->dev       = dev;\n\tentry->offset\t = offset_in_page(virt);\n\tentry->size      = size;\n\tentry->dev_addr  = dma_addr;\n\tentry->direction = DMA_BIDIRECTIONAL;\n\n\tif (is_vmalloc_addr(virt))\n\t\tentry->pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tentry->pfn = page_to_pfn(virt_to_page(virt));\n\n\tadd_dma_entry(entry, attrs);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_dma_entry",
          "args": [
            "entry",
            "attrs"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "add_dma_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "555-573",
          "snippet": "static void add_dma_entry(struct dma_debug_entry *entry, unsigned long attrs)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t} else if (rc == -EEXIST && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {\n\t\terr_printk(entry->dev, entry,\n\t\t\t\"cacheline tracking EEXIST, overlapping mappings aren't supported\\n\");\n\t}\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic void add_dma_entry(struct dma_debug_entry *entry, unsigned long attrs)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t} else if (rc == -EEXIST && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {\n\t\terr_printk(entry->dev, entry,\n\t\t\t\"cacheline tracking EEXIST, overlapping mappings aren't supported\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "virt_to_page(virt)"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "virt"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_pfn",
          "args": [
            "virt"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "virt"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "virt"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_entry_alloc",
          "args": [],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "dma_entry_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "625-651",
          "snippet": "static struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tif (num_free_entries == 0) {\n\t\tif (dma_debug_create_entries(GFP_ATOMIC)) {\n\t\t\tglobal_disable = true;\n\t\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\t\tpr_err(\"debugging out of memory - disabling\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t__dma_entry_alloc_check_leak();\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stack_len = stack_trace_save(entry->stack_entries,\n\t\t\t\t\t    ARRAY_SIZE(entry->stack_entries),\n\t\t\t\t\t    1);\n#endif\n\treturn entry;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;",
            "static DEFINE_SPINLOCK(free_entries_lock);",
            "static bool global_disable",
            "static u32 num_free_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstruct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic bool global_disable;\nstatic u32 num_free_entries;\n\nstatic struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tif (num_free_entries == 0) {\n\t\tif (dma_debug_create_entries(GFP_ATOMIC)) {\n\t\t\tglobal_disable = true;\n\t\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\t\tpr_err(\"debugging out of memory - disabling\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t__dma_entry_alloc_check_leak();\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stack_len = stack_trace_save(entry->stack_entries,\n\t\t\t\t\t    ARRAY_SIZE(entry->stack_entries),\n\t\t\t\t\t    1);\n#endif\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_addr_valid",
          "args": [
            "virt"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "virt"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "virt == NULL"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t      dma_addr_t dma_addr, void *virt,\n\t\t\t      unsigned long attrs)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (unlikely(virt == NULL))\n\t\treturn;\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->type      = dma_debug_coherent;\n\tentry->dev       = dev;\n\tentry->offset\t = offset_in_page(virt);\n\tentry->size      = size;\n\tentry->dev_addr  = dma_addr;\n\tentry->direction = DMA_BIDIRECTIONAL;\n\n\tif (is_vmalloc_addr(virt))\n\t\tentry->pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tentry->pfn = page_to_pfn(virt_to_page(virt));\n\n\tadd_dma_entry(entry, attrs);\n}"
  },
  {
    "function_name": "debug_dma_unmap_sg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1340-1370",
    "snippet": "void debug_dma_unmap_sg(struct device *dev, struct scatterlist *sglist,\n\t\t\tint nelems, int dir)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sglist, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = dir,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\n\t\tif (mapped_ents && i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tcheck_unmap(&ref);\n\t}\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_unmap",
          "args": [
            "&ref"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "check_unmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "945-1039",
          "snippet": "static void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/core-api/dma-api.rst.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};",
            "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/core-api/dma-api.rst.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_mapped_entries",
          "args": [
            "dev",
            "&ref"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_mapped_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1321-1338",
          "snippet": "static int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, flags);\n\n\treturn mapped_ents;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, flags);\n\n\treturn mapped_ents;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "s"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "s"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "sg_page(s)"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sglist",
            "s",
            "nelems",
            "i"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_unmap_sg(struct device *dev, struct scatterlist *sglist,\n\t\t\tint nelems, int dir)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sglist, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = dir,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\n\t\tif (mapped_ents && i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tcheck_unmap(&ref);\n\t}\n}"
  },
  {
    "function_name": "get_nr_mapped_entries",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1321-1338",
    "snippet": "static int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, flags);\n\n\treturn mapped_ents;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "bucket",
            "flags"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "263-268",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_find_exact",
          "args": [
            "bucket",
            "ref"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "bucket_find_exact",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "342-346",
          "snippet": "static struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "ref",
            "&flags"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "248-258",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, flags);\n\n\treturn mapped_ents;\n}"
  },
  {
    "function_name": "debug_dma_map_sg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1283-1319",
    "snippet": "void debug_dma_map_sg(struct device *dev, struct scatterlist *sg,\n\t\t      int nents, int mapped_ents, int direction,\n\t\t      unsigned long attrs)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct scatterlist *s;\n\tint i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, nents, i) {\n\t\tcheck_for_stack(dev, sg_page(s), s->offset);\n\t\tif (!PageHighMem(sg_page(s)))\n\t\t\tcheck_for_illegal_area(dev, sg_virt(s), s->length);\n\t}\n\n\tfor_each_sg(sg, s, mapped_ents, i) {\n\t\tentry = dma_entry_alloc();\n\t\tif (!entry)\n\t\t\treturn;\n\n\t\tentry->type           = dma_debug_sg;\n\t\tentry->dev            = dev;\n\t\tentry->pfn\t      = page_to_pfn(sg_page(s));\n\t\tentry->offset\t      = s->offset;\n\t\tentry->size           = sg_dma_len(s);\n\t\tentry->dev_addr       = sg_dma_address(s);\n\t\tentry->direction      = direction;\n\t\tentry->sg_call_ents   = nents;\n\t\tentry->sg_mapped_ents = mapped_ents;\n\n\t\tcheck_sg_segment(dev, s);\n\n\t\tadd_dma_entry(entry, attrs);\n\t}\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_dma_entry",
          "args": [
            "entry",
            "attrs"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "add_dma_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "555-573",
          "snippet": "static void add_dma_entry(struct dma_debug_entry *entry, unsigned long attrs)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t} else if (rc == -EEXIST && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {\n\t\terr_printk(entry->dev, entry,\n\t\t\t\"cacheline tracking EEXIST, overlapping mappings aren't supported\\n\");\n\t}\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic void add_dma_entry(struct dma_debug_entry *entry, unsigned long attrs)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t} else if (rc == -EEXIST && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {\n\t\terr_printk(entry->dev, entry,\n\t\t\t\"cacheline tracking EEXIST, overlapping mappings aren't supported\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_sg_segment",
          "args": [
            "dev",
            "s"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "check_sg_segment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1151-1175",
          "snippet": "static void check_sg_segment(struct device *dev, struct scatterlist *sg)\n{\n#ifdef CONFIG_DMA_API_DEBUG_SG\n\tunsigned int max_seg = dma_get_max_seg_size(dev);\n\tu64 start, end, boundary = dma_get_seg_boundary(dev);\n\n\t/*\n\t * Either the driver forgot to set dma_parms appropriately, or\n\t * whoever generated the list forgot to check them.\n\t */\n\tif (sg->length > max_seg)\n\t\terr_printk(dev, NULL, \"mapping sg segment longer than device claims to support [len=%u] [max=%u]\\n\",\n\t\t\t   sg->length, max_seg);\n\t/*\n\t * In some cases this could potentially be the DMA API\n\t * implementation's fault, but it would usually imply that\n\t * the scatterlist was built inappropriately to begin with.\n\t */\n\tstart = sg_dma_address(sg);\n\tend = start + sg_dma_len(sg) - 1;\n\tif ((start ^ end) & ~boundary)\n\t\terr_printk(dev, NULL, \"mapping sg segment across boundary [start=0x%016llx] [end=0x%016llx] [boundary=0x%016llx]\\n\",\n\t\t\t   start, end, boundary);\n#endif\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_sg_segment(struct device *dev, struct scatterlist *sg)\n{\n#ifdef CONFIG_DMA_API_DEBUG_SG\n\tunsigned int max_seg = dma_get_max_seg_size(dev);\n\tu64 start, end, boundary = dma_get_seg_boundary(dev);\n\n\t/*\n\t * Either the driver forgot to set dma_parms appropriately, or\n\t * whoever generated the list forgot to check them.\n\t */\n\tif (sg->length > max_seg)\n\t\terr_printk(dev, NULL, \"mapping sg segment longer than device claims to support [len=%u] [max=%u]\\n\",\n\t\t\t   sg->length, max_seg);\n\t/*\n\t * In some cases this could potentially be the DMA API\n\t * implementation's fault, but it would usually imply that\n\t * the scatterlist was built inappropriately to begin with.\n\t */\n\tstart = sg_dma_address(sg);\n\tend = start + sg_dma_len(sg) - 1;\n\tif ((start ^ end) & ~boundary)\n\t\terr_printk(dev, NULL, \"mapping sg segment across boundary [start=0x%016llx] [end=0x%016llx] [boundary=0x%016llx]\\n\",\n\t\t\t   start, end, boundary);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "s"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "s"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "sg_page(s)"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_entry_alloc",
          "args": [],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "dma_entry_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "625-651",
          "snippet": "static struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tif (num_free_entries == 0) {\n\t\tif (dma_debug_create_entries(GFP_ATOMIC)) {\n\t\t\tglobal_disable = true;\n\t\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\t\tpr_err(\"debugging out of memory - disabling\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t__dma_entry_alloc_check_leak();\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stack_len = stack_trace_save(entry->stack_entries,\n\t\t\t\t\t    ARRAY_SIZE(entry->stack_entries),\n\t\t\t\t\t    1);\n#endif\n\treturn entry;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;",
            "static DEFINE_SPINLOCK(free_entries_lock);",
            "static bool global_disable",
            "static u32 num_free_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstruct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic bool global_disable;\nstatic u32 num_free_entries;\n\nstatic struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tif (num_free_entries == 0) {\n\t\tif (dma_debug_create_entries(GFP_ATOMIC)) {\n\t\t\tglobal_disable = true;\n\t\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\t\tpr_err(\"debugging out of memory - disabling\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t__dma_entry_alloc_check_leak();\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stack_len = stack_trace_save(entry->stack_entries,\n\t\t\t\t\t    ARRAY_SIZE(entry->stack_entries),\n\t\t\t\t\t    1);\n#endif\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sg",
            "s",
            "mapped_ents",
            "i"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_illegal_area",
          "args": [
            "dev",
            "sg_virt(s)",
            "s->length"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_illegal_area",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1069-1074",
          "snippet": "static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (memory_intersects(_stext, _etext, addr, len) ||\n\t    memory_intersects(__start_rodata, __end_rodata, addr, len))\n\t\terr_printk(dev, NULL, \"device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (memory_intersects(_stext, _etext, addr, len) ||\n\t    memory_intersects(__start_rodata, __end_rodata, addr, len))\n\t\terr_printk(dev, NULL, \"device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_virt",
          "args": [
            "s"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "sg_page(s)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_stack",
          "args": [
            "dev",
            "sg_page(s)",
            "s->offset"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1041-1067",
          "snippet": "static void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sg",
            "s",
            "nents",
            "i"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_map_sg(struct device *dev, struct scatterlist *sg,\n\t\t      int nents, int mapped_ents, int direction,\n\t\t      unsigned long attrs)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct scatterlist *s;\n\tint i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, nents, i) {\n\t\tcheck_for_stack(dev, sg_page(s), s->offset);\n\t\tif (!PageHighMem(sg_page(s)))\n\t\t\tcheck_for_illegal_area(dev, sg_virt(s), s->length);\n\t}\n\n\tfor_each_sg(sg, s, mapped_ents, i) {\n\t\tentry = dma_entry_alloc();\n\t\tif (!entry)\n\t\t\treturn;\n\n\t\tentry->type           = dma_debug_sg;\n\t\tentry->dev            = dev;\n\t\tentry->pfn\t      = page_to_pfn(sg_page(s));\n\t\tentry->offset\t      = s->offset;\n\t\tentry->size           = sg_dma_len(s);\n\t\tentry->dev_addr       = sg_dma_address(s);\n\t\tentry->direction      = direction;\n\t\tentry->sg_call_ents   = nents;\n\t\tentry->sg_mapped_ents = mapped_ents;\n\n\t\tcheck_sg_segment(dev, s);\n\n\t\tadd_dma_entry(entry, attrs);\n\t}\n}"
  },
  {
    "function_name": "debug_dma_unmap_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1267-1281",
    "snippet": "void debug_dma_unmap_page(struct device *dev, dma_addr_t addr,\n\t\t\t  size_t size, int direction)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_single,\n\t\t.dev            = dev,\n\t\t.dev_addr       = addr,\n\t\t.size           = size,\n\t\t.direction      = direction,\n\t};\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\tcheck_unmap(&ref);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_unmap",
          "args": [
            "&ref"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "check_unmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "945-1039",
          "snippet": "static void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/core-api/dma-api.rst.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};",
            "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/core-api/dma-api.rst.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_unmap_page(struct device *dev, dma_addr_t addr,\n\t\t\t  size_t size, int direction)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_single,\n\t\t.dev            = dev,\n\t\t.dev_addr       = addr,\n\t\t.size           = size,\n\t\t.direction      = direction,\n\t};\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\tcheck_unmap(&ref);\n}"
  },
  {
    "function_name": "debug_dma_mapping_error",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1229-1264",
    "snippet": "void debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, flags);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "bucket",
            "flags"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "263-268",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exact_match",
          "args": [
            "&ref",
            "entry"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "exact_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "270-274",
          "snippet": "static bool exact_match(struct dma_debug_entry *a, struct dma_debug_entry *b)\n{\n\treturn ((a->dev_addr == b->dev_addr) &&\n\t\t(a->dev == b->dev)) ? true : false;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool exact_match(struct dma_debug_entry *a, struct dma_debug_entry *b)\n{\n\treturn ((a->dev_addr == b->dev_addr) &&\n\t\t(a->dev == b->dev)) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&bucket->list",
            "list"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "&ref",
            "&flags"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "248-258",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, flags);\n}"
  },
  {
    "function_name": "debug_dma_map_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1193-1227",
    "snippet": "void debug_dma_map_page(struct device *dev, struct page *page, size_t offset,\n\t\t\tsize_t size, int direction, dma_addr_t dma_addr,\n\t\t\tunsigned long attrs)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (dma_mapping_error(dev, dma_addr))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->dev       = dev;\n\tentry->type      = dma_debug_single;\n\tentry->pfn\t = page_to_pfn(page);\n\tentry->offset\t = offset;\n\tentry->dev_addr  = dma_addr;\n\tentry->size      = size;\n\tentry->direction = direction;\n\tentry->map_err_type = MAP_ERR_NOT_CHECKED;\n\n\tcheck_for_stack(dev, page, offset);\n\n\tif (!PageHighMem(page)) {\n\t\tvoid *addr = page_address(page) + offset;\n\n\t\tcheck_for_illegal_area(dev, addr, size);\n\t}\n\n\tadd_dma_entry(entry, attrs);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_dma_entry",
          "args": [
            "entry",
            "attrs"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "add_dma_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "555-573",
          "snippet": "static void add_dma_entry(struct dma_debug_entry *entry, unsigned long attrs)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t} else if (rc == -EEXIST && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {\n\t\terr_printk(entry->dev, entry,\n\t\t\t\"cacheline tracking EEXIST, overlapping mappings aren't supported\\n\");\n\t}\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic void add_dma_entry(struct dma_debug_entry *entry, unsigned long attrs)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t} else if (rc == -EEXIST && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {\n\t\terr_printk(entry->dev, entry,\n\t\t\t\"cacheline tracking EEXIST, overlapping mappings aren't supported\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_for_illegal_area",
          "args": [
            "dev",
            "addr",
            "size"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_illegal_area",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1069-1074",
          "snippet": "static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (memory_intersects(_stext, _etext, addr, len) ||\n\t    memory_intersects(__start_rodata, __end_rodata, addr, len))\n\t\terr_printk(dev, NULL, \"device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (memory_intersects(_stext, _etext, addr, len) ||\n\t    memory_intersects(__start_rodata, __end_rodata, addr, len))\n\t\terr_printk(dev, NULL, \"device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_stack",
          "args": [
            "dev",
            "page",
            "offset"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1041-1067",
          "snippet": "static void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_entry_alloc",
          "args": [],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "dma_entry_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "625-651",
          "snippet": "static struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tif (num_free_entries == 0) {\n\t\tif (dma_debug_create_entries(GFP_ATOMIC)) {\n\t\t\tglobal_disable = true;\n\t\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\t\tpr_err(\"debugging out of memory - disabling\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t__dma_entry_alloc_check_leak();\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stack_len = stack_trace_save(entry->stack_entries,\n\t\t\t\t\t    ARRAY_SIZE(entry->stack_entries),\n\t\t\t\t\t    1);\n#endif\n\treturn entry;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;",
            "static DEFINE_SPINLOCK(free_entries_lock);",
            "static bool global_disable",
            "static u32 num_free_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstruct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic bool global_disable;\nstatic u32 num_free_entries;\n\nstatic struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tif (num_free_entries == 0) {\n\t\tif (dma_debug_create_entries(GFP_ATOMIC)) {\n\t\t\tglobal_disable = true;\n\t\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\t\tpr_err(\"debugging out of memory - disabling\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t__dma_entry_alloc_check_leak();\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stack_len = stack_trace_save(entry->stack_entries,\n\t\t\t\t\t    ARRAY_SIZE(entry->stack_entries),\n\t\t\t\t\t    1);\n#endif\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_mapping_error",
          "args": [
            "dev",
            "dma_addr"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_mapping_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1229-1264",
          "snippet": "void debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_map_page(struct device *dev, struct page *page, size_t offset,\n\t\t\tsize_t size, int direction, dma_addr_t dma_addr,\n\t\t\tunsigned long attrs)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (dma_mapping_error(dev, dma_addr))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->dev       = dev;\n\tentry->type      = dma_debug_single;\n\tentry->pfn\t = page_to_pfn(page);\n\tentry->offset\t = offset;\n\tentry->dev_addr  = dma_addr;\n\tentry->size      = size;\n\tentry->direction = direction;\n\tentry->map_err_type = MAP_ERR_NOT_CHECKED;\n\n\tcheck_for_stack(dev, page, offset);\n\n\tif (!PageHighMem(page)) {\n\t\tvoid *addr = page_address(page) + offset;\n\n\t\tcheck_for_illegal_area(dev, addr, size);\n\t}\n\n\tadd_dma_entry(entry, attrs);\n}"
  },
  {
    "function_name": "debug_dma_map_single",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1177-1190",
    "snippet": "void debug_dma_map_single(struct device *dev, const void *addr,\n\t\t\t    unsigned long len)\n{\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (!virt_addr_valid(addr))\n\t\terr_printk(dev, NULL, \"device driver maps memory from invalid area [addr=%p] [len=%lu]\\n\",\n\t\t\t   addr, len);\n\n\tif (is_vmalloc_addr(addr))\n\t\terr_printk(dev, NULL, \"device driver maps memory from vmalloc area [addr=%p] [len=%lu]\\n\",\n\t\t\t   addr, len);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"device driver maps memory from vmalloc area [addr=%p] [len=%lu]\\n\"",
            "addr",
            "len"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "addr"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"device driver maps memory from invalid area [addr=%p] [len=%lu]\\n\"",
            "addr",
            "len"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_addr_valid",
          "args": [
            "addr"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_map_single(struct device *dev, const void *addr,\n\t\t\t    unsigned long len)\n{\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (!virt_addr_valid(addr))\n\t\terr_printk(dev, NULL, \"device driver maps memory from invalid area [addr=%p] [len=%lu]\\n\",\n\t\t\t   addr, len);\n\n\tif (is_vmalloc_addr(addr))\n\t\terr_printk(dev, NULL, \"device driver maps memory from vmalloc area [addr=%p] [len=%lu]\\n\",\n\t\t\t   addr, len);\n}"
  },
  {
    "function_name": "check_sg_segment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1151-1175",
    "snippet": "static void check_sg_segment(struct device *dev, struct scatterlist *sg)\n{\n#ifdef CONFIG_DMA_API_DEBUG_SG\n\tunsigned int max_seg = dma_get_max_seg_size(dev);\n\tu64 start, end, boundary = dma_get_seg_boundary(dev);\n\n\t/*\n\t * Either the driver forgot to set dma_parms appropriately, or\n\t * whoever generated the list forgot to check them.\n\t */\n\tif (sg->length > max_seg)\n\t\terr_printk(dev, NULL, \"mapping sg segment longer than device claims to support [len=%u] [max=%u]\\n\",\n\t\t\t   sg->length, max_seg);\n\t/*\n\t * In some cases this could potentially be the DMA API\n\t * implementation's fault, but it would usually imply that\n\t * the scatterlist was built inappropriately to begin with.\n\t */\n\tstart = sg_dma_address(sg);\n\tend = start + sg_dma_len(sg) - 1;\n\tif ((start ^ end) & ~boundary)\n\t\terr_printk(dev, NULL, \"mapping sg segment across boundary [start=0x%016llx] [end=0x%016llx] [boundary=0x%016llx]\\n\",\n\t\t\t   start, end, boundary);\n#endif\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"mapping sg segment across boundary [start=0x%016llx] [end=0x%016llx] [boundary=0x%016llx]\\n\"",
            "start",
            "end",
            "boundary"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "sg"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "sg"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"mapping sg segment longer than device claims to support [len=%u] [max=%u]\\n\"",
            "sg->length",
            "max_seg"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_get_seg_boundary",
          "args": [
            "dev"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_get_max_seg_size",
          "args": [
            "dev"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_sg_segment(struct device *dev, struct scatterlist *sg)\n{\n#ifdef CONFIG_DMA_API_DEBUG_SG\n\tunsigned int max_seg = dma_get_max_seg_size(dev);\n\tu64 start, end, boundary = dma_get_seg_boundary(dev);\n\n\t/*\n\t * Either the driver forgot to set dma_parms appropriately, or\n\t * whoever generated the list forgot to check them.\n\t */\n\tif (sg->length > max_seg)\n\t\terr_printk(dev, NULL, \"mapping sg segment longer than device claims to support [len=%u] [max=%u]\\n\",\n\t\t\t   sg->length, max_seg);\n\t/*\n\t * In some cases this could potentially be the DMA API\n\t * implementation's fault, but it would usually imply that\n\t * the scatterlist was built inappropriately to begin with.\n\t */\n\tstart = sg_dma_address(sg);\n\tend = start + sg_dma_len(sg) - 1;\n\tif ((start ^ end) & ~boundary)\n\t\terr_printk(dev, NULL, \"mapping sg segment across boundary [start=0x%016llx] [end=0x%016llx] [boundary=0x%016llx]\\n\",\n\t\t\t   start, end, boundary);\n#endif\n}"
  },
  {
    "function_name": "check_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1076-1149",
    "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, flags);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "bucket",
            "flags"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "263-268",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\"",
            "entry->sg_call_ents",
            "ref->sg_call_ents"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "entry",
            "\"device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\"",
            "(unsigned long long)ref->dev_addr",
            "entry->size",
            "dir2name[entry->direction]",
            "dir2name[ref->direction]"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "entry",
            "\"device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\"",
            "(unsigned long long)ref->dev_addr",
            "entry->size",
            "dir2name[entry->direction]",
            "dir2name[ref->direction]"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "entry",
            "\"device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\"",
            "(unsigned long long)ref->dev_addr",
            "entry->size",
            "dir2name[entry->direction]",
            "dir2name[ref->direction]"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "entry",
            "\"device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\"",
            "entry->dev_addr",
            "entry->size",
            "ref->size"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\"",
            "(unsigned long long)ref->dev_addr",
            "ref->size"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_find_contain",
          "args": [
            "&bucket",
            "ref",
            "&flags"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "bucket_find_contain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "348-373",
          "snippet": "static struct dma_debug_entry *bucket_find_contain(struct hash_bucket **bucket,\n\t\t\t\t\t\t   struct dma_debug_entry *ref,\n\t\t\t\t\t\t   unsigned long *flags)\n{\n\n\tunsigned int max_range = dma_get_max_seg_size(ref->dev);\n\tstruct dma_debug_entry *entry, index = *ref;\n\tunsigned int range = 0;\n\n\twhile (range <= max_range) {\n\t\tentry = __hash_bucket_find(*bucket, ref, containing_match);\n\n\t\tif (entry)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * Nothing found, go back a hash bucket\n\t\t */\n\t\tput_hash_bucket(*bucket, *flags);\n\t\trange          += (1 << HASH_FN_SHIFT);\n\t\tindex.dev_addr -= (1 << HASH_FN_SHIFT);\n\t\t*bucket = get_hash_bucket(&index, flags);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define HASH_FN_SHIFT   13"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_FN_SHIFT   13\n\nstatic struct dma_debug_entry *bucket_find_contain(struct hash_bucket **bucket,\n\t\t\t\t\t\t   struct dma_debug_entry *ref,\n\t\t\t\t\t\t   unsigned long *flags)\n{\n\n\tunsigned int max_range = dma_get_max_seg_size(ref->dev);\n\tstruct dma_debug_entry *entry, index = *ref;\n\tunsigned int range = 0;\n\n\twhile (range <= max_range) {\n\t\tentry = __hash_bucket_find(*bucket, ref, containing_match);\n\n\t\tif (entry)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * Nothing found, go back a hash bucket\n\t\t */\n\t\tput_hash_bucket(*bucket, *flags);\n\t\trange          += (1 << HASH_FN_SHIFT);\n\t\tindex.dev_addr -= (1 << HASH_FN_SHIFT);\n\t\t*bucket = get_hash_bucket(&index, flags);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "ref",
            "&flags"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "248-258",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, flags);\n}"
  },
  {
    "function_name": "check_for_illegal_area",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1069-1074",
    "snippet": "static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (memory_intersects(_stext, _etext, addr, len) ||\n\t    memory_intersects(__start_rodata, __end_rodata, addr, len))\n\t\terr_printk(dev, NULL, \"device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\"",
            "addr",
            "len"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_intersects",
          "args": [
            "__start_rodata",
            "__end_rodata",
            "addr",
            "len"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_intersects",
          "args": [
            "_stext",
            "_etext",
            "addr",
            "len"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (memory_intersects(_stext, _etext, addr, len) ||\n\t    memory_intersects(__start_rodata, __end_rodata, addr, len))\n\t\terr_printk(dev, NULL, \"device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}"
  },
  {
    "function_name": "check_for_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "1041-1067",
    "snippet": "static void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"device driver maps memory from stack [probable addr=%p]\\n\"",
            "addr"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"device driver maps memory from stack [addr=%p]\\n\"",
            "addr"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_is_on_stack",
          "args": [
            "addr"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_stack_vm_area",
          "args": [
            "current"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_unmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "945-1039",
    "snippet": "static void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/core-api/dma-api.rst.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, flags);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};",
      "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "bucket",
            "flags"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "263-268",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_entry_free",
          "args": [
            "entry"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "dma_entry_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "653-667",
          "snippet": "static void dma_entry_free(struct dma_debug_entry *entry)\n{\n\tunsigned long flags;\n\n\tactive_cacheline_remove(entry);\n\n\t/*\n\t * add to beginning of the list - this way the entries are\n\t * more likely cache hot when they are reallocated.\n\t */\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tlist_add(&entry->list, &free_entries);\n\tnum_free_entries += 1;\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(free_entries);",
            "static DEFINE_SPINLOCK(free_entries_lock);",
            "static u32 num_free_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic LIST_HEAD(free_entries);\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic u32 num_free_entries;\n\nstatic void dma_entry_free(struct dma_debug_entry *entry)\n{\n\tunsigned long flags;\n\n\tactive_cacheline_remove(entry);\n\n\t/*\n\t * add to beginning of the list - this way the entries are\n\t * more likely cache hot when they are reallocated.\n\t */\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tlist_add(&entry->list, &free_entries);\n\tnum_free_entries += 1;\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_bucket_del",
          "args": [
            "entry"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "hash_bucket_del",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "387-390",
          "snippet": "static void hash_bucket_del(struct dma_debug_entry *entry)\n{\n\tlist_del(&entry->list);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void hash_bucket_del(struct dma_debug_entry *entry)\n{\n\tlist_del(&entry->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\"",
            "ref->dev_addr",
            "ref->size",
            "type2name[entry->type]"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\"",
            "ref->dev_addr",
            "ref->size",
            "dir2name[entry->direction]",
            "dir2name[ref->direction]"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\"",
            "entry->sg_call_ents",
            "ref->sg_call_ents"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\"",
            "ref->dev_addr",
            "ref->size",
            "phys_addr(entry)",
            "phys_addr(ref)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_addr",
          "args": [
            "ref"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "phys_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "392-398",
          "snippet": "static unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\"",
            "ref->dev_addr",
            "ref->size",
            "type2name[entry->type]",
            "type2name[ref->type]"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\"",
            "ref->dev_addr",
            "entry->size",
            "ref->size"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "NULL",
            "\"device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\"",
            "ref->dev_addr",
            "ref->size"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "NULL",
            "\"device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\""
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_mapping_error",
          "args": [
            "ref->dev",
            "ref->dev_addr"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_mapping_error",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "1229-1264",
          "snippet": "void debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_find_exact",
          "args": [
            "bucket",
            "ref"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "bucket_find_exact",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "342-346",
          "snippet": "static struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "ref",
            "&flags"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "248-258",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/core-api/dma-api.rst.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, flags);\n}"
  },
  {
    "function_name": "dma_debug_entries_cmdline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "933-940",
    "snippet": "static __init int dma_debug_entries_cmdline(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\tif (!get_option(&str, &nr_prealloc_entries))\n\t\tnr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;\n\treturn 0;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)"
    ],
    "globals_used": [
      "static u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&nr_prealloc_entries"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)\n\nstatic u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;\n\nstatic __init int dma_debug_entries_cmdline(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\tif (!get_option(&str, &nr_prealloc_entries))\n\t\tnr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_debug_cmdline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "920-931",
    "snippet": "static __init int dma_debug_cmdline(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (strncmp(str, \"off\", 3) == 0) {\n\t\tpr_info(\"debugging disabled on kernel command line\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool global_disable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"debugging disabled on kernel command line\\n\""
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"off\"",
            "3"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic __init int dma_debug_cmdline(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (strncmp(str, \"off\", 3) == 0) {\n\t\tpr_info(\"debugging disabled on kernel command line\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_debug_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "882-917",
    "snippet": "static int dma_debug_init(void)\n{\n\tint i, nr_pages;\n\n\t/* Do not use dma_debug_initialized here, since we really want to be\n\t * called to set dma_debug_initialized\n\t */\n\tif (global_disable)\n\t\treturn 0;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tINIT_LIST_HEAD(&dma_entry_hash[i].list);\n\t\tspin_lock_init(&dma_entry_hash[i].lock);\n\t}\n\n\tnr_pages = DIV_ROUND_UP(nr_prealloc_entries, DMA_DEBUG_DYNAMIC_ENTRIES);\n\tfor (i = 0; i < nr_pages; ++i)\n\t\tdma_debug_create_entries(GFP_KERNEL);\n\tif (num_free_entries >= nr_prealloc_entries) {\n\t\tpr_info(\"preallocated %d debug entries\\n\", nr_total_entries);\n\t} else if (num_free_entries > 0) {\n\t\tpr_warn(\"%d debug entries requested but only %d allocated\\n\",\n\t\t\tnr_prealloc_entries, nr_total_entries);\n\t} else {\n\t\tpr_err(\"debugging out of memory error - disabled\\n\");\n\t\tglobal_disable = true;\n\n\t\treturn 0;\n\t}\n\tmin_free_entries = num_free_entries;\n\n\tdma_debug_initialized = true;\n\n\tpr_info(\"debugging enabled by kernel config\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))",
      "#define HASH_SIZE       16384ULL"
    ],
    "globals_used": [
      "static struct hash_bucket dma_entry_hash[HASH_SIZE];",
      "static bool global_disable",
      "static bool dma_debug_initialized",
      "static u32 num_free_entries;",
      "static u32 min_free_entries;",
      "static u32 nr_total_entries;",
      "static u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"debugging enabled by kernel config\\n\""
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"debugging out of memory error - disabled\\n\""
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%d debug entries requested but only %d allocated\\n\"",
            "nr_prealloc_entries",
            "nr_total_entries"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"preallocated %d debug entries\\n\"",
            "nr_total_entries"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_create_entries",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_create_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "575-591",
          "snippet": "static int dma_debug_create_entries(gfp_t gfp)\n{\n\tstruct dma_debug_entry *entry;\n\tint i;\n\n\tentry = (void *)get_zeroed_page(gfp);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < DMA_DEBUG_DYNAMIC_ENTRIES; i++)\n\t\tlist_add_tail(&entry[i].list, &free_entries);\n\n\tnum_free_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\tnr_total_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))"
          ],
          "globals_used": [
            "static LIST_HEAD(free_entries);",
            "static u32 num_free_entries;",
            "static u32 nr_total_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))\n\nstatic LIST_HEAD(free_entries);\nstatic u32 num_free_entries;\nstatic u32 nr_total_entries;\n\nstatic int dma_debug_create_entries(gfp_t gfp)\n{\n\tstruct dma_debug_entry *entry;\n\tint i;\n\n\tentry = (void *)get_zeroed_page(gfp);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < DMA_DEBUG_DYNAMIC_ENTRIES; i++)\n\t\tlist_add_tail(&entry[i].list, &free_entries);\n\n\tnum_free_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\tnr_total_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "nr_prealloc_entries",
            "DMA_DEBUG_DYNAMIC_ENTRIES"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dma_entry_hash[i].lock"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dma_entry_hash[i].list"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))\n#define HASH_SIZE       16384ULL\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\nstatic u32 num_free_entries;\nstatic u32 min_free_entries;\nstatic u32 nr_total_entries;\nstatic u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;\n\nstatic int dma_debug_init(void)\n{\n\tint i, nr_pages;\n\n\t/* Do not use dma_debug_initialized here, since we really want to be\n\t * called to set dma_debug_initialized\n\t */\n\tif (global_disable)\n\t\treturn 0;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tINIT_LIST_HEAD(&dma_entry_hash[i].list);\n\t\tspin_lock_init(&dma_entry_hash[i].lock);\n\t}\n\n\tnr_pages = DIV_ROUND_UP(nr_prealloc_entries, DMA_DEBUG_DYNAMIC_ENTRIES);\n\tfor (i = 0; i < nr_pages; ++i)\n\t\tdma_debug_create_entries(GFP_KERNEL);\n\tif (num_free_entries >= nr_prealloc_entries) {\n\t\tpr_info(\"preallocated %d debug entries\\n\", nr_total_entries);\n\t} else if (num_free_entries > 0) {\n\t\tpr_warn(\"%d debug entries requested but only %d allocated\\n\",\n\t\t\tnr_prealloc_entries, nr_total_entries);\n\t} else {\n\t\tpr_err(\"debugging out of memory error - disabled\\n\");\n\t\tglobal_disable = true;\n\n\t\treturn 0;\n\t}\n\tmin_free_entries = num_free_entries;\n\n\tdma_debug_initialized = true;\n\n\tpr_info(\"debugging enabled by kernel config\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_debug_add_bus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "864-880",
    "snippet": "void dma_debug_add_bus(struct bus_type *bus)\n{\n\tstruct notifier_block *nb;\n\n\tif (dma_debug_disabled())\n\t\treturn;\n\n\tnb = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);\n\tif (nb == NULL) {\n\t\tpr_err(\"dma_debug_add_bus: out of memory\\n\");\n\t\treturn;\n\t}\n\n\tnb->notifier_call = dma_debug_device_change;\n\n\tbus_register_notifier(bus, nb);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_register_notifier",
          "args": [
            "bus",
            "nb"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"dma_debug_add_bus: out of memory\\n\""
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct notifier_block)",
            "GFP_KERNEL"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid dma_debug_add_bus(struct bus_type *bus)\n{\n\tstruct notifier_block *nb;\n\n\tif (dma_debug_disabled())\n\t\treturn;\n\n\tnb = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);\n\tif (nb == NULL) {\n\t\tpr_err(\"dma_debug_add_bus: out of memory\\n\");\n\t\treturn;\n\t}\n\n\tnb->notifier_call = dma_debug_device_change;\n\n\tbus_register_notifier(bus, nb);\n}"
  },
  {
    "function_name": "dma_debug_device_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "834-862",
    "snippet": "static int dma_debug_device_change(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct dma_debug_entry *entry;\n\tint count;\n\n\tif (dma_debug_disabled())\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_UNBOUND_DRIVER:\n\t\tcount = device_dma_allocations(dev, &entry);\n\t\tif (count == 0)\n\t\t\tbreak;\n\t\terr_printk(dev, entry, \"device driver has pending \"\n\t\t\t\t\"DMA allocations while released from device \"\n\t\t\t\t\"[count=%d]\\n\"\n\t\t\t\t\"One of leaked entries details: \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [mapped as %s]\\n\",\n\t\t\tcount, entry->dev_addr, entry->size,\n\t\t\tdir2name[entry->direction], type2name[entry->type]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};",
      "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "entry",
            "\"device driver has pending \"\n\t\t\t\t\"DMA allocations while released from device \"\n\t\t\t\t\"[count=%d]\\n\"\n\t\t\t\t\"One of leaked entries details: \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [mapped as %s]\\n\"",
            "count",
            "entry->dev_addr",
            "entry->size",
            "dir2name[entry->direction]",
            "type2name[entry->type]"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_dma_allocations",
          "args": [
            "dev",
            "&entry"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "device_dma_allocations",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "814-832",
          "snippet": "static int device_dma_allocations(struct device *dev, struct dma_debug_entry **out_entry)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\tint count = 0, i;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tspin_lock_irqsave(&dma_entry_hash[i].lock, flags);\n\t\tlist_for_each_entry(entry, &dma_entry_hash[i].list, list) {\n\t\t\tif (entry->dev == dev) {\n\t\t\t\tcount += 1;\n\t\t\t\t*out_entry = entry;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&dma_entry_hash[i].lock, flags);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define HASH_SIZE       16384ULL"
          ],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_SIZE       16384ULL\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic int device_dma_allocations(struct device *dev, struct dma_debug_entry **out_entry)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\tint count = 0, i;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tspin_lock_irqsave(&dma_entry_hash[i].lock, flags);\n\t\tlist_for_each_entry(entry, &dma_entry_hash[i].list, list) {\n\t\t\tif (entry->dev == dev) {\n\t\t\t\tcount += 1;\n\t\t\t\t*out_entry = entry;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&dma_entry_hash[i].lock, flags);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "104-107",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic int dma_debug_device_change(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct dma_debug_entry *entry;\n\tint count;\n\n\tif (dma_debug_disabled())\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_UNBOUND_DRIVER:\n\t\tcount = device_dma_allocations(dev, &entry);\n\t\tif (count == 0)\n\t\t\tbreak;\n\t\terr_printk(dev, entry, \"device driver has pending \"\n\t\t\t\t\"DMA allocations while released from device \"\n\t\t\t\t\"[count=%d]\\n\"\n\t\t\t\t\"One of leaked entries details: \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [mapped as %s]\\n\",\n\t\t\tcount, entry->dev_addr, entry->size,\n\t\t\tdir2name[entry->direction], type2name[entry->type]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "device_dma_allocations",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "814-832",
    "snippet": "static int device_dma_allocations(struct device *dev, struct dma_debug_entry **out_entry)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\tint count = 0, i;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tspin_lock_irqsave(&dma_entry_hash[i].lock, flags);\n\t\tlist_for_each_entry(entry, &dma_entry_hash[i].list, list) {\n\t\t\tif (entry->dev == dev) {\n\t\t\t\tcount += 1;\n\t\t\t\t*out_entry = entry;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&dma_entry_hash[i].lock, flags);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define HASH_SIZE       16384ULL"
    ],
    "globals_used": [
      "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&dma_entry_hash[i].lock",
            "flags"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&dma_entry_hash[i].list",
            "list"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&dma_entry_hash[i].lock",
            "flags"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_SIZE       16384ULL\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic int device_dma_allocations(struct device *dev, struct dma_debug_entry **out_entry)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\tint count = 0, i;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tspin_lock_irqsave(&dma_entry_hash[i].lock, flags);\n\t\tlist_for_each_entry(entry, &dma_entry_hash[i].list, list) {\n\t\t\tif (entry->dev == dev) {\n\t\t\t\tcount += 1;\n\t\t\t\t*out_entry = entry;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&dma_entry_hash[i].lock, flags);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "dma_debug_fs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "796-811",
    "snippet": "static int __init dma_debug_fs_init(void)\n{\n\tstruct dentry *dentry = debugfs_create_dir(\"dma-api\", NULL);\n\n\tdebugfs_create_bool(\"disabled\", 0444, dentry, &global_disable);\n\tdebugfs_create_u32(\"error_count\", 0444, dentry, &error_count);\n\tdebugfs_create_u32(\"all_errors\", 0644, dentry, &show_all_errors);\n\tdebugfs_create_u32(\"num_errors\", 0644, dentry, &show_num_errors);\n\tdebugfs_create_u32(\"num_free_entries\", 0444, dentry, &num_free_entries);\n\tdebugfs_create_u32(\"min_free_entries\", 0444, dentry, &min_free_entries);\n\tdebugfs_create_u32(\"nr_total_entries\", 0444, dentry, &nr_total_entries);\n\tdebugfs_create_file(\"driver_filter\", 0644, dentry, NULL, &filter_fops);\n\tdebugfs_create_file(\"dump\", 0444, dentry, NULL, &dump_fops);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool global_disable",
      "static u32 error_count;",
      "static u32 show_all_errors",
      "static u32 show_num_errors = 1;",
      "static u32 num_free_entries;",
      "static u32 min_free_entries;",
      "static u32 nr_total_entries;",
      "static const struct file_operations filter_fops = {\n\t.read  = filter_read,\n\t.write = filter_write,\n\t.llseek = default_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"dump\"",
            "0444",
            "dentry",
            "NULL",
            "&dump_fops"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"driver_filter\"",
            "0644",
            "dentry",
            "NULL",
            "&filter_fops"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"nr_total_entries\"",
            "0444",
            "dentry",
            "&nr_total_entries"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"min_free_entries\"",
            "0444",
            "dentry",
            "&min_free_entries"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"num_free_entries\"",
            "0444",
            "dentry",
            "&num_free_entries"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"num_errors\"",
            "0644",
            "dentry",
            "&show_num_errors"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"all_errors\"",
            "0644",
            "dentry",
            "&show_all_errors"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"error_count\"",
            "0444",
            "dentry",
            "&error_count"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_bool",
          "args": [
            "\"disabled\"",
            "0444",
            "dentry",
            "&global_disable"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"dma-api\"",
            "NULL"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic u32 error_count;\nstatic u32 show_all_errors;\nstatic u32 show_num_errors = 1;\nstatic u32 num_free_entries;\nstatic u32 min_free_entries;\nstatic u32 nr_total_entries;\nstatic const struct file_operations filter_fops = {\n\t.read  = filter_read,\n\t.write = filter_write,\n\t.llseek = default_llseek,\n};\n\nstatic int __init dma_debug_fs_init(void)\n{\n\tstruct dentry *dentry = debugfs_create_dir(\"dma-api\", NULL);\n\n\tdebugfs_create_bool(\"disabled\", 0444, dentry, &global_disable);\n\tdebugfs_create_u32(\"error_count\", 0444, dentry, &error_count);\n\tdebugfs_create_u32(\"all_errors\", 0644, dentry, &show_all_errors);\n\tdebugfs_create_u32(\"num_errors\", 0644, dentry, &show_num_errors);\n\tdebugfs_create_u32(\"num_free_entries\", 0444, dentry, &num_free_entries);\n\tdebugfs_create_u32(\"min_free_entries\", 0444, dentry, &min_free_entries);\n\tdebugfs_create_u32(\"nr_total_entries\", 0444, dentry, &nr_total_entries);\n\tdebugfs_create_file(\"driver_filter\", 0644, dentry, NULL, &filter_fops);\n\tdebugfs_create_file(\"dump\", 0444, dentry, NULL, &dump_fops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dump_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "769-793",
    "snippet": "static int dump_show(struct seq_file *seq, void *v)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HASH_SIZE; idx++) {\n\t\tstruct hash_bucket *bucket = &dma_entry_hash[idx];\n\t\tstruct dma_debug_entry *entry;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bucket->lock, flags);\n\t\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\t\tseq_printf(seq,\n\t\t\t\t   \"%s %s %s idx %d P=%llx N=%lx D=%llx L=%llx %s %s\\n\",\n\t\t\t\t   dev_name(entry->dev),\n\t\t\t\t   dev_driver_string(entry->dev),\n\t\t\t\t   type2name[entry->type], idx,\n\t\t\t\t   phys_addr(entry), entry->pfn,\n\t\t\t\t   entry->dev_addr, entry->size,\n\t\t\t\t   dir2name[entry->direction],\n\t\t\t\t   maperr2str[entry->map_err_type]);\n\t\t}\n\t\tspin_unlock_irqrestore(&bucket->lock, flags);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define HASH_SIZE       16384ULL"
    ],
    "globals_used": [
      "static struct hash_bucket dma_entry_hash[HASH_SIZE];",
      "static const char *const maperr2str[] = {\n\t[MAP_ERR_CHECK_NOT_APPLICABLE] = \"dma map error check not applicable\",\n\t[MAP_ERR_NOT_CHECKED] = \"dma map error not checked\",\n\t[MAP_ERR_CHECKED] = \"dma map error checked\",\n};",
      "static const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};",
      "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&bucket->lock",
            "flags"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s %s %s idx %d P=%llx N=%lx D=%llx L=%llx %s %s\\n\"",
            "dev_name(entry->dev)",
            "dev_driver_string(entry->dev)",
            "type2name[entry->type]",
            "idx",
            "phys_addr(entry)",
            "entry->pfn",
            "entry->dev_addr",
            "entry->size",
            "dir2name[entry->direction]",
            "maperr2str[entry->map_err_type]"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "phys_addr",
          "args": [
            "entry"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "phys_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "392-398",
          "snippet": "static unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_driver_string",
          "args": [
            "entry->dev"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "entry->dev"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&bucket->list",
            "list"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&bucket->lock",
            "flags"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_SIZE       16384ULL\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\nstatic const char *const maperr2str[] = {\n\t[MAP_ERR_CHECK_NOT_APPLICABLE] = \"dma map error check not applicable\",\n\t[MAP_ERR_NOT_CHECKED] = \"dma map error not checked\",\n\t[MAP_ERR_CHECKED] = \"dma map error checked\",\n};\nstatic const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nstatic int dump_show(struct seq_file *seq, void *v)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HASH_SIZE; idx++) {\n\t\tstruct hash_bucket *bucket = &dma_entry_hash[idx];\n\t\tstruct dma_debug_entry *entry;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bucket->lock, flags);\n\t\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\t\tseq_printf(seq,\n\t\t\t\t   \"%s %s %s idx %d P=%llx N=%lx D=%llx L=%llx %s %s\\n\",\n\t\t\t\t   dev_name(entry->dev),\n\t\t\t\t   dev_driver_string(entry->dev),\n\t\t\t\t   type2name[entry->type], idx,\n\t\t\t\t   phys_addr(entry), entry->pfn,\n\t\t\t\t   entry->dev_addr, entry->size,\n\t\t\t\t   dir2name[entry->direction],\n\t\t\t\t   maperr2str[entry->map_err_type]);\n\t\t}\n\t\tspin_unlock_irqrestore(&bucket->lock, flags);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "filter_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "699-761",
    "snippet": "static ssize_t filter_write(struct file *file, const char __user *userbuf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar buf[NAME_MAX_LEN];\n\tunsigned long flags;\n\tsize_t len;\n\tint i;\n\n\t/*\n\t * We can't copy from userspace directly. Access to\n\t * current_driver_name is protected with a write_lock with irqs\n\t * disabled. Since copy_from_user can fault and may sleep we\n\t * need to copy to temporary buffer first\n\t */\n\tlen = min(count, (size_t)(NAME_MAX_LEN - 1));\n\tif (copy_from_user(buf, userbuf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = 0;\n\n\twrite_lock_irqsave(&driver_name_lock, flags);\n\n\t/*\n\t * Now handle the string we got from userspace very carefully.\n\t * The rules are:\n\t *         - only use the first token we got\n\t *         - token delimiter is everything looking like a space\n\t *           character (' ', '\\n', '\\t' ...)\n\t *\n\t */\n\tif (!isalnum(buf[0])) {\n\t\t/*\n\t\t * If the first character userspace gave us is not\n\t\t * alphanumerical then assume the filter should be\n\t\t * switched off.\n\t\t */\n\t\tif (current_driver_name[0])\n\t\t\tpr_info(\"switching off dma-debug driver filter\\n\");\n\t\tcurrent_driver_name[0] = 0;\n\t\tcurrent_driver = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Now parse out the first token and use it as the name for the\n\t * driver to filter for.\n\t */\n\tfor (i = 0; i < NAME_MAX_LEN - 1; ++i) {\n\t\tcurrent_driver_name[i] = buf[i];\n\t\tif (isspace(buf[i]) || buf[i] == ' ' || buf[i] == 0)\n\t\t\tbreak;\n\t}\n\tcurrent_driver_name[i] = 0;\n\tcurrent_driver = NULL;\n\n\tpr_info(\"enable driver filter for driver [%s]\\n\",\n\t\tcurrent_driver_name);\n\nout_unlock:\n\twrite_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn count;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define NAME_MAX_LEN\t64"
    ],
    "globals_used": [
      "static char                  current_driver_name[NAME_MAX_LEN]",
      "static struct device_driver *current_driver",
      "static DEFINE_RWLOCK(driver_name_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "348-351",
          "snippet": "void __lockfunc _raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_write_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_write_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"enable driver filter for driver [%s]\\n\"",
            "current_driver_name"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "buf[i]"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"switching off dma-debug driver filter\\n\""
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "buf[0]"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "userbuf",
            "len"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count",
            "(size_t)(NAME_MAX_LEN - 1)"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define NAME_MAX_LEN\t64\n\nstatic char                  current_driver_name[NAME_MAX_LEN];\nstatic struct device_driver *current_driver;\nstatic DEFINE_RWLOCK(driver_name_lock);\n\nstatic ssize_t filter_write(struct file *file, const char __user *userbuf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar buf[NAME_MAX_LEN];\n\tunsigned long flags;\n\tsize_t len;\n\tint i;\n\n\t/*\n\t * We can't copy from userspace directly. Access to\n\t * current_driver_name is protected with a write_lock with irqs\n\t * disabled. Since copy_from_user can fault and may sleep we\n\t * need to copy to temporary buffer first\n\t */\n\tlen = min(count, (size_t)(NAME_MAX_LEN - 1));\n\tif (copy_from_user(buf, userbuf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = 0;\n\n\twrite_lock_irqsave(&driver_name_lock, flags);\n\n\t/*\n\t * Now handle the string we got from userspace very carefully.\n\t * The rules are:\n\t *         - only use the first token we got\n\t *         - token delimiter is everything looking like a space\n\t *           character (' ', '\\n', '\\t' ...)\n\t *\n\t */\n\tif (!isalnum(buf[0])) {\n\t\t/*\n\t\t * If the first character userspace gave us is not\n\t\t * alphanumerical then assume the filter should be\n\t\t * switched off.\n\t\t */\n\t\tif (current_driver_name[0])\n\t\t\tpr_info(\"switching off dma-debug driver filter\\n\");\n\t\tcurrent_driver_name[0] = 0;\n\t\tcurrent_driver = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Now parse out the first token and use it as the name for the\n\t * driver to filter for.\n\t */\n\tfor (i = 0; i < NAME_MAX_LEN - 1; ++i) {\n\t\tcurrent_driver_name[i] = buf[i];\n\t\tif (isspace(buf[i]) || buf[i] == ' ' || buf[i] == 0)\n\t\t\tbreak;\n\t}\n\tcurrent_driver_name[i] = 0;\n\tcurrent_driver = NULL;\n\n\tpr_info(\"enable driver filter for driver [%s]\\n\",\n\t\tcurrent_driver_name);\n\nout_unlock:\n\twrite_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn count;\n}"
  },
  {
    "function_name": "filter_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "677-697",
    "snippet": "static ssize_t filter_read(struct file *file, char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tchar buf[NAME_MAX_LEN + 1];\n\tunsigned long flags;\n\tint len;\n\n\tif (!current_driver_name[0])\n\t\treturn 0;\n\n\t/*\n\t * We can't copy to userspace directly because current_driver_name can\n\t * only be read under the driver_name_lock with irqs disabled. So\n\t * create a temporary copy first.\n\t */\n\tread_lock_irqsave(&driver_name_lock, flags);\n\tlen = scnprintf(buf, NAME_MAX_LEN + 1, \"%s\\n\", current_driver_name);\n\tread_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define NAME_MAX_LEN\t64"
    ],
    "globals_used": [
      "static char                  current_driver_name[NAME_MAX_LEN]",
      "static DEFINE_RWLOCK(driver_name_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "user_buf",
            "count",
            "ppos",
            "buf",
            "len"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_read_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "266-269",
          "snippet": "void __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "NAME_MAX_LEN + 1",
            "\"%s\\n\"",
            "current_driver_name"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define NAME_MAX_LEN\t64\n\nstatic char                  current_driver_name[NAME_MAX_LEN];\nstatic DEFINE_RWLOCK(driver_name_lock);\n\nstatic ssize_t filter_read(struct file *file, char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tchar buf[NAME_MAX_LEN + 1];\n\tunsigned long flags;\n\tint len;\n\n\tif (!current_driver_name[0])\n\t\treturn 0;\n\n\t/*\n\t * We can't copy to userspace directly because current_driver_name can\n\t * only be read under the driver_name_lock with irqs disabled. So\n\t * create a temporary copy first.\n\t */\n\tread_lock_irqsave(&driver_name_lock, flags);\n\tlen = scnprintf(buf, NAME_MAX_LEN + 1, \"%s\\n\", current_driver_name);\n\tread_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}"
  },
  {
    "function_name": "dma_entry_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "653-667",
    "snippet": "static void dma_entry_free(struct dma_debug_entry *entry)\n{\n\tunsigned long flags;\n\n\tactive_cacheline_remove(entry);\n\n\t/*\n\t * add to beginning of the list - this way the entries are\n\t * more likely cache hot when they are reallocated.\n\t */\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tlist_add(&entry->list, &free_entries);\n\tnum_free_entries += 1;\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(free_entries);",
      "static DEFINE_SPINLOCK(free_entries_lock);",
      "static u32 num_free_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&free_entries_lock",
            "flags"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&entry->list",
            "&free_entries"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&free_entries_lock",
            "flags"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "active_cacheline_remove",
          "args": [
            "entry"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "532-549",
          "snippet": "static void active_cacheline_remove(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\n\t/* ...mirror the insert case */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\t/* since we are counting overlaps the final put of the\n\t * cacheline will occur when the overlap count is 0.\n\t * active_cacheline_dec_overlap() returns -1 in that case\n\t */\n\tif (active_cacheline_dec_overlap(cln) < 0)\n\t\tradix_tree_delete(&dma_active_cacheline, cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(radix_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic DEFINE_SPINLOCK(radix_lock);\n\nstatic void active_cacheline_remove(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\n\t/* ...mirror the insert case */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\t/* since we are counting overlaps the final put of the\n\t * cacheline will occur when the overlap count is 0.\n\t * active_cacheline_dec_overlap() returns -1 in that case\n\t */\n\tif (active_cacheline_dec_overlap(cln) < 0)\n\t\tradix_tree_delete(&dma_active_cacheline, cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic LIST_HEAD(free_entries);\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic u32 num_free_entries;\n\nstatic void dma_entry_free(struct dma_debug_entry *entry)\n{\n\tunsigned long flags;\n\n\tactive_cacheline_remove(entry);\n\n\t/*\n\t * add to beginning of the list - this way the entries are\n\t * more likely cache hot when they are reallocated.\n\t */\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tlist_add(&entry->list, &free_entries);\n\tnum_free_entries += 1;\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n}"
  },
  {
    "function_name": "dma_entry_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "625-651",
    "snippet": "static struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tif (num_free_entries == 0) {\n\t\tif (dma_debug_create_entries(GFP_ATOMIC)) {\n\t\t\tglobal_disable = true;\n\t\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\t\tpr_err(\"debugging out of memory - disabling\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t__dma_entry_alloc_check_leak();\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stack_len = stack_trace_save(entry->stack_entries,\n\t\t\t\t\t    ARRAY_SIZE(entry->stack_entries),\n\t\t\t\t\t    1);\n#endif\n\treturn entry;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;",
      "static DEFINE_SPINLOCK(free_entries_lock);",
      "static bool global_disable",
      "static u32 num_free_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stack_trace_save",
          "args": [
            "entry->stack_entries",
            "ARRAY_SIZE(entry->stack_entries)",
            "1"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_save_tsk_reliable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stacktrace.c",
          "lines": "343-353",
          "snippet": "int stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}",
          "includes": [
            "#include <linux/interrupt.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\nint stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "entry->stack_entries"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&free_entries_lock",
            "flags"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dma_entry_alloc",
          "args": [],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_entry_alloc_check_leak",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "608-618",
          "snippet": "static void __dma_entry_alloc_check_leak(void)\n{\n\tu32 tmp = nr_total_entries % nr_prealloc_entries;\n\n\t/* Shout each time we tick over some multiple of the initial pool */\n\tif (tmp < DMA_DEBUG_DYNAMIC_ENTRIES) {\n\t\tpr_info(\"dma_debug_entry pool grown to %u (%u00%%)\\n\",\n\t\t\tnr_total_entries,\n\t\t\t(nr_total_entries / nr_prealloc_entries));\n\t}\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))"
          ],
          "globals_used": [
            "static u32 nr_total_entries;",
            "static u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))\n\nstatic u32 nr_total_entries;\nstatic u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;\n\nstatic void __dma_entry_alloc_check_leak(void)\n{\n\tu32 tmp = nr_total_entries % nr_prealloc_entries;\n\n\t/* Shout each time we tick over some multiple of the initial pool */\n\tif (tmp < DMA_DEBUG_DYNAMIC_ENTRIES) {\n\t\tpr_info(\"dma_debug_entry pool grown to %u (%u00%%)\\n\",\n\t\t\tnr_total_entries,\n\t\t\t(nr_total_entries / nr_prealloc_entries));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"debugging out of memory - disabling\\n\""
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_create_entries",
          "args": [
            "GFP_ATOMIC"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_create_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "575-591",
          "snippet": "static int dma_debug_create_entries(gfp_t gfp)\n{\n\tstruct dma_debug_entry *entry;\n\tint i;\n\n\tentry = (void *)get_zeroed_page(gfp);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < DMA_DEBUG_DYNAMIC_ENTRIES; i++)\n\t\tlist_add_tail(&entry[i].list, &free_entries);\n\n\tnum_free_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\tnr_total_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))"
          ],
          "globals_used": [
            "static LIST_HEAD(free_entries);",
            "static u32 num_free_entries;",
            "static u32 nr_total_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))\n\nstatic LIST_HEAD(free_entries);\nstatic u32 num_free_entries;\nstatic u32 nr_total_entries;\n\nstatic int dma_debug_create_entries(gfp_t gfp)\n{\n\tstruct dma_debug_entry *entry;\n\tint i;\n\n\tentry = (void *)get_zeroed_page(gfp);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < DMA_DEBUG_DYNAMIC_ENTRIES; i++)\n\t\tlist_add_tail(&entry[i].list, &free_entries);\n\n\tnum_free_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\tnr_total_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&free_entries_lock",
            "flags"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstruct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic bool global_disable;\nstatic u32 num_free_entries;\n\nstatic struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tif (num_free_entries == 0) {\n\t\tif (dma_debug_create_entries(GFP_ATOMIC)) {\n\t\t\tglobal_disable = true;\n\t\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\t\tpr_err(\"debugging out of memory - disabling\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t__dma_entry_alloc_check_leak();\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stack_len = stack_trace_save(entry->stack_entries,\n\t\t\t\t\t    ARRAY_SIZE(entry->stack_entries),\n\t\t\t\t\t    1);\n#endif\n\treturn entry;\n}"
  },
  {
    "function_name": "__dma_entry_alloc_check_leak",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "608-618",
    "snippet": "static void __dma_entry_alloc_check_leak(void)\n{\n\tu32 tmp = nr_total_entries % nr_prealloc_entries;\n\n\t/* Shout each time we tick over some multiple of the initial pool */\n\tif (tmp < DMA_DEBUG_DYNAMIC_ENTRIES) {\n\t\tpr_info(\"dma_debug_entry pool grown to %u (%u00%%)\\n\",\n\t\t\tnr_total_entries,\n\t\t\t(nr_total_entries / nr_prealloc_entries));\n\t}\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))"
    ],
    "globals_used": [
      "static u32 nr_total_entries;",
      "static u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"dma_debug_entry pool grown to %u (%u00%%)\\n\"",
            "nr_total_entries",
            "(nr_total_entries / nr_prealloc_entries)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))\n\nstatic u32 nr_total_entries;\nstatic u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;\n\nstatic void __dma_entry_alloc_check_leak(void)\n{\n\tu32 tmp = nr_total_entries % nr_prealloc_entries;\n\n\t/* Shout each time we tick over some multiple of the initial pool */\n\tif (tmp < DMA_DEBUG_DYNAMIC_ENTRIES) {\n\t\tpr_info(\"dma_debug_entry pool grown to %u (%u00%%)\\n\",\n\t\t\tnr_total_entries,\n\t\t\t(nr_total_entries / nr_prealloc_entries));\n\t}\n}"
  },
  {
    "function_name": "__dma_entry_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "593-606",
    "snippet": "static struct dma_debug_entry *__dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\n\tentry = list_entry(free_entries.next, struct dma_debug_entry, list);\n\tlist_del(&entry->list);\n\tmemset(entry, 0, sizeof(*entry));\n\n\tnum_free_entries -= 1;\n\tif (num_free_entries < min_free_entries)\n\t\tmin_free_entries = num_free_entries;\n\n\treturn entry;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(free_entries);",
      "static u32 num_free_entries;",
      "static u32 min_free_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "entry",
            "0",
            "sizeof(*entry)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "free_entries.next",
            "structdma_debug_entry",
            "list"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic LIST_HEAD(free_entries);\nstatic u32 num_free_entries;\nstatic u32 min_free_entries;\n\nstatic struct dma_debug_entry *__dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\n\tentry = list_entry(free_entries.next, struct dma_debug_entry, list);\n\tlist_del(&entry->list);\n\tmemset(entry, 0, sizeof(*entry));\n\n\tnum_free_entries -= 1;\n\tif (num_free_entries < min_free_entries)\n\t\tmin_free_entries = num_free_entries;\n\n\treturn entry;\n}"
  },
  {
    "function_name": "dma_debug_create_entries",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "575-591",
    "snippet": "static int dma_debug_create_entries(gfp_t gfp)\n{\n\tstruct dma_debug_entry *entry;\n\tint i;\n\n\tentry = (void *)get_zeroed_page(gfp);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < DMA_DEBUG_DYNAMIC_ENTRIES; i++)\n\t\tlist_add_tail(&entry[i].list, &free_entries);\n\n\tnum_free_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\tnr_total_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))"
    ],
    "globals_used": [
      "static LIST_HEAD(free_entries);",
      "static u32 num_free_entries;",
      "static u32 nr_total_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry[i].list",
            "&free_entries"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "gfp"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define DMA_DEBUG_DYNAMIC_ENTRIES (PAGE_SIZE / sizeof(struct dma_debug_entry))\n\nstatic LIST_HEAD(free_entries);\nstatic u32 num_free_entries;\nstatic u32 nr_total_entries;\n\nstatic int dma_debug_create_entries(gfp_t gfp)\n{\n\tstruct dma_debug_entry *entry;\n\tint i;\n\n\tentry = (void *)get_zeroed_page(gfp);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < DMA_DEBUG_DYNAMIC_ENTRIES; i++)\n\t\tlist_add_tail(&entry[i].list, &free_entries);\n\n\tnum_free_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\tnr_total_entries += DMA_DEBUG_DYNAMIC_ENTRIES;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "add_dma_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "555-573",
    "snippet": "static void add_dma_entry(struct dma_debug_entry *entry, unsigned long attrs)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t} else if (rc == -EEXIST && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {\n\t\terr_printk(entry->dev, entry,\n\t\t\t\"cacheline tracking EEXIST, overlapping mappings aren't supported\\n\");\n\t}\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool global_disable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "entry->dev",
            "entry",
            "\"cacheline tracking EEXIST, overlapping mappings aren't supported\\n\""
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cacheline tracking ENOMEM, dma-debug disabled\\n\""
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "active_cacheline_insert",
          "args": [
            "entry"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_insert",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "510-530",
          "snippet": "static int active_cacheline_insert(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\tint rc;\n\n\t/* If the device is not writing memory then we don't have any\n\t * concerns about the cpu consuming stale data.  This mitigates\n\t * legitimate usages of overlapping mappings.\n\t */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\trc = radix_tree_insert(&dma_active_cacheline, cln, entry);\n\tif (rc == -EEXIST)\n\t\tactive_cacheline_inc_overlap(cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(radix_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic DEFINE_SPINLOCK(radix_lock);\n\nstatic int active_cacheline_insert(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\tint rc;\n\n\t/* If the device is not writing memory then we don't have any\n\t * concerns about the cpu consuming stale data.  This mitigates\n\t * legitimate usages of overlapping mappings.\n\t */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\trc = radix_tree_insert(&dma_active_cacheline, cln, entry);\n\tif (rc == -EEXIST)\n\t\tactive_cacheline_inc_overlap(cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "bucket",
            "flags"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "263-268",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_bucket_add",
          "args": [
            "bucket",
            "entry"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "hash_bucket_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "378-382",
          "snippet": "static void hash_bucket_add(struct hash_bucket *bucket,\n\t\t\t    struct dma_debug_entry *entry)\n{\n\tlist_add_tail(&entry->list, &bucket->list);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void hash_bucket_add(struct hash_bucket *bucket,\n\t\t\t    struct dma_debug_entry *entry)\n{\n\tlist_add_tail(&entry->list, &bucket->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "entry",
            "&flags"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "248-258",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic void add_dma_entry(struct dma_debug_entry *entry, unsigned long attrs)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t} else if (rc == -EEXIST && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {\n\t\terr_printk(entry->dev, entry,\n\t\t\t\"cacheline tracking EEXIST, overlapping mappings aren't supported\\n\");\n\t}\n}"
  },
  {
    "function_name": "active_cacheline_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "532-549",
    "snippet": "static void active_cacheline_remove(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\n\t/* ...mirror the insert case */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\t/* since we are counting overlaps the final put of the\n\t * cacheline will occur when the overlap count is 0.\n\t * active_cacheline_dec_overlap() returns -1 in that case\n\t */\n\tif (active_cacheline_dec_overlap(cln) < 0)\n\t\tradix_tree_delete(&dma_active_cacheline, cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(radix_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&radix_lock",
            "flags"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&dma_active_cacheline",
            "cln"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "active_cacheline_dec_overlap",
          "args": [
            "cln"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_dec_overlap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "503-508",
          "snippet": "static int active_cacheline_dec_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\treturn active_cacheline_set_overlap(cln, --overlap);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int active_cacheline_dec_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\treturn active_cacheline_set_overlap(cln, --overlap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&radix_lock",
            "flags"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_cacheline_number",
          "args": [
            "entry"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "to_cacheline_number",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "457-461",
          "snippet": "static phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)\n\nstatic phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic DEFINE_SPINLOCK(radix_lock);\n\nstatic void active_cacheline_remove(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\n\t/* ...mirror the insert case */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\t/* since we are counting overlaps the final put of the\n\t * cacheline will occur when the overlap count is 0.\n\t * active_cacheline_dec_overlap() returns -1 in that case\n\t */\n\tif (active_cacheline_dec_overlap(cln) < 0)\n\t\tradix_tree_delete(&dma_active_cacheline, cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n}"
  },
  {
    "function_name": "active_cacheline_insert",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "510-530",
    "snippet": "static int active_cacheline_insert(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\tint rc;\n\n\t/* If the device is not writing memory then we don't have any\n\t * concerns about the cpu consuming stale data.  This mitigates\n\t * legitimate usages of overlapping mappings.\n\t */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\trc = radix_tree_insert(&dma_active_cacheline, cln, entry);\n\tif (rc == -EEXIST)\n\t\tactive_cacheline_inc_overlap(cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(radix_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&radix_lock",
            "flags"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "active_cacheline_inc_overlap",
          "args": [
            "cln"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_inc_overlap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "489-501",
          "snippet": "static void active_cacheline_inc_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\toverlap = active_cacheline_set_overlap(cln, ++overlap);\n\n\t/* If we overflowed the overlap counter then we're potentially\n\t * leaking dma-mappings.\n\t */\n\tWARN_ONCE(overlap > ACTIVE_CACHELINE_MAX_OVERLAP,\n\t\t  pr_fmt(\"exceeded %d overlapping mappings of cacheline %pa\\n\"),\n\t\t  ACTIVE_CACHELINE_MAX_OVERLAP, &cln);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)\n\nstatic void active_cacheline_inc_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\toverlap = active_cacheline_set_overlap(cln, ++overlap);\n\n\t/* If we overflowed the overlap counter then we're potentially\n\t * leaking dma-mappings.\n\t */\n\tWARN_ONCE(overlap > ACTIVE_CACHELINE_MAX_OVERLAP,\n\t\t  pr_fmt(\"exceeded %d overlapping mappings of cacheline %pa\\n\"),\n\t\t  ACTIVE_CACHELINE_MAX_OVERLAP, &cln);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&dma_active_cacheline",
            "cln",
            "entry"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&radix_lock",
            "flags"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_cacheline_number",
          "args": [
            "entry"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "to_cacheline_number",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "457-461",
          "snippet": "static phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)\n\nstatic phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic DEFINE_SPINLOCK(radix_lock);\n\nstatic int active_cacheline_insert(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\tint rc;\n\n\t/* If the device is not writing memory then we don't have any\n\t * concerns about the cpu consuming stale data.  This mitigates\n\t * legitimate usages of overlapping mappings.\n\t */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\trc = radix_tree_insert(&dma_active_cacheline, cln, entry);\n\tif (rc == -EEXIST)\n\t\tactive_cacheline_inc_overlap(cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "active_cacheline_dec_overlap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "503-508",
    "snippet": "static int active_cacheline_dec_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\treturn active_cacheline_set_overlap(cln, --overlap);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "active_cacheline_set_overlap",
          "args": [
            "cln",
            "--overlap"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_set_overlap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "473-487",
          "snippet": "static int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)\n\nstatic int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "active_cacheline_read_overlap",
          "args": [
            "cln"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_read_overlap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "463-471",
          "snippet": "static int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int active_cacheline_dec_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\treturn active_cacheline_set_overlap(cln, --overlap);\n}"
  },
  {
    "function_name": "active_cacheline_inc_overlap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "489-501",
    "snippet": "static void active_cacheline_inc_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\toverlap = active_cacheline_set_overlap(cln, ++overlap);\n\n\t/* If we overflowed the overlap counter then we're potentially\n\t * leaking dma-mappings.\n\t */\n\tWARN_ONCE(overlap > ACTIVE_CACHELINE_MAX_OVERLAP,\n\t\t  pr_fmt(\"exceeded %d overlapping mappings of cacheline %pa\\n\"),\n\t\t  ACTIVE_CACHELINE_MAX_OVERLAP, &cln);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "overlap > ACTIVE_CACHELINE_MAX_OVERLAP",
            "pr_fmt(\"exceeded %d overlapping mappings of cacheline %pa\\n\")",
            "ACTIVE_CACHELINE_MAX_OVERLAP",
            "&cln"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_fmt",
          "args": [
            "\"exceeded %d overlapping mappings of cacheline %pa\\n\""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "active_cacheline_set_overlap",
          "args": [
            "cln",
            "++overlap"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_set_overlap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "473-487",
          "snippet": "static int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)\n\nstatic int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "active_cacheline_read_overlap",
          "args": [
            "cln"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_read_overlap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "463-471",
          "snippet": "static int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)\n\nstatic void active_cacheline_inc_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\toverlap = active_cacheline_set_overlap(cln, ++overlap);\n\n\t/* If we overflowed the overlap counter then we're potentially\n\t * leaking dma-mappings.\n\t */\n\tWARN_ONCE(overlap > ACTIVE_CACHELINE_MAX_OVERLAP,\n\t\t  pr_fmt(\"exceeded %d overlapping mappings of cacheline %pa\\n\"),\n\t\t  ACTIVE_CACHELINE_MAX_OVERLAP, &cln);\n}"
  },
  {
    "function_name": "active_cacheline_set_overlap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "473-487",
    "snippet": "static int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&dma_active_cacheline",
            "cln",
            "i"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&dma_active_cacheline",
            "cln",
            "i"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)\n\nstatic int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}"
  },
  {
    "function_name": "active_cacheline_read_overlap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "463-471",
    "snippet": "static int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_tag_get",
          "args": [
            "&dma_active_cacheline",
            "cln",
            "i"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}"
  },
  {
    "function_name": "to_cacheline_number",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "457-461",
    "snippet": "static phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)\n\nstatic phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}"
  },
  {
    "function_name": "debug_dma_dump_mappings",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "403-429",
    "snippet": "void debug_dma_dump_mappings(struct device *dev)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HASH_SIZE; idx++) {\n\t\tstruct hash_bucket *bucket = &dma_entry_hash[idx];\n\t\tstruct dma_debug_entry *entry;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bucket->lock, flags);\n\n\t\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\t\tif (!dev || dev == entry->dev) {\n\t\t\t\tdev_info(entry->dev,\n\t\t\t\t\t \"%s idx %d P=%Lx N=%lx D=%Lx L=%Lx %s %s\\n\",\n\t\t\t\t\t type2name[entry->type], idx,\n\t\t\t\t\t phys_addr(entry), entry->pfn,\n\t\t\t\t\t entry->dev_addr, entry->size,\n\t\t\t\t\t dir2name[entry->direction],\n\t\t\t\t\t maperr2str[entry->map_err_type]);\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_irqrestore(&bucket->lock, flags);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define HASH_SIZE       16384ULL"
    ],
    "globals_used": [
      "static struct hash_bucket dma_entry_hash[HASH_SIZE];",
      "static const char *const maperr2str[] = {\n\t[MAP_ERR_CHECK_NOT_APPLICABLE] = \"dma map error check not applicable\",\n\t[MAP_ERR_NOT_CHECKED] = \"dma map error not checked\",\n\t[MAP_ERR_CHECKED] = \"dma map error checked\",\n};",
      "static const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};",
      "static const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&bucket->lock",
            "flags"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "entry->dev",
            "\"%s idx %d P=%Lx N=%lx D=%Lx L=%Lx %s %s\\n\"",
            "type2name[entry->type]",
            "idx",
            "phys_addr(entry)",
            "entry->pfn",
            "entry->dev_addr",
            "entry->size",
            "dir2name[entry->direction]",
            "maperr2str[entry->map_err_type]"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_addr",
          "args": [
            "entry"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "phys_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "392-398",
          "snippet": "static unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&bucket->list",
            "list"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&bucket->lock",
            "flags"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_SIZE       16384ULL\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\nstatic const char *const maperr2str[] = {\n\t[MAP_ERR_CHECK_NOT_APPLICABLE] = \"dma map error check not applicable\",\n\t[MAP_ERR_NOT_CHECKED] = \"dma map error not checked\",\n\t[MAP_ERR_CHECKED] = \"dma map error checked\",\n};\nstatic const char *type2name[] = {\n\t[dma_debug_single] = \"single\",\n\t[dma_debug_sg] = \"scather-gather\",\n\t[dma_debug_coherent] = \"coherent\",\n\t[dma_debug_resource] = \"resource\",\n};\nstatic const char *dir2name[] = {\n\t[DMA_BIDIRECTIONAL]\t= \"DMA_BIDIRECTIONAL\",\n\t[DMA_TO_DEVICE]\t\t= \"DMA_TO_DEVICE\",\n\t[DMA_FROM_DEVICE]\t= \"DMA_FROM_DEVICE\",\n\t[DMA_NONE]\t\t= \"DMA_NONE\",\n};\n\nvoid debug_dma_dump_mappings(struct device *dev)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HASH_SIZE; idx++) {\n\t\tstruct hash_bucket *bucket = &dma_entry_hash[idx];\n\t\tstruct dma_debug_entry *entry;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bucket->lock, flags);\n\n\t\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\t\tif (!dev || dev == entry->dev) {\n\t\t\t\tdev_info(entry->dev,\n\t\t\t\t\t \"%s idx %d P=%Lx N=%lx D=%Lx L=%Lx %s %s\\n\",\n\t\t\t\t\t type2name[entry->type], idx,\n\t\t\t\t\t phys_addr(entry), entry->pfn,\n\t\t\t\t\t entry->dev_addr, entry->size,\n\t\t\t\t\t dir2name[entry->direction],\n\t\t\t\t\t maperr2str[entry->map_err_type]);\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_irqrestore(&bucket->lock, flags);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "phys_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "392-398",
    "snippet": "static unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "pfn_to_page(entry->pfn)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "entry->pfn"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pfn_to_phys",
          "args": [
            "entry->pfn"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}"
  },
  {
    "function_name": "hash_bucket_del",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "387-390",
    "snippet": "static void hash_bucket_del(struct dma_debug_entry *entry)\n{\n\tlist_del(&entry->list);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void hash_bucket_del(struct dma_debug_entry *entry)\n{\n\tlist_del(&entry->list);\n}"
  },
  {
    "function_name": "hash_bucket_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "378-382",
    "snippet": "static void hash_bucket_add(struct hash_bucket *bucket,\n\t\t\t    struct dma_debug_entry *entry)\n{\n\tlist_add_tail(&entry->list, &bucket->list);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->list",
            "&bucket->list"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void hash_bucket_add(struct hash_bucket *bucket,\n\t\t\t    struct dma_debug_entry *entry)\n{\n\tlist_add_tail(&entry->list, &bucket->list);\n}"
  },
  {
    "function_name": "bucket_find_contain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "348-373",
    "snippet": "static struct dma_debug_entry *bucket_find_contain(struct hash_bucket **bucket,\n\t\t\t\t\t\t   struct dma_debug_entry *ref,\n\t\t\t\t\t\t   unsigned long *flags)\n{\n\n\tunsigned int max_range = dma_get_max_seg_size(ref->dev);\n\tstruct dma_debug_entry *entry, index = *ref;\n\tunsigned int range = 0;\n\n\twhile (range <= max_range) {\n\t\tentry = __hash_bucket_find(*bucket, ref, containing_match);\n\n\t\tif (entry)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * Nothing found, go back a hash bucket\n\t\t */\n\t\tput_hash_bucket(*bucket, *flags);\n\t\trange          += (1 << HASH_FN_SHIFT);\n\t\tindex.dev_addr -= (1 << HASH_FN_SHIFT);\n\t\t*bucket = get_hash_bucket(&index, flags);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define HASH_FN_SHIFT   13"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "&index",
            "flags"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "248-258",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "*bucket",
            "*flags"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "263-268",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hash_bucket_find",
          "args": [
            "*bucket",
            "ref",
            "containing_match"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__hash_bucket_find",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "292-340",
          "snippet": "static struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_get_max_seg_size",
          "args": [
            "ref->dev"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_FN_SHIFT   13\n\nstatic struct dma_debug_entry *bucket_find_contain(struct hash_bucket **bucket,\n\t\t\t\t\t\t   struct dma_debug_entry *ref,\n\t\t\t\t\t\t   unsigned long *flags)\n{\n\n\tunsigned int max_range = dma_get_max_seg_size(ref->dev);\n\tstruct dma_debug_entry *entry, index = *ref;\n\tunsigned int range = 0;\n\n\twhile (range <= max_range) {\n\t\tentry = __hash_bucket_find(*bucket, ref, containing_match);\n\n\t\tif (entry)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * Nothing found, go back a hash bucket\n\t\t */\n\t\tput_hash_bucket(*bucket, *flags);\n\t\trange          += (1 << HASH_FN_SHIFT);\n\t\tindex.dev_addr -= (1 << HASH_FN_SHIFT);\n\t\t*bucket = get_hash_bucket(&index, flags);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "bucket_find_exact",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "342-346",
    "snippet": "static struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hash_bucket_find",
          "args": [
            "bucket",
            "ref",
            "exact_match"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "__hash_bucket_find",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "292-340",
          "snippet": "static struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}"
  },
  {
    "function_name": "__hash_bucket_find",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "292-340",
    "snippet": "static struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match",
          "args": [
            "ref",
            "entry"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "containing_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "276-287",
          "snippet": "static bool containing_match(struct dma_debug_entry *a,\n\t\t\t     struct dma_debug_entry *b)\n{\n\tif (a->dev != b->dev)\n\t\treturn false;\n\n\tif ((b->dev_addr <= a->dev_addr) &&\n\t    ((b->dev_addr + b->size) >= (a->dev_addr + a->size)))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool containing_match(struct dma_debug_entry *a,\n\t\t\t     struct dma_debug_entry *b)\n{\n\tif (a->dev != b->dev)\n\t\treturn false;\n\n\tif ((b->dev_addr <= a->dev_addr) &&\n\t    ((b->dev_addr + b->size) >= (a->dev_addr + a->size)))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&bucket->list",
            "list"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "containing_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "276-287",
    "snippet": "static bool containing_match(struct dma_debug_entry *a,\n\t\t\t     struct dma_debug_entry *b)\n{\n\tif (a->dev != b->dev)\n\t\treturn false;\n\n\tif ((b->dev_addr <= a->dev_addr) &&\n\t    ((b->dev_addr + b->size) >= (a->dev_addr + a->size)))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool containing_match(struct dma_debug_entry *a,\n\t\t\t     struct dma_debug_entry *b)\n{\n\tif (a->dev != b->dev)\n\t\treturn false;\n\n\tif ((b->dev_addr <= a->dev_addr) &&\n\t    ((b->dev_addr + b->size) >= (a->dev_addr + a->size)))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "exact_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "270-274",
    "snippet": "static bool exact_match(struct dma_debug_entry *a, struct dma_debug_entry *b)\n{\n\treturn ((a->dev_addr == b->dev_addr) &&\n\t\t(a->dev == b->dev)) ? true : false;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool exact_match(struct dma_debug_entry *a, struct dma_debug_entry *b)\n{\n\treturn ((a->dev_addr == b->dev_addr) &&\n\t\t(a->dev == b->dev)) ? true : false;\n}"
  },
  {
    "function_name": "put_hash_bucket",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "263-268",
    "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&bucket->lock",
            "flags"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&bucket->lock"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long flags)\n\t__releases(&bucket->lock)\n{\n\tspin_unlock_irqrestore(&bucket->lock, flags);\n}"
  },
  {
    "function_name": "get_hash_bucket",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "248-258",
    "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&dma_entry_hash[idx].lock",
            "__flags"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_fn",
          "args": [
            "entry"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "hash_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
          "lines": "236-243",
          "snippet": "static int hash_fn(struct dma_debug_entry *entry)\n{\n\t/*\n\t * Hash function is based on the dma address.\n\t * We use bits 20-27 here as the index into the hash\n\t */\n\treturn (entry->dev_addr >> HASH_FN_SHIFT) & HASH_FN_MASK;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define HASH_FN_MASK    (HASH_SIZE - 1)",
            "#define HASH_FN_SHIFT   13"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_FN_MASK    (HASH_SIZE - 1)\n#define HASH_FN_SHIFT   13\n\nstatic int hash_fn(struct dma_debug_entry *entry)\n{\n\t/*\n\t * Hash function is based on the dma address.\n\t * We use bits 20-27 here as the index into the hash\n\t */\n\treturn (entry->dev_addr >> HASH_FN_SHIFT) & HASH_FN_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&dma_entry_hash"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
  },
  {
    "function_name": "hash_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "236-243",
    "snippet": "static int hash_fn(struct dma_debug_entry *entry)\n{\n\t/*\n\t * Hash function is based on the dma address.\n\t * We use bits 20-27 here as the index into the hash\n\t */\n\treturn (entry->dev_addr >> HASH_FN_SHIFT) & HASH_FN_MASK;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define HASH_FN_MASK    (HASH_SIZE - 1)",
      "#define HASH_FN_SHIFT   13"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_FN_MASK    (HASH_SIZE - 1)\n#define HASH_FN_SHIFT   13\n\nstatic int hash_fn(struct dma_debug_entry *entry)\n{\n\t/*\n\t * Hash function is based on the dma address.\n\t * We use bits 20-27 here as the index into the hash\n\t */\n\treturn (entry->dev_addr >> HASH_FN_SHIFT) & HASH_FN_MASK;\n}"
  },
  {
    "function_name": "driver_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "176-215",
    "snippet": "static bool driver_filter(struct device *dev)\n{\n\tstruct device_driver *drv;\n\tunsigned long flags;\n\tbool ret;\n\n\t/* driver filter off */\n\tif (likely(!current_driver_name[0]))\n\t\treturn true;\n\n\t/* driver filter on and initialized */\n\tif (current_driver && dev && dev->driver == current_driver)\n\t\treturn true;\n\n\t/* driver filter on, but we can't filter on a NULL device... */\n\tif (!dev)\n\t\treturn false;\n\n\tif (current_driver || !current_driver_name[0])\n\t\treturn false;\n\n\t/* driver filter on but not yet initialized */\n\tdrv = dev->driver;\n\tif (!drv)\n\t\treturn false;\n\n\t/* lock to protect against change of current_driver_name */\n\tread_lock_irqsave(&driver_name_lock, flags);\n\n\tret = false;\n\tif (drv->name &&\n\t    strncmp(current_driver_name, drv->name, NAME_MAX_LEN - 1) == 0) {\n\t\tcurrent_driver = drv;\n\t\tret = true;\n\t}\n\n\tread_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define NAME_MAX_LEN\t64"
    ],
    "globals_used": [
      "static char                  current_driver_name[NAME_MAX_LEN]",
      "static struct device_driver *current_driver",
      "static DEFINE_RWLOCK(driver_name_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_read_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "266-269",
          "snippet": "void __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "current_driver_name",
            "drv->name",
            "NAME_MAX_LEN - 1"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!current_driver_name[0]"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define NAME_MAX_LEN\t64\n\nstatic char                  current_driver_name[NAME_MAX_LEN];\nstatic struct device_driver *current_driver;\nstatic DEFINE_RWLOCK(driver_name_lock);\n\nstatic bool driver_filter(struct device *dev)\n{\n\tstruct device_driver *drv;\n\tunsigned long flags;\n\tbool ret;\n\n\t/* driver filter off */\n\tif (likely(!current_driver_name[0]))\n\t\treturn true;\n\n\t/* driver filter on and initialized */\n\tif (current_driver && dev && dev->driver == current_driver)\n\t\treturn true;\n\n\t/* driver filter on, but we can't filter on a NULL device... */\n\tif (!dev)\n\t\treturn false;\n\n\tif (current_driver || !current_driver_name[0])\n\t\treturn false;\n\n\t/* driver filter on but not yet initialized */\n\tdrv = dev->driver;\n\tif (!drv)\n\t\treturn false;\n\n\t/* lock to protect against change of current_driver_name */\n\tread_lock_irqsave(&driver_name_lock, flags);\n\n\tret = false;\n\tif (drv->name &&\n\t    strncmp(current_driver_name, drv->name, NAME_MAX_LEN - 1) == 0) {\n\t\tcurrent_driver = drv;\n\t\tret = true;\n\t}\n\n\tread_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dump_entry_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "166-174",
    "snippet": "static inline void dump_entry_trace(struct dma_debug_entry *entry)\n{\n#ifdef CONFIG_STACKTRACE\n\tif (entry) {\n\t\tpr_warn(\"Mapped at:\\n\");\n\t\tstack_trace_print(entry->stack_entries, entry->stack_len, 0);\n\t}\n#endif\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stack_trace_print",
          "args": [
            "entry->stack_entries",
            "entry->stack_len",
            "0"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stacktrace.c",
          "lines": "24-34",
          "snippet": "void stack_trace_print(const unsigned long *entries, unsigned int nr_entries,\n\t\t       int spaces)\n{\n\tunsigned int i;\n\n\tif (WARN_ON(!entries))\n\t\treturn;\n\n\tfor (i = 0; i < nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)entries[i]);\n}",
          "includes": [
            "#include <linux/interrupt.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\nvoid stack_trace_print(const unsigned long *entries, unsigned int nr_entries,\n\t\t       int spaces)\n{\n\tunsigned int i;\n\n\tif (WARN_ON(!entries))\n\t\treturn;\n\n\tfor (i = 0; i < nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)entries[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Mapped at:\\n\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstruct dma_debug_entry {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tu64              dev_addr;\n\tu64              size;\n\tint              type;\n\tint              direction;\n\tint\t\t sg_call_ents;\n\tint\t\t sg_mapped_ents;\n\tunsigned long\t pfn;\n\tsize_t\t\t offset;\n\tenum map_err_types  map_err_type;\n#ifdef CONFIG_STACKTRACE\n\tunsigned int\tstack_len;\n\tunsigned long\tstack_entries[DMA_DEBUG_STACKTRACE_ENTRIES];\n#endif\n} ____cacheline_aligned_in_smp;\n\nstatic inline void dump_entry_trace(struct dma_debug_entry *entry)\n{\n#ifdef CONFIG_STACKTRACE\n\tif (entry) {\n\t\tpr_warn(\"Mapped at:\\n\");\n\t\tstack_trace_print(entry->stack_entries, entry->stack_len, 0);\n\t}\n#endif\n}"
  },
  {
    "function_name": "dma_debug_disabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/debug.c",
    "lines": "104-107",
    "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool global_disable",
      "static bool dma_debug_initialized"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"debug.h\"\n#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
  }
]