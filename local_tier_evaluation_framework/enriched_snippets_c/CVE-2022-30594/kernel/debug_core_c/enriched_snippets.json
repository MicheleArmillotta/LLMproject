[
  {
    "function_name": "opt_kgdb_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "1212-1222",
    "snippet": "static int __init opt_kgdb_wait(char *str)\n{\n\tkgdb_break_asap = 1;\n\n\tkdb_init(KDB_INIT_EARLY);\n\tif (kgdb_io_module_registered &&\n\t    IS_ENABLED(CONFIG_ARCH_HAS_EARLY_DEBUG))\n\t\tkgdb_initial_breakpoint();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdb_break_asap;",
      "int\t\t\tkgdb_io_module_registered;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_initial_breakpoint",
          "args": [],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_initial_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "1003-1009",
          "snippet": "static void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kgdb_break_asap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\n\nstatic void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_HAS_EARLY_DEBUG"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_init",
          "args": [
            "KDB_INIT_EARLY"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2913-2932",
          "snippet": "void __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\nint\t\t\tkgdb_io_module_registered;\n\nstatic int __init opt_kgdb_wait(char *str)\n{\n\tkgdb_break_asap = 1;\n\n\tkdb_init(KDB_INIT_EARLY);\n\tif (kgdb_io_module_registered &&\n\t    IS_ENABLED(CONFIG_ARCH_HAS_EARLY_DEBUG))\n\t\tkgdb_initial_breakpoint();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "1202-1209",
    "snippet": "noinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_t\t\t\tkgdb_setting_breakpoint;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&kgdb_setting_breakpoint"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kgdb_breakpoint",
          "args": [],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&kgdb_setting_breakpoint"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}"
  },
  {
    "function_name": "dbg_io_get_char",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "1182-1192",
    "snippet": "int dbg_io_get_char(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\tif (ret == NO_POLL_CHAR)\n\t\treturn -1;\n\tif (!dbg_kdb_mode)\n\t\treturn ret;\n\tif (ret == 127)\n\t\treturn 8;\n\treturn ret;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kgdb_io\t\t*dbg_io_ops;",
      "int dbg_kdb_mode = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_io_ops->read_char",
          "args": [],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_kdb_mode = 1;\n\nint dbg_io_get_char(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\tif (ret == NO_POLL_CHAR)\n\t\treturn -1;\n\tif (!dbg_kdb_mode)\n\t\treturn ret;\n\tif (ret == 127)\n\t\treturn 8;\n\treturn ret;\n}"
  },
  {
    "function_name": "kgdb_unregister_io_module",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "1157-1179",
    "snippet": "void kgdb_unregister_io_module(struct kgdb_io *old_dbg_io_ops)\n{\n\tBUG_ON(kgdb_connected);\n\n\t/*\n\t * KGDB is no longer able to communicate out, so\n\t * unregister our callbacks and reset state.\n\t */\n\tkgdb_unregister_callbacks();\n\n\tspin_lock(&kgdb_registration_lock);\n\n\tWARN_ON_ONCE(dbg_io_ops != old_dbg_io_ops);\n\tdbg_io_ops = NULL;\n\n\tspin_unlock(&kgdb_registration_lock);\n\n\tif (old_dbg_io_ops->deinit)\n\t\told_dbg_io_ops->deinit();\n\n\tpr_info(\"Unregistered I/O driver %s, debugger disabled\\n\",\n\t\told_dbg_io_ops->name);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\t\tkgdb_connected;",
      "struct kgdb_io\t\t*dbg_io_ops;",
      "static DEFINE_SPINLOCK(kgdb_registration_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Unregistered I/O driver %s, debugger disabled\\n\"",
            "old_dbg_io_ops->name"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_dbg_io_ops->deinit",
          "args": [],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kgdb_registration_lock"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dbg_io_ops != old_dbg_io_ops"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kgdb_registration_lock"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_unregister_callbacks",
          "args": [],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_unregister_callbacks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "1073-1093",
          "snippet": "static void kgdb_unregister_callbacks(void)\n{\n\t/*\n\t * When this routine is called KGDB should unregister from\n\t * handlers and clean up, making sure it is not handling any\n\t * break exceptions at the time.\n\t */\n\tif (kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 0;\n\t\tunregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tunregister_module_notifier(&dbg_module_load_nb);\n\t\tkgdb_arch_exit();\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tunregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_con_registered) {\n\t\t\tunregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\tkgdb_io_module_registered;",
            "static int kgdb_con_registered;",
            "static struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};",
            "static struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};",
            "static struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nstatic int kgdb_con_registered;\nstatic struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};\nstatic struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};\nstatic struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};\n\nstatic void kgdb_unregister_callbacks(void)\n{\n\t/*\n\t * When this routine is called KGDB should unregister from\n\t * handlers and clean up, making sure it is not handling any\n\t * break exceptions at the time.\n\t */\n\tif (kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 0;\n\t\tunregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tunregister_module_notifier(&dbg_module_load_nb);\n\t\tkgdb_arch_exit();\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tunregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_con_registered) {\n\t\t\tunregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "kgdb_connected"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nstruct kgdb_io\t\t*dbg_io_ops;\nstatic DEFINE_SPINLOCK(kgdb_registration_lock);\n\nvoid kgdb_unregister_io_module(struct kgdb_io *old_dbg_io_ops)\n{\n\tBUG_ON(kgdb_connected);\n\n\t/*\n\t * KGDB is no longer able to communicate out, so\n\t * unregister our callbacks and reset state.\n\t */\n\tkgdb_unregister_callbacks();\n\n\tspin_lock(&kgdb_registration_lock);\n\n\tWARN_ON_ONCE(dbg_io_ops != old_dbg_io_ops);\n\tdbg_io_ops = NULL;\n\n\tspin_unlock(&kgdb_registration_lock);\n\n\tif (old_dbg_io_ops->deinit)\n\t\told_dbg_io_ops->deinit();\n\n\tpr_info(\"Unregistered I/O driver %s, debugger disabled\\n\",\n\t\told_dbg_io_ops->name);\n}"
  },
  {
    "function_name": "kgdb_register_io_module",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "1101-1148",
    "snippet": "int kgdb_register_io_module(struct kgdb_io *new_dbg_io_ops)\n{\n\tstruct kgdb_io *old_dbg_io_ops;\n\tint err;\n\n\tspin_lock(&kgdb_registration_lock);\n\n\told_dbg_io_ops = dbg_io_ops;\n\tif (old_dbg_io_ops) {\n\t\tif (!old_dbg_io_ops->deinit) {\n\t\t\tspin_unlock(&kgdb_registration_lock);\n\n\t\t\tpr_err(\"KGDB I/O driver %s can't replace %s.\\n\",\n\t\t\t\tnew_dbg_io_ops->name, old_dbg_io_ops->name);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tpr_info(\"Replacing I/O driver %s with %s\\n\",\n\t\t\told_dbg_io_ops->name, new_dbg_io_ops->name);\n\t}\n\n\tif (new_dbg_io_ops->init) {\n\t\terr = new_dbg_io_ops->init();\n\t\tif (err) {\n\t\t\tspin_unlock(&kgdb_registration_lock);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdbg_io_ops = new_dbg_io_ops;\n\n\tspin_unlock(&kgdb_registration_lock);\n\n\tif (old_dbg_io_ops) {\n\t\told_dbg_io_ops->deinit();\n\t\treturn 0;\n\t}\n\n\tpr_info(\"Registered I/O driver %s\\n\", new_dbg_io_ops->name);\n\n\t/* Arm KGDB now. */\n\tkgdb_register_callbacks();\n\n\tif (kgdb_break_asap &&\n\t    (!dbg_is_early || IS_ENABLED(CONFIG_ARCH_HAS_EARLY_DEBUG)))\n\t\tkgdb_initial_breakpoint();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdb_break_asap;",
      "struct kgdb_io\t\t*dbg_io_ops;",
      "static DEFINE_SPINLOCK(kgdb_registration_lock);",
      "bool dbg_is_early = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_initial_breakpoint",
          "args": [],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_initial_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "1003-1009",
          "snippet": "static void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kgdb_break_asap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\n\nstatic void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_HAS_EARLY_DEBUG"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_register_callbacks",
          "args": [],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_register_callbacks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "1054-1071",
          "snippet": "static void kgdb_register_callbacks(void)\n{\n\tif (!kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 1;\n\t\tkgdb_arch_init();\n\t\tif (!dbg_is_early)\n\t\t\tkgdb_arch_late();\n\t\tregister_module_notifier(&dbg_module_load_nb);\n\t\tregister_reboot_notifier(&dbg_reboot_notifier);\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_use_con && !kgdb_con_registered) {\n\t\t\tregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\tkgdb_io_module_registered;",
            "static int kgdb_con_registered;",
            "static int kgdb_use_con;",
            "bool dbg_is_early = true;",
            "static struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};",
            "static struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};",
            "static struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nstatic int kgdb_con_registered;\nstatic int kgdb_use_con;\nbool dbg_is_early = true;\nstatic struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};\nstatic struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};\nstatic struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};\n\nstatic void kgdb_register_callbacks(void)\n{\n\tif (!kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 1;\n\t\tkgdb_arch_init();\n\t\tif (!dbg_is_early)\n\t\t\tkgdb_arch_late();\n\t\tregister_module_notifier(&dbg_module_load_nb);\n\t\tregister_reboot_notifier(&dbg_reboot_notifier);\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_use_con && !kgdb_con_registered) {\n\t\t\tregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Registered I/O driver %s\\n\"",
            "new_dbg_io_ops->name"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_dbg_io_ops->deinit",
          "args": [],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kgdb_registration_lock"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_dbg_io_ops->init",
          "args": [],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Replacing I/O driver %s with %s\\n\"",
            "old_dbg_io_ops->name",
            "new_dbg_io_ops->name"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"KGDB I/O driver %s can't replace %s.\\n\"",
            "new_dbg_io_ops->name",
            "old_dbg_io_ops->name"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kgdb_registration_lock"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\nstruct kgdb_io\t\t*dbg_io_ops;\nstatic DEFINE_SPINLOCK(kgdb_registration_lock);\nbool dbg_is_early = true;\n\nint kgdb_register_io_module(struct kgdb_io *new_dbg_io_ops)\n{\n\tstruct kgdb_io *old_dbg_io_ops;\n\tint err;\n\n\tspin_lock(&kgdb_registration_lock);\n\n\told_dbg_io_ops = dbg_io_ops;\n\tif (old_dbg_io_ops) {\n\t\tif (!old_dbg_io_ops->deinit) {\n\t\t\tspin_unlock(&kgdb_registration_lock);\n\n\t\t\tpr_err(\"KGDB I/O driver %s can't replace %s.\\n\",\n\t\t\t\tnew_dbg_io_ops->name, old_dbg_io_ops->name);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tpr_info(\"Replacing I/O driver %s with %s\\n\",\n\t\t\told_dbg_io_ops->name, new_dbg_io_ops->name);\n\t}\n\n\tif (new_dbg_io_ops->init) {\n\t\terr = new_dbg_io_ops->init();\n\t\tif (err) {\n\t\t\tspin_unlock(&kgdb_registration_lock);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdbg_io_ops = new_dbg_io_ops;\n\n\tspin_unlock(&kgdb_registration_lock);\n\n\tif (old_dbg_io_ops) {\n\t\told_dbg_io_ops->deinit();\n\t\treturn 0;\n\t}\n\n\tpr_info(\"Registered I/O driver %s\\n\", new_dbg_io_ops->name);\n\n\t/* Arm KGDB now. */\n\tkgdb_register_callbacks();\n\n\tif (kgdb_break_asap &&\n\t    (!dbg_is_early || IS_ENABLED(CONFIG_ARCH_HAS_EARLY_DEBUG)))\n\t\tkgdb_initial_breakpoint();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_unregister_callbacks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "1073-1093",
    "snippet": "static void kgdb_unregister_callbacks(void)\n{\n\t/*\n\t * When this routine is called KGDB should unregister from\n\t * handlers and clean up, making sure it is not handling any\n\t * break exceptions at the time.\n\t */\n\tif (kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 0;\n\t\tunregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tunregister_module_notifier(&dbg_module_load_nb);\n\t\tkgdb_arch_exit();\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tunregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_con_registered) {\n\t\t\tunregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\tkgdb_io_module_registered;",
      "static int kgdb_con_registered;",
      "static struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};",
      "static struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};",
      "static struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_console",
          "args": [
            "&kgdbcons"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3080-3137",
          "snippet": "int unregister_console(struct console *console)\n{\n\tstruct console *con;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res < 0)\n\t\treturn res;\n\tif (res > 0)\n\t\treturn 0;\n\n\tres = -ENODEV;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else {\n\t\tfor_each_console(con) {\n\t\t\tif (con->next == console) {\n\t\t\t\tcon->next = console->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res)\n\t\tgoto out_disable_unlock;\n\n\tif (console->flags & CON_EXTENDED)\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\tif (console->exit)\n\t\tres = console->exit(console);\n\n\treturn res;\n\nout_disable_unlock:\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct console *console_drivers;",
            "static int nr_ext_console_drivers;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstruct console *console_drivers;\nstatic int nr_ext_console_drivers;\n\nint unregister_console(struct console *console)\n{\n\tstruct console *con;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res < 0)\n\t\treturn res;\n\tif (res > 0)\n\t\treturn 0;\n\n\tres = -ENODEV;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else {\n\t\tfor_each_console(con) {\n\t\t\tif (con->next == console) {\n\t\t\t\tcon->next = console->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res)\n\t\tgoto out_disable_unlock;\n\n\tif (console->flags & CON_EXTENDED)\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\tif (console->exit)\n\t\tres = console->exit(console);\n\n\treturn res;\n\nout_disable_unlock:\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_sysrq_key",
          "args": [
            "'g'",
            "&sysrq_dbg_op"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_exit",
          "args": [],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_module_notifier",
          "args": [
            "&dbg_module_load_nb"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "307-310",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_reboot_notifier",
          "args": [
            "&dbg_reboot_notifier"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_reboot_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "106-109",
          "snippet": "int unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nstatic int kgdb_con_registered;\nstatic struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};\nstatic struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};\nstatic struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};\n\nstatic void kgdb_unregister_callbacks(void)\n{\n\t/*\n\t * When this routine is called KGDB should unregister from\n\t * handlers and clean up, making sure it is not handling any\n\t * break exceptions at the time.\n\t */\n\tif (kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 0;\n\t\tunregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tunregister_module_notifier(&dbg_module_load_nb);\n\t\tkgdb_arch_exit();\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tunregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_con_registered) {\n\t\t\tunregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kgdb_register_callbacks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "1054-1071",
    "snippet": "static void kgdb_register_callbacks(void)\n{\n\tif (!kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 1;\n\t\tkgdb_arch_init();\n\t\tif (!dbg_is_early)\n\t\t\tkgdb_arch_late();\n\t\tregister_module_notifier(&dbg_module_load_nb);\n\t\tregister_reboot_notifier(&dbg_reboot_notifier);\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_use_con && !kgdb_con_registered) {\n\t\t\tregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 1;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\tkgdb_io_module_registered;",
      "static int kgdb_con_registered;",
      "static int kgdb_use_con;",
      "bool dbg_is_early = true;",
      "static struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};",
      "static struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};",
      "static struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_console",
          "args": [
            "&kgdbcons"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3080-3137",
          "snippet": "int unregister_console(struct console *console)\n{\n\tstruct console *con;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res < 0)\n\t\treturn res;\n\tif (res > 0)\n\t\treturn 0;\n\n\tres = -ENODEV;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else {\n\t\tfor_each_console(con) {\n\t\t\tif (con->next == console) {\n\t\t\t\tcon->next = console->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res)\n\t\tgoto out_disable_unlock;\n\n\tif (console->flags & CON_EXTENDED)\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\tif (console->exit)\n\t\tres = console->exit(console);\n\n\treturn res;\n\nout_disable_unlock:\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct console *console_drivers;",
            "static int nr_ext_console_drivers;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstruct console *console_drivers;\nstatic int nr_ext_console_drivers;\n\nint unregister_console(struct console *console)\n{\n\tstruct console *con;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res < 0)\n\t\treturn res;\n\tif (res > 0)\n\t\treturn 0;\n\n\tres = -ENODEV;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else {\n\t\tfor_each_console(con) {\n\t\t\tif (con->next == console) {\n\t\t\t\tcon->next = console->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res)\n\t\tgoto out_disable_unlock;\n\n\tif (console->flags & CON_EXTENDED)\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\tif (console->exit)\n\t\tres = console->exit(console);\n\n\treturn res;\n\nout_disable_unlock:\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_sysrq_key",
          "args": [
            "'g'",
            "&sysrq_dbg_op"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_reboot_notifier",
          "args": [
            "&dbg_reboot_notifier"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_reboot_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "106-109",
          "snippet": "int unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&dbg_module_load_nb"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "307-310",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_arch_late",
          "args": [],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_late",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "1011-1013",
          "snippet": "void __weak kgdb_arch_late(void)\n{\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nvoid __weak kgdb_arch_late(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_arch_init",
          "args": [],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "207-210",
          "snippet": "int __weak kgdb_arch_init(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_init(void)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nstatic int kgdb_con_registered;\nstatic int kgdb_use_con;\nbool dbg_is_early = true;\nstatic struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};\nstatic struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};\nstatic struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};\n\nstatic void kgdb_register_callbacks(void)\n{\n\tif (!kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 1;\n\t\tkgdb_arch_init();\n\t\tif (!dbg_is_early)\n\t\t\tkgdb_arch_late();\n\t\tregister_module_notifier(&dbg_module_load_nb);\n\t\tregister_reboot_notifier(&dbg_reboot_notifier);\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_use_con && !kgdb_con_registered) {\n\t\t\tregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 1;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "dbg_notify_reboot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "1026-1046",
    "snippet": "static int\ndbg_notify_reboot(struct notifier_block *this, unsigned long code, void *x)\n{\n\t/*\n\t * Take the following action on reboot notify depending on value:\n\t *    1 == Enter debugger\n\t *    0 == [the default] detach debug client\n\t *   -1 == Do nothing... and use this until the board resets\n\t */\n\tswitch (kgdbreboot) {\n\tcase 1:\n\t\tkgdb_breakpoint();\n\t\tgoto done;\n\tcase -1:\n\t\tgoto done;\n\t}\n\tif (!dbg_kdb_mode)\n\t\tgdbstub_exit(code);\ndone:\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdbreboot;",
      "int dbg_kdb_mode = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gdbstub_exit",
          "args": [
            "code"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "gdbstub_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "1124-1156",
          "snippet": "void gdbstub_exit(int status)\n{\n\tunsigned char checksum, ch, buffer[3];\n\tint loop;\n\n\tif (!kgdb_connected)\n\t\treturn;\n\tkgdb_connected = 0;\n\n\tif (!dbg_io_ops || dbg_kdb_mode)\n\t\treturn;\n\n\tbuffer[0] = 'W';\n\tbuffer[1] = hex_asc_hi(status);\n\tbuffer[2] = hex_asc_lo(status);\n\n\tdbg_io_ops->write_char('$');\n\tchecksum = 0;\n\n\tfor (loop = 0; loop < 3; loop++) {\n\t\tch = buffer[loop];\n\t\tchecksum += ch;\n\t\tdbg_io_ops->write_char(ch);\n\t}\n\n\tdbg_io_ops->write_char('#');\n\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\n\t/* make sure the output is flushed, lest the bootloader clobber it */\n\tif (dbg_io_ops->flush)\n\t\tdbg_io_ops->flush();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid gdbstub_exit(int status)\n{\n\tunsigned char checksum, ch, buffer[3];\n\tint loop;\n\n\tif (!kgdb_connected)\n\t\treturn;\n\tkgdb_connected = 0;\n\n\tif (!dbg_io_ops || dbg_kdb_mode)\n\t\treturn;\n\n\tbuffer[0] = 'W';\n\tbuffer[1] = hex_asc_hi(status);\n\tbuffer[2] = hex_asc_lo(status);\n\n\tdbg_io_ops->write_char('$');\n\tchecksum = 0;\n\n\tfor (loop = 0; loop < 3; loop++) {\n\t\tch = buffer[loop];\n\t\tchecksum += ch;\n\t\tdbg_io_ops->write_char(ch);\n\t}\n\n\tdbg_io_ops->write_char('#');\n\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\n\t/* make sure the output is flushed, lest the bootloader clobber it */\n\tif (dbg_io_ops->flush)\n\t\tdbg_io_ops->flush();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_breakpoint",
          "args": [],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "1202-1209",
          "snippet": "noinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdbreboot;\nint dbg_kdb_mode = 1;\n\nstatic int\ndbg_notify_reboot(struct notifier_block *this, unsigned long code, void *x)\n{\n\t/*\n\t * Take the following action on reboot notify depending on value:\n\t *    1 == Enter debugger\n\t *    0 == [the default] detach debug client\n\t *   -1 == Do nothing... and use this until the board resets\n\t */\n\tswitch (kgdbreboot) {\n\tcase 1:\n\t\tkgdb_breakpoint();\n\t\tgoto done;\n\tcase -1:\n\t\tgoto done;\n\t}\n\tif (!dbg_kdb_mode)\n\t\tgdbstub_exit(code);\ndone:\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "dbg_late_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "1015-1024",
    "snippet": "void __init dbg_late_init(void)\n{\n\tdbg_is_early = false;\n\tif (kgdb_io_module_registered)\n\t\tkgdb_arch_late();\n\tkdb_init(KDB_INIT_FULL);\n\n\tif (kgdb_io_module_registered && kgdb_break_asap)\n\t\tkgdb_initial_breakpoint();\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdb_break_asap;",
      "int\t\t\tkgdb_io_module_registered;",
      "bool dbg_is_early = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_initial_breakpoint",
          "args": [],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_initial_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "1003-1009",
          "snippet": "static void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kgdb_break_asap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\n\nstatic void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_init",
          "args": [
            "KDB_INIT_FULL"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2913-2932",
          "snippet": "void __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_arch_late",
          "args": [],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_late",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "1011-1013",
          "snippet": "void __weak kgdb_arch_late(void)\n{\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nvoid __weak kgdb_arch_late(void)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\nint\t\t\tkgdb_io_module_registered;\nbool dbg_is_early = true;\n\nvoid __init dbg_late_init(void)\n{\n\tdbg_is_early = false;\n\tif (kgdb_io_module_registered)\n\t\tkgdb_arch_late();\n\tkdb_init(KDB_INIT_FULL);\n\n\tif (kgdb_io_module_registered && kgdb_break_asap)\n\t\tkgdb_initial_breakpoint();\n}"
  },
  {
    "function_name": "kgdb_arch_late",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "1011-1013",
    "snippet": "void __weak kgdb_arch_late(void)\n{\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nvoid __weak kgdb_arch_late(void)\n{\n}"
  },
  {
    "function_name": "kgdb_initial_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "1003-1009",
    "snippet": "static void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdb_break_asap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_breakpoint",
          "args": [],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "1202-1209",
          "snippet": "noinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Waiting for connection from remote gdb...\\n\""
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_break_asap;\n\nstatic void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}"
  },
  {
    "function_name": "kgdb_panic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "984-1001",
    "snippet": "void kgdb_panic(const char *msg)\n{\n\tif (!kgdb_io_module_registered)\n\t\treturn;\n\n\t/*\n\t * We don't want to get stuck waiting for input from user if\n\t * \"panic_timeout\" indicates the system should automatically\n\t * reboot on panic.\n\t */\n\tif (panic_timeout)\n\t\treturn;\n\n\tif (dbg_kdb_mode)\n\t\tkdb_printf(\"PANIC: %s\\n\", msg);\n\n\tkgdb_breakpoint();\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\tkgdb_io_module_registered;",
      "int dbg_kdb_mode = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_breakpoint",
          "args": [],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "1202-1209",
          "snippet": "noinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"PANIC: %s\\n\"",
            "msg"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nint dbg_kdb_mode = 1;\n\nvoid kgdb_panic(const char *msg)\n{\n\tif (!kgdb_io_module_registered)\n\t\treturn;\n\n\t/*\n\t * We don't want to get stuck waiting for input from user if\n\t * \"panic_timeout\" indicates the system should automatically\n\t * reboot on panic.\n\t */\n\tif (panic_timeout)\n\t\treturn;\n\n\tif (dbg_kdb_mode)\n\t\tkdb_printf(\"PANIC: %s\\n\", msg);\n\n\tkgdb_breakpoint();\n}"
  },
  {
    "function_name": "sysrq_handle_dbg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "959-975",
    "snippet": "static void sysrq_handle_dbg(int key)\n{\n\tif (!dbg_io_ops) {\n\t\tpr_crit(\"ERROR: No KGDB I/O module available\\n\");\n\t\treturn;\n\t}\n\tif (!kgdb_connected) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"KGDB or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Entering KGDB\\n\");\n#endif\n\t}\n\n\tkgdb_breakpoint();\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\t\tkgdb_connected;",
      "struct kgdb_io\t\t*dbg_io_ops;",
      "int dbg_kdb_mode = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_breakpoint",
          "args": [],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "1202-1209",
          "snippet": "noinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb(); /* Sync point before breakpoint */\n\tarch_kgdb_breakpoint();\n\twmb(); /* Sync point after breakpoint */\n\tatomic_dec(&kgdb_setting_breakpoint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Entering KGDB\\n\""
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"KGDB or $3#33 for KDB\\n\""
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"ERROR: No KGDB I/O module available\\n\""
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_kdb_mode = 1;\n\nstatic void sysrq_handle_dbg(int key)\n{\n\tif (!dbg_io_ops) {\n\t\tpr_crit(\"ERROR: No KGDB I/O module available\\n\");\n\t\treturn;\n\t}\n\tif (!kgdb_connected) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"KGDB or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Entering KGDB\\n\");\n#endif\n\t}\n\n\tkgdb_breakpoint();\n}"
  },
  {
    "function_name": "opt_kgdb_con",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "944-954",
    "snippet": "static int __init opt_kgdb_con(char *str)\n{\n\tkgdb_use_con = 1;\n\n\tif (kgdb_io_module_registered && !kgdb_con_registered) {\n\t\tregister_console(&kgdbcons);\n\t\tkgdb_con_registered = 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\tkgdb_io_module_registered;",
      "static int kgdb_con_registered;",
      "static int kgdb_use_con;",
      "static struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_console",
          "args": [
            "&kgdbcons"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3080-3137",
          "snippet": "int unregister_console(struct console *console)\n{\n\tstruct console *con;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res < 0)\n\t\treturn res;\n\tif (res > 0)\n\t\treturn 0;\n\n\tres = -ENODEV;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else {\n\t\tfor_each_console(con) {\n\t\t\tif (con->next == console) {\n\t\t\t\tcon->next = console->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res)\n\t\tgoto out_disable_unlock;\n\n\tif (console->flags & CON_EXTENDED)\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\tif (console->exit)\n\t\tres = console->exit(console);\n\n\treturn res;\n\nout_disable_unlock:\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct console *console_drivers;",
            "static int nr_ext_console_drivers;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstruct console *console_drivers;\nstatic int nr_ext_console_drivers;\n\nint unregister_console(struct console *console)\n{\n\tstruct console *con;\n\tint res;\n\n\tpr_info(\"%sconsole [%s%d] disabled\\n\",\n\t\t(console->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res < 0)\n\t\treturn res;\n\tif (res > 0)\n\t\treturn 0;\n\n\tres = -ENODEV;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else {\n\t\tfor_each_console(con) {\n\t\t\tif (con->next == console) {\n\t\t\t\tcon->next = console->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res)\n\t\tgoto out_disable_unlock;\n\n\tif (console->flags & CON_EXTENDED)\n\t\tnr_ext_console_drivers--;\n\n\t/*\n\t * If this isn't the last console and it has CON_CONSDEV set, we\n\t * need to set it on the next preferred console.\n\t */\n\tif (console_drivers != NULL && console->flags & CON_CONSDEV)\n\t\tconsole_drivers->flags |= CON_CONSDEV;\n\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\tif (console->exit)\n\t\tres = console->exit(console);\n\n\treturn res;\n\nout_disable_unlock:\n\tconsole->flags &= ~CON_ENABLED;\n\tconsole_unlock();\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nstatic int kgdb_con_registered;\nstatic int kgdb_use_con;\nstatic struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};\n\nstatic int __init opt_kgdb_con(char *str)\n{\n\tkgdb_use_con = 1;\n\n\tif (kgdb_io_module_registered && !kgdb_con_registered) {\n\t\tregister_console(&kgdbcons);\n\t\tkgdb_con_registered = 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_console_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "922-935",
    "snippet": "static void kgdb_console_write(struct console *co, const char *s,\n   unsigned count)\n{\n\tunsigned long flags;\n\n\t/* If we're debugging, or KGDB has not connected, don't try\n\t * and print. */\n\tif (!kgdb_connected || atomic_read(&kgdb_active) != -1 || dbg_kdb_mode)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tgdbstub_msg_write(s, count);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\t\tkgdb_connected;",
      "int dbg_kdb_mode = 1;",
      "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdbstub_msg_write",
          "args": [
            "s",
            "count"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "gdbstub_msg_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "195-229",
          "snippet": "void gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char gdbmsgbuf[BUFMAX + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char gdbmsgbuf[BUFMAX + 1];\n\nvoid gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_active"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\n\nstatic void kgdb_console_write(struct console *co, const char *s,\n   unsigned count)\n{\n\tunsigned long flags;\n\n\t/* If we're debugging, or KGDB has not connected, don't try\n\t * and print. */\n\tif (!kgdb_connected || atomic_read(&kgdb_active) != -1 || dbg_kdb_mode)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tgdbstub_msg_write(s, count);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "kgdb_nmicallin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "896-919",
    "snippet": "int kgdb_nmicallin(int cpu, int trapnr, void *regs, int err_code,\n\t\t\t\t\t\t\tatomic_t *send_ready)\n{\n#ifdef CONFIG_SMP\n\tif (!kgdb_io_ready(0) || !send_ready)\n\t\treturn 1;\n\n\tif (kgdb_info[cpu].enter_kgdb == 0) {\n\t\tstruct kgdb_state kgdb_var;\n\t\tstruct kgdb_state *ks = &kgdb_var;\n\n\t\tmemset(ks, 0, sizeof(struct kgdb_state));\n\t\tks->cpu\t\t\t= cpu;\n\t\tks->ex_vector\t\t= trapnr;\n\t\tks->signo\t\t= SIGTRAP;\n\t\tks->err_code\t\t= err_code;\n\t\tks->linux_regs\t\t= regs;\n\t\tks->send_ready\t\t= send_ready;\n\t\tkgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct debuggerinfo_struct kgdb_info[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_cpu_enter",
          "args": [
            "ks",
            "regs",
            "DCPU_WANT_MASTER"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_cpu_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "582-813",
          "snippet": "static int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\trcu_read_lock();\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_BT) {\n\t\t\tdump_stack();\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_WANT_BT;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].debuggerinfo = NULL;\n\t\t\tkgdb_info[cpu].task = NULL;\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\t\trcu_read_unlock();\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\tatomic_inc(&ignore_console_lock_warning);\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus();\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_activate_sw_breakpoints();\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tatomic_dec(&ignore_console_lock_warning);\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].debuggerinfo = NULL;\n\tkgdb_info[cpu].task = NULL;\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\trcu_read_unlock();\n\n\treturn kgdb_info[cpu].ret_state;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct debuggerinfo_struct kgdb_info[NR_CPUS];",
            "int\t\t\t\tkgdb_connected;",
            "static int\t\t\texception_level;",
            "struct kgdb_io\t\t*dbg_io_ops;",
            "int dbg_switch_cpu;",
            "int dbg_kdb_mode = 1;",
            "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);",
            "static DEFINE_RAW_SPINLOCK(dbg_master_lock);",
            "static DEFINE_RAW_SPINLOCK(dbg_slave_lock);",
            "static atomic_t\t\t\tmasters_in_kgdb;",
            "static atomic_t\t\t\tslaves_in_kgdb;",
            "struct task_struct\t\t*kgdb_contthread;",
            "int\t\t\t\tkgdb_single_step;",
            "static pid_t\t\t\tkgdb_sstep_pid;",
            "atomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);",
            "static int kgdb_do_roundup = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\nint\t\t\t\tkgdb_connected;\nstatic int\t\t\texception_level;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_switch_cpu;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\nstatic DEFINE_RAW_SPINLOCK(dbg_slave_lock);\nstatic atomic_t\t\t\tmasters_in_kgdb;\nstatic atomic_t\t\t\tslaves_in_kgdb;\nstruct task_struct\t\t*kgdb_contthread;\nint\t\t\t\tkgdb_single_step;\nstatic pid_t\t\t\tkgdb_sstep_pid;\natomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);\nstatic int kgdb_do_roundup = 1;\n\nstatic int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\trcu_read_lock();\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_BT) {\n\t\t\tdump_stack();\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_WANT_BT;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].debuggerinfo = NULL;\n\t\t\tkgdb_info[cpu].task = NULL;\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\t\trcu_read_unlock();\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\tatomic_inc(&ignore_console_lock_warning);\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus();\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_activate_sw_breakpoints();\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tatomic_dec(&ignore_console_lock_warning);\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].debuggerinfo = NULL;\n\tkgdb_info[cpu].task = NULL;\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\trcu_read_unlock();\n\n\treturn kgdb_info[cpu].ret_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ks",
            "0",
            "sizeof(struct kgdb_state)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_io_ready",
          "args": [
            "0"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_io_ready",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "506-523",
          "snippet": "static int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\t\tkgdb_connected;",
            "struct kgdb_io\t\t*dbg_io_ops;",
            "int dbg_kdb_mode = 1;",
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nstatic int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\n\nint kgdb_nmicallin(int cpu, int trapnr, void *regs, int err_code,\n\t\t\t\t\t\t\tatomic_t *send_ready)\n{\n#ifdef CONFIG_SMP\n\tif (!kgdb_io_ready(0) || !send_ready)\n\t\treturn 1;\n\n\tif (kgdb_info[cpu].enter_kgdb == 0) {\n\t\tstruct kgdb_state kgdb_var;\n\t\tstruct kgdb_state *ks = &kgdb_var;\n\n\t\tmemset(ks, 0, sizeof(struct kgdb_state));\n\t\tks->cpu\t\t\t= cpu;\n\t\tks->ex_vector\t\t= trapnr;\n\t\tks->signo\t\t= SIGTRAP;\n\t\tks->err_code\t\t= err_code;\n\t\tks->linux_regs\t\t= regs;\n\t\tks->send_ready\t\t= send_ready;\n\t\tkgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "kgdb_nmicallback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "874-893",
    "snippet": "int kgdb_nmicallback(int cpu, void *regs)\n{\n#ifdef CONFIG_SMP\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\n\tkgdb_info[cpu].rounding_up = false;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= cpu;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_info[ks->cpu].enter_kgdb == 0 &&\n\t\t\traw_spin_is_locked(&dbg_master_lock)) {\n\t\tkgdb_cpu_enter(ks, regs, DCPU_IS_SLAVE);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct debuggerinfo_struct kgdb_info[NR_CPUS];",
      "static DEFINE_RAW_SPINLOCK(dbg_master_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_cpu_enter",
          "args": [
            "ks",
            "regs",
            "DCPU_IS_SLAVE"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_cpu_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "582-813",
          "snippet": "static int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\trcu_read_lock();\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_BT) {\n\t\t\tdump_stack();\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_WANT_BT;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].debuggerinfo = NULL;\n\t\t\tkgdb_info[cpu].task = NULL;\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\t\trcu_read_unlock();\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\tatomic_inc(&ignore_console_lock_warning);\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus();\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_activate_sw_breakpoints();\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tatomic_dec(&ignore_console_lock_warning);\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].debuggerinfo = NULL;\n\tkgdb_info[cpu].task = NULL;\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\trcu_read_unlock();\n\n\treturn kgdb_info[cpu].ret_state;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct debuggerinfo_struct kgdb_info[NR_CPUS];",
            "int\t\t\t\tkgdb_connected;",
            "static int\t\t\texception_level;",
            "struct kgdb_io\t\t*dbg_io_ops;",
            "int dbg_switch_cpu;",
            "int dbg_kdb_mode = 1;",
            "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);",
            "static DEFINE_RAW_SPINLOCK(dbg_master_lock);",
            "static DEFINE_RAW_SPINLOCK(dbg_slave_lock);",
            "static atomic_t\t\t\tmasters_in_kgdb;",
            "static atomic_t\t\t\tslaves_in_kgdb;",
            "struct task_struct\t\t*kgdb_contthread;",
            "int\t\t\t\tkgdb_single_step;",
            "static pid_t\t\t\tkgdb_sstep_pid;",
            "atomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);",
            "static int kgdb_do_roundup = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\nint\t\t\t\tkgdb_connected;\nstatic int\t\t\texception_level;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_switch_cpu;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\nstatic DEFINE_RAW_SPINLOCK(dbg_slave_lock);\nstatic atomic_t\t\t\tmasters_in_kgdb;\nstatic atomic_t\t\t\tslaves_in_kgdb;\nstruct task_struct\t\t*kgdb_contthread;\nint\t\t\t\tkgdb_single_step;\nstatic pid_t\t\t\tkgdb_sstep_pid;\natomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);\nstatic int kgdb_do_roundup = 1;\n\nstatic int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\trcu_read_lock();\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_BT) {\n\t\t\tdump_stack();\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_WANT_BT;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].debuggerinfo = NULL;\n\t\t\tkgdb_info[cpu].task = NULL;\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\t\trcu_read_unlock();\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\tatomic_inc(&ignore_console_lock_warning);\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus();\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_activate_sw_breakpoints();\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tatomic_dec(&ignore_console_lock_warning);\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].debuggerinfo = NULL;\n\tkgdb_info[cpu].task = NULL;\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\trcu_read_unlock();\n\n\treturn kgdb_info[cpu].ret_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_is_locked",
          "args": [
            "&dbg_master_lock"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ks",
            "0",
            "sizeof(struct kgdb_state)"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\n\nint kgdb_nmicallback(int cpu, void *regs)\n{\n#ifdef CONFIG_SMP\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\n\tkgdb_info[cpu].rounding_up = false;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= cpu;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_info[ks->cpu].enter_kgdb == 0 &&\n\t\t\traw_spin_is_locked(&dbg_master_lock)) {\n\t\tkgdb_cpu_enter(ks, regs, DCPU_IS_SLAVE);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "module_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "864-868",
    "snippet": "static int module_event(struct notifier_block *self, unsigned long val,\n\tvoid *data)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int module_event(struct notifier_block *self, unsigned long val,\n\tvoid *data)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_handle_exception",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "823-858",
    "snippet": "int\nkgdb_handle_exception(int evector, int signo, int ecode, struct pt_regs *regs)\n{\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\tint ret = 0;\n\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tarch_kgdb_ops.enable_nmi(0);\n\t/*\n\t * Avoid entering the debugger if we were triggered due to an oops\n\t * but panic_timeout indicates the system should automatically\n\t * reboot on panic. We don't want to get stuck waiting for input\n\t * on such systems, especially if its \"just\" an oops.\n\t */\n\tif (signo != SIGTRAP && panic_timeout)\n\t\treturn 1;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= raw_smp_processor_id();\n\tks->ex_vector\t\t= evector;\n\tks->signo\t\t= signo;\n\tks->err_code\t\t= ecode;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_reenter_check(ks))\n\t\tgoto out; /* Ouch, double exception ! */\n\tif (kgdb_info[ks->cpu].enter_kgdb != 0)\n\t\tgoto out;\n\n\tret = kgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\nout:\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tarch_kgdb_ops.enable_nmi(1);\n\treturn ret;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct debuggerinfo_struct kgdb_info[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kgdb_ops.enable_nmi",
          "args": [
            "1"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "enable_nmi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "834-837",
          "snippet": "void enable_nmi(unsigned int irq)\n{\n\tenable_irq(irq);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid enable_nmi(unsigned int irq)\n{\n\tenable_irq(irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_cpu_enter",
          "args": [
            "ks",
            "regs",
            "DCPU_WANT_MASTER"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_cpu_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "582-813",
          "snippet": "static int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\trcu_read_lock();\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_BT) {\n\t\t\tdump_stack();\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_WANT_BT;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].debuggerinfo = NULL;\n\t\t\tkgdb_info[cpu].task = NULL;\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\t\trcu_read_unlock();\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\tatomic_inc(&ignore_console_lock_warning);\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus();\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_activate_sw_breakpoints();\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tatomic_dec(&ignore_console_lock_warning);\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].debuggerinfo = NULL;\n\tkgdb_info[cpu].task = NULL;\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\trcu_read_unlock();\n\n\treturn kgdb_info[cpu].ret_state;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct debuggerinfo_struct kgdb_info[NR_CPUS];",
            "int\t\t\t\tkgdb_connected;",
            "static int\t\t\texception_level;",
            "struct kgdb_io\t\t*dbg_io_ops;",
            "int dbg_switch_cpu;",
            "int dbg_kdb_mode = 1;",
            "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);",
            "static DEFINE_RAW_SPINLOCK(dbg_master_lock);",
            "static DEFINE_RAW_SPINLOCK(dbg_slave_lock);",
            "static atomic_t\t\t\tmasters_in_kgdb;",
            "static atomic_t\t\t\tslaves_in_kgdb;",
            "struct task_struct\t\t*kgdb_contthread;",
            "int\t\t\t\tkgdb_single_step;",
            "static pid_t\t\t\tkgdb_sstep_pid;",
            "atomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);",
            "static int kgdb_do_roundup = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\nint\t\t\t\tkgdb_connected;\nstatic int\t\t\texception_level;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_switch_cpu;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\nstatic DEFINE_RAW_SPINLOCK(dbg_slave_lock);\nstatic atomic_t\t\t\tmasters_in_kgdb;\nstatic atomic_t\t\t\tslaves_in_kgdb;\nstruct task_struct\t\t*kgdb_contthread;\nint\t\t\t\tkgdb_single_step;\nstatic pid_t\t\t\tkgdb_sstep_pid;\natomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);\nstatic int kgdb_do_roundup = 1;\n\nstatic int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\trcu_read_lock();\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_BT) {\n\t\t\tdump_stack();\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_WANT_BT;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].debuggerinfo = NULL;\n\t\t\tkgdb_info[cpu].task = NULL;\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\t\trcu_read_unlock();\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\tatomic_inc(&ignore_console_lock_warning);\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus();\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_activate_sw_breakpoints();\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tatomic_dec(&ignore_console_lock_warning);\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].debuggerinfo = NULL;\n\tkgdb_info[cpu].task = NULL;\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\trcu_read_unlock();\n\n\treturn kgdb_info[cpu].ret_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_reenter_check",
          "args": [
            "ks"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_reenter_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "526-571",
          "snippet": "static int kgdb_reenter_check(struct kgdb_state *ks)\n{\n\tunsigned long addr;\n\n\tif (atomic_read(&kgdb_active) != raw_smp_processor_id())\n\t\treturn 0;\n\n\t/* Panic on recursive debugger calls: */\n\texception_level++;\n\taddr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tdbg_deactivate_sw_breakpoints();\n\n\t/*\n\t * If the break point removed ok at the place exception\n\t * occurred, try to recover and print a warning to the end\n\t * user because the user planted a breakpoint in a place that\n\t * KGDB needs in order to function.\n\t */\n\tif (dbg_remove_sw_break(addr) == 0) {\n\t\texception_level = 0;\n\t\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\t\tdbg_activate_sw_breakpoints();\n\t\tpr_crit(\"re-enter error: breakpoint removed %lx\\n\", addr);\n\t\tWARN_ON_ONCE(1);\n\n\t\treturn 1;\n\t}\n\tdbg_remove_all_break();\n\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\n\tif (exception_level > 1) {\n\t\tdump_stack();\n\t\tkgdb_io_module_registered = false;\n\t\tpanic(\"Recursive entry to debugger\");\n\t}\n\n\tpr_crit(\"re-enter exception: ALL breakpoints killed\\n\");\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow kdb to debug itself one level */\n\treturn 0;\n#endif\n\tdump_stack();\n\tpanic(\"Recursive entry to debugger\");\n\n\treturn 1;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\tkgdb_io_module_registered;",
            "static int\t\t\texception_level;",
            "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nstatic int\t\t\texception_level;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\n\nstatic int kgdb_reenter_check(struct kgdb_state *ks)\n{\n\tunsigned long addr;\n\n\tif (atomic_read(&kgdb_active) != raw_smp_processor_id())\n\t\treturn 0;\n\n\t/* Panic on recursive debugger calls: */\n\texception_level++;\n\taddr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tdbg_deactivate_sw_breakpoints();\n\n\t/*\n\t * If the break point removed ok at the place exception\n\t * occurred, try to recover and print a warning to the end\n\t * user because the user planted a breakpoint in a place that\n\t * KGDB needs in order to function.\n\t */\n\tif (dbg_remove_sw_break(addr) == 0) {\n\t\texception_level = 0;\n\t\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\t\tdbg_activate_sw_breakpoints();\n\t\tpr_crit(\"re-enter error: breakpoint removed %lx\\n\", addr);\n\t\tWARN_ON_ONCE(1);\n\n\t\treturn 1;\n\t}\n\tdbg_remove_all_break();\n\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\n\tif (exception_level > 1) {\n\t\tdump_stack();\n\t\tkgdb_io_module_registered = false;\n\t\tpanic(\"Recursive entry to debugger\");\n\t}\n\n\tpr_crit(\"re-enter exception: ALL breakpoints killed\\n\");\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow kdb to debug itself one level */\n\treturn 0;\n#endif\n\tdump_stack();\n\tpanic(\"Recursive entry to debugger\");\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ks",
            "0",
            "sizeof(struct kgdb_state)"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\n\nint\nkgdb_handle_exception(int evector, int signo, int ecode, struct pt_regs *regs)\n{\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\tint ret = 0;\n\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tarch_kgdb_ops.enable_nmi(0);\n\t/*\n\t * Avoid entering the debugger if we were triggered due to an oops\n\t * but panic_timeout indicates the system should automatically\n\t * reboot on panic. We don't want to get stuck waiting for input\n\t * on such systems, especially if its \"just\" an oops.\n\t */\n\tif (signo != SIGTRAP && panic_timeout)\n\t\treturn 1;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= raw_smp_processor_id();\n\tks->ex_vector\t\t= evector;\n\tks->signo\t\t= signo;\n\tks->err_code\t\t= ecode;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_reenter_check(ks))\n\t\tgoto out; /* Ouch, double exception ! */\n\tif (kgdb_info[ks->cpu].enter_kgdb != 0)\n\t\tgoto out;\n\n\tret = kgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\nout:\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tarch_kgdb_ops.enable_nmi(1);\n\treturn ret;\n}"
  },
  {
    "function_name": "kgdb_cpu_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "582-813",
    "snippet": "static int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\trcu_read_lock();\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_BT) {\n\t\t\tdump_stack();\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_WANT_BT;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].debuggerinfo = NULL;\n\t\t\tkgdb_info[cpu].task = NULL;\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\t\trcu_read_unlock();\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\tatomic_inc(&ignore_console_lock_warning);\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus();\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_activate_sw_breakpoints();\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tatomic_dec(&ignore_console_lock_warning);\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].debuggerinfo = NULL;\n\tkgdb_info[cpu].task = NULL;\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\trcu_read_unlock();\n\n\treturn kgdb_info[cpu].ret_state;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct debuggerinfo_struct kgdb_info[NR_CPUS];",
      "int\t\t\t\tkgdb_connected;",
      "static int\t\t\texception_level;",
      "struct kgdb_io\t\t*dbg_io_ops;",
      "int dbg_switch_cpu;",
      "int dbg_kdb_mode = 1;",
      "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);",
      "static DEFINE_RAW_SPINLOCK(dbg_master_lock);",
      "static DEFINE_RAW_SPINLOCK(dbg_slave_lock);",
      "static atomic_t\t\t\tmasters_in_kgdb;",
      "static atomic_t\t\t\tslaves_in_kgdb;",
      "struct task_struct\t\t*kgdb_contthread;",
      "int\t\t\t\tkgdb_single_step;",
      "static pid_t\t\t\tkgdb_sstep_pid;",
      "atomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);",
      "static int kgdb_do_roundup = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_touch_watchdogs",
          "args": [],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_touch_watchdogs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "574-579",
          "snippet": "static void dbg_touch_watchdogs(void)\n{\n\ttouch_softlockup_watchdog_sync();\n\tclocksource_touch_watchdog();\n\trcu_cpu_stall_reset();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic void dbg_touch_watchdogs(void)\n{\n\ttouch_softlockup_watchdog_sync();\n\tclocksource_touch_watchdog();\n\trcu_cpu_stall_reset();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&dbg_master_lock"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kgdb_active",
            "-1"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&masters_in_kgdb"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_on",
          "args": [],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "965-968",
          "snippet": "void tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_kgdb_ops.correct_hw_break",
          "args": [],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_cpu_doing_single_step"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_cpu_doing_single_step"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&slaves_in_kgdb"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&ignore_console_lock_warning"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->post_exception",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_activate_sw_breakpoints",
          "args": [],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_activate_sw_breakpoints",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "304-326",
          "snippet": "int dbg_activate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_SET)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"BP install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_ACTIVE;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_activate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_SET)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"BP install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_ACTIVE;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_serial_stub",
          "args": [
            "ks"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_serial_stub",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "954-1090",
          "snippet": "int gdb_serial_stub(struct kgdb_state *ks)\n{\n\tint error = 0;\n\tint tmp;\n\n\t/* Initialize comm buffer and globals. */\n\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\tkgdb_usethread = kgdb_info[ks->cpu].task;\n\tks->kgdb_usethreadid = shadow_pid(kgdb_info[ks->cpu].task->pid);\n\tks->pass_exception = 0;\n\n\tif (kgdb_connected) {\n\t\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\t\tchar *ptr;\n\n\t\t/* Reply to host that an exception has occurred */\n\t\tptr = remcom_out_buffer;\n\t\t*ptr++ = 'T';\n\t\tptr = hex_byte_pack(ptr, ks->signo);\n\t\tptr += strlen(strcpy(ptr, \"thread:\"));\n\t\tint_to_threadref(thref, shadow_pid(current->pid));\n\t\tptr = pack_threadid(ptr, thref);\n\t\t*ptr++ = ';';\n\t\tput_packet(remcom_out_buffer);\n\t}\n\n\twhile (1) {\n\t\terror = 0;\n\n\t\t/* Clear the out buffer. */\n\t\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\n\t\tget_packet(remcom_in_buffer);\n\n\t\tswitch (remcom_in_buffer[0]) {\n\t\tcase '?': /* gdbserial status */\n\t\t\tgdb_cmd_status(ks);\n\t\t\tbreak;\n\t\tcase 'g': /* return the value of the CPU registers */\n\t\t\tgdb_cmd_getregs(ks);\n\t\t\tbreak;\n\t\tcase 'G': /* set the value of the CPU registers - return OK */\n\t\t\tgdb_cmd_setregs(ks);\n\t\t\tbreak;\n\t\tcase 'm': /* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memread(ks);\n\t\t\tbreak;\n\t\tcase 'M': /* MAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memwrite(ks);\n\t\t\tbreak;\n#if DBG_MAX_REG_NUM > 0\n\t\tcase 'p': /* pXX Return gdb register XX (in hex) */\n\t\t\tgdb_cmd_reg_get(ks);\n\t\t\tbreak;\n\t\tcase 'P': /* PXX=aaaa Set gdb register XX to aaaa (in hex) */\n\t\t\tgdb_cmd_reg_set(ks);\n\t\t\tbreak;\n#endif /* DBG_MAX_REG_NUM > 0 */\n\t\tcase 'X': /* XAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_binwrite(ks);\n\t\t\tbreak;\n\t\t\t/* kill or detach. KGDB should treat this like a\n\t\t\t * continue.\n\t\t\t */\n\t\tcase 'D': /* Debugger detach */\n\t\tcase 'k': /* Debugger detach via kill */\n\t\t\tgdb_cmd_detachkill(ks);\n\t\t\tgoto default_handle;\n\t\tcase 'R': /* Reboot */\n\t\t\tif (gdb_cmd_reboot(ks))\n\t\t\t\tgoto default_handle;\n\t\t\tbreak;\n\t\tcase 'q': /* query command */\n\t\t\tgdb_cmd_query(ks);\n\t\t\tbreak;\n\t\tcase 'H': /* task related */\n\t\t\tgdb_cmd_task(ks);\n\t\t\tbreak;\n\t\tcase 'T': /* Query thread status */\n\t\t\tgdb_cmd_thread(ks);\n\t\t\tbreak;\n\t\tcase 'z': /* Break point remove */\n\t\tcase 'Z': /* Break point set */\n\t\t\tgdb_cmd_break(ks);\n\t\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\t\tcase '3': /* Escape into back into kdb */\n\t\t\tif (remcom_in_buffer[1] == '\\0') {\n\t\t\t\tgdb_cmd_detachkill(ks);\n\t\t\t\treturn DBG_PASS_EVENT;\n\t\t\t}\n\t\t\tfallthrough;\n#endif\n\t\tcase 'C': /* Exception passing */\n\t\t\ttmp = gdb_cmd_exception_pass(ks);\n\t\t\tif (tmp > 0)\n\t\t\t\tgoto default_handle;\n\t\t\tif (tmp == 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\t/* on tmp < 0 */\n\t\tcase 'c': /* Continue packet */\n\t\tcase 's': /* Single step packet */\n\t\t\tif (kgdb_contthread && kgdb_contthread != current) {\n\t\t\t\t/* Can't switch threads in kgdb */\n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t/* to default processing */\n\t\tdefault:\ndefault_handle:\n\t\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\tks->signo,\n\t\t\t\t\t\tks->err_code,\n\t\t\t\t\t\tremcom_in_buffer,\n\t\t\t\t\t\tremcom_out_buffer,\n\t\t\t\t\t\tks->linux_regs);\n\t\t\t/*\n\t\t\t * Leave cmd processing on error, detach,\n\t\t\t * kill, continue, or single step.\n\t\t\t */\n\t\t\tif (error >= 0 || remcom_in_buffer[0] == 'D' ||\n\t\t\t    remcom_in_buffer[0] == 'k') {\n\t\t\t\terror = 0;\n\t\t\t\tgoto kgdb_exit;\n\t\t\t}\n\n\t\t}\n\n\t\t/* reply to the request */\n\t\tput_packet(remcom_out_buffer);\n\t}\n\nkgdb_exit:\n\tif (ks->pass_exception)\n\t\terror = 1;\n\treturn error;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BUF_THREAD_ID_SIZE\t8"
          ],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BUF_THREAD_ID_SIZE\t8\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nint gdb_serial_stub(struct kgdb_state *ks)\n{\n\tint error = 0;\n\tint tmp;\n\n\t/* Initialize comm buffer and globals. */\n\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\tkgdb_usethread = kgdb_info[ks->cpu].task;\n\tks->kgdb_usethreadid = shadow_pid(kgdb_info[ks->cpu].task->pid);\n\tks->pass_exception = 0;\n\n\tif (kgdb_connected) {\n\t\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\t\tchar *ptr;\n\n\t\t/* Reply to host that an exception has occurred */\n\t\tptr = remcom_out_buffer;\n\t\t*ptr++ = 'T';\n\t\tptr = hex_byte_pack(ptr, ks->signo);\n\t\tptr += strlen(strcpy(ptr, \"thread:\"));\n\t\tint_to_threadref(thref, shadow_pid(current->pid));\n\t\tptr = pack_threadid(ptr, thref);\n\t\t*ptr++ = ';';\n\t\tput_packet(remcom_out_buffer);\n\t}\n\n\twhile (1) {\n\t\terror = 0;\n\n\t\t/* Clear the out buffer. */\n\t\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\n\t\tget_packet(remcom_in_buffer);\n\n\t\tswitch (remcom_in_buffer[0]) {\n\t\tcase '?': /* gdbserial status */\n\t\t\tgdb_cmd_status(ks);\n\t\t\tbreak;\n\t\tcase 'g': /* return the value of the CPU registers */\n\t\t\tgdb_cmd_getregs(ks);\n\t\t\tbreak;\n\t\tcase 'G': /* set the value of the CPU registers - return OK */\n\t\t\tgdb_cmd_setregs(ks);\n\t\t\tbreak;\n\t\tcase 'm': /* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memread(ks);\n\t\t\tbreak;\n\t\tcase 'M': /* MAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memwrite(ks);\n\t\t\tbreak;\n#if DBG_MAX_REG_NUM > 0\n\t\tcase 'p': /* pXX Return gdb register XX (in hex) */\n\t\t\tgdb_cmd_reg_get(ks);\n\t\t\tbreak;\n\t\tcase 'P': /* PXX=aaaa Set gdb register XX to aaaa (in hex) */\n\t\t\tgdb_cmd_reg_set(ks);\n\t\t\tbreak;\n#endif /* DBG_MAX_REG_NUM > 0 */\n\t\tcase 'X': /* XAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_binwrite(ks);\n\t\t\tbreak;\n\t\t\t/* kill or detach. KGDB should treat this like a\n\t\t\t * continue.\n\t\t\t */\n\t\tcase 'D': /* Debugger detach */\n\t\tcase 'k': /* Debugger detach via kill */\n\t\t\tgdb_cmd_detachkill(ks);\n\t\t\tgoto default_handle;\n\t\tcase 'R': /* Reboot */\n\t\t\tif (gdb_cmd_reboot(ks))\n\t\t\t\tgoto default_handle;\n\t\t\tbreak;\n\t\tcase 'q': /* query command */\n\t\t\tgdb_cmd_query(ks);\n\t\t\tbreak;\n\t\tcase 'H': /* task related */\n\t\t\tgdb_cmd_task(ks);\n\t\t\tbreak;\n\t\tcase 'T': /* Query thread status */\n\t\t\tgdb_cmd_thread(ks);\n\t\t\tbreak;\n\t\tcase 'z': /* Break point remove */\n\t\tcase 'Z': /* Break point set */\n\t\t\tgdb_cmd_break(ks);\n\t\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\t\tcase '3': /* Escape into back into kdb */\n\t\t\tif (remcom_in_buffer[1] == '\\0') {\n\t\t\t\tgdb_cmd_detachkill(ks);\n\t\t\t\treturn DBG_PASS_EVENT;\n\t\t\t}\n\t\t\tfallthrough;\n#endif\n\t\tcase 'C': /* Exception passing */\n\t\t\ttmp = gdb_cmd_exception_pass(ks);\n\t\t\tif (tmp > 0)\n\t\t\t\tgoto default_handle;\n\t\t\tif (tmp == 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\t/* on tmp < 0 */\n\t\tcase 'c': /* Continue packet */\n\t\tcase 's': /* Single step packet */\n\t\t\tif (kgdb_contthread && kgdb_contthread != current) {\n\t\t\t\t/* Can't switch threads in kgdb */\n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t/* to default processing */\n\t\tdefault:\ndefault_handle:\n\t\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\tks->signo,\n\t\t\t\t\t\tks->err_code,\n\t\t\t\t\t\tremcom_in_buffer,\n\t\t\t\t\t\tremcom_out_buffer,\n\t\t\t\t\t\tks->linux_regs);\n\t\t\t/*\n\t\t\t * Leave cmd processing on error, detach,\n\t\t\t * kill, continue, or single step.\n\t\t\t */\n\t\t\tif (error >= 0 || remcom_in_buffer[0] == 'D' ||\n\t\t\t    remcom_in_buffer[0] == 'k') {\n\t\t\t\terror = 0;\n\t\t\t\tgoto kgdb_exit;\n\t\t\t}\n\n\t\t}\n\n\t\t/* reply to the request */\n\t\tput_packet(remcom_out_buffer);\n\t}\n\nkgdb_exit:\n\tif (ks->pass_exception)\n\t\terror = 1;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_stub",
          "args": [
            "ks"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_stub",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.h",
          "lines": "81-84",
          "snippet": "static inline int kdb_stub(struct kgdb_state *ks)\n{\n\treturn DBG_PASS_EVENT;\n}",
          "includes": [],
          "macros_used": [
            "#define DBG_PASS_EVENT -12345"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define DBG_PASS_EVENT -12345\n\nstatic inline int kdb_stub(struct kgdb_state *ks)\n{\n\treturn DBG_PASS_EVENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_off",
          "args": [],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1429-1432",
          "snippet": "void tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1460-1463",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_deactivate_sw_breakpoints",
          "args": [],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_deactivate_sw_breakpoints",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "370-390",
          "snippet": "int dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Timed out waiting for secondary CPUs.\\n\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1000"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&slaves_in_kgdb"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&masters_in_kgdb"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_roundup_cpus",
          "args": [],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_roundup_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "241-271",
          "snippet": "void __weak kgdb_roundup_cpus(void)\n{\n\tcall_single_data_t *csd;\n\tint this_cpu = raw_smp_processor_id();\n\tint cpu;\n\tint ret;\n\n\tfor_each_online_cpu(cpu) {\n\t\t/* No need to roundup ourselves */\n\t\tif (cpu == this_cpu)\n\t\t\tcontinue;\n\n\t\tcsd = &per_cpu(kgdb_roundup_csd, cpu);\n\n\t\t/*\n\t\t * If it didn't round up last time, don't try again\n\t\t * since smp_call_function_single_async() will block.\n\t\t *\n\t\t * If rounding_up is false then we know that the\n\t\t * previous call must have at least started and that\n\t\t * means smp_call_function_single_async() won't block.\n\t\t */\n\t\tif (kgdb_info[cpu].rounding_up)\n\t\t\tcontinue;\n\t\tkgdb_info[cpu].rounding_up = true;\n\n\t\tret = smp_call_function_single_async(cpu, csd);\n\t\tif (ret)\n\t\t\tkgdb_info[cpu].rounding_up = false;\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct debuggerinfo_struct kgdb_info[NR_CPUS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\n\nvoid __weak kgdb_roundup_cpus(void)\n{\n\tcall_single_data_t *csd;\n\tint this_cpu = raw_smp_processor_id();\n\tint cpu;\n\tint ret;\n\n\tfor_each_online_cpu(cpu) {\n\t\t/* No need to roundup ourselves */\n\t\tif (cpu == this_cpu)\n\t\t\tcontinue;\n\n\t\tcsd = &per_cpu(kgdb_roundup_csd, cpu);\n\n\t\t/*\n\t\t * If it didn't round up last time, don't try again\n\t\t * since smp_call_function_single_async() will block.\n\t\t *\n\t\t * If rounding_up is false then we know that the\n\t\t * previous call must have at least started and that\n\t\t * means smp_call_function_single_async() won't block.\n\t\t */\n\t\tif (kgdb_info[cpu].rounding_up)\n\t\t\tcontinue;\n\t\tkgdb_info[cpu].rounding_up = true;\n\n\t\tret = smp_call_function_single_async(cpu, csd);\n\t\tif (ret)\n\t\t\tkgdb_info[cpu].rounding_up = false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "ks->send_ready",
            "1"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&dbg_slave_lock"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->pre_exception",
          "args": [],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ignore_console_lock_warning"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_skipexception",
          "args": [
            "ks->ex_vector",
            "ks->linux_regs"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_skipexception",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "212-215",
          "snippet": "int __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_io_ready",
          "args": [
            "1"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_io_ready",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "506-523",
          "snippet": "static int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\t\tkgdb_connected;",
            "struct kgdb_io\t\t*dbg_io_ops;",
            "int dbg_kdb_mode = 1;",
            "atomic_t\t\t\tkgdb_setting_breakpoint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nstatic int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kgdb_active",
            "-1"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_cpu_doing_single_step"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&slaves_in_kgdb"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kgdb_ops.correct_hw_break",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_is_locked",
          "args": [
            "&dbg_slave_lock"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&kgdb_active",
            "cpu"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock",
          "args": [
            "&dbg_master_lock"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "144-147",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&kgdb_active",
            "cpu"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hardirq_count",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_kgdb_ops.disable_hw_break",
          "args": [
            "regs"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&slaves_in_kgdb"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&masters_in_kgdb"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\nint\t\t\t\tkgdb_connected;\nstatic int\t\t\texception_level;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_switch_cpu;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\nstatic DEFINE_RAW_SPINLOCK(dbg_slave_lock);\nstatic atomic_t\t\t\tmasters_in_kgdb;\nstatic atomic_t\t\t\tslaves_in_kgdb;\nstruct task_struct\t\t*kgdb_contthread;\nint\t\t\t\tkgdb_single_step;\nstatic pid_t\t\t\tkgdb_sstep_pid;\natomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);\nstatic int kgdb_do_roundup = 1;\n\nstatic int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\trcu_read_lock();\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_BT) {\n\t\t\tdump_stack();\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_WANT_BT;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].debuggerinfo = NULL;\n\t\t\tkgdb_info[cpu].task = NULL;\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\t\trcu_read_unlock();\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\tatomic_inc(&ignore_console_lock_warning);\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus();\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_activate_sw_breakpoints();\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tatomic_dec(&ignore_console_lock_warning);\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].debuggerinfo = NULL;\n\tkgdb_info[cpu].task = NULL;\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\trcu_read_unlock();\n\n\treturn kgdb_info[cpu].ret_state;\n}"
  },
  {
    "function_name": "dbg_touch_watchdogs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "574-579",
    "snippet": "static void dbg_touch_watchdogs(void)\n{\n\ttouch_softlockup_watchdog_sync();\n\tclocksource_touch_watchdog();\n\trcu_cpu_stall_reset();\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_cpu_stall_reset",
          "args": [],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cpu_stall_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "126-130",
          "snippet": "void rcu_cpu_stall_reset(void)\n{\n\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t   jiffies + rcu_jiffies_till_stall_check());\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nvoid rcu_cpu_stall_reset(void)\n{\n\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t   jiffies + rcu_jiffies_till_stall_check());\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_touch_watchdog",
          "args": [],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_touch_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "843-846",
          "snippet": "void clocksource_touch_watchdog(void)\n{\n\tclocksource_resume_watchdog();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid clocksource_touch_watchdog(void)\n{\n\tclocksource_resume_watchdog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog_sync",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "299-303",
          "snippet": "void touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic void dbg_touch_watchdogs(void)\n{\n\ttouch_softlockup_watchdog_sync();\n\tclocksource_touch_watchdog();\n\trcu_cpu_stall_reset();\n}"
  },
  {
    "function_name": "kgdb_reenter_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "526-571",
    "snippet": "static int kgdb_reenter_check(struct kgdb_state *ks)\n{\n\tunsigned long addr;\n\n\tif (atomic_read(&kgdb_active) != raw_smp_processor_id())\n\t\treturn 0;\n\n\t/* Panic on recursive debugger calls: */\n\texception_level++;\n\taddr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tdbg_deactivate_sw_breakpoints();\n\n\t/*\n\t * If the break point removed ok at the place exception\n\t * occurred, try to recover and print a warning to the end\n\t * user because the user planted a breakpoint in a place that\n\t * KGDB needs in order to function.\n\t */\n\tif (dbg_remove_sw_break(addr) == 0) {\n\t\texception_level = 0;\n\t\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\t\tdbg_activate_sw_breakpoints();\n\t\tpr_crit(\"re-enter error: breakpoint removed %lx\\n\", addr);\n\t\tWARN_ON_ONCE(1);\n\n\t\treturn 1;\n\t}\n\tdbg_remove_all_break();\n\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\n\tif (exception_level > 1) {\n\t\tdump_stack();\n\t\tkgdb_io_module_registered = false;\n\t\tpanic(\"Recursive entry to debugger\");\n\t}\n\n\tpr_crit(\"re-enter exception: ALL breakpoints killed\\n\");\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow kdb to debug itself one level */\n\treturn 0;\n#endif\n\tdump_stack();\n\tpanic(\"Recursive entry to debugger\");\n\n\treturn 1;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\tkgdb_io_module_registered;",
      "static int\t\t\texception_level;",
      "atomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Recursive entry to debugger\""
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "984-1001",
          "snippet": "void kgdb_panic(const char *msg)\n{\n\tif (!kgdb_io_module_registered)\n\t\treturn;\n\n\t/*\n\t * We don't want to get stuck waiting for input from user if\n\t * \"panic_timeout\" indicates the system should automatically\n\t * reboot on panic.\n\t */\n\tif (panic_timeout)\n\t\treturn;\n\n\tif (dbg_kdb_mode)\n\t\tkdb_printf(\"PANIC: %s\\n\", msg);\n\n\tkgdb_breakpoint();\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\tkgdb_io_module_registered;",
            "int dbg_kdb_mode = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nint dbg_kdb_mode = 1;\n\nvoid kgdb_panic(const char *msg)\n{\n\tif (!kgdb_io_module_registered)\n\t\treturn;\n\n\t/*\n\t * We don't want to get stuck waiting for input from user if\n\t * \"panic_timeout\" indicates the system should automatically\n\t * reboot on panic.\n\t */\n\tif (panic_timeout)\n\t\treturn;\n\n\tif (dbg_kdb_mode)\n\t\tkdb_printf(\"PANIC: %s\\n\", msg);\n\n\tkgdb_breakpoint();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"re-enter exception: ALL breakpoints killed\\n\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_skipexception",
          "args": [
            "ks->ex_vector",
            "ks->linux_regs"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_skipexception",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "212-215",
          "snippet": "int __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_remove_all_break",
          "args": [],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_remove_all_break",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "431-453",
          "snippet": "int dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"re-enter error: breakpoint removed %lx\\n\"",
            "addr"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_activate_sw_breakpoints",
          "args": [],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_activate_sw_breakpoints",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "304-326",
          "snippet": "int dbg_activate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_SET)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"BP install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_ACTIVE;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_activate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_SET)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"BP install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_ACTIVE;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_remove_sw_break",
          "args": [
            "addr"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_remove_sw_break",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "393-405",
          "snippet": "int dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_deactivate_sw_breakpoints",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_deactivate_sw_breakpoints",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "370-390",
          "snippet": "int dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_arch_pc",
          "args": [
            "ks->ex_vector",
            "ks->linux_regs"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_pc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "201-204",
          "snippet": "unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nunsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_active"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\tkgdb_io_module_registered;\nstatic int\t\t\texception_level;\natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\n\nstatic int kgdb_reenter_check(struct kgdb_state *ks)\n{\n\tunsigned long addr;\n\n\tif (atomic_read(&kgdb_active) != raw_smp_processor_id())\n\t\treturn 0;\n\n\t/* Panic on recursive debugger calls: */\n\texception_level++;\n\taddr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tdbg_deactivate_sw_breakpoints();\n\n\t/*\n\t * If the break point removed ok at the place exception\n\t * occurred, try to recover and print a warning to the end\n\t * user because the user planted a breakpoint in a place that\n\t * KGDB needs in order to function.\n\t */\n\tif (dbg_remove_sw_break(addr) == 0) {\n\t\texception_level = 0;\n\t\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\t\tdbg_activate_sw_breakpoints();\n\t\tpr_crit(\"re-enter error: breakpoint removed %lx\\n\", addr);\n\t\tWARN_ON_ONCE(1);\n\n\t\treturn 1;\n\t}\n\tdbg_remove_all_break();\n\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\n\tif (exception_level > 1) {\n\t\tdump_stack();\n\t\tkgdb_io_module_registered = false;\n\t\tpanic(\"Recursive entry to debugger\");\n\t}\n\n\tpr_crit(\"re-enter exception: ALL breakpoints killed\\n\");\n#ifdef CONFIG_KGDB_KDB\n\t/* Allow kdb to debug itself one level */\n\treturn 0;\n#endif\n\tdump_stack();\n\tpanic(\"Recursive entry to debugger\");\n\n\treturn 1;\n}"
  },
  {
    "function_name": "kgdb_io_ready",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "506-523",
    "snippet": "static int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\t\tkgdb_connected;",
      "struct kgdb_io\t\t*dbg_io_ops;",
      "int dbg_kdb_mode = 1;",
      "atomic_t\t\t\tkgdb_setting_breakpoint;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Waiting for remote debugger\\n\""
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"waiting... or $3#33 for KDB\\n\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_setting_breakpoint"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint\t\t\t\tkgdb_connected;\nstruct kgdb_io\t\t*dbg_io_ops;\nint dbg_kdb_mode = 1;\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nstatic int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "kdb_dump_stack_on_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "467-494",
    "snippet": "void kdb_dump_stack_on_cpu(int cpu)\n{\n\tif (cpu == raw_smp_processor_id() || !IS_ENABLED(CONFIG_SMP)) {\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tif (!(kgdb_info[cpu].exception_state & DCPU_IS_SLAVE)) {\n\t\tkdb_printf(\"ERROR: Task on cpu %d didn't stop in the debugger\\n\",\n\t\t\t   cpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * In general, architectures don't support dumping the stack of a\n\t * \"running\" process that's not the current one.  From the point of\n\t * view of the Linux, kernel processes that are looping in the kgdb\n\t * slave loop are still \"running\".  There's also no API (that actually\n\t * works across all architectures) that can do a stack crawl based\n\t * on registers passed as a parameter.\n\t *\n\t * Solve this conundrum by asking slave CPUs to do the backtrace\n\t * themselves.\n\t */\n\tkgdb_info[cpu].exception_state |= DCPU_WANT_BT;\n\twhile (kgdb_info[cpu].exception_state & DCPU_WANT_BT)\n\t\tcpu_relax();\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct debuggerinfo_struct kgdb_info[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"ERROR: Task on cpu %d didn't stop in the debugger\\n\"",
            "cpu"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SMP"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\n\nvoid kdb_dump_stack_on_cpu(int cpu)\n{\n\tif (cpu == raw_smp_processor_id() || !IS_ENABLED(CONFIG_SMP)) {\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tif (!(kgdb_info[cpu].exception_state & DCPU_IS_SLAVE)) {\n\t\tkdb_printf(\"ERROR: Task on cpu %d didn't stop in the debugger\\n\",\n\t\t\t   cpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * In general, architectures don't support dumping the stack of a\n\t * \"running\" process that's not the current one.  From the point of\n\t * view of the Linux, kernel processes that are looping in the kgdb\n\t * slave loop are still \"running\".  There's also no API (that actually\n\t * works across all architectures) that can do a stack crawl based\n\t * on registers passed as a parameter.\n\t *\n\t * Solve this conundrum by asking slave CPUs to do the backtrace\n\t * themselves.\n\t */\n\tkgdb_info[cpu].exception_state |= DCPU_WANT_BT;\n\twhile (kgdb_info[cpu].exception_state & DCPU_WANT_BT)\n\t\tcpu_relax();\n}"
  },
  {
    "function_name": "kgdb_free_init_mem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "455-464",
    "snippet": "void kgdb_free_init_mem(void)\n{\n\tint i;\n\n\t/* Clear init memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (init_section_contains((void *)kgdb_break[i].bpt_addr, 0))\n\t\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_section_contains",
          "args": [
            "(void *)kgdb_break[i].bpt_addr",
            "0"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nvoid kgdb_free_init_mem(void)\n{\n\tint i;\n\n\t/* Clear init memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (init_section_contains((void *)kgdb_break[i].bpt_addr, 0))\n\t\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n}"
  },
  {
    "function_name": "dbg_remove_all_break",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "431-453",
    "snippet": "int dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kgdb_ops.remove_all_hw_break",
          "args": [],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"breakpoint remove failed: %lx\\n\"",
            "kgdb_break[i].bpt_addr"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_remove_breakpoint",
          "args": [
            "&kgdb_break[i]"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_remove_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "170-174",
          "snippet": "int __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_has_hit_break",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "419-429",
    "snippet": "int kgdb_has_hit_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_ACTIVE &&\n\t\t    kgdb_break[i].bpt_addr == addr)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint kgdb_has_hit_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_ACTIVE &&\n\t\t    kgdb_break[i].bpt_addr == addr)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_isremovedbreak",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "407-417",
    "snippet": "int kgdb_isremovedbreak(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_REMOVED) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint kgdb_isremovedbreak(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_REMOVED) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_remove_sw_break",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "393-405",
    "snippet": "int dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "dbg_deactivate_sw_breakpoints",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "370-390",
    "snippet": "int dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_flush_swbreak_addr",
          "args": [
            "kgdb_break[i].bpt_addr"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_flush_swbreak_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "280-298",
          "snippet": "static void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"BP remove failed: %lx\\n\"",
            "kgdb_break[i].bpt_addr"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_remove_breakpoint",
          "args": [
            "&kgdb_break[i]"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_remove_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "170-174",
          "snippet": "int __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "dbg_set_sw_break",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "329-368",
    "snippet": "int dbg_set_sw_break(unsigned long addr)\n{\n\tint err = kgdb_validate_break_address(addr);\n\tint breakno = -1;\n\tint i;\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn -EEXIST;\n\t}\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_REMOVED &&\n\t\t\t\t\tkgdb_break[i].bpt_addr == addr) {\n\t\t\tbreakno = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (breakno == -1) {\n\t\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\t\tif (kgdb_break[i].state == BP_UNDEFINED) {\n\t\t\t\tbreakno = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (breakno == -1)\n\t\treturn -E2BIG;\n\n\tkgdb_break[breakno].state = BP_SET;\n\tkgdb_break[breakno].type = BP_BREAKPOINT;\n\tkgdb_break[breakno].bpt_addr = addr;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_validate_break_address",
          "args": [
            "addr"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_validate_break_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "177-199",
          "snippet": "int __weak kgdb_validate_break_address(unsigned long addr)\n{\n\tstruct kgdb_bkpt tmp;\n\tint err;\n\n\tif (kgdb_within_blocklist(addr))\n\t\treturn -EINVAL;\n\n\t/* Validate setting the breakpoint and then removing it.  If the\n\t * remove fails, the kernel needs to emit a bad message because we\n\t * are deep trouble not being able to put things back the way we\n\t * found them.\n\t */\n\ttmp.bpt_addr = addr;\n\terr = kgdb_arch_set_breakpoint(&tmp);\n\tif (err)\n\t\treturn err;\n\terr = kgdb_arch_remove_breakpoint(&tmp);\n\tif (err)\n\t\tpr_err(\"Critical breakpoint error, kernel memory destroyed at: %lx\\n\",\n\t\t       addr);\n\treturn err;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_validate_break_address(unsigned long addr)\n{\n\tstruct kgdb_bkpt tmp;\n\tint err;\n\n\tif (kgdb_within_blocklist(addr))\n\t\treturn -EINVAL;\n\n\t/* Validate setting the breakpoint and then removing it.  If the\n\t * remove fails, the kernel needs to emit a bad message because we\n\t * are deep trouble not being able to put things back the way we\n\t * found them.\n\t */\n\ttmp.bpt_addr = addr;\n\terr = kgdb_arch_set_breakpoint(&tmp);\n\tif (err)\n\t\treturn err;\n\terr = kgdb_arch_remove_breakpoint(&tmp);\n\tif (err)\n\t\tpr_err(\"Critical breakpoint error, kernel memory destroyed at: %lx\\n\",\n\t\t       addr);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_set_sw_break(unsigned long addr)\n{\n\tint err = kgdb_validate_break_address(addr);\n\tint breakno = -1;\n\tint i;\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn -EEXIST;\n\t}\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_REMOVED &&\n\t\t\t\t\tkgdb_break[i].bpt_addr == addr) {\n\t\t\tbreakno = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (breakno == -1) {\n\t\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\t\tif (kgdb_break[i].state == BP_UNDEFINED) {\n\t\t\t\tbreakno = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (breakno == -1)\n\t\treturn -E2BIG;\n\n\tkgdb_break[breakno].state = BP_SET;\n\tkgdb_break[breakno].type = BP_BREAKPOINT;\n\tkgdb_break[breakno].bpt_addr = addr;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_activate_sw_breakpoints",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "304-326",
    "snippet": "int dbg_activate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_SET)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"BP install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_ACTIVE;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_flush_swbreak_addr",
          "args": [
            "kgdb_break[i].bpt_addr"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_flush_swbreak_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "280-298",
          "snippet": "static void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"BP install failed: %lx\\n\"",
            "kgdb_break[i].bpt_addr"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_set_breakpoint",
          "args": [
            "&kgdb_break[i]"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_set_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "156-167",
          "snippet": "int __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = copy_from_kernel_nofault(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = copy_from_kernel_nofault(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_activate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_SET)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"BP install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_ACTIVE;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "kgdb_flush_swbreak_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "280-298",
    "snippet": "static void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "addr",
            "addr + BREAK_INSTR_SIZE"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_range",
          "args": [
            "current->vmacache.vmas[i]",
            "addr",
            "addr + BREAK_INSTR_SIZE"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\tif (current->mm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\t\tif (!current->vmacache.vmas[i])\n\t\t\t\tcontinue;\n\t\t\tflush_cache_range(current->vmacache.vmas[i],\n\t\t\t\t\t  addr, addr + BREAK_INSTR_SIZE);\n\t\t}\n\t}\n\n\t/* Force flush instruction cache if it was outside the mm */\n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}"
  },
  {
    "function_name": "kgdb_roundup_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "241-271",
    "snippet": "void __weak kgdb_roundup_cpus(void)\n{\n\tcall_single_data_t *csd;\n\tint this_cpu = raw_smp_processor_id();\n\tint cpu;\n\tint ret;\n\n\tfor_each_online_cpu(cpu) {\n\t\t/* No need to roundup ourselves */\n\t\tif (cpu == this_cpu)\n\t\t\tcontinue;\n\n\t\tcsd = &per_cpu(kgdb_roundup_csd, cpu);\n\n\t\t/*\n\t\t * If it didn't round up last time, don't try again\n\t\t * since smp_call_function_single_async() will block.\n\t\t *\n\t\t * If rounding_up is false then we know that the\n\t\t * previous call must have at least started and that\n\t\t * means smp_call_function_single_async() won't block.\n\t\t */\n\t\tif (kgdb_info[cpu].rounding_up)\n\t\t\tcontinue;\n\t\tkgdb_info[cpu].rounding_up = true;\n\n\t\tret = smp_call_function_single_async(cpu, csd);\n\t\tif (ret)\n\t\t\tkgdb_info[cpu].rounding_up = false;\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct debuggerinfo_struct kgdb_info[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single_async",
          "args": [
            "cpu",
            "csd"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "28-36",
          "snippet": "int smp_call_function_single_async(int cpu, struct __call_single_data *csd)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tcsd->func(csd->info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single_async(int cpu, struct __call_single_data *csd)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tcsd->func(csd->info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "kgdb_roundup_csd",
            "cpu"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\n\nvoid __weak kgdb_roundup_cpus(void)\n{\n\tcall_single_data_t *csd;\n\tint this_cpu = raw_smp_processor_id();\n\tint cpu;\n\tint ret;\n\n\tfor_each_online_cpu(cpu) {\n\t\t/* No need to roundup ourselves */\n\t\tif (cpu == this_cpu)\n\t\t\tcontinue;\n\n\t\tcsd = &per_cpu(kgdb_roundup_csd, cpu);\n\n\t\t/*\n\t\t * If it didn't round up last time, don't try again\n\t\t * since smp_call_function_single_async() will block.\n\t\t *\n\t\t * If rounding_up is false then we know that the\n\t\t * previous call must have at least started and that\n\t\t * means smp_call_function_single_async() won't block.\n\t\t */\n\t\tif (kgdb_info[cpu].rounding_up)\n\t\t\tcontinue;\n\t\tkgdb_info[cpu].rounding_up = true;\n\n\t\tret = smp_call_function_single_async(cpu, csd);\n\t\tif (ret)\n\t\t\tkgdb_info[cpu].rounding_up = false;\n\t}\n}"
  },
  {
    "function_name": "kgdb_call_nmi_hook",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "224-235",
    "snippet": "void __weak kgdb_call_nmi_hook(void *ignored)\n{\n\t/*\n\t * NOTE: get_irq_regs() is supposed to get the registers from\n\t * before the IPI interrupt happened and so is supposed to\n\t * show where the processor was.  In some situations it's\n\t * possible we might be called without an IPI, so it might be\n\t * safer to figure out how to make kgdb_breakpoint() work\n\t * properly here.\n\t */\n\tkgdb_nmicallback(raw_smp_processor_id(), get_irq_regs());\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_nmicallback",
          "args": [
            "raw_smp_processor_id()",
            "get_irq_regs()"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_nmicallback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "874-893",
          "snippet": "int kgdb_nmicallback(int cpu, void *regs)\n{\n#ifdef CONFIG_SMP\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\n\tkgdb_info[cpu].rounding_up = false;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= cpu;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_info[ks->cpu].enter_kgdb == 0 &&\n\t\t\traw_spin_is_locked(&dbg_master_lock)) {\n\t\tkgdb_cpu_enter(ks, regs, DCPU_IS_SLAVE);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct debuggerinfo_struct kgdb_info[NR_CPUS];",
            "static DEFINE_RAW_SPINLOCK(dbg_master_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\n\nint kgdb_nmicallback(int cpu, void *regs)\n{\n#ifdef CONFIG_SMP\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\n\tkgdb_info[cpu].rounding_up = false;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= cpu;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_info[ks->cpu].enter_kgdb == 0 &&\n\t\t\traw_spin_is_locked(&dbg_master_lock)) {\n\t\tkgdb_cpu_enter(ks, regs, DCPU_IS_SLAVE);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nvoid __weak kgdb_call_nmi_hook(void *ignored)\n{\n\t/*\n\t * NOTE: get_irq_regs() is supposed to get the registers from\n\t * before the IPI interrupt happened and so is supposed to\n\t * show where the processor was.  In some situations it's\n\t * possible we might be called without an IPI, so it might be\n\t * safer to figure out how to make kgdb_breakpoint() work\n\t * properly here.\n\t */\n\tkgdb_nmicallback(raw_smp_processor_id(), get_irq_regs());\n}"
  },
  {
    "function_name": "kgdb_skipexception",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "212-215",
    "snippet": "int __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_arch_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "207-210",
    "snippet": "int __weak kgdb_arch_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kgdb_arch_pc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "201-204",
    "snippet": "unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nunsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}"
  },
  {
    "function_name": "kgdb_validate_break_address",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "177-199",
    "snippet": "int __weak kgdb_validate_break_address(unsigned long addr)\n{\n\tstruct kgdb_bkpt tmp;\n\tint err;\n\n\tif (kgdb_within_blocklist(addr))\n\t\treturn -EINVAL;\n\n\t/* Validate setting the breakpoint and then removing it.  If the\n\t * remove fails, the kernel needs to emit a bad message because we\n\t * are deep trouble not being able to put things back the way we\n\t * found them.\n\t */\n\ttmp.bpt_addr = addr;\n\terr = kgdb_arch_set_breakpoint(&tmp);\n\tif (err)\n\t\treturn err;\n\terr = kgdb_arch_remove_breakpoint(&tmp);\n\tif (err)\n\t\tpr_err(\"Critical breakpoint error, kernel memory destroyed at: %lx\\n\",\n\t\t       addr);\n\treturn err;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Critical breakpoint error, kernel memory destroyed at: %lx\\n\"",
            "addr"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_remove_breakpoint",
          "args": [
            "&tmp"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_remove_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "170-174",
          "snippet": "int __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_arch_set_breakpoint",
          "args": [
            "&tmp"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_arch_set_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "156-167",
          "snippet": "int __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = copy_from_kernel_nofault(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = copy_from_kernel_nofault(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_within_blocklist",
          "args": [
            "addr"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_validate_break_address(unsigned long addr)\n{\n\tstruct kgdb_bkpt tmp;\n\tint err;\n\n\tif (kgdb_within_blocklist(addr))\n\t\treturn -EINVAL;\n\n\t/* Validate setting the breakpoint and then removing it.  If the\n\t * remove fails, the kernel needs to emit a bad message because we\n\t * are deep trouble not being able to put things back the way we\n\t * found them.\n\t */\n\ttmp.bpt_addr = addr;\n\terr = kgdb_arch_set_breakpoint(&tmp);\n\tif (err)\n\t\treturn err;\n\terr = kgdb_arch_remove_breakpoint(&tmp);\n\tif (err)\n\t\tpr_err(\"Critical breakpoint error, kernel memory destroyed at: %lx\\n\",\n\t\t       addr);\n\treturn err;\n}"
  },
  {
    "function_name": "kgdb_arch_remove_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "170-174",
    "snippet": "int __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_kernel_nofault",
          "args": [
            "(char *)bpt->bpt_addr",
            "(char *)bpt->saved_instr",
            "BREAK_INSTR_SIZE"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}"
  },
  {
    "function_name": "kgdb_arch_set_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "156-167",
    "snippet": "int __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = copy_from_kernel_nofault(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_kernel_nofault",
          "args": [
            "(char *)bpt->bpt_addr",
            "arch_kgdb_ops.gdb_bpt_instr",
            "BREAK_INSTR_SIZE"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "bpt->saved_instr",
            "(char *)bpt->bpt_addr",
            "BREAK_INSTR_SIZE"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nint __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = copy_from_kernel_nofault(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}"
  },
  {
    "function_name": "opt_nokgdbroundup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
    "lines": "139-144",
    "snippet": "static int __init opt_nokgdbroundup(char *str)\n{\n\tkgdb_do_roundup = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <linux/atomic.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/irq.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/smp.h>",
      "#include <linux/pid.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>",
      "#include <linux/reboot.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/string.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/threads.h>",
      "#include <linux/console.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/pid_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kgdb_do_roundup = 1;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic int kgdb_do_roundup = 1;\n\nstatic int __init opt_nokgdbroundup(char *str)\n{\n\tkgdb_do_roundup = 0;\n\n\treturn 0;\n}"
  }
]