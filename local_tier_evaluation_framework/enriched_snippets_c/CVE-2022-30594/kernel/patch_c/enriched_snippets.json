[
  {
    "function_name": "klp_unpatch_objects_dynamic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
    "lines": "301-304",
    "snippet": "void klp_unpatch_objects_dynamic(struct klp_patch *patch)\n{\n\t__klp_unpatch_objects(patch, true);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__klp_unpatch_objects",
          "args": [
            "patch",
            "true"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_unpatch_objects",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "287-294",
          "snippet": "static void __klp_unpatch_objects(struct klp_patch *patch, bool nops_only)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\t__klp_unpatch_object(obj, nops_only);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic void __klp_unpatch_objects(struct klp_patch *patch, bool nops_only)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\t__klp_unpatch_object(obj, nops_only);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nvoid klp_unpatch_objects_dynamic(struct klp_patch *patch)\n{\n\t__klp_unpatch_objects(patch, true);\n}"
  },
  {
    "function_name": "klp_unpatch_objects",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
    "lines": "296-299",
    "snippet": "void klp_unpatch_objects(struct klp_patch *patch)\n{\n\t__klp_unpatch_objects(patch, false);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__klp_unpatch_objects",
          "args": [
            "patch",
            "false"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_unpatch_objects",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "287-294",
          "snippet": "static void __klp_unpatch_objects(struct klp_patch *patch, bool nops_only)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\t__klp_unpatch_object(obj, nops_only);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic void __klp_unpatch_objects(struct klp_patch *patch, bool nops_only)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\t__klp_unpatch_object(obj, nops_only);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nvoid klp_unpatch_objects(struct klp_patch *patch)\n{\n\t__klp_unpatch_objects(patch, false);\n}"
  },
  {
    "function_name": "__klp_unpatch_objects",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
    "lines": "287-294",
    "snippet": "static void __klp_unpatch_objects(struct klp_patch *patch, bool nops_only)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\t__klp_unpatch_object(obj, nops_only);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__klp_unpatch_object",
          "args": [
            "obj",
            "nops_only"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_unpatch_objects",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "287-294",
          "snippet": "static void __klp_unpatch_objects(struct klp_patch *patch, bool nops_only)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\t__klp_unpatch_object(obj, nops_only);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "patch",
            "obj"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic void __klp_unpatch_objects(struct klp_patch *patch, bool nops_only)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\t__klp_unpatch_object(obj, nops_only);\n}"
  },
  {
    "function_name": "klp_patch_object",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
    "lines": "267-285",
    "snippet": "int klp_patch_object(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tif (WARN_ON(obj->patched))\n\t\treturn -EINVAL;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_patch_func(func);\n\t\tif (ret) {\n\t\t\tklp_unpatch_object(obj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tobj->patched = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_unpatch_object",
          "args": [
            "obj"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "klp_unpatch_objects_dynamic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "301-304",
          "snippet": "void klp_unpatch_objects_dynamic(struct klp_patch *patch)\n{\n\t__klp_unpatch_objects(patch, true);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nvoid klp_unpatch_objects_dynamic(struct klp_patch *patch)\n{\n\t__klp_unpatch_objects(patch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_patch_func",
          "args": [
            "func"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "klp_patch_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "174-243",
          "snippet": "static int klp_patch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\tint ret;\n\n\tif (WARN_ON(!func->old_func))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(func->patched))\n\t\treturn -EINVAL;\n\n\tops = klp_find_ops(func->old_func);\n\tif (!ops) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc =\n\t\t\tklp_get_ftrace_location((unsigned long)func->old_func);\n\t\tif (!ftrace_loc) {\n\t\t\tpr_err(\"failed to find location for function '%s'\\n\",\n\t\t\t\tfunc->old_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\t\tif (!ops)\n\t\t\treturn -ENOMEM;\n\n\t\tops->fops.func = klp_ftrace_handler;\n\t\tops->fops.flags = FTRACE_OPS_FL_DYNAMIC |\n#ifndef CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS\n\t\t\t\t  FTRACE_OPS_FL_SAVE_REGS |\n#endif\n\t\t\t\t  FTRACE_OPS_FL_IPMODIFY |\n\t\t\t\t  FTRACE_OPS_FL_PERMANENT;\n\n\t\tlist_add(&ops->node, &klp_ops);\n\n\t\tINIT_LIST_HEAD(&ops->func_stack);\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\n\t\tret = ftrace_set_filter_ip(&ops->fops, ftrace_loc, 0, 0);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set ftrace filter for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = register_ftrace_function(&ops->fops);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to register ftrace handler for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0);\n\t\t\tgoto err;\n\t\t}\n\n\n\t} else {\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\t}\n\n\tfunc->patched = true;\n\n\treturn 0;\n\nerr:\n\tlist_del_rcu(&func->stack_node);\n\tlist_del(&ops->node);\n\tkfree(ops);\n\treturn ret;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstatic int klp_patch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\tint ret;\n\n\tif (WARN_ON(!func->old_func))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(func->patched))\n\t\treturn -EINVAL;\n\n\tops = klp_find_ops(func->old_func);\n\tif (!ops) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc =\n\t\t\tklp_get_ftrace_location((unsigned long)func->old_func);\n\t\tif (!ftrace_loc) {\n\t\t\tpr_err(\"failed to find location for function '%s'\\n\",\n\t\t\t\tfunc->old_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\t\tif (!ops)\n\t\t\treturn -ENOMEM;\n\n\t\tops->fops.func = klp_ftrace_handler;\n\t\tops->fops.flags = FTRACE_OPS_FL_DYNAMIC |\n#ifndef CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS\n\t\t\t\t  FTRACE_OPS_FL_SAVE_REGS |\n#endif\n\t\t\t\t  FTRACE_OPS_FL_IPMODIFY |\n\t\t\t\t  FTRACE_OPS_FL_PERMANENT;\n\n\t\tlist_add(&ops->node, &klp_ops);\n\n\t\tINIT_LIST_HEAD(&ops->func_stack);\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\n\t\tret = ftrace_set_filter_ip(&ops->fops, ftrace_loc, 0, 0);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set ftrace filter for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = register_ftrace_function(&ops->fops);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to register ftrace handler for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0);\n\t\t\tgoto err;\n\t\t}\n\n\n\t} else {\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\t}\n\n\tfunc->patched = true;\n\n\treturn 0;\n\nerr:\n\tlist_del_rcu(&func->stack_node);\n\tlist_del(&ops->node);\n\tkfree(ops);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "obj->patched"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nint klp_patch_object(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tif (WARN_ON(obj->patched))\n\t\treturn -EINVAL;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_patch_func(func);\n\t\tif (ret) {\n\t\t\tklp_unpatch_object(obj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tobj->patched = true;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "klp_unpatch_object",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
    "lines": "262-265",
    "snippet": "void klp_unpatch_object(struct klp_object *obj)\n{\n\t__klp_unpatch_object(obj, false);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__klp_unpatch_object",
          "args": [
            "obj",
            "false"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_unpatch_objects",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "287-294",
          "snippet": "static void __klp_unpatch_objects(struct klp_patch *patch, bool nops_only)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\t__klp_unpatch_object(obj, nops_only);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic void __klp_unpatch_objects(struct klp_patch *patch, bool nops_only)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\t__klp_unpatch_object(obj, nops_only);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nvoid klp_unpatch_object(struct klp_object *obj)\n{\n\t__klp_unpatch_object(obj, false);\n}"
  },
  {
    "function_name": "__klp_unpatch_object",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
    "lines": "245-259",
    "snippet": "static void __klp_unpatch_object(struct klp_object *obj, bool nops_only)\n{\n\tstruct klp_func *func;\n\n\tklp_for_each_func(obj, func) {\n\t\tif (nops_only && !func->nop)\n\t\t\tcontinue;\n\n\t\tif (func->patched)\n\t\t\tklp_unpatch_func(func);\n\t}\n\n\tif (obj->dynamic || !nops_only)\n\t\tobj->patched = false;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_unpatch_func",
          "args": [
            "func"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "klp_unpatch_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "140-172",
          "snippet": "static void klp_unpatch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\n\tif (WARN_ON(!func->patched))\n\t\treturn;\n\tif (WARN_ON(!func->old_func))\n\t\treturn;\n\n\tops = klp_find_ops(func->old_func);\n\tif (WARN_ON(!ops))\n\t\treturn;\n\n\tif (list_is_singular(&ops->func_stack)) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc =\n\t\t\tklp_get_ftrace_location((unsigned long)func->old_func);\n\t\tif (WARN_ON(!ftrace_loc))\n\t\t\treturn;\n\n\t\tWARN_ON(unregister_ftrace_function(&ops->fops));\n\t\tWARN_ON(ftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0));\n\n\t\tlist_del_rcu(&func->stack_node);\n\t\tlist_del(&ops->node);\n\t\tkfree(ops);\n\t} else {\n\t\tlist_del_rcu(&func->stack_node);\n\t}\n\n\tfunc->patched = false;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstatic void klp_unpatch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\n\tif (WARN_ON(!func->patched))\n\t\treturn;\n\tif (WARN_ON(!func->old_func))\n\t\treturn;\n\n\tops = klp_find_ops(func->old_func);\n\tif (WARN_ON(!ops))\n\t\treturn;\n\n\tif (list_is_singular(&ops->func_stack)) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc =\n\t\t\tklp_get_ftrace_location((unsigned long)func->old_func);\n\t\tif (WARN_ON(!ftrace_loc))\n\t\t\treturn;\n\n\t\tWARN_ON(unregister_ftrace_function(&ops->fops));\n\t\tWARN_ON(ftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0));\n\n\t\tlist_del_rcu(&func->stack_node);\n\t\tlist_del(&ops->node);\n\t\tkfree(ops);\n\t} else {\n\t\tlist_del_rcu(&func->stack_node);\n\t}\n\n\tfunc->patched = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic void __klp_unpatch_object(struct klp_object *obj, bool nops_only)\n{\n\tstruct klp_func *func;\n\n\tklp_for_each_func(obj, func) {\n\t\tif (nops_only && !func->nop)\n\t\t\tcontinue;\n\n\t\tif (func->patched)\n\t\t\tklp_unpatch_func(func);\n\t}\n\n\tif (obj->dynamic || !nops_only)\n\t\tobj->patched = false;\n}"
  },
  {
    "function_name": "klp_patch_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
    "lines": "174-243",
    "snippet": "static int klp_patch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\tint ret;\n\n\tif (WARN_ON(!func->old_func))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(func->patched))\n\t\treturn -EINVAL;\n\n\tops = klp_find_ops(func->old_func);\n\tif (!ops) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc =\n\t\t\tklp_get_ftrace_location((unsigned long)func->old_func);\n\t\tif (!ftrace_loc) {\n\t\t\tpr_err(\"failed to find location for function '%s'\\n\",\n\t\t\t\tfunc->old_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\t\tif (!ops)\n\t\t\treturn -ENOMEM;\n\n\t\tops->fops.func = klp_ftrace_handler;\n\t\tops->fops.flags = FTRACE_OPS_FL_DYNAMIC |\n#ifndef CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS\n\t\t\t\t  FTRACE_OPS_FL_SAVE_REGS |\n#endif\n\t\t\t\t  FTRACE_OPS_FL_IPMODIFY |\n\t\t\t\t  FTRACE_OPS_FL_PERMANENT;\n\n\t\tlist_add(&ops->node, &klp_ops);\n\n\t\tINIT_LIST_HEAD(&ops->func_stack);\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\n\t\tret = ftrace_set_filter_ip(&ops->fops, ftrace_loc, 0, 0);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set ftrace filter for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = register_ftrace_function(&ops->fops);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to register ftrace handler for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0);\n\t\t\tgoto err;\n\t\t}\n\n\n\t} else {\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\t}\n\n\tfunc->patched = true;\n\n\treturn 0;\n\nerr:\n\tlist_del_rcu(&func->stack_node);\n\tlist_del(&ops->node);\n\tkfree(ops);\n\treturn ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ops"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ops->node"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&func->stack_node"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&func->stack_node",
            "&ops->func_stack"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter_ip",
          "args": [
            "&ops->fops",
            "ftrace_loc",
            "1",
            "0"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5633-5638",
          "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to register ftrace handler for function '%s' (%d)\\n\"",
            "func->old_name",
            "ret"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "&ops->fops"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to set ftrace filter for function '%s' (%d)\\n\"",
            "func->old_name",
            "ret"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&func->stack_node",
            "&ops->func_stack"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ops->func_stack"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ops->node",
            "&klp_ops"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ops)",
            "GFP_KERNEL"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to find location for function '%s'\\n\"",
            "func->old_name"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_get_ftrace_location",
          "args": [
            "(unsigned long)func->old_func"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "klp_get_ftrace_location",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "134-137",
          "snippet": "static unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_find_ops",
          "args": [
            "func->old_func"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "klp_find_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "25-38",
          "snippet": "struct klp_ops *klp_find_ops(void *old_func)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_func == old_func)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstruct klp_ops *klp_find_ops(void *old_func)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_func == old_func)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "func->patched"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!func->old_func"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstatic int klp_patch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\tint ret;\n\n\tif (WARN_ON(!func->old_func))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(func->patched))\n\t\treturn -EINVAL;\n\n\tops = klp_find_ops(func->old_func);\n\tif (!ops) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc =\n\t\t\tklp_get_ftrace_location((unsigned long)func->old_func);\n\t\tif (!ftrace_loc) {\n\t\t\tpr_err(\"failed to find location for function '%s'\\n\",\n\t\t\t\tfunc->old_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\t\tif (!ops)\n\t\t\treturn -ENOMEM;\n\n\t\tops->fops.func = klp_ftrace_handler;\n\t\tops->fops.flags = FTRACE_OPS_FL_DYNAMIC |\n#ifndef CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS\n\t\t\t\t  FTRACE_OPS_FL_SAVE_REGS |\n#endif\n\t\t\t\t  FTRACE_OPS_FL_IPMODIFY |\n\t\t\t\t  FTRACE_OPS_FL_PERMANENT;\n\n\t\tlist_add(&ops->node, &klp_ops);\n\n\t\tINIT_LIST_HEAD(&ops->func_stack);\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\n\t\tret = ftrace_set_filter_ip(&ops->fops, ftrace_loc, 0, 0);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set ftrace filter for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = register_ftrace_function(&ops->fops);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to register ftrace handler for function '%s' (%d)\\n\",\n\t\t\t       func->old_name, ret);\n\t\t\tftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0);\n\t\t\tgoto err;\n\t\t}\n\n\n\t} else {\n\t\tlist_add_rcu(&func->stack_node, &ops->func_stack);\n\t}\n\n\tfunc->patched = true;\n\n\treturn 0;\n\nerr:\n\tlist_del_rcu(&func->stack_node);\n\tlist_del(&ops->node);\n\tkfree(ops);\n\treturn ret;\n}"
  },
  {
    "function_name": "klp_unpatch_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
    "lines": "140-172",
    "snippet": "static void klp_unpatch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\n\tif (WARN_ON(!func->patched))\n\t\treturn;\n\tif (WARN_ON(!func->old_func))\n\t\treturn;\n\n\tops = klp_find_ops(func->old_func);\n\tif (WARN_ON(!ops))\n\t\treturn;\n\n\tif (list_is_singular(&ops->func_stack)) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc =\n\t\t\tklp_get_ftrace_location((unsigned long)func->old_func);\n\t\tif (WARN_ON(!ftrace_loc))\n\t\t\treturn;\n\n\t\tWARN_ON(unregister_ftrace_function(&ops->fops));\n\t\tWARN_ON(ftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0));\n\n\t\tlist_del_rcu(&func->stack_node);\n\t\tlist_del(&ops->node);\n\t\tkfree(ops);\n\t} else {\n\t\tlist_del_rcu(&func->stack_node);\n\t}\n\n\tfunc->patched = false;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&func->stack_node"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ops"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ops->node"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&func->stack_node"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter_ip",
          "args": [
            "&ops->fops",
            "ftrace_loc",
            "1",
            "0"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5633-5638",
          "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "unregister_ftrace_function(&ops->fops)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&ops->fops"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ftrace_loc"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_get_ftrace_location",
          "args": [
            "(unsigned long)func->old_func"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "klp_get_ftrace_location",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "134-137",
          "snippet": "static unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&ops->func_stack"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ops"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_find_ops",
          "args": [
            "func->old_func"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "klp_find_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "25-38",
          "snippet": "struct klp_ops *klp_find_ops(void *old_func)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_func == old_func)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstruct klp_ops *klp_find_ops(void *old_func)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_func == old_func)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!func->old_func"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!func->patched"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstatic void klp_unpatch_func(struct klp_func *func)\n{\n\tstruct klp_ops *ops;\n\n\tif (WARN_ON(!func->patched))\n\t\treturn;\n\tif (WARN_ON(!func->old_func))\n\t\treturn;\n\n\tops = klp_find_ops(func->old_func);\n\tif (WARN_ON(!ops))\n\t\treturn;\n\n\tif (list_is_singular(&ops->func_stack)) {\n\t\tunsigned long ftrace_loc;\n\n\t\tftrace_loc =\n\t\t\tklp_get_ftrace_location((unsigned long)func->old_func);\n\t\tif (WARN_ON(!ftrace_loc))\n\t\t\treturn;\n\n\t\tWARN_ON(unregister_ftrace_function(&ops->fops));\n\t\tWARN_ON(ftrace_set_filter_ip(&ops->fops, ftrace_loc, 1, 0));\n\n\t\tlist_del_rcu(&func->stack_node);\n\t\tlist_del(&ops->node);\n\t\tkfree(ops);\n\t} else {\n\t\tlist_del_rcu(&func->stack_node);\n\t}\n\n\tfunc->patched = false;\n}"
  },
  {
    "function_name": "klp_get_ftrace_location",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
    "lines": "134-137",
    "snippet": "static unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic unsigned long klp_get_ftrace_location(unsigned long faddr)\n{\n\treturn faddr;\n}"
  },
  {
    "function_name": "klp_ftrace_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
    "lines": "40-125",
    "snippet": "static void notrace klp_ftrace_handler(unsigned long ip,\n\t\t\t\t       unsigned long parent_ip,\n\t\t\t\t       struct ftrace_ops *fops,\n\t\t\t\t       struct ftrace_regs *fregs)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\tint patch_state;\n\tint bit;\n\n\tops = container_of(fops, struct klp_ops, fops);\n\n\t/*\n\t * The ftrace_test_recursion_trylock() will disable preemption,\n\t * which is required for the variant of synchronize_rcu() that is\n\t * used to allow patching functions where RCU is not watching.\n\t * See klp_synchronize_transition() for more details.\n\t */\n\tbit = ftrace_test_recursion_trylock(ip, parent_ip);\n\tif (WARN_ON_ONCE(bit < 0))\n\t\treturn;\n\n\tfunc = list_first_or_null_rcu(&ops->func_stack, struct klp_func,\n\t\t\t\t      stack_node);\n\n\t/*\n\t * func should never be NULL because preemption should be disabled here\n\t * and unregister_ftrace_function() does the equivalent of a\n\t * synchronize_rcu() before the func_stack removal.\n\t */\n\tif (WARN_ON_ONCE(!func))\n\t\tgoto unlock;\n\n\t/*\n\t * In the enable path, enforce the order of the ops->func_stack and\n\t * func->transition reads.  The corresponding write barrier is in\n\t * __klp_enable_patch().\n\t *\n\t * (Note that this barrier technically isn't needed in the disable\n\t * path.  In the rare case where klp_update_patch_state() runs before\n\t * this handler, its TIF_PATCH_PENDING read and this func->transition\n\t * read need to be ordered.  But klp_update_patch_state() already\n\t * enforces that.)\n\t */\n\tsmp_rmb();\n\n\tif (unlikely(func->transition)) {\n\n\t\t/*\n\t\t * Enforce the order of the func->transition and\n\t\t * current->patch_state reads.  Otherwise we could read an\n\t\t * out-of-date task state and pick the wrong function.  The\n\t\t * corresponding write barrier is in klp_init_transition().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tpatch_state = current->patch_state;\n\n\t\tWARN_ON_ONCE(patch_state == KLP_UNDEFINED);\n\n\t\tif (patch_state == KLP_UNPATCHED) {\n\t\t\t/*\n\t\t\t * Use the previously patched version of the function.\n\t\t\t * If no previous patches exist, continue with the\n\t\t\t * original function.\n\t\t\t */\n\t\t\tfunc = list_entry_rcu(func->stack_node.next,\n\t\t\t\t\t      struct klp_func, stack_node);\n\n\t\t\tif (&func->stack_node == &ops->func_stack)\n\t\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/*\n\t * NOPs are used to replace existing patches with original code.\n\t * Do nothing! Setting pc would cause an infinite loop.\n\t */\n\tif (func->nop)\n\t\tgoto unlock;\n\n\tklp_arch_set_pc(fregs, (unsigned long)func->new_func);\n\nunlock:\n\tftrace_test_recursion_unlock(bit);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_test_recursion_unlock",
          "args": [
            "bit"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_arch_set_pc",
          "args": [
            "fregs",
            "(unsigned long)func->new_func"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "func->stack_node.next",
            "structklp_func",
            "stack_node"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "patch_state == KLP_UNDEFINED"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "func->transition"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!func"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_or_null_rcu",
          "args": [
            "&ops->func_stack",
            "structklp_func",
            "stack_node"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "bit < 0"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_test_recursion_trylock",
          "args": [
            "ip",
            "parent_ip"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fops",
            "structklp_ops",
            "fops"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstatic void notrace klp_ftrace_handler(unsigned long ip,\n\t\t\t\t       unsigned long parent_ip,\n\t\t\t\t       struct ftrace_ops *fops,\n\t\t\t\t       struct ftrace_regs *fregs)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\tint patch_state;\n\tint bit;\n\n\tops = container_of(fops, struct klp_ops, fops);\n\n\t/*\n\t * The ftrace_test_recursion_trylock() will disable preemption,\n\t * which is required for the variant of synchronize_rcu() that is\n\t * used to allow patching functions where RCU is not watching.\n\t * See klp_synchronize_transition() for more details.\n\t */\n\tbit = ftrace_test_recursion_trylock(ip, parent_ip);\n\tif (WARN_ON_ONCE(bit < 0))\n\t\treturn;\n\n\tfunc = list_first_or_null_rcu(&ops->func_stack, struct klp_func,\n\t\t\t\t      stack_node);\n\n\t/*\n\t * func should never be NULL because preemption should be disabled here\n\t * and unregister_ftrace_function() does the equivalent of a\n\t * synchronize_rcu() before the func_stack removal.\n\t */\n\tif (WARN_ON_ONCE(!func))\n\t\tgoto unlock;\n\n\t/*\n\t * In the enable path, enforce the order of the ops->func_stack and\n\t * func->transition reads.  The corresponding write barrier is in\n\t * __klp_enable_patch().\n\t *\n\t * (Note that this barrier technically isn't needed in the disable\n\t * path.  In the rare case where klp_update_patch_state() runs before\n\t * this handler, its TIF_PATCH_PENDING read and this func->transition\n\t * read need to be ordered.  But klp_update_patch_state() already\n\t * enforces that.)\n\t */\n\tsmp_rmb();\n\n\tif (unlikely(func->transition)) {\n\n\t\t/*\n\t\t * Enforce the order of the func->transition and\n\t\t * current->patch_state reads.  Otherwise we could read an\n\t\t * out-of-date task state and pick the wrong function.  The\n\t\t * corresponding write barrier is in klp_init_transition().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tpatch_state = current->patch_state;\n\n\t\tWARN_ON_ONCE(patch_state == KLP_UNDEFINED);\n\n\t\tif (patch_state == KLP_UNPATCHED) {\n\t\t\t/*\n\t\t\t * Use the previously patched version of the function.\n\t\t\t * If no previous patches exist, continue with the\n\t\t\t * original function.\n\t\t\t */\n\t\t\tfunc = list_entry_rcu(func->stack_node.next,\n\t\t\t\t\t      struct klp_func, stack_node);\n\n\t\t\tif (&func->stack_node == &ops->func_stack)\n\t\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/*\n\t * NOPs are used to replace existing patches with original code.\n\t * Do nothing! Setting pc would cause an infinite loop.\n\t */\n\tif (func->nop)\n\t\tgoto unlock;\n\n\tklp_arch_set_pc(fregs, (unsigned long)func->new_func);\n\nunlock:\n\tftrace_test_recursion_unlock(bit);\n}"
  },
  {
    "function_name": "klp_find_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
    "lines": "25-38",
    "snippet": "struct klp_ops *klp_find_ops(void *old_func)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_func == old_func)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/printk.h>",
      "#include <linux/bug.h>",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/list.h>",
      "#include <linux/livepatch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_ops);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ops->func_stack",
            "structklp_func",
            "stack_node"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ops",
            "&klp_ops",
            "node"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstruct klp_ops *klp_find_ops(void *old_func)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_func == old_func)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}"
  }
]