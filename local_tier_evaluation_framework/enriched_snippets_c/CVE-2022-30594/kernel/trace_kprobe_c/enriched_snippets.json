[
  {
    "function_name": "kprobe_trace_self_tests_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1954-2093",
    "snippet": "static __init int kprobe_trace_self_tests_init(void)\n{\n\tint ret, warn = 0;\n\tint (*target)(int, int, int, int, int, int);\n\tstruct trace_kprobe *tk;\n\tstruct trace_event_file *file;\n\n\tif (tracing_is_disabled())\n\t\treturn -ENODEV;\n\n\tif (tracing_selftest_disabled)\n\t\treturn 0;\n\n\ttarget = kprobe_trace_selftest_target;\n\n\tpr_info(\"Testing kprobe tracing: \");\n\n\tret = create_or_delete_trace_kprobe(\"p:testprobe kprobe_trace_selftest_target $stack $stack0 +0($stack)\");\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on probing function entry.\\n\");\n\t\twarn++;\n\t} else {\n\t\t/* Enable trace point */\n\t\ttk = find_trace_kprobe(\"testprobe\", KPROBE_EVENT_SYSTEM);\n\t\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\t\tpr_warn(\"error on getting new probe.\\n\");\n\t\t\twarn++;\n\t\t} else {\n\t\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\t\twarn++;\n\t\t\t} else\n\t\t\t\tenable_trace_kprobe(\n\t\t\t\t\ttrace_probe_event_call(&tk->tp), file);\n\t\t}\n\t}\n\n\tret = create_or_delete_trace_kprobe(\"r:testprobe2 kprobe_trace_selftest_target $retval\");\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on probing function return.\\n\");\n\t\twarn++;\n\t} else {\n\t\t/* Enable trace point */\n\t\ttk = find_trace_kprobe(\"testprobe2\", KPROBE_EVENT_SYSTEM);\n\t\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\t\tpr_warn(\"error on getting 2nd new probe.\\n\");\n\t\t\twarn++;\n\t\t} else {\n\t\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\t\twarn++;\n\t\t\t} else\n\t\t\t\tenable_trace_kprobe(\n\t\t\t\t\ttrace_probe_event_call(&tk->tp), file);\n\t\t}\n\t}\n\n\tif (warn)\n\t\tgoto end;\n\n\tret = target(1, 2, 3, 4, 5, 6);\n\n\t/*\n\t * Not expecting an error here, the check is only to prevent the\n\t * optimizer from removing the call to target() as otherwise there\n\t * are no side-effects and the call is never performed.\n\t */\n\tif (ret != 21)\n\t\twarn++;\n\n\t/* Disable trace points before removing it */\n\ttk = find_trace_kprobe(\"testprobe\", KPROBE_EVENT_SYSTEM);\n\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\tpr_warn(\"error on getting test probe.\\n\");\n\t\twarn++;\n\t} else {\n\t\tif (trace_kprobe_nhit(tk) != 1) {\n\t\t\tpr_warn(\"incorrect number of testprobe hits\\n\");\n\t\t\twarn++;\n\t\t}\n\n\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\twarn++;\n\t\t} else\n\t\t\tdisable_trace_kprobe(\n\t\t\t\ttrace_probe_event_call(&tk->tp), file);\n\t}\n\n\ttk = find_trace_kprobe(\"testprobe2\", KPROBE_EVENT_SYSTEM);\n\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\tpr_warn(\"error on getting 2nd test probe.\\n\");\n\t\twarn++;\n\t} else {\n\t\tif (trace_kprobe_nhit(tk) != 1) {\n\t\t\tpr_warn(\"incorrect number of testprobe2 hits\\n\");\n\t\t\twarn++;\n\t\t}\n\n\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\twarn++;\n\t\t} else\n\t\t\tdisable_trace_kprobe(\n\t\t\t\ttrace_probe_event_call(&tk->tp), file);\n\t}\n\n\tret = create_or_delete_trace_kprobe(\"-:testprobe\");\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on deleting a probe.\\n\");\n\t\twarn++;\n\t}\n\n\tret = create_or_delete_trace_kprobe(\"-:testprobe2\");\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on deleting a probe.\\n\");\n\t\twarn++;\n\t}\n\nend:\n\tret = dyn_events_release_all(&trace_kprobe_ops);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on cleaning up probes.\\n\");\n\t\twarn++;\n\t}\n\t/*\n\t * Wait for the optimizer work to finish. Otherwise it might fiddle\n\t * with probes in already freed __init text.\n\t */\n\twait_for_kprobe_optimizer();\n\tif (warn)\n\t\tpr_cont(\"NG: Some tests are failed. Please check them.\\n\");\n\telse\n\t\tpr_cont(\"OK\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [
      "#define KPROBE_EVENT_SYSTEM \"kprobes\""
    ],
    "globals_used": [
      "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};",
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"OK\\n\""
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_kprobe_optimizer",
          "args": [],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_kprobe_optimizer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "647-663",
          "snippet": "void wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* This will also make 'optimizing_work' execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* 'optimizing_work' might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* This will also make 'optimizing_work' execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* 'optimizing_work' might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on cleaning up probes.\\n\""
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_events_release_all",
          "args": [
            "&trace_kprobe_ops"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_events_release_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "195-220",
          "snippet": "int dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on deleting a probe.\\n\""
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_or_delete_trace_kprobe",
          "args": [
            "\"-:testprobe2\""
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "create_or_delete_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "905-914",
          "snippet": "static int create_or_delete_trace_kprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_kprobe_ops);\n\n\tret = trace_kprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_create(const char *raw_command);",
            "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_create(const char *raw_command);\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\n\nstatic int create_or_delete_trace_kprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_kprobe_ops);\n\n\tret = trace_kprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on deleting a probe.\\n\""
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_trace_kprobe",
          "args": [
            "trace_probe_event_call(&tk->tp)",
            "file"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "disable_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "397-429",
          "snippet": "static int disable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp))\n\t\t__disable_trace_kprobe(tp);\n\n out:\n\tif (file)\n\t\t/*\n\t\t * Synchronization is done in below function. For perf event,\n\t\t * file == NULL and perf_trace_event_unreg() calls\n\t\t * tracepoint_synchronize_unregister() to ensure synchronize\n\t\t * event. We don't need to care about it.\n\t\t */\n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic int disable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp))\n\t\t__disable_trace_kprobe(tp);\n\n out:\n\tif (file)\n\t\t/*\n\t\t * Synchronization is done in below function. For perf event,\n\t\t * file == NULL and perf_trace_event_unreg() calls\n\t\t * tracepoint_synchronize_unregister() to ensure synchronize\n\t\t * event. We don't need to care about it.\n\t\t */\n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting probe file.\\n\""
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "file == NULL"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_trace_probe_file",
          "args": [
            "tk",
            "top_trace_array()"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "find_trace_probe_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1938-1948",
          "snippet": "trace_event_file *\nfind_trace_probe_file(struct trace_kprobe *tk, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list)\n\t\tif (file->event_call == trace_probe_event_call(&tk->tp))\n\t\t\treturn file;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\ntrace_event_file *\nfind_trace_probe_file(struct trace_kprobe *tk, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list)\n\t\tif (file->event_call == trace_probe_event_call(&tk->tp))\n\t\t\treturn file;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "411-422",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"incorrect number of testprobe2 hits\\n\""
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_nhit",
          "args": [
            "tk"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_nhit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "171-180",
          "snippet": "static nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting 2nd test probe.\\n\""
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tk == NULL"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_trace_kprobe",
          "args": [
            "\"testprobe2\"",
            "KPROBE_EVENT_SYSTEM"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "find_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "302-313",
          "snippet": "static struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_kprobe *tk;\n\n\tfor_each_trace_kprobe(tk, pos)\n\t\tif (strcmp(trace_probe_name(&tk->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tk->tp), group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_kprobe *tk;\n\n\tfor_each_trace_kprobe(tk, pos)\n\t\tif (strcmp(trace_probe_name(&tk->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tk->tp), group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting probe file.\\n\""
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "file == NULL"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"incorrect number of testprobe hits\\n\""
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting test probe.\\n\""
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tk == NULL"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target",
          "args": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_trace_selftest_target",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe_selftest.c",
          "lines": "7-10",
          "snippet": "int kprobe_trace_selftest_target(int a1, int a2, int a3, int a4, int a5, int a6)\n{\n\treturn a1 + a2 + a3 + a4 + a5 + a6;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "int kprobe_trace_selftest_target(int a1, int a2, int a3, int a4, int a5, int a6)\n{\n\treturn a1 + a2 + a3 + a4 + a5 + a6;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_trace_kprobe",
          "args": [
            "trace_probe_event_call(&tk->tp)",
            "file"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "enable_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "347-391",
          "snippet": "static int enable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_kprobe *tk;\n\tbool enabled;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This also changes \"enabled\" state */\n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (enabled)\n\t\treturn 0;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (trace_kprobe_has_gone(tk))\n\t\t\tcontinue;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tenabled = true;\n\t}\n\n\tif (ret) {\n\t\t/* Failed to enable one of them. Roll back all */\n\t\tif (enabled)\n\t\t\t__disable_trace_kprobe(tp);\n\t\tif (file)\n\t\t\ttrace_probe_remove_file(tp, file);\n\t\telse\n\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int enable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_kprobe *tk;\n\tbool enabled;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This also changes \"enabled\" state */\n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (enabled)\n\t\treturn 0;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (trace_kprobe_has_gone(tk))\n\t\t\tcontinue;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tenabled = true;\n\t}\n\n\tif (ret) {\n\t\t/* Failed to enable one of them. Roll back all */\n\t\tif (enabled)\n\t\t\t__disable_trace_kprobe(tp);\n\t\tif (file)\n\t\t\ttrace_probe_remove_file(tp, file);\n\t\telse\n\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting probe file.\\n\""
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "file == NULL"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting 2nd new probe.\\n\""
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tk == NULL"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on probing function return.\\n\""
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting probe file.\\n\""
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "file == NULL"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on getting new probe.\\n\""
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tk == NULL"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error on probing function entry.\\n\""
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing kprobe tracing: \""
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_is_disabled",
          "args": [],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4823-4826",
          "snippet": "bool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\n\nbool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\n#define KPROBE_EVENT_SYSTEM \"kprobes\"\n\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic __init int kprobe_trace_self_tests_init(void)\n{\n\tint ret, warn = 0;\n\tint (*target)(int, int, int, int, int, int);\n\tstruct trace_kprobe *tk;\n\tstruct trace_event_file *file;\n\n\tif (tracing_is_disabled())\n\t\treturn -ENODEV;\n\n\tif (tracing_selftest_disabled)\n\t\treturn 0;\n\n\ttarget = kprobe_trace_selftest_target;\n\n\tpr_info(\"Testing kprobe tracing: \");\n\n\tret = create_or_delete_trace_kprobe(\"p:testprobe kprobe_trace_selftest_target $stack $stack0 +0($stack)\");\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on probing function entry.\\n\");\n\t\twarn++;\n\t} else {\n\t\t/* Enable trace point */\n\t\ttk = find_trace_kprobe(\"testprobe\", KPROBE_EVENT_SYSTEM);\n\t\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\t\tpr_warn(\"error on getting new probe.\\n\");\n\t\t\twarn++;\n\t\t} else {\n\t\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\t\twarn++;\n\t\t\t} else\n\t\t\t\tenable_trace_kprobe(\n\t\t\t\t\ttrace_probe_event_call(&tk->tp), file);\n\t\t}\n\t}\n\n\tret = create_or_delete_trace_kprobe(\"r:testprobe2 kprobe_trace_selftest_target $retval\");\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on probing function return.\\n\");\n\t\twarn++;\n\t} else {\n\t\t/* Enable trace point */\n\t\ttk = find_trace_kprobe(\"testprobe2\", KPROBE_EVENT_SYSTEM);\n\t\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\t\tpr_warn(\"error on getting 2nd new probe.\\n\");\n\t\t\twarn++;\n\t\t} else {\n\t\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\t\twarn++;\n\t\t\t} else\n\t\t\t\tenable_trace_kprobe(\n\t\t\t\t\ttrace_probe_event_call(&tk->tp), file);\n\t\t}\n\t}\n\n\tif (warn)\n\t\tgoto end;\n\n\tret = target(1, 2, 3, 4, 5, 6);\n\n\t/*\n\t * Not expecting an error here, the check is only to prevent the\n\t * optimizer from removing the call to target() as otherwise there\n\t * are no side-effects and the call is never performed.\n\t */\n\tif (ret != 21)\n\t\twarn++;\n\n\t/* Disable trace points before removing it */\n\ttk = find_trace_kprobe(\"testprobe\", KPROBE_EVENT_SYSTEM);\n\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\tpr_warn(\"error on getting test probe.\\n\");\n\t\twarn++;\n\t} else {\n\t\tif (trace_kprobe_nhit(tk) != 1) {\n\t\t\tpr_warn(\"incorrect number of testprobe hits\\n\");\n\t\t\twarn++;\n\t\t}\n\n\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\twarn++;\n\t\t} else\n\t\t\tdisable_trace_kprobe(\n\t\t\t\ttrace_probe_event_call(&tk->tp), file);\n\t}\n\n\ttk = find_trace_kprobe(\"testprobe2\", KPROBE_EVENT_SYSTEM);\n\tif (WARN_ON_ONCE(tk == NULL)) {\n\t\tpr_warn(\"error on getting 2nd test probe.\\n\");\n\t\twarn++;\n\t} else {\n\t\tif (trace_kprobe_nhit(tk) != 1) {\n\t\t\tpr_warn(\"incorrect number of testprobe2 hits\\n\");\n\t\t\twarn++;\n\t\t}\n\n\t\tfile = find_trace_probe_file(tk, top_trace_array());\n\t\tif (WARN_ON_ONCE(file == NULL)) {\n\t\t\tpr_warn(\"error on getting probe file.\\n\");\n\t\t\twarn++;\n\t\t} else\n\t\t\tdisable_trace_kprobe(\n\t\t\t\ttrace_probe_event_call(&tk->tp), file);\n\t}\n\n\tret = create_or_delete_trace_kprobe(\"-:testprobe\");\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on deleting a probe.\\n\");\n\t\twarn++;\n\t}\n\n\tret = create_or_delete_trace_kprobe(\"-:testprobe2\");\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on deleting a probe.\\n\");\n\t\twarn++;\n\t}\n\nend:\n\tret = dyn_events_release_all(&trace_kprobe_ops);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error on cleaning up probes.\\n\");\n\t\twarn++;\n\t}\n\t/*\n\t * Wait for the optimizer work to finish. Otherwise it might fiddle\n\t * with probes in already freed __init text.\n\t */\n\twait_for_kprobe_optimizer();\n\tif (warn)\n\t\tpr_cont(\"NG: Some tests are failed. Please check them.\\n\");\n\telse\n\t\tpr_cont(\"OK\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "find_trace_probe_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1938-1948",
    "snippet": "trace_event_file *\nfind_trace_probe_file(struct trace_kprobe *tk, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list)\n\t\tif (file->event_call == trace_probe_event_call(&tk->tp))\n\t\t\treturn file;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\ntrace_event_file *\nfind_trace_probe_file(struct trace_kprobe *tk, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list)\n\t\tif (file->event_call == trace_probe_event_call(&tk->tp))\n\t\t\treturn file;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "init_kprobe_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1907-1933",
    "snippet": "static __init int init_kprobe_trace(void)\n{\n\tint ret;\n\tstruct dentry *entry;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\tentry = tracefs_create_file(\"kprobe_events\", TRACE_MODE_WRITE,\n\t\t\t\t    NULL, NULL, &kprobe_events_ops);\n\n\t/* Event list interface */\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'kprobe_events' entry\\n\");\n\n\t/* Profile interface */\n\tentry = tracefs_create_file(\"kprobe_profile\", TRACE_MODE_READ,\n\t\t\t\t    NULL, NULL, &kprobe_profile_ops);\n\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'kprobe_profile' entry\\n\");\n\n\tsetup_boot_kprobe_events();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static const struct file_operations kprobe_events_ops = {\n\t.owner          = THIS_MODULE,\n\t.open           = probes_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n\t.write\t\t= probes_write,\n};",
      "static const struct file_operations kprobe_profile_ops = {\n\t.owner          = THIS_MODULE,\n\t.open           = profile_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_boot_kprobe_events",
          "args": [],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "setup_boot_kprobe_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1865-1885",
          "snippet": "static __init void setup_boot_kprobe_events(void)\n{\n\tchar *p, *cmd = kprobe_boot_events_buf;\n\tint ret;\n\n\tstrreplace(kprobe_boot_events_buf, ',', ' ');\n\n\twhile (cmd && *cmd != '\\0') {\n\t\tp = strchr(cmd, ';');\n\t\tif (p)\n\t\t\t*p++ = '\\0';\n\n\t\tret = create_or_delete_trace_kprobe(cmd);\n\t\tif (ret)\n\t\t\tpr_warn(\"Failed to add event(%d): %s\\n\", ret, cmd);\n\n\t\tcmd = p;\n\t}\n\n\tenable_boot_kprobe_events();\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char kprobe_boot_events_buf[COMMAND_LINE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic char kprobe_boot_events_buf[COMMAND_LINE_SIZE];\n\nstatic __init void setup_boot_kprobe_events(void)\n{\n\tchar *p, *cmd = kprobe_boot_events_buf;\n\tint ret;\n\n\tstrreplace(kprobe_boot_events_buf, ',', ' ');\n\n\twhile (cmd && *cmd != '\\0') {\n\t\tp = strchr(cmd, ';');\n\t\tif (p)\n\t\t\t*p++ = '\\0';\n\n\t\tret = create_or_delete_trace_kprobe(cmd);\n\t\tif (ret)\n\t\t\tpr_warn(\"Failed to add event(%d): %s\\n\", ret, cmd);\n\n\t\tcmd = p;\n\t}\n\n\tenable_boot_kprobe_events();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'kprobe_profile' entry\\n\""
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"kprobe_profile\"",
            "TRACE_MODE_READ",
            "NULL",
            "NULL",
            "&kprobe_profile_ops"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'kprobe_events' entry\\n\""
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"kprobe_events\"",
            "TRACE_MODE_WRITE",
            "NULL",
            "NULL",
            "&kprobe_events_ops"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9527-9553",
          "snippet": "int tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nint tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic const struct file_operations kprobe_events_ops = {\n\t.owner          = THIS_MODULE,\n\t.open           = probes_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n\t.write\t\t= probes_write,\n};\nstatic const struct file_operations kprobe_profile_ops = {\n\t.owner          = THIS_MODULE,\n\t.open           = profile_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n};\n\nstatic __init int init_kprobe_trace(void)\n{\n\tint ret;\n\tstruct dentry *entry;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\tentry = tracefs_create_file(\"kprobe_events\", TRACE_MODE_WRITE,\n\t\t\t\t    NULL, NULL, &kprobe_events_ops);\n\n\t/* Event list interface */\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'kprobe_events' entry\\n\");\n\n\t/* Profile interface */\n\tentry = tracefs_create_file(\"kprobe_profile\", TRACE_MODE_READ,\n\t\t\t\t    NULL, NULL, &kprobe_profile_ops);\n\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'kprobe_profile' entry\\n\");\n\n\tsetup_boot_kprobe_events();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "init_kprobe_trace_early",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1891-1903",
    "snippet": "static __init int init_kprobe_trace_early(void)\n{\n\tint ret;\n\n\tret = dyn_event_register(&trace_kprobe_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tif (register_module_notifier(&trace_kprobe_module_nb))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};",
      "static struct notifier_block trace_kprobe_module_nb = {\n\t.notifier_call = trace_kprobe_module_callback,\n\t.priority = 1\t/* Invoked after kprobe module callback */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&trace_kprobe_module_nb"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "307-310",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_register",
          "args": [
            "&trace_kprobe_ops"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "59-70",
          "snippet": "int dyn_event_register(struct dyn_event_operations *ops)\n{\n\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||\n\t    !ops->free || !ops->match)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ops->list);\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_add_tail(&ops->list, &dyn_event_ops_list);\n\tmutex_unlock(&dyn_event_ops_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(dyn_event_ops_mutex);",
            "static LIST_HEAD(dyn_event_ops_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nstatic DEFINE_MUTEX(dyn_event_ops_mutex);\nstatic LIST_HEAD(dyn_event_ops_list);\n\nint dyn_event_register(struct dyn_event_operations *ops)\n{\n\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||\n\t    !ops->free || !ops->match)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ops->list);\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_add_tail(&ops->list, &dyn_event_ops_list);\n\tmutex_unlock(&dyn_event_ops_mutex);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\nstatic struct notifier_block trace_kprobe_module_nb = {\n\t.notifier_call = trace_kprobe_module_callback,\n\t.priority = 1\t/* Invoked after kprobe module callback */\n};\n\nstatic __init int init_kprobe_trace_early(void)\n{\n\tint ret;\n\n\tret = dyn_event_register(&trace_kprobe_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tif (register_module_notifier(&trace_kprobe_module_nb))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_boot_kprobe_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1865-1885",
    "snippet": "static __init void setup_boot_kprobe_events(void)\n{\n\tchar *p, *cmd = kprobe_boot_events_buf;\n\tint ret;\n\n\tstrreplace(kprobe_boot_events_buf, ',', ' ');\n\n\twhile (cmd && *cmd != '\\0') {\n\t\tp = strchr(cmd, ';');\n\t\tif (p)\n\t\t\t*p++ = '\\0';\n\n\t\tret = create_or_delete_trace_kprobe(cmd);\n\t\tif (ret)\n\t\t\tpr_warn(\"Failed to add event(%d): %s\\n\", ret, cmd);\n\n\t\tcmd = p;\n\t}\n\n\tenable_boot_kprobe_events();\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char kprobe_boot_events_buf[COMMAND_LINE_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_boot_kprobe_events",
          "args": [],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "enable_boot_kprobe_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1849-1863",
          "snippet": "static __init void enable_boot_kprobe_events(void)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file;\n\tstruct trace_kprobe *tk;\n\tstruct dyn_event *pos;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_trace_kprobe(tk, pos) {\n\t\tlist_for_each_entry(file, &tr->events, list)\n\t\t\tif (file->event_call == trace_probe_event_call(&tk->tp))\n\t\t\t\ttrace_event_enable_disable(file, 1, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic __init void enable_boot_kprobe_events(void)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file;\n\tstruct trace_kprobe *tk;\n\tstruct dyn_event *pos;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_trace_kprobe(tk, pos) {\n\t\tlist_for_each_entry(file, &tr->events, list)\n\t\t\tif (file->event_call == trace_probe_event_call(&tk->tp))\n\t\t\t\ttrace_event_enable_disable(file, 1, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to add event(%d): %s\\n\"",
            "ret",
            "cmd"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_or_delete_trace_kprobe",
          "args": [
            "cmd"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "create_or_delete_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "905-914",
          "snippet": "static int create_or_delete_trace_kprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_kprobe_ops);\n\n\tret = trace_kprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_create(const char *raw_command);",
            "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_create(const char *raw_command);\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\n\nstatic int create_or_delete_trace_kprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_kprobe_ops);\n\n\tret = trace_kprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cmd",
            "';'"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strreplace",
          "args": [
            "kprobe_boot_events_buf",
            "','",
            "' '"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic char kprobe_boot_events_buf[COMMAND_LINE_SIZE];\n\nstatic __init void setup_boot_kprobe_events(void)\n{\n\tchar *p, *cmd = kprobe_boot_events_buf;\n\tint ret;\n\n\tstrreplace(kprobe_boot_events_buf, ',', ' ');\n\n\twhile (cmd && *cmd != '\\0') {\n\t\tp = strchr(cmd, ';');\n\t\tif (p)\n\t\t\t*p++ = '\\0';\n\n\t\tret = create_or_delete_trace_kprobe(cmd);\n\t\tif (ret)\n\t\t\tpr_warn(\"Failed to add event(%d): %s\\n\", ret, cmd);\n\n\t\tcmd = p;\n\t}\n\n\tenable_boot_kprobe_events();\n}"
  },
  {
    "function_name": "enable_boot_kprobe_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1849-1863",
    "snippet": "static __init void enable_boot_kprobe_events(void)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file;\n\tstruct trace_kprobe *tk;\n\tstruct dyn_event *pos;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_trace_kprobe(tk, pos) {\n\t\tlist_for_each_entry(file, &tr->events, list)\n\t\t\tif (file->event_call == trace_probe_event_call(&tk->tp))\n\t\t\t\ttrace_event_enable_disable(file, 1, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_enable_disable",
          "args": [
            "file",
            "1",
            "0"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "694-698",
          "snippet": "int trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nint trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_trace_kprobe",
          "args": [
            "tk",
            "pos"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "411-422",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic __init void enable_boot_kprobe_events(void)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file;\n\tstruct trace_kprobe *tk;\n\tstruct dyn_event *pos;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_trace_kprobe(tk, pos) {\n\t\tlist_for_each_entry(file, &tr->events, list)\n\t\t\tif (file->event_call == trace_probe_event_call(&tk->tp))\n\t\t\t\ttrace_event_enable_disable(file, 1, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "destroy_local_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1830-1846",
    "snippet": "void destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = trace_kprobe_primary_from_call(event_call);\n\tif (unlikely(!tk))\n\t\treturn;\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tfree_trace_kprobe(tk);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "241-249",
          "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "514-527",
          "snippet": "static void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_kprobe_is_registered(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\t/* Cleanup kprobe for reuse and mark it unregistered */\n\t\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\t\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_kprobe_is_registered(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\t/* Cleanup kprobe for reuse and mark it unregistered */\n\t\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\t\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tk->tp"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tk"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_primary_from_call",
          "args": [
            "event_call"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "205-215",
          "snippet": "trace_kprobe *\ntrace_kprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_kprobe, tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\ntrace_kprobe *\ntrace_kprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_kprobe, tp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nvoid destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = trace_kprobe_primary_from_call(event_call);\n\tif (unlikely(!tk))\n\t\treturn;\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tfree_trace_kprobe(tk);\n}"
  },
  {
    "function_name": "create_local_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1785-1828",
    "snippet": "struct trace_event_call *\ncreate_local_trace_kprobe(char *func, void *addr, unsigned long offs,\n\t\t\t  bool is_return)\n{\n\tenum probe_print_type ptype;\n\tstruct trace_kprobe *tk;\n\tint ret;\n\tchar *event;\n\n\t/*\n\t * local trace_kprobes are not added to dyn_event, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name here.\n\t */\n\tevent = func ? func : \"DUMMY_EVENT\";\n\n\ttk = alloc_trace_kprobe(KPROBE_EVENT_SYSTEM, event, (void *)addr, func,\n\t\t\t\toffs, 0 /* maxactive */, 0 /* nargs */,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tk)) {\n\t\tpr_info(\"Failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tk));\n\t\treturn ERR_CAST(tk);\n\t}\n\n\tinit_trace_event_call(tk);\n\n\tptype = trace_kprobe_is_return(tk) ?\n\t\tPROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tif (traceprobe_set_print_fmt(&tk->tp, ptype) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = __register_trace_kprobe(tk);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn trace_probe_event_call(&tk->tp);\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [
      "#define KPROBE_EVENT_SYSTEM \"kprobes\""
    ],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "241-249",
          "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "__register_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "476-511",
          "snippet": "static int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tret = security_locked_down(LOCKDOWN_KPROBES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trace_kprobe_is_registered(tk))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tret = security_locked_down(LOCKDOWN_KPROBES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trace_kprobe_is_registered(tk))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_set_print_fmt",
          "args": [
            "&tk->tp",
            "ptype"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_set_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "935-952",
          "snippet": "int traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-87",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_trace_event_call",
          "args": [
            "tk"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "init_trace_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1755-1769",
          "snippet": "static inline void init_trace_event_call(struct trace_kprobe *tk)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->fields_array = kretprobe_fields_array;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->fields_array = kprobe_fields_array;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};",
            "static struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};",
            "static struct trace_event_fields kretprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kretprobe_event_define_fields },\n\t{}\n};",
            "static struct trace_event_fields kprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kprobe_event_define_fields },\n\t{}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};\nstatic struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};\nstatic struct trace_event_fields kretprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kretprobe_event_define_fields },\n\t{}\n};\nstatic struct trace_event_fields kprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kprobe_event_define_fields },\n\t{}\n};\n\nstatic inline void init_trace_event_call(struct trace_kprobe *tk)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->fields_array = kretprobe_fields_array;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->fields_array = kprobe_fields_array;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "tk"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to allocate trace_probe.(%d)\\n\"",
            "(int)PTR_ERR(tk)"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tk"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tk"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_trace_kprobe",
          "args": [
            "KPROBE_EVENT_SYSTEM",
            "event",
            "(void *)addr",
            "func",
            "offs",
            "0/* maxactive */",
            "0/* nargs */",
            "is_return"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "254-300",
          "snippet": "static struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(struct_size(tk, tp.args, nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\n\tret = trace_probe_init(&tk->tp, event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tk->devent, &trace_kprobe_ops);\n\treturn tk;\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};",
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(struct_size(tk, tp.args, nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\n\tret = trace_probe_init(&tk->tp, event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tk->devent, &trace_kprobe_ops);\n\treturn tk;\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\n#define KPROBE_EVENT_SYSTEM \"kprobes\"\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstruct trace_event_call *\ncreate_local_trace_kprobe(char *func, void *addr, unsigned long offs,\n\t\t\t  bool is_return)\n{\n\tenum probe_print_type ptype;\n\tstruct trace_kprobe *tk;\n\tint ret;\n\tchar *event;\n\n\t/*\n\t * local trace_kprobes are not added to dyn_event, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name here.\n\t */\n\tevent = func ? func : \"DUMMY_EVENT\";\n\n\ttk = alloc_trace_kprobe(KPROBE_EVENT_SYSTEM, event, (void *)addr, func,\n\t\t\t\toffs, 0 /* maxactive */, 0 /* nargs */,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tk)) {\n\t\tpr_info(\"Failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tk));\n\t\treturn ERR_CAST(tk);\n\t}\n\n\tinit_trace_event_call(tk);\n\n\tptype = trace_kprobe_is_return(tk) ?\n\t\tPROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tif (traceprobe_set_print_fmt(&tk->tp, ptype) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = __register_trace_kprobe(tk);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn trace_probe_event_call(&tk->tp);\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "unregister_kprobe_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1778-1781",
    "snippet": "static int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\treturn trace_probe_unregister_event_call(&tk->tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_unregister_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_unregister_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "321-325",
          "snippet": "static inline int trace_probe_unregister_event_call(struct trace_probe *tp)\n{\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\treturn trace_remove_event_call(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline int trace_probe_unregister_event_call(struct trace_probe *tp)\n{\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\treturn trace_remove_event_call(&tp->event->call);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\treturn trace_probe_unregister_event_call(&tk->tp);\n}"
  },
  {
    "function_name": "register_kprobe_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1771-1776",
    "snippet": "static int register_kprobe_event(struct trace_kprobe *tk)\n{\n\tinit_trace_event_call(tk);\n\n\treturn trace_probe_register_event_call(&tk->tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_register_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_register_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1083-1103",
          "snippet": "int trace_probe_register_event_call(struct trace_probe *tp)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (find_trace_event_call(trace_probe_group_name(tp),\n\t\t\t\t  trace_probe_name(tp)))\n\t\treturn -EEXIST;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret)\n\t\treturn -ENODEV;\n\n\tret = trace_add_event_call(call);\n\tif (ret)\n\t\tunregister_trace_event(&call->event);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_register_event_call(struct trace_probe *tp)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (find_trace_event_call(trace_probe_group_name(tp),\n\t\t\t\t  trace_probe_name(tp)))\n\t\treturn -EEXIST;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret)\n\t\treturn -ENODEV;\n\n\tret = trace_add_event_call(call);\n\tif (ret)\n\t\tunregister_trace_event(&call->event);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_trace_event_call",
          "args": [
            "tk"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "init_trace_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1755-1769",
          "snippet": "static inline void init_trace_event_call(struct trace_kprobe *tk)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->fields_array = kretprobe_fields_array;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->fields_array = kprobe_fields_array;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};",
            "static struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};",
            "static struct trace_event_fields kretprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kretprobe_event_define_fields },\n\t{}\n};",
            "static struct trace_event_fields kprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kprobe_event_define_fields },\n\t{}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};\nstatic struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};\nstatic struct trace_event_fields kretprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kretprobe_event_define_fields },\n\t{}\n};\nstatic struct trace_event_fields kprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kprobe_event_define_fields },\n\t{}\n};\n\nstatic inline void init_trace_event_call(struct trace_kprobe *tk)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->fields_array = kretprobe_fields_array;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->fields_array = kprobe_fields_array;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int register_kprobe_event(struct trace_kprobe *tk)\n{\n\tinit_trace_event_call(tk);\n\n\treturn trace_probe_register_event_call(&tk->tp);\n}"
  },
  {
    "function_name": "init_trace_event_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1755-1769",
    "snippet": "static inline void init_trace_event_call(struct trace_kprobe *tk)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->fields_array = kretprobe_fields_array;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->fields_array = kprobe_fields_array;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};",
      "static struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};",
      "static struct trace_event_fields kretprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kretprobe_event_define_fields },\n\t{}\n};",
      "static struct trace_event_fields kprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kprobe_event_define_fields },\n\t{}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-87",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic struct trace_event_functions kretprobe_funcs = {\n\t.trace\t\t= print_kretprobe_event\n};\nstatic struct trace_event_functions kprobe_funcs = {\n\t.trace\t\t= print_kprobe_event\n};\nstatic struct trace_event_fields kretprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kretprobe_event_define_fields },\n\t{}\n};\nstatic struct trace_event_fields kprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = kprobe_event_define_fields },\n\t{}\n};\n\nstatic inline void init_trace_event_call(struct trace_kprobe *tk)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\n\tif (trace_kprobe_is_return(tk)) {\n\t\tcall->event.funcs = &kretprobe_funcs;\n\t\tcall->class->fields_array = kretprobe_fields_array;\n\t} else {\n\t\tcall->event.funcs = &kprobe_funcs;\n\t\tcall->class->fields_array = kprobe_fields_array;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_KPROBE;\n\tcall->class->reg = kprobe_register;\n}"
  },
  {
    "function_name": "kretprobe_dispatcher",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1717-1732",
    "snippet": "static int\nkretprobe_dispatcher(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tstruct kretprobe *rp = get_kretprobe(ri);\n\tstruct trace_kprobe *tk = container_of(rp, struct trace_kprobe, rp);\n\n\traw_cpu_inc(*tk->nhit);\n\n\tif (trace_probe_test_flag(&tk->tp, TP_FLAG_TRACE))\n\t\tkretprobe_trace_func(tk, ri, regs);\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tk->tp, TP_FLAG_PROFILE))\n\t\tkretprobe_perf_func(tk, ri, regs);\n#endif\n\treturn 0;\t/* We don't tweak kernel, so just return 0 */\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kretprobe_perf_func",
          "args": [
            "tk",
            "ri",
            "regs"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_perf_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1604-1635",
          "snippet": "static void\nkretprobe_perf_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t    struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkretprobe_perf_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t    struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_test_flag",
          "args": [
            "&tk->tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_test_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "256-260",
          "snippet": "static inline bool trace_probe_test_flag(struct trace_probe *tp,\n\t\t\t\t\t unsigned int flag)\n{\n\treturn !!(tp->event->flags & flag);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_test_flag(struct trace_probe *tp,\n\t\t\t\t\t unsigned int flag)\n{\n\treturn !!(tp->event->flags & flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kretprobe_trace_func",
          "args": [
            "tk",
            "ri",
            "regs"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "kretprobe_trace_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1442-1450",
          "snippet": "static void\nkretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t     struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link_rcu(link, &tk->tp)\n\t\t__kretprobe_trace_func(tk, ri, regs, link->file);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t     struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link_rcu(link, &tk->tp)\n\t\t__kretprobe_trace_func(tk, ri, regs, link->file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_inc",
          "args": [
            "*tk->nhit"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rp",
            "structtrace_kprobe",
            "rp"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kretprobe",
          "args": [
            "ri"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic int\nkretprobe_dispatcher(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tstruct kretprobe *rp = get_kretprobe(ri);\n\tstruct trace_kprobe *tk = container_of(rp, struct trace_kprobe, rp);\n\n\traw_cpu_inc(*tk->nhit);\n\n\tif (trace_probe_test_flag(&tk->tp, TP_FLAG_TRACE))\n\t\tkretprobe_trace_func(tk, ri, regs);\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tk->tp, TP_FLAG_PROFILE))\n\t\tkretprobe_perf_func(tk, ri, regs);\n#endif\n\treturn 0;\t/* We don't tweak kernel, so just return 0 */\n}"
  },
  {
    "function_name": "kprobe_dispatcher",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1700-1714",
    "snippet": "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs)\n{\n\tstruct trace_kprobe *tk = container_of(kp, struct trace_kprobe, rp.kp);\n\tint ret = 0;\n\n\traw_cpu_inc(*tk->nhit);\n\n\tif (trace_probe_test_flag(&tk->tp, TP_FLAG_TRACE))\n\t\tkprobe_trace_func(tk, regs);\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tk->tp, TP_FLAG_PROFILE))\n\t\tret = kprobe_perf_func(tk, regs);\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_perf_func",
          "args": [
            "tk",
            "regs"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_perf_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1555-1600",
          "snippet": "static int\nkprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tunsigned long orig_ip = instruction_pointer(regs);\n\t\tint ret;\n\n\t\tret = trace_call_bpf(call, regs);\n\n\t\t/*\n\t\t * We need to check and see if we modified the pc of the\n\t\t * pt_regs, and if so return 1 so that we don't do the\n\t\t * single stepping.\n\t\t */\n\t\tif (orig_ip != instruction_pointer(regs))\n\t\t\treturn 1;\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tmemset(&entry[1], 0, dsize);\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic int\nkprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tunsigned long orig_ip = instruction_pointer(regs);\n\t\tint ret;\n\n\t\tret = trace_call_bpf(call, regs);\n\n\t\t/*\n\t\t * We need to check and see if we modified the pc of the\n\t\t * pt_regs, and if so return 1 so that we don't do the\n\t\t * single stepping.\n\t\t */\n\t\tif (orig_ip != instruction_pointer(regs))\n\t\t\treturn 1;\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tmemset(&entry[1], 0, dsize);\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_test_flag",
          "args": [
            "&tk->tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_test_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "256-260",
          "snippet": "static inline bool trace_probe_test_flag(struct trace_probe *tp,\n\t\t\t\t\t unsigned int flag)\n{\n\treturn !!(tp->event->flags & flag);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_test_flag(struct trace_probe *tp,\n\t\t\t\t\t unsigned int flag)\n{\n\treturn !!(tp->event->flags & flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_trace_func",
          "args": [
            "tk",
            "regs"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_trace_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1400-1407",
          "snippet": "static void\nkprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link_rcu(link, &tk->tp)\n\t\t__kprobe_trace_func(tk, regs, link->file);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link_rcu(link, &tk->tp)\n\t\t__kprobe_trace_func(tk, regs, link->file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_inc",
          "args": [
            "*tk->nhit"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kp",
            "structtrace_kprobe",
            "rp.kp"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs)\n{\n\tstruct trace_kprobe *tk = container_of(kp, struct trace_kprobe, rp.kp);\n\tint ret = 0;\n\n\traw_cpu_inc(*tk->nhit);\n\n\tif (trace_probe_test_flag(&tk->tp, TP_FLAG_TRACE))\n\t\tkprobe_trace_func(tk, regs);\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tk->tp, TP_FLAG_PROFILE))\n\t\tret = kprobe_perf_func(tk, regs);\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "kprobe_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1674-1698",
    "snippet": "static int kprobe_register(struct trace_event_call *event,\n\t\t\t   enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn enable_trace_kprobe(event, file);\n\tcase TRACE_REG_UNREGISTER:\n\t\treturn disable_trace_kprobe(event, file);\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn enable_trace_kprobe(event, NULL);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\treturn disable_trace_kprobe(event, NULL);\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_trace_kprobe",
          "args": [
            "event",
            "NULL"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "disable_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "397-429",
          "snippet": "static int disable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp))\n\t\t__disable_trace_kprobe(tp);\n\n out:\n\tif (file)\n\t\t/*\n\t\t * Synchronization is done in below function. For perf event,\n\t\t * file == NULL and perf_trace_event_unreg() calls\n\t\t * tracepoint_synchronize_unregister() to ensure synchronize\n\t\t * event. We don't need to care about it.\n\t\t */\n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic int disable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp))\n\t\t__disable_trace_kprobe(tp);\n\n out:\n\tif (file)\n\t\t/*\n\t\t * Synchronization is done in below function. For perf event,\n\t\t * file == NULL and perf_trace_event_unreg() calls\n\t\t * tracepoint_synchronize_unregister() to ensure synchronize\n\t\t * event. We don't need to care about it.\n\t\t */\n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_trace_kprobe",
          "args": [
            "event",
            "NULL"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "enable_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "347-391",
          "snippet": "static int enable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_kprobe *tk;\n\tbool enabled;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This also changes \"enabled\" state */\n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (enabled)\n\t\treturn 0;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (trace_kprobe_has_gone(tk))\n\t\t\tcontinue;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tenabled = true;\n\t}\n\n\tif (ret) {\n\t\t/* Failed to enable one of them. Roll back all */\n\t\tif (enabled)\n\t\t\t__disable_trace_kprobe(tp);\n\t\tif (file)\n\t\t\ttrace_probe_remove_file(tp, file);\n\t\telse\n\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int enable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_kprobe *tk;\n\tbool enabled;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This also changes \"enabled\" state */\n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (enabled)\n\t\treturn 0;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (trace_kprobe_has_gone(tk))\n\t\t\tcontinue;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tenabled = true;\n\t}\n\n\tif (ret) {\n\t\t/* Failed to enable one of them. Roll back all */\n\t\tif (enabled)\n\t\t\t__disable_trace_kprobe(tp);\n\t\tif (file)\n\t\t\ttrace_probe_remove_file(tp, file);\n\t\telse\n\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic int kprobe_register(struct trace_event_call *event,\n\t\t\t   enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn enable_trace_kprobe(event, file);\n\tcase TRACE_REG_UNREGISTER:\n\t\treturn disable_trace_kprobe(event, file);\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn enable_trace_kprobe(event, NULL);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\treturn disable_trace_kprobe(event, NULL);\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_get_kprobe_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1638-1665",
    "snippet": "int bpf_get_kprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **symbol, u64 *probe_offset,\n\t\t\tu64 *probe_addr, bool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_kprobe *tk;\n\n\tif (perf_type_tracepoint)\n\t\ttk = find_trace_kprobe(pevent, group);\n\telse\n\t\ttk = trace_kprobe_primary_from_call(event->tp_event);\n\tif (!tk)\n\t\treturn -EINVAL;\n\n\t*fd_type = trace_kprobe_is_return(tk) ? BPF_FD_TYPE_KRETPROBE\n\t\t\t\t\t      : BPF_FD_TYPE_KPROBE;\n\tif (tk->symbol) {\n\t\t*symbol = tk->symbol;\n\t\t*probe_offset = tk->rp.kp.offset;\n\t\t*probe_addr = 0;\n\t} else {\n\t\t*symbol = NULL;\n\t\t*probe_offset = 0;\n\t\t*probe_addr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-87",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_primary_from_call",
          "args": [
            "event->tp_event"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "205-215",
          "snippet": "trace_kprobe *\ntrace_kprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_kprobe, tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\ntrace_kprobe *\ntrace_kprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_kprobe, tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_trace_kprobe",
          "args": [
            "pevent",
            "group"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "find_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "302-313",
          "snippet": "static struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_kprobe *tk;\n\n\tfor_each_trace_kprobe(tk, pos)\n\t\tif (strcmp(trace_probe_name(&tk->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tk->tp), group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_kprobe *tk;\n\n\tfor_each_trace_kprobe(tk, pos)\n\t\tif (strcmp(trace_probe_name(&tk->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tk->tp), group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "event->tp_event"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nint bpf_get_kprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **symbol, u64 *probe_offset,\n\t\t\tu64 *probe_addr, bool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_kprobe *tk;\n\n\tif (perf_type_tracepoint)\n\t\ttk = find_trace_kprobe(pevent, group);\n\telse\n\t\ttk = trace_kprobe_primary_from_call(event->tp_event);\n\tif (!tk)\n\t\treturn -EINVAL;\n\n\t*fd_type = trace_kprobe_is_return(tk) ? BPF_FD_TYPE_KRETPROBE\n\t\t\t\t\t      : BPF_FD_TYPE_KPROBE;\n\tif (tk->symbol) {\n\t\t*symbol = tk->symbol;\n\t\t*probe_offset = tk->rp.kp.offset;\n\t\t*probe_addr = 0;\n\t} else {\n\t\t*symbol = NULL;\n\t\t*probe_offset = 0;\n\t\t*probe_addr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kretprobe_perf_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1604-1635",
    "snippet": "static void\nkretprobe_perf_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t    struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "entry",
            "size",
            "rctx",
            "call->event.type",
            "1",
            "regs",
            "head",
            "NULL"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "&entry[1]",
            "&tk->tp",
            "regs",
            "sizeof(*entry)",
            "dsize"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "190-214",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "size",
            "NULL",
            "&rctx"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "395-418",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "__size + sizeof(u32)",
            "sizeof(u64)"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tk->tp",
            "regs"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "171-187",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "call->perf_events"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_call_bpf",
          "args": [
            "call",
            "regs"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "trace_call_bpf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/bpf_trace.c",
          "lines": "95-133",
          "snippet": "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tcant_sleep();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heuristic to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY(call->prog_array, ctx, bpf_prog_run);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"bpf_trace.h\"",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <asm/tlb.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_trace.h\"\n#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <asm/tlb.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nunsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tcant_sleep();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heuristic to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY(call->prog_array, ctx, bpf_prog_run);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_valid",
          "args": [
            "call"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkretprobe_perf_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t    struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))\n\t\treturn;\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n}"
  },
  {
    "function_name": "kprobe_perf_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1555-1600",
    "snippet": "static int\nkprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tunsigned long orig_ip = instruction_pointer(regs);\n\t\tint ret;\n\n\t\tret = trace_call_bpf(call, regs);\n\n\t\t/*\n\t\t * We need to check and see if we modified the pc of the\n\t\t * pt_regs, and if so return 1 so that we don't do the\n\t\t * single stepping.\n\t\t */\n\t\tif (orig_ip != instruction_pointer(regs))\n\t\t\treturn 1;\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tmemset(&entry[1], 0, dsize);\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "entry",
            "size",
            "rctx",
            "call->event.type",
            "1",
            "regs",
            "head",
            "NULL"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "&entry[1]",
            "&tk->tp",
            "regs",
            "sizeof(*entry)",
            "dsize"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "190-214",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&entry[1]",
            "0",
            "dsize"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "size",
            "NULL",
            "&rctx"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_event_perf.c",
          "lines": "395-418",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/security.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/security.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough, wanted %d, have %d\",\n\t\t      size, PERF_MAX_TRACE_SIZE))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "__size + sizeof(u32)",
            "sizeof(u64)"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tk->tp",
            "regs"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "171-187",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "call->perf_events"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_call_bpf",
          "args": [
            "call",
            "regs"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "trace_call_bpf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/bpf_trace.c",
          "lines": "95-133",
          "snippet": "unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tcant_sleep();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heuristic to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY(call->prog_array, ctx, bpf_prog_run);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"bpf_trace.h\"",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <asm/tlb.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_trace.h\"\n#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <asm/tlb.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nunsigned int trace_call_bpf(struct trace_event_call *call, void *ctx)\n{\n\tunsigned int ret;\n\n\tcant_sleep();\n\n\tif (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {\n\t\t/*\n\t\t * since some bpf program is already running on this cpu,\n\t\t * don't call into another bpf program (same or different)\n\t\t * and don't send kprobe event into ring-buffer,\n\t\t * so return zero here\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock\n\t * to all call sites, we did a bpf_prog_array_valid() there to check\n\t * whether call->prog_array is empty or not, which is\n\t * a heuristic to speed up execution.\n\t *\n\t * If bpf_prog_array_valid() fetched prog_array was\n\t * non-NULL, we go into trace_call_bpf() and do the actual\n\t * proper rcu_dereference() under RCU lock.\n\t * If it turns out that prog_array is NULL then, we bail out.\n\t * For the opposite, if the bpf_prog_array_valid() fetched pointer\n\t * was NULL, you'll skip the prog_array with the risk of missing\n\t * out of events when it was updated in between this and the\n\t * rcu_dereference() which is accepted risk.\n\t */\n\tret = BPF_PROG_RUN_ARRAY(call->prog_array, ctx, bpf_prog_run);\n\n out:\n\t__this_cpu_dec(bpf_prog_active);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_valid",
          "args": [
            "call"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic int\nkprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\tif (bpf_prog_array_valid(call)) {\n\t\tunsigned long orig_ip = instruction_pointer(regs);\n\t\tint ret;\n\n\t\tret = trace_call_bpf(call, regs);\n\n\t\t/*\n\t\t * We need to check and see if we modified the pc of the\n\t\t * pt_regs, and if so return 1 so that we don't do the\n\t\t * single stepping.\n\t\t */\n\t\tif (orig_ip != instruction_pointer(regs))\n\t\t\treturn 1;\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\t__size = sizeof(*entry) + tk->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tmemset(&entry[1], 0, dsize);\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "kretprobe_event_define_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1536-1550",
    "snippet": "static int kretprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct kretprobe_trace_entry_head field;\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(event_call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENOENT;\n\n\tDEFINE_FIELD(unsigned long, func, FIELD_STRING_FUNC, 0);\n\tDEFINE_FIELD(unsigned long, ret_ip, FIELD_STRING_RETIP, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "traceprobe_define_arg_fields",
          "args": [
            "event_call",
            "sizeof(field)",
            "tp"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_define_arg_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "954-977",
          "snippet": "int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "event_call"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic int kretprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct kretprobe_trace_entry_head field;\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(event_call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENOENT;\n\n\tDEFINE_FIELD(unsigned long, func, FIELD_STRING_FUNC, 0);\n\tDEFINE_FIELD(unsigned long, ret_ip, FIELD_STRING_RETIP, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), tp);\n}"
  },
  {
    "function_name": "kprobe_event_define_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1521-1534",
    "snippet": "static int kprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct kprobe_trace_entry_head field;\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(event_call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENOENT;\n\n\tDEFINE_FIELD(unsigned long, ip, FIELD_STRING_IP, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "traceprobe_define_arg_fields",
          "args": [
            "event_call",
            "sizeof(field)",
            "tp"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_define_arg_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "954-977",
          "snippet": "int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "event_call"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic int kprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct kprobe_trace_entry_head field;\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(event_call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENOENT;\n\n\tDEFINE_FIELD(unsigned long, ip, FIELD_STRING_IP, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), tp);\n}"
  },
  {
    "function_name": "print_kretprobe_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1484-1518",
    "snippet": "static enum print_line_t\nprint_kretprobe_event(struct trace_iterator *iter, int flags,\n\t\t      struct trace_event *event)\n{\n\tstruct kretprobe_trace_entry_head *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct kretprobe_trace_entry_head *)iter->ent;\n\ttp = trace_probe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (WARN_ON_ONCE(!tp))\n\t\tgoto out;\n\n\ttrace_seq_printf(s, \"%s: (\", trace_probe_name(tp));\n\n\tif (!seq_print_ip_sym(s, field->ret_ip, flags | TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_puts(s, \" <- \");\n\n\tif (!seq_print_ip_sym(s, field->func, flags & ~TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_putc(s, ')');\n\n\tif (print_probe_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n\n out:\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_probe_args",
          "args": [
            "s",
            "tp->args",
            "tp->nr_args",
            "(u8 *)&field[1]",
            "field"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "print_probe_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "216-242",
          "snippet": "static inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_print_ip_sym",
          "args": [
            "s",
            "field->func",
            "flags & ~TRACE_ITER_SYM_OFFSET"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "seq_print_ip_sym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "416-431",
          "snippet": "int\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" <- \""
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s: (\"",
            "trace_probe_name(tp)"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "tp"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "container_of(event, struct trace_event_call, event)"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "event",
            "structtrace_event_call",
            "event"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic enum print_line_t\nprint_kretprobe_event(struct trace_iterator *iter, int flags,\n\t\t      struct trace_event *event)\n{\n\tstruct kretprobe_trace_entry_head *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct kretprobe_trace_entry_head *)iter->ent;\n\ttp = trace_probe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (WARN_ON_ONCE(!tp))\n\t\tgoto out;\n\n\ttrace_seq_printf(s, \"%s: (\", trace_probe_name(tp));\n\n\tif (!seq_print_ip_sym(s, field->ret_ip, flags | TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_puts(s, \" <- \");\n\n\tif (!seq_print_ip_sym(s, field->func, flags & ~TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_putc(s, ')');\n\n\tif (print_probe_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n\n out:\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_kprobe_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1454-1482",
    "snippet": "static enum print_line_t\nprint_kprobe_event(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct kprobe_trace_entry_head *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct kprobe_trace_entry_head *)iter->ent;\n\ttp = trace_probe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (WARN_ON_ONCE(!tp))\n\t\tgoto out;\n\n\ttrace_seq_printf(s, \"%s: (\", trace_probe_name(tp));\n\n\tif (!seq_print_ip_sym(s, field->ip, flags | TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_putc(s, ')');\n\n\tif (print_probe_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n out:\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_probe_args",
          "args": [
            "s",
            "tp->args",
            "tp->nr_args",
            "(u8 *)&field[1]",
            "field"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "print_probe_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "216-242",
          "snippet": "static inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_print_ip_sym",
          "args": [
            "s",
            "field->ip",
            "flags | TRACE_ITER_SYM_OFFSET"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "seq_print_ip_sym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "416-431",
          "snippet": "int\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s: (\"",
            "trace_probe_name(tp)"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "tp"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "container_of(event, struct trace_event_call, event)"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "event",
            "structtrace_event_call",
            "event"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic enum print_line_t\nprint_kprobe_event(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct kprobe_trace_entry_head *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct kprobe_trace_entry_head *)iter->ent;\n\ttp = trace_probe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (WARN_ON_ONCE(!tp))\n\t\tgoto out;\n\n\ttrace_seq_printf(s, \"%s: (\", trace_probe_name(tp));\n\n\tif (!seq_print_ip_sym(s, field->ip, flags | TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_putc(s, ')');\n\n\tif (print_probe_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n out:\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "kretprobe_trace_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1442-1450",
    "snippet": "static void\nkretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t     struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link_rcu(link, &tk->tp)\n\t\t__kretprobe_trace_func(tk, ri, regs, link->file);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kretprobe_trace_func",
          "args": [
            "tk",
            "ri",
            "regs",
            "link->file"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "__kretprobe_trace_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1411-1440",
          "snippet": "static nokprobe_inline void\n__kretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t       struct pt_regs *regs,\n\t\t       struct trace_event_file *trace_file)\n{\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tint dsize;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + tk->tp.size + dsize);\n\tif (!entry)\n\t\treturn;\n\n\tfbuffer.regs = regs;\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline void\n__kretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t       struct pt_regs *regs,\n\t\t       struct trace_event_file *trace_file)\n{\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tint dsize;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + tk->tp.size + dsize);\n\tif (!entry)\n\t\treturn;\n\n\tfbuffer.regs = regs;\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_for_each_link_rcu",
          "args": [
            "link",
            "&tk->tp"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t     struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link_rcu(link, &tk->tp)\n\t\t__kretprobe_trace_func(tk, ri, regs, link->file);\n}"
  },
  {
    "function_name": "__kretprobe_trace_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1411-1440",
    "snippet": "static nokprobe_inline void\n__kretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t       struct pt_regs *regs,\n\t\t       struct trace_event_file *trace_file)\n{\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tint dsize;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + tk->tp.size + dsize);\n\tif (!entry)\n\t\treturn;\n\n\tfbuffer.regs = regs;\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_event_buffer_commit",
          "args": [
            "&fbuffer"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2893-2915",
          "snippet": "void trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);",
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);\nstatic __always_inline struct;\n\nvoid trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "&entry[1]",
            "&tk->tp",
            "regs",
            "sizeof(*entry)",
            "dsize"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "190-214",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "fbuffer.event"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_reserve",
          "args": [
            "&fbuffer",
            "trace_file",
            "sizeof(*entry) + tk->tp.size + dsize"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "462-491",
          "snippet": "void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nvoid *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tk->tp",
            "regs"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "171-187",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "call != trace_file->event_call"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline void\n__kretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\n\t\t       struct pt_regs *regs,\n\t\t       struct trace_event_file *trace_file)\n{\n\tstruct kretprobe_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tint dsize;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + tk->tp.size + dsize);\n\tif (!entry)\n\t\treturn;\n\n\tfbuffer.regs = regs;\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tentry->func = (unsigned long)tk->rp.kp.addr;\n\tentry->ret_ip = (unsigned long)ri->ret_addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}"
  },
  {
    "function_name": "kprobe_trace_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1400-1407",
    "snippet": "static void\nkprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link_rcu(link, &tk->tp)\n\t\t__kprobe_trace_func(tk, regs, link->file);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kprobe_trace_func",
          "args": [
            "tk",
            "regs",
            "link->file"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "__kprobe_trace_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1371-1398",
          "snippet": "void\n__kprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs,\n\t\t    struct trace_event_file *trace_file)\n{\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct trace_event_buffer fbuffer;\n\tint dsize;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + tk->tp.size + dsize);\n\tif (!entry)\n\t\treturn;\n\n\tfbuffer.regs = regs;\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
            "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nvoid\n__kprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs,\n\t\t    struct trace_event_file *trace_file)\n{\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct trace_event_buffer fbuffer;\n\tint dsize;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + tk->tp.size + dsize);\n\tif (!entry)\n\t\treturn;\n\n\tfbuffer.regs = regs;\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_for_each_link_rcu",
          "args": [
            "link",
            "&tk->tp"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic void\nkprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link_rcu(link, &tk->tp)\n\t\t__kprobe_trace_func(tk, regs, link->file);\n}"
  },
  {
    "function_name": "__kprobe_trace_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1371-1398",
    "snippet": "void\n__kprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs,\n\t\t    struct trace_event_file *trace_file)\n{\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct trace_event_buffer fbuffer;\n\tint dsize;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + tk->tp.size + dsize);\n\tif (!entry)\n\t\treturn;\n\n\tfbuffer.regs = regs;\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_event_buffer_commit",
          "args": [
            "&fbuffer"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2893-2915",
          "snippet": "void trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);",
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);\nstatic __always_inline struct;\n\nvoid trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "&entry[1]",
            "&tk->tp",
            "regs",
            "sizeof(*entry)",
            "dsize"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "190-214",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "fbuffer.event"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_reserve",
          "args": [
            "&fbuffer",
            "trace_file",
            "sizeof(*entry) + tk->tp.size + dsize"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "462-491",
          "snippet": "void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nvoid *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_data_size",
          "args": [
            "&tk->tp",
            "regs"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "__get_data_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "171-187",
          "snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "call != trace_file->event_call"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nvoid\n__kprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs,\n\t\t    struct trace_event_file *trace_file)\n{\n\tstruct kprobe_trace_entry_head *entry;\n\tstruct trace_event_call *call = trace_probe_event_call(&tk->tp);\n\tstruct trace_event_buffer fbuffer;\n\tint dsize;\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tdsize = __get_data_size(&tk->tp, regs);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + tk->tp.size + dsize);\n\tif (!entry)\n\t\treturn;\n\n\tfbuffer.regs = regs;\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tentry->ip = (unsigned long)tk->rp.kp.addr;\n\tstore_trace_args(&entry[1], &tk->tp, regs, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}"
  },
  {
    "function_name": "process_fetch_insn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1322-1367",
    "snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec, void *dest,\n\t\t   void *base)\n{\n\tstruct pt_regs *regs = rec;\n\tunsigned long val;\n\nretry:\n\t/* 1st stage: get value from context */\n\tswitch (code->op) {\n\tcase FETCH_OP_REG:\n\t\tval = regs_get_register(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACK:\n\t\tval = regs_get_kernel_stack_nth(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACKP:\n\t\tval = kernel_stack_pointer(regs);\n\t\tbreak;\n\tcase FETCH_OP_RETVAL:\n\t\tval = regs_return_value(regs);\n\t\tbreak;\n\tcase FETCH_OP_IMM:\n\t\tval = code->immediate;\n\t\tbreak;\n\tcase FETCH_OP_COMM:\n\t\tval = (unsigned long)current->comm;\n\t\tbreak;\n\tcase FETCH_OP_DATA:\n\t\tval = (unsigned long)code->data;\n\t\tbreak;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\tcase FETCH_OP_ARG:\n\t\tval = regs_get_kernel_argument(regs, code->param);\n\t\tbreak;\n#endif\n\tcase FETCH_NOP_SYMBOL:\t/* Ignore a place holder */\n\t\tcode++;\n\t\tgoto retry;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\treturn process_fetch_insn_bottom(code, val, dest, base);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);",
      "static int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_fetch_insn_bottom",
          "args": [
            "code",
            "val",
            "dest",
            "base"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "process_fetch_insn_bottom",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "71-168",
          "snippet": "static nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regs_get_kernel_argument",
          "args": [
            "regs",
            "code->param"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regs_return_value",
          "args": [
            "regs"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_stack_pointer",
          "args": [
            "regs"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regs_get_kernel_stack_nth",
          "args": [
            "regs",
            "code->param"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regs_get_register",
          "args": [
            "regs",
            "code->param"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs);\nstatic int kretprobe_dispatcher(struct kretprobe_instance *ri,\n\t\t\t\tstruct pt_regs *regs);\n\nstatic int\nprocess_fetch_insn(struct fetch_insn *code, void *rec, void *dest,\n\t\t   void *base)\n{\n\tstruct pt_regs *regs = rec;\n\tunsigned long val;\n\nretry:\n\t/* 1st stage: get value from context */\n\tswitch (code->op) {\n\tcase FETCH_OP_REG:\n\t\tval = regs_get_register(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACK:\n\t\tval = regs_get_kernel_stack_nth(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACKP:\n\t\tval = kernel_stack_pointer(regs);\n\t\tbreak;\n\tcase FETCH_OP_RETVAL:\n\t\tval = regs_return_value(regs);\n\t\tbreak;\n\tcase FETCH_OP_IMM:\n\t\tval = code->immediate;\n\t\tbreak;\n\tcase FETCH_OP_COMM:\n\t\tval = (unsigned long)current->comm;\n\t\tbreak;\n\tcase FETCH_OP_DATA:\n\t\tval = (unsigned long)code->data;\n\t\tbreak;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\tcase FETCH_OP_ARG:\n\t\tval = regs_get_kernel_argument(regs, code->param);\n\t\tbreak;\n#endif\n\tcase FETCH_NOP_SYMBOL:\t/* Ignore a place holder */\n\t\tcode++;\n\t\tgoto retry;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\treturn process_fetch_insn_bottom(code, val, dest, base);\n}"
  },
  {
    "function_name": "probe_mem_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1311-1319",
    "snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)src < TASK_SIZE)\n\t\treturn probe_mem_read_user(dest, src, size);\n#endif\n\treturn copy_from_kernel_nofault(dest, src, size);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "dest",
            "src",
            "size"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_mem_read_user",
          "args": [
            "dest",
            "src",
            "size"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "probe_mem_read_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1303-1309",
          "snippet": "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\tconst void __user *uaddr =  (__force const void __user *)src;\n\n\treturn copy_from_user_nofault(dest, uaddr, size);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\tconst void __user *uaddr =  (__force const void __user *)src;\n\n\treturn copy_from_user_nofault(dest, uaddr, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)src < TASK_SIZE)\n\t\treturn probe_mem_read_user(dest, src, size);\n#endif\n\treturn copy_from_kernel_nofault(dest, src, size);\n}"
  },
  {
    "function_name": "probe_mem_read_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1303-1309",
    "snippet": "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\tconst void __user *uaddr =  (__force const void __user *)src;\n\n\treturn copy_from_user_nofault(dest, uaddr, size);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user_nofault",
          "args": [
            "dest",
            "uaddr",
            "size"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\tconst void __user *uaddr =  (__force const void __user *)src;\n\n\treturn copy_from_user_nofault(dest, uaddr, size);\n}"
  },
  {
    "function_name": "fetch_store_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1275-1301",
    "snippet": "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)addr < TASK_SIZE)\n\t\treturn fetch_store_string_user(addr, dest, base);\n#endif\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\t/*\n\t * Try to get string again, since the string can be changed while\n\t * probing.\n\t */\n\tret = strncpy_from_kernel_nofault(__dest, (void *)addr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_data_loc",
          "args": [
            "ret",
            "__dest - base"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_kernel_nofault",
          "args": [
            "__dest",
            "(void *)addr",
            "maxlen"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_loc_data",
          "args": [
            "dest",
            "base"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "get_loc_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "65-68",
          "snippet": "static nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!maxlen"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_store_string_user",
          "args": [
            "addr",
            "dest",
            "base"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_string_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1251-1269",
          "snippet": "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\tret = strncpy_from_user_nofault(__dest, uaddr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\tret = strncpy_from_user_nofault(__dest, uaddr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_loc_len",
          "args": [
            "*(u32 *)dest"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)addr < TASK_SIZE)\n\t\treturn fetch_store_string_user(addr, dest, base);\n#endif\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\t/*\n\t * Try to get string again, since the string can be changed while\n\t * probing.\n\t */\n\tret = strncpy_from_kernel_nofault(__dest, (void *)addr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fetch_store_string_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1251-1269",
    "snippet": "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\tret = strncpy_from_user_nofault(__dest, uaddr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_data_loc",
          "args": [
            "ret",
            "__dest - base"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_user_nofault",
          "args": [
            "__dest",
            "uaddr",
            "maxlen"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_loc_data",
          "args": [
            "dest",
            "base"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "get_loc_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "65-68",
          "snippet": "static nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!maxlen"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_loc_len",
          "args": [
            "*(u32 *)dest"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\tret = strncpy_from_user_nofault(__dest, uaddr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fetch_store_strlen",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1228-1245",
    "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "&c",
            "(u8 *)addr + len",
            "1"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_store_strlen_user",
          "args": [
            "addr"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1219-1225",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\n\treturn strnlen_user_nofault(uaddr, MAX_STRING_SIZE);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\n\treturn strnlen_user_nofault(uaddr, MAX_STRING_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
  },
  {
    "function_name": "fetch_store_strlen_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1219-1225",
    "snippet": "static nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\n\treturn strnlen_user_nofault(uaddr, MAX_STRING_SIZE);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strnlen_user_nofault",
          "args": [
            "uaddr",
            "MAX_STRING_SIZE"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\n\treturn strnlen_user_nofault(uaddr, MAX_STRING_SIZE);\n}"
  },
  {
    "function_name": "profile_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1197-1206",
    "snippet": "static int profile_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(file, &profile_seq_op);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static const struct seq_operations profile_seq_op = {\n\t.start  = dyn_event_seq_start,\n\t.next   = dyn_event_seq_next,\n\t.stop   = dyn_event_seq_stop,\n\t.show   = probes_profile_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&profile_seq_op"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic const struct seq_operations profile_seq_op = {\n\t.start  = dyn_event_seq_start,\n\t.next   = dyn_event_seq_next,\n\t.stop   = dyn_event_seq_stop,\n\t.show   = probes_profile_seq_show\n};\n\nstatic int profile_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(file, &profile_seq_op);\n}"
  },
  {
    "function_name": "probes_profile_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1170-1188",
    "snippet": "static int probes_profile_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\tstruct trace_kprobe *tk;\n\tunsigned long nmissed;\n\n\tif (!is_trace_kprobe(ev))\n\t\treturn 0;\n\n\ttk = to_trace_kprobe(ev);\n\tnmissed = trace_kprobe_is_return(tk) ?\n\t\ttk->rp.kp.nmissed + tk->rp.nmissed : tk->rp.kp.nmissed;\n\tseq_printf(m, \"  %-44s %15lu %15lu\\n\",\n\t\t   trace_probe_name(&tk->tp),\n\t\t   trace_kprobe_nhit(tk),\n\t\t   nmissed);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_kprobe_release(struct dyn_event *ev);",
      "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"  %-44s %15lu %15lu\\n\"",
            "trace_probe_name(&tk->tp)",
            "trace_kprobe_nhit(tk)",
            "nmissed"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_nhit",
          "args": [
            "tk"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_nhit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "171-180",
          "snippet": "static nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tk->tp"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-87",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_kprobe",
          "args": [
            "ev"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "70-73",
          "snippet": "static struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_kprobe_release(struct dyn_event *ev);",
            "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_trace_kprobe",
          "args": [
            "ev"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "is_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "65-68",
          "snippet": "static bool is_trace_kprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_kprobe_ops;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_kprobe_release(struct dyn_event *ev);",
            "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\nstatic nokprobe_inline struct;\n\nstatic bool is_trace_kprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_kprobe_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\tstruct trace_kprobe *tk;\n\tunsigned long nmissed;\n\n\tif (!is_trace_kprobe(ev))\n\t\treturn 0;\n\n\ttk = to_trace_kprobe(ev);\n\tnmissed = trace_kprobe_is_return(tk) ?\n\t\ttk->rp.kp.nmissed + tk->rp.nmissed : tk->rp.kp.nmissed;\n\tseq_printf(m, \"  %-44s %15lu %15lu\\n\",\n\t\t   trace_probe_name(&tk->tp),\n\t\t   trace_kprobe_nhit(tk),\n\t\t   nmissed);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "probes_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1153-1158",
    "snippet": "static ssize_t probes_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_or_delete_trace_kprobe);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parse_run_command",
          "args": [
            "file",
            "buffer",
            "count",
            "ppos",
            "create_or_delete_trace_kprobe"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parse_run_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9922-9985",
          "snippet": "ssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(const char *))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = createfn(buf);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define WRITE_BUFSIZE  4096"
          ],
          "globals_used": [
            "int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define WRITE_BUFSIZE  4096\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(const char *))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = createfn(buf);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_or_delete_trace_kprobe);\n}"
  },
  {
    "function_name": "probes_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1136-1151",
    "snippet": "static int probes_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = dyn_events_release_all(&trace_kprobe_ops);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &probes_seq_op);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};",
      "static nokprobe_inline struct",
      "static const struct seq_operations probes_seq_op = {\n\t.start  = dyn_event_seq_start,\n\t.next   = dyn_event_seq_next,\n\t.stop   = dyn_event_seq_stop,\n\t.show   = probes_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&probes_seq_op"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_events_release_all",
          "args": [
            "&trace_kprobe_ops"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_events_release_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "195-220",
          "snippet": "int dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\nstatic nokprobe_inline struct;\nstatic const struct seq_operations probes_seq_op = {\n\t.start  = dyn_event_seq_start,\n\t.next   = dyn_event_seq_next,\n\t.stop   = dyn_event_seq_stop,\n\t.show   = probes_seq_show\n};\n\nstatic int probes_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = dyn_events_release_all(&trace_kprobe_ops);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &probes_seq_op);\n}"
  },
  {
    "function_name": "probes_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1119-1127",
    "snippet": "static int probes_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\n\tif (!is_trace_kprobe(ev))\n\t\treturn 0;\n\n\treturn trace_kprobe_show(m, ev);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_kprobe_release(struct dyn_event *ev);",
      "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kprobe_show",
          "args": [
            "m",
            "ev"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1093-1117",
          "snippet": "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_kprobe *tk = to_trace_kprobe(ev);\n\tint i;\n\n\tseq_putc(m, trace_kprobe_is_return(tk) ? 'r' : 'p');\n\tif (trace_kprobe_is_return(tk) && tk->rp.maxactive)\n\t\tseq_printf(m, \"%d\", tk->rp.maxactive);\n\tseq_printf(m, \":%s/%s\", trace_probe_group_name(&tk->tp),\n\t\t\t\ttrace_probe_name(&tk->tp));\n\n\tif (!tk->symbol)\n\t\tseq_printf(m, \" 0x%p\", tk->rp.kp.addr);\n\telse if (tk->rp.kp.offset)\n\t\tseq_printf(m, \" %s+%u\", trace_kprobe_symbol(tk),\n\t\t\t   tk->rp.kp.offset);\n\telse\n\t\tseq_printf(m, \" %s\", trace_kprobe_symbol(tk));\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tk->tp.args[i].name, tk->tp.args[i].comm);\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_kprobe_release(struct dyn_event *ev);",
            "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_kprobe *tk = to_trace_kprobe(ev);\n\tint i;\n\n\tseq_putc(m, trace_kprobe_is_return(tk) ? 'r' : 'p');\n\tif (trace_kprobe_is_return(tk) && tk->rp.maxactive)\n\t\tseq_printf(m, \"%d\", tk->rp.maxactive);\n\tseq_printf(m, \":%s/%s\", trace_probe_group_name(&tk->tp),\n\t\t\t\ttrace_probe_name(&tk->tp));\n\n\tif (!tk->symbol)\n\t\tseq_printf(m, \" 0x%p\", tk->rp.kp.addr);\n\telse if (tk->rp.kp.offset)\n\t\tseq_printf(m, \" %s+%u\", trace_kprobe_symbol(tk),\n\t\t\t   tk->rp.kp.offset);\n\telse\n\t\tseq_printf(m, \" %s\", trace_kprobe_symbol(tk));\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tk->tp.args[i].name, tk->tp.args[i].comm);\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_trace_kprobe",
          "args": [
            "ev"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "is_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "65-68",
          "snippet": "static bool is_trace_kprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_kprobe_ops;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_kprobe_release(struct dyn_event *ev);",
            "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\nstatic nokprobe_inline struct;\n\nstatic bool is_trace_kprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_kprobe_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic int probes_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\n\tif (!is_trace_kprobe(ev))\n\t\treturn 0;\n\n\treturn trace_kprobe_show(m, ev);\n}"
  },
  {
    "function_name": "trace_kprobe_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1093-1117",
    "snippet": "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_kprobe *tk = to_trace_kprobe(ev);\n\tint i;\n\n\tseq_putc(m, trace_kprobe_is_return(tk) ? 'r' : 'p');\n\tif (trace_kprobe_is_return(tk) && tk->rp.maxactive)\n\t\tseq_printf(m, \"%d\", tk->rp.maxactive);\n\tseq_printf(m, \":%s/%s\", trace_probe_group_name(&tk->tp),\n\t\t\t\ttrace_probe_name(&tk->tp));\n\n\tif (!tk->symbol)\n\t\tseq_printf(m, \" 0x%p\", tk->rp.kp.addr);\n\telse if (tk->rp.kp.offset)\n\t\tseq_printf(m, \" %s+%u\", trace_kprobe_symbol(tk),\n\t\t\t   tk->rp.kp.offset);\n\telse\n\t\tseq_printf(m, \" %s\", trace_kprobe_symbol(tk));\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tk->tp.args[i].name, tk->tp.args[i].comm);\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_kprobe_release(struct dyn_event *ev);",
      "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %s=%s\"",
            "tk->tp.args[i].name",
            "tk->tp.args[i].comm"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_symbol",
          "args": [
            "tk"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "89-92",
          "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tk->tp"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_group_name",
          "args": [
            "&tk->tp"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_group_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "284-287",
          "snippet": "static inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-87",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_kprobe",
          "args": [
            "ev"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "70-73",
          "snippet": "static struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_kprobe_release(struct dyn_event *ev);",
            "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_kprobe *tk = to_trace_kprobe(ev);\n\tint i;\n\n\tseq_putc(m, trace_kprobe_is_return(tk) ? 'r' : 'p');\n\tif (trace_kprobe_is_return(tk) && tk->rp.maxactive)\n\t\tseq_printf(m, \"%d\", tk->rp.maxactive);\n\tseq_printf(m, \":%s/%s\", trace_probe_group_name(&tk->tp),\n\t\t\t\ttrace_probe_name(&tk->tp));\n\n\tif (!tk->symbol)\n\t\tseq_printf(m, \" 0x%p\", tk->rp.kp.addr);\n\telse if (tk->rp.kp.offset)\n\t\tseq_printf(m, \" %s+%u\", trace_kprobe_symbol(tk),\n\t\t\t   tk->rp.kp.offset);\n\telse\n\t\tseq_printf(m, \" %s\", trace_kprobe_symbol(tk));\n\n\tfor (i = 0; i < tk->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tk->tp.args[i].name, tk->tp.args[i].comm);\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_kprobe_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1083-1091",
    "snippet": "static int trace_kprobe_release(struct dyn_event *ev)\n{\n\tstruct trace_kprobe *tk = to_trace_kprobe(ev);\n\tint ret = unregister_trace_kprobe(tk);\n\n\tif (!ret)\n\t\tfree_trace_kprobe(tk);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_kprobe_release(struct dyn_event *ev);",
      "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "241-249",
          "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "530-554",
          "snippet": "static int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* If other probes are on the event, just unregister kprobe */\n\tif (trace_probe_has_sibling(&tk->tp))\n\t\tgoto unreg;\n\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* If there's a reference to the dynamic event */\n\tif (trace_event_dyn_busy(trace_probe_event_call(&tk->tp)))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\nunreg:\n\t__unregister_trace_kprobe(tk);\n\tdyn_event_remove(&tk->devent);\n\ttrace_probe_unlink(&tk->tp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* If other probes are on the event, just unregister kprobe */\n\tif (trace_probe_has_sibling(&tk->tp))\n\t\tgoto unreg;\n\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* If there's a reference to the dynamic event */\n\tif (trace_event_dyn_busy(trace_probe_event_call(&tk->tp)))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\nunreg:\n\t__unregister_trace_kprobe(tk);\n\tdyn_event_remove(&tk->devent);\n\ttrace_probe_unlink(&tk->tp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_kprobe",
          "args": [
            "ev"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "70-73",
          "snippet": "static struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_kprobe_release(struct dyn_event *ev);",
            "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int trace_kprobe_release(struct dyn_event *ev)\n{\n\tstruct trace_kprobe *tk = to_trace_kprobe(ev);\n\tint ret = unregister_trace_kprobe(tk);\n\n\tif (!ret)\n\t\tfree_trace_kprobe(tk);\n\treturn ret;\n}"
  },
  {
    "function_name": "kprobe_event_delete",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1073-1080",
    "snippet": "int kprobe_event_delete(const char *name)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\n\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"-:%s\", name);\n\n\treturn create_or_delete_trace_kprobe(buf);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_or_delete_trace_kprobe",
          "args": [
            "buf"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "create_or_delete_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "905-914",
          "snippet": "static int create_or_delete_trace_kprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_kprobe_ops);\n\n\tret = trace_kprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_create(const char *raw_command);",
            "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_create(const char *raw_command);\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\n\nstatic int create_or_delete_trace_kprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_kprobe_ops);\n\n\tret = trace_kprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "MAX_EVENT_NAME_LEN",
            "\"-:%s\"",
            "name"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nint kprobe_event_delete(const char *name)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\n\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"-:%s\", name);\n\n\treturn create_or_delete_trace_kprobe(buf);\n}"
  },
  {
    "function_name": "__kprobe_event_add_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "1029-1061",
    "snippet": "int __kprobe_event_add_fields(struct dynevent_cmd *cmd, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret = 0;\n\n\tif (cmd->type != DYNEVENT_TYPE_KPROBE)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\n\tva_start(args, cmd);\n\tfor (;;) {\n\t\tconst char *field;\n\n\t\tfield = va_arg(args, const char *);\n\t\tif (!field)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > MAX_TRACE_ARGS) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\targ.str = field;\n\t\tret = dynevent_arg_add(cmd, &arg, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynevent_arg_add",
          "args": [
            "cmd",
            "&arg",
            "NULL"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "294-313",
          "snippet": "int dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "constchar *"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "cmd"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynevent_arg_init",
          "args": [
            "&arg",
            "0"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "430-438",
          "snippet": "void dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nint __kprobe_event_add_fields(struct dynevent_cmd *cmd, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret = 0;\n\n\tif (cmd->type != DYNEVENT_TYPE_KPROBE)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\n\tva_start(args, cmd);\n\tfor (;;) {\n\t\tconst char *field;\n\n\t\tfield = va_arg(args, const char *);\n\t\tif (!field)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > MAX_TRACE_ARGS) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\targ.str = field;\n\t\tret = dynevent_arg_add(cmd, &arg, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__kprobe_event_gen_cmd_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "960-1010",
    "snippet": "int __kprobe_event_gen_cmd_start(struct dynevent_cmd *cmd, bool kretprobe,\n\t\t\t\t const char *name, const char *loc, ...)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_KPROBE)\n\t\treturn -EINVAL;\n\n\tif (!loc)\n\t\treturn -EINVAL;\n\n\tif (kretprobe)\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"r:kprobes/%s\", name);\n\telse\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"p:kprobes/%s\", name);\n\n\tret = dynevent_str_add(cmd, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = loc;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, loc);\n\tfor (;;) {\n\t\tconst char *field;\n\n\t\tfield = va_arg(args, const char *);\n\t\tif (!field)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > MAX_TRACE_ARGS) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\targ.str = field;\n\t\tret = dynevent_arg_add(cmd, &arg, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynevent_arg_add",
          "args": [
            "cmd",
            "&arg",
            "NULL"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "294-313",
          "snippet": "int dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "constchar *"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "loc"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynevent_arg_init",
          "args": [
            "&arg",
            "0"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "430-438",
          "snippet": "void dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynevent_str_add",
          "args": [
            "cmd",
            "buf"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_str_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "374-385",
          "snippet": "int dynevent_str_add(struct dynevent_cmd *cmd, const char *str)\n{\n\tint ret = 0;\n\n\tret = seq_buf_puts(&cmd->seq, str);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s\\n\", str);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dynevent_str_add(struct dynevent_cmd *cmd, const char *str)\n{\n\tint ret = 0;\n\n\tret = seq_buf_puts(&cmd->seq, str);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s\\n\", str);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "MAX_EVENT_NAME_LEN",
            "\"p:kprobes/%s\"",
            "name"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "MAX_EVENT_NAME_LEN",
            "\"r:kprobes/%s\"",
            "name"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nint __kprobe_event_gen_cmd_start(struct dynevent_cmd *cmd, bool kretprobe,\n\t\t\t\t const char *name, const char *loc, ...)\n{\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_KPROBE)\n\t\treturn -EINVAL;\n\n\tif (!loc)\n\t\treturn -EINVAL;\n\n\tif (kretprobe)\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"r:kprobes/%s\", name);\n\telse\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"p:kprobes/%s\", name);\n\n\tret = dynevent_str_add(cmd, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = loc;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, loc);\n\tfor (;;) {\n\t\tconst char *field;\n\n\t\tfield = va_arg(args, const char *);\n\t\tif (!field)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > MAX_TRACE_ARGS) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\targ.str = field;\n\t\tret = dynevent_arg_add(cmd, &arg, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kprobe_event_cmd_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "930-934",
    "snippet": "void kprobe_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_KPROBE,\n\t\t\t  trace_kprobe_run_command);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dynevent_cmd_init",
          "args": [
            "cmd",
            "buf",
            "maxlen",
            "DYNEVENT_TYPE_KPROBE",
            "trace_kprobe_run_command"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_cmd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "407-416",
          "snippet": "void dynevent_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen,\n\t\t       enum dynevent_type type,\n\t\t       dynevent_create_fn_t run_command)\n{\n\tmemset(cmd, '\\0', sizeof(*cmd));\n\n\tseq_buf_init(&cmd->seq, buf, maxlen);\n\tcmd->type = type;\n\tcmd->run_command = run_command;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dynevent_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen,\n\t\t       enum dynevent_type type,\n\t\t       dynevent_create_fn_t run_command)\n{\n\tmemset(cmd, '\\0', sizeof(*cmd));\n\n\tseq_buf_init(&cmd->seq, buf, maxlen);\n\tcmd->type = type;\n\tcmd->run_command = run_command;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nvoid kprobe_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_KPROBE,\n\t\t\t  trace_kprobe_run_command);\n}"
  },
  {
    "function_name": "trace_kprobe_run_command",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "916-919",
    "snippet": "static int trace_kprobe_run_command(struct dynevent_cmd *cmd)\n{\n\treturn create_or_delete_trace_kprobe(cmd->seq.buffer);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_or_delete_trace_kprobe",
          "args": [
            "cmd->seq.buffer"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "create_or_delete_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "905-914",
          "snippet": "static int create_or_delete_trace_kprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_kprobe_ops);\n\n\tret = trace_kprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_create(const char *raw_command);",
            "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_create(const char *raw_command);\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\n\nstatic int create_or_delete_trace_kprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_kprobe_ops);\n\n\tret = trace_kprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic int trace_kprobe_run_command(struct dynevent_cmd *cmd)\n{\n\treturn create_or_delete_trace_kprobe(cmd->seq.buffer);\n}"
  },
  {
    "function_name": "create_or_delete_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "905-914",
    "snippet": "static int create_or_delete_trace_kprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_kprobe_ops);\n\n\tret = trace_kprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_kprobe_create(const char *raw_command);",
      "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kprobe_create",
          "args": [
            "raw_command"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "900-903",
          "snippet": "static int trace_kprobe_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_kprobe_create);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_create(const char *raw_command);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_create(const char *raw_command);\n\nstatic int trace_kprobe_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_kprobe_create);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_release",
          "args": [
            "raw_command",
            "&trace_kprobe_ops"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "72-125",
          "snippet": "int dyn_event_release(const char *raw_command, struct dyn_event_operations *type)\n{\n\tstruct dyn_event *pos, *n;\n\tchar *system = NULL, *event, *p;\n\tint argc, ret = -ENOENT;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argv[0][0] == '-') {\n\t\tif (argv[0][1] != ':') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent = &argv[0][2];\n\t} else {\n\t\tevent = strchr(argv[0], ':');\n\t\tif (!event) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent++;\n\t}\n\n\tp = strchr(event, '/');\n\tif (p) {\n\t\tsystem = event;\n\t\tevent = p + 1;\n\t\t*p = '\\0';\n\t}\n\tif (event[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event_safe(pos, n) {\n\t\tif (type && type != pos->ops)\n\t\t\tcontinue;\n\t\tif (!pos->ops->match(system, event,\n\t\t\t\targc - 1, (const char **)argv + 1, pos))\n\t\t\tcontinue;\n\n\t\tret = pos->ops->free(pos);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\nout:\n\targv_free(argv);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dyn_event_release(const char *raw_command, struct dyn_event_operations *type)\n{\n\tstruct dyn_event *pos, *n;\n\tchar *system = NULL, *event, *p;\n\tint argc, ret = -ENOENT;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argv[0][0] == '-') {\n\t\tif (argv[0][1] != ':') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent = &argv[0][2];\n\t} else {\n\t\tevent = strchr(argv[0], ':');\n\t\tif (!event) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent++;\n\t}\n\n\tp = strchr(event, '/');\n\tif (p) {\n\t\tsystem = event;\n\t\tevent = p + 1;\n\t\t*p = '\\0';\n\t}\n\tif (event[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event_safe(pos, n) {\n\t\tif (type && type != pos->ops)\n\t\t\tcontinue;\n\t\tif (!pos->ops->match(system, event,\n\t\t\t\targc - 1, (const char **)argv + 1, pos))\n\t\t\tcontinue;\n\n\t\tret = pos->ops->free(pos);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\nout:\n\targv_free(argv);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_create(const char *raw_command);\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\n\nstatic int create_or_delete_trace_kprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_kprobe_ops);\n\n\tret = trace_kprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}"
  },
  {
    "function_name": "trace_kprobe_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "900-903",
    "snippet": "static int trace_kprobe_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_kprobe_create);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_kprobe_create(const char *raw_command);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_create",
          "args": [
            "raw_command",
            "__trace_kprobe_create"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1194-1209",
          "snippet": "int trace_probe_create(const char *raw_command, int (*createfn)(int, const char **))\n{\n\tint argc = 0, ret = 0;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, (const char **)argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_create(const char *raw_command, int (*createfn)(int, const char **))\n{\n\tint argc = 0, ret = 0;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, (const char **)argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_create(const char *raw_command);\n\nstatic int trace_kprobe_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_kprobe_create);\n}"
  },
  {
    "function_name": "__trace_kprobe_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "706-898",
    "snippet": "static int __trace_kprobe_create(int argc, const char *argv[])\n{\n\t/*\n\t * Argument syntax:\n\t *  - Add kprobe:\n\t *      p[:[GRP/]EVENT] [MOD:]KSYM[+OFFS]|KADDR [FETCHARGS]\n\t *  - Add kretprobe:\n\t *      r[MAXACTIVE][:[GRP/]EVENT] [MOD:]KSYM[+0] [FETCHARGS]\n\t *    Or\n\t *      p:[GRP/]EVENT] [MOD:]KSYM[+0]%return [FETCHARGS]\n\t *\n\t * Fetch args:\n\t *  $retval\t: fetch return value\n\t *  $stack\t: fetch stack address\n\t *  $stackN\t: fetch Nth of stack (N:0-)\n\t *  $comm       : fetch current task comm\n\t *  @ADDR\t: fetch memory at ADDR (ADDR should be in kernel)\n\t *  @SYM[+|-offs] : fetch memory at SYM +|- offs (SYM is a data symbol)\n\t *  %REG\t: fetch register REG\n\t * Dereferencing memory fetch:\n\t *  +|-offs(ARG) : fetch memory at ARG +|- offs address.\n\t * Alias name of args:\n\t *  NAME=FETCHARG : set NAME as alias of FETCHARG.\n\t * Type of args:\n\t *  FETCHARG:TYPE : use TYPE instead of unsigned long.\n\t */\n\tstruct trace_kprobe *tk = NULL;\n\tint i, len, ret = 0;\n\tbool is_return = false;\n\tchar *symbol = NULL, *tmp = NULL;\n\tconst char *event = NULL, *group = KPROBE_EVENT_SYSTEM;\n\tenum probe_print_type ptype;\n\tint maxactive = 0;\n\tlong offset = 0;\n\tvoid *addr = NULL;\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tunsigned int flags = TPARG_FL_KERNEL;\n\n\tswitch (argv[0][0]) {\n\tcase 'r':\n\t\tis_return = true;\n\t\tbreak;\n\tcase 'p':\n\t\tbreak;\n\tdefault:\n\t\treturn -ECANCELED;\n\t}\n\tif (argc < 2)\n\t\treturn -ECANCELED;\n\n\ttrace_probe_log_init(\"trace_kprobe\", argc, argv);\n\n\tevent = strchr(&argv[0][1], ':');\n\tif (event)\n\t\tevent++;\n\n\tif (isdigit(argv[0][1])) {\n\t\tif (!is_return) {\n\t\t\ttrace_probe_log_err(1, MAXACT_NO_KPROBE);\n\t\t\tgoto parse_error;\n\t\t}\n\t\tif (event)\n\t\t\tlen = event - &argv[0][1] - 1;\n\t\telse\n\t\t\tlen = strlen(&argv[0][1]);\n\t\tif (len > MAX_EVENT_NAME_LEN - 1) {\n\t\t\ttrace_probe_log_err(1, BAD_MAXACT);\n\t\t\tgoto parse_error;\n\t\t}\n\t\tmemcpy(buf, &argv[0][1], len);\n\t\tbuf[len] = '\\0';\n\t\tret = kstrtouint(buf, 0, &maxactive);\n\t\tif (ret || !maxactive) {\n\t\t\ttrace_probe_log_err(1, BAD_MAXACT);\n\t\t\tgoto parse_error;\n\t\t}\n\t\t/* kretprobes instances are iterated over via a list. The\n\t\t * maximum should stay reasonable.\n\t\t */\n\t\tif (maxactive > KRETPROBE_MAXACTIVE_MAX) {\n\t\t\ttrace_probe_log_err(1, MAXACT_TOO_BIG);\n\t\t\tgoto parse_error;\n\t\t}\n\t}\n\n\t/* try to parse an address. if that fails, try to read the\n\t * input as a symbol. */\n\tif (kstrtoul(argv[1], 0, (unsigned long *)&addr)) {\n\t\ttrace_probe_log_set_index(1);\n\t\t/* Check whether uprobe event specified */\n\t\tif (strchr(argv[1], '/') && strchr(argv[1], ':')) {\n\t\t\tret = -ECANCELED;\n\t\t\tgoto error;\n\t\t}\n\t\t/* a symbol specified */\n\t\tsymbol = kstrdup(argv[1], GFP_KERNEL);\n\t\tif (!symbol)\n\t\t\treturn -ENOMEM;\n\n\t\ttmp = strchr(symbol, '%');\n\t\tif (tmp) {\n\t\t\tif (!strcmp(tmp, \"%return\")) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tis_return = true;\n\t\t\t} else {\n\t\t\t\ttrace_probe_log_err(tmp - symbol, BAD_ADDR_SUFFIX);\n\t\t\t\tgoto parse_error;\n\t\t\t}\n\t\t}\n\n\t\t/* TODO: support .init module functions */\n\t\tret = traceprobe_split_symbol_offset(symbol, &offset);\n\t\tif (ret || offset < 0 || offset > UINT_MAX) {\n\t\t\ttrace_probe_log_err(0, BAD_PROBE_ADDR);\n\t\t\tgoto parse_error;\n\t\t}\n\t\tif (is_return)\n\t\t\tflags |= TPARG_FL_RETURN;\n\t\tret = kprobe_on_func_entry(NULL, symbol, offset);\n\t\tif (ret == 0)\n\t\t\tflags |= TPARG_FL_FENTRY;\n\t\t/* Defer the ENOENT case until register kprobe */\n\t\tif (ret == -EINVAL && is_return) {\n\t\t\ttrace_probe_log_err(0, BAD_RETPROBE);\n\t\t\tgoto parse_error;\n\t\t}\n\t}\n\n\ttrace_probe_log_set_index(0);\n\tif (event) {\n\t\tret = traceprobe_parse_event_name(&event, &group, buf,\n\t\t\t\t\t\t  event - argv[0]);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t} else {\n\t\t/* Make a new event name */\n\t\tif (symbol)\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_%s_%ld\",\n\t\t\t\t is_return ? 'r' : 'p', symbol, offset);\n\t\telse\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_0x%p\",\n\t\t\t\t is_return ? 'r' : 'p', addr);\n\t\tsanitize_event_name(buf);\n\t\tevent = buf;\n\t}\n\n\t/* setup a probe */\n\ttk = alloc_trace_kprobe(group, event, addr, symbol, offset, maxactive,\n\t\t\t       argc - 2, is_return);\n\tif (IS_ERR(tk)) {\n\t\tret = PTR_ERR(tk);\n\t\t/* This must return -ENOMEM, else there is a bug */\n\t\tWARN_ON_ONCE(ret != -ENOMEM);\n\t\tgoto out;\t/* We know tk is not allocated */\n\t}\n\targc -= 2; argv += 2;\n\n\t/* parse arguments */\n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\ttrace_probe_log_set_index(i + 2);\n\t\tret = traceprobe_parse_probe_arg(&tk->tp, i, argv[i], flags);\n\t\tif (ret)\n\t\t\tgoto error;\t/* This can be -ENOMEM */\n\t}\n\n\tptype = is_return ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tret = traceprobe_set_print_fmt(&tk->tp, ptype);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = register_trace_kprobe(tk);\n\tif (ret) {\n\t\ttrace_probe_log_set_index(1);\n\t\tif (ret == -EILSEQ)\n\t\t\ttrace_probe_log_err(0, BAD_INSN_BNDRY);\n\t\telse if (ret == -ENOENT)\n\t\t\ttrace_probe_log_err(0, BAD_PROBE_ADDR);\n\t\telse if (ret != -ENOMEM && ret != -EEXIST)\n\t\t\ttrace_probe_log_err(0, FAIL_REG_PROBE);\n\t\tgoto error;\n\t}\n\nout:\n\ttrace_probe_log_clear();\n\tkfree(symbol);\n\treturn ret;\n\nparse_error:\n\tret = -EINVAL;\nerror:\n\tfree_trace_kprobe(tk);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [
      "#define KRETPROBE_MAXACTIVE_MAX 4096",
      "#define KPROBE_EVENT_SYSTEM \"kprobes\""
    ],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "241-249",
          "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "symbol"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_clear",
          "args": [],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "153-156",
          "snippet": "void trace_probe_log_clear(void)\n{\n\tmemset(&trace_probe_log, 0, sizeof(trace_probe_log));\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_clear(void)\n{\n\tmemset(&trace_probe_log, 0, sizeof(trace_probe_log));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "0",
            "FAIL_REG_PROBE"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_set_index",
          "args": [
            "1"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_set_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "158-161",
          "snippet": "void trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "register_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "623-669",
          "snippet": "static int register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tstruct trace_kprobe *old_tk;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\told_tk = find_trace_kprobe(trace_probe_name(&tk->tp),\n\t\t\t\t   trace_probe_group_name(&tk->tp));\n\tif (old_tk) {\n\t\tif (trace_kprobe_is_return(tk) != trace_kprobe_is_return(old_tk)) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, DIFF_PROBE_TYPE);\n\t\t\tret = -EEXIST;\n\t\t} else {\n\t\t\tret = append_trace_kprobe(tk, old_tk);\n\t\t}\n\t\tgoto end;\n\t}\n\n\t/* Register new event */\n\tret = register_kprobe_event(tk);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t} else\n\t\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret < 0)\n\t\tunregister_kprobe_event(tk);\n\telse\n\t\tdyn_event_add(&tk->devent, trace_probe_event_call(&tk->tp));\n\nend:\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tstruct trace_kprobe *old_tk;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\told_tk = find_trace_kprobe(trace_probe_name(&tk->tp),\n\t\t\t\t   trace_probe_group_name(&tk->tp));\n\tif (old_tk) {\n\t\tif (trace_kprobe_is_return(tk) != trace_kprobe_is_return(old_tk)) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, DIFF_PROBE_TYPE);\n\t\t\tret = -EEXIST;\n\t\t} else {\n\t\t\tret = append_trace_kprobe(tk, old_tk);\n\t\t}\n\t\tgoto end;\n\t}\n\n\t/* Register new event */\n\tret = register_kprobe_event(tk);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t} else\n\t\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret < 0)\n\t\tunregister_kprobe_event(tk);\n\telse\n\t\tdyn_event_add(&tk->devent, trace_probe_event_call(&tk->tp));\n\nend:\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_set_print_fmt",
          "args": [
            "&tk->tp",
            "ptype"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_set_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "935-952",
          "snippet": "int traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_parse_probe_arg",
          "args": [
            "&tk->tp",
            "i",
            "argv[i]",
            "flags"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_parse_probe_arg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "770-809",
          "snippet": "int traceprobe_parse_probe_arg(struct trace_probe *tp, int i, const char *arg,\n\t\t\t\tunsigned int flags)\n{\n\tstruct probe_arg *parg = &tp->args[i];\n\tconst char *body;\n\n\t/* Increment count for freeing args in error case */\n\ttp->nr_args++;\n\n\tbody = strchr(arg, '=');\n\tif (body) {\n\t\tif (body - arg > MAX_ARG_NAME_LEN) {\n\t\t\ttrace_probe_log_err(0, ARG_NAME_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t} else if (body == arg) {\n\t\t\ttrace_probe_log_err(0, NO_ARG_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparg->name = kmemdup_nul(arg, body - arg, GFP_KERNEL);\n\t\tbody++;\n\t} else {\n\t\t/* If argument name is omitted, set \"argN\" */\n\t\tparg->name = kasprintf(GFP_KERNEL, \"arg%d\", i + 1);\n\t\tbody = arg;\n\t}\n\tif (!parg->name)\n\t\treturn -ENOMEM;\n\n\tif (!is_good_name(parg->name)) {\n\t\ttrace_probe_log_err(0, BAD_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\tif (traceprobe_conflict_field_name(parg->name, tp->args, i)) {\n\t\ttrace_probe_log_err(0, USED_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\t/* Parse fetch argument */\n\treturn traceprobe_parse_probe_arg_body(body, &tp->size, parg, flags,\n\t\t\t\t\t       body - arg);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_parse_probe_arg(struct trace_probe *tp, int i, const char *arg,\n\t\t\t\tunsigned int flags)\n{\n\tstruct probe_arg *parg = &tp->args[i];\n\tconst char *body;\n\n\t/* Increment count for freeing args in error case */\n\ttp->nr_args++;\n\n\tbody = strchr(arg, '=');\n\tif (body) {\n\t\tif (body - arg > MAX_ARG_NAME_LEN) {\n\t\t\ttrace_probe_log_err(0, ARG_NAME_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t} else if (body == arg) {\n\t\t\ttrace_probe_log_err(0, NO_ARG_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparg->name = kmemdup_nul(arg, body - arg, GFP_KERNEL);\n\t\tbody++;\n\t} else {\n\t\t/* If argument name is omitted, set \"argN\" */\n\t\tparg->name = kasprintf(GFP_KERNEL, \"arg%d\", i + 1);\n\t\tbody = arg;\n\t}\n\tif (!parg->name)\n\t\treturn -ENOMEM;\n\n\tif (!is_good_name(parg->name)) {\n\t\ttrace_probe_log_err(0, BAD_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\tif (traceprobe_conflict_field_name(parg->name, tp->args, i)) {\n\t\ttrace_probe_log_err(0, USED_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\t/* Parse fetch argument */\n\treturn traceprobe_parse_probe_arg_body(body, &tp->size, parg, flags,\n\t\t\t\t\t       body - arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret != -ENOMEM"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tk"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tk"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_trace_kprobe",
          "args": [
            "group",
            "event",
            "addr",
            "symbol",
            "offset",
            "maxactive",
            "argc - 2",
            "is_return"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "254-300",
          "snippet": "static struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(struct_size(tk, tp.args, nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\n\tret = trace_probe_init(&tk->tp, event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tk->devent, &trace_kprobe_ops);\n\treturn tk;\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};",
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(struct_size(tk, tp.args, nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\n\tret = trace_probe_init(&tk->tp, event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tk->devent, &trace_kprobe_ops);\n\treturn tk;\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitize_event_name",
          "args": [
            "buf"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_event_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1988-1993",
          "snippet": "static inline void sanitize_event_name(char *name)\n{\n\twhile (*name++ != '\\0')\n\t\tif (*name == ':' || *name == '.')\n\t\t\t*name = '_';\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void sanitize_event_name(char *name)\n{\n\twhile (*name++ != '\\0')\n\t\tif (*name == ':' || *name == '.')\n\t\t\t*name = '_';\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "MAX_EVENT_NAME_LEN",
            "\"%c_0x%p\"",
            "is_return ? 'r' : 'p'",
            "addr"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "MAX_EVENT_NAME_LEN",
            "\"%c_%s_%ld\"",
            "is_return ? 'r' : 'p'",
            "symbol",
            "offset"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5994-6013",
          "snippet": "int btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_parse_event_name",
          "args": [
            "&event",
            "&group",
            "buf",
            "event - argv[0]"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_parse_event_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "229-271",
          "snippet": "int traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset)\n{\n\tconst char *slash, *event = *pevent;\n\tint len;\n\n\tslash = strchr(event, '/');\n\tif (!slash)\n\t\tslash = strchr(event, '.');\n\n\tif (slash) {\n\t\tif (slash == event) {\n\t\t\ttrace_probe_log_err(offset, NO_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (slash - event + 1 > MAX_EVENT_NAME_LEN) {\n\t\t\ttrace_probe_log_err(offset, GROUP_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstrlcpy(buf, event, slash - event + 1);\n\t\tif (!is_good_name(buf)) {\n\t\t\ttrace_probe_log_err(offset, BAD_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pgroup = buf;\n\t\t*pevent = slash + 1;\n\t\toffset += slash - event + 1;\n\t\tevent = *pevent;\n\t}\n\tlen = strlen(event);\n\tif (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_EVENT_NAME);\n\t\treturn -EINVAL;\n\t} else if (len > MAX_EVENT_NAME_LEN) {\n\t\ttrace_probe_log_err(offset, EVENT_TOO_LONG);\n\t\treturn -EINVAL;\n\t}\n\tif (!is_good_name(event)) {\n\t\ttrace_probe_log_err(offset, BAD_EVENT_NAME);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset)\n{\n\tconst char *slash, *event = *pevent;\n\tint len;\n\n\tslash = strchr(event, '/');\n\tif (!slash)\n\t\tslash = strchr(event, '.');\n\n\tif (slash) {\n\t\tif (slash == event) {\n\t\t\ttrace_probe_log_err(offset, NO_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (slash - event + 1 > MAX_EVENT_NAME_LEN) {\n\t\t\ttrace_probe_log_err(offset, GROUP_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstrlcpy(buf, event, slash - event + 1);\n\t\tif (!is_good_name(buf)) {\n\t\t\ttrace_probe_log_err(offset, BAD_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pgroup = buf;\n\t\t*pevent = slash + 1;\n\t\toffset += slash - event + 1;\n\t\tevent = *pevent;\n\t}\n\tlen = strlen(event);\n\tif (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_EVENT_NAME);\n\t\treturn -EINVAL;\n\t} else if (len > MAX_EVENT_NAME_LEN) {\n\t\ttrace_probe_log_err(offset, EVENT_TOO_LONG);\n\t\treturn -EINVAL;\n\t}\n\tif (!is_good_name(event)) {\n\t\ttrace_probe_log_err(offset, BAD_EVENT_NAME);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_on_func_entry",
          "args": [
            "NULL",
            "symbol",
            "offset"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_on_func_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2068-2082",
          "snippet": "int kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn PTR_ERR(kp_addr);\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset))\n\t\treturn -ENOENT;\n\n\tif (!arch_kprobe_on_func_entry(offset))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn PTR_ERR(kp_addr);\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset))\n\t\treturn -ENOENT;\n\n\tif (!arch_kprobe_on_func_entry(offset))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_split_symbol_offset",
          "args": [
            "symbol",
            "&offset"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_split_symbol_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "208-226",
          "snippet": "int traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\n\nint traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tmp",
            "\"%return\""
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "symbol",
            "'%'"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "argv[1]",
            "GFP_KERNEL"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[1]",
            "':'"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[1]",
            "'/'"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "argv[1]",
            "0",
            "(unsigned long *)&addr"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "buf",
            "0",
            "&maxactive"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&argv[0][1]",
            "len"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "&argv[0][1]"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1228-1245",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "argv[0][1]"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "&argv[0][1]",
            "':'"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_log_init",
          "args": [
            "\"trace_kprobe\"",
            "argc",
            "argv"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "145-151",
          "snippet": "void trace_probe_log_init(const char *subsystem, int argc, const char **argv)\n{\n\ttrace_probe_log.subsystem = subsystem;\n\ttrace_probe_log.argc = argc;\n\ttrace_probe_log.argv = argv;\n\ttrace_probe_log.index = 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_init(const char *subsystem, int argc, const char **argv)\n{\n\ttrace_probe_log.subsystem = subsystem;\n\ttrace_probe_log.argc = argc;\n\ttrace_probe_log.argv = argv;\n\ttrace_probe_log.index = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\n#define KRETPROBE_MAXACTIVE_MAX 4096\n#define KPROBE_EVENT_SYSTEM \"kprobes\"\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int __trace_kprobe_create(int argc, const char *argv[])\n{\n\t/*\n\t * Argument syntax:\n\t *  - Add kprobe:\n\t *      p[:[GRP/]EVENT] [MOD:]KSYM[+OFFS]|KADDR [FETCHARGS]\n\t *  - Add kretprobe:\n\t *      r[MAXACTIVE][:[GRP/]EVENT] [MOD:]KSYM[+0] [FETCHARGS]\n\t *    Or\n\t *      p:[GRP/]EVENT] [MOD:]KSYM[+0]%return [FETCHARGS]\n\t *\n\t * Fetch args:\n\t *  $retval\t: fetch return value\n\t *  $stack\t: fetch stack address\n\t *  $stackN\t: fetch Nth of stack (N:0-)\n\t *  $comm       : fetch current task comm\n\t *  @ADDR\t: fetch memory at ADDR (ADDR should be in kernel)\n\t *  @SYM[+|-offs] : fetch memory at SYM +|- offs (SYM is a data symbol)\n\t *  %REG\t: fetch register REG\n\t * Dereferencing memory fetch:\n\t *  +|-offs(ARG) : fetch memory at ARG +|- offs address.\n\t * Alias name of args:\n\t *  NAME=FETCHARG : set NAME as alias of FETCHARG.\n\t * Type of args:\n\t *  FETCHARG:TYPE : use TYPE instead of unsigned long.\n\t */\n\tstruct trace_kprobe *tk = NULL;\n\tint i, len, ret = 0;\n\tbool is_return = false;\n\tchar *symbol = NULL, *tmp = NULL;\n\tconst char *event = NULL, *group = KPROBE_EVENT_SYSTEM;\n\tenum probe_print_type ptype;\n\tint maxactive = 0;\n\tlong offset = 0;\n\tvoid *addr = NULL;\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tunsigned int flags = TPARG_FL_KERNEL;\n\n\tswitch (argv[0][0]) {\n\tcase 'r':\n\t\tis_return = true;\n\t\tbreak;\n\tcase 'p':\n\t\tbreak;\n\tdefault:\n\t\treturn -ECANCELED;\n\t}\n\tif (argc < 2)\n\t\treturn -ECANCELED;\n\n\ttrace_probe_log_init(\"trace_kprobe\", argc, argv);\n\n\tevent = strchr(&argv[0][1], ':');\n\tif (event)\n\t\tevent++;\n\n\tif (isdigit(argv[0][1])) {\n\t\tif (!is_return) {\n\t\t\ttrace_probe_log_err(1, MAXACT_NO_KPROBE);\n\t\t\tgoto parse_error;\n\t\t}\n\t\tif (event)\n\t\t\tlen = event - &argv[0][1] - 1;\n\t\telse\n\t\t\tlen = strlen(&argv[0][1]);\n\t\tif (len > MAX_EVENT_NAME_LEN - 1) {\n\t\t\ttrace_probe_log_err(1, BAD_MAXACT);\n\t\t\tgoto parse_error;\n\t\t}\n\t\tmemcpy(buf, &argv[0][1], len);\n\t\tbuf[len] = '\\0';\n\t\tret = kstrtouint(buf, 0, &maxactive);\n\t\tif (ret || !maxactive) {\n\t\t\ttrace_probe_log_err(1, BAD_MAXACT);\n\t\t\tgoto parse_error;\n\t\t}\n\t\t/* kretprobes instances are iterated over via a list. The\n\t\t * maximum should stay reasonable.\n\t\t */\n\t\tif (maxactive > KRETPROBE_MAXACTIVE_MAX) {\n\t\t\ttrace_probe_log_err(1, MAXACT_TOO_BIG);\n\t\t\tgoto parse_error;\n\t\t}\n\t}\n\n\t/* try to parse an address. if that fails, try to read the\n\t * input as a symbol. */\n\tif (kstrtoul(argv[1], 0, (unsigned long *)&addr)) {\n\t\ttrace_probe_log_set_index(1);\n\t\t/* Check whether uprobe event specified */\n\t\tif (strchr(argv[1], '/') && strchr(argv[1], ':')) {\n\t\t\tret = -ECANCELED;\n\t\t\tgoto error;\n\t\t}\n\t\t/* a symbol specified */\n\t\tsymbol = kstrdup(argv[1], GFP_KERNEL);\n\t\tif (!symbol)\n\t\t\treturn -ENOMEM;\n\n\t\ttmp = strchr(symbol, '%');\n\t\tif (tmp) {\n\t\t\tif (!strcmp(tmp, \"%return\")) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tis_return = true;\n\t\t\t} else {\n\t\t\t\ttrace_probe_log_err(tmp - symbol, BAD_ADDR_SUFFIX);\n\t\t\t\tgoto parse_error;\n\t\t\t}\n\t\t}\n\n\t\t/* TODO: support .init module functions */\n\t\tret = traceprobe_split_symbol_offset(symbol, &offset);\n\t\tif (ret || offset < 0 || offset > UINT_MAX) {\n\t\t\ttrace_probe_log_err(0, BAD_PROBE_ADDR);\n\t\t\tgoto parse_error;\n\t\t}\n\t\tif (is_return)\n\t\t\tflags |= TPARG_FL_RETURN;\n\t\tret = kprobe_on_func_entry(NULL, symbol, offset);\n\t\tif (ret == 0)\n\t\t\tflags |= TPARG_FL_FENTRY;\n\t\t/* Defer the ENOENT case until register kprobe */\n\t\tif (ret == -EINVAL && is_return) {\n\t\t\ttrace_probe_log_err(0, BAD_RETPROBE);\n\t\t\tgoto parse_error;\n\t\t}\n\t}\n\n\ttrace_probe_log_set_index(0);\n\tif (event) {\n\t\tret = traceprobe_parse_event_name(&event, &group, buf,\n\t\t\t\t\t\t  event - argv[0]);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t} else {\n\t\t/* Make a new event name */\n\t\tif (symbol)\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_%s_%ld\",\n\t\t\t\t is_return ? 'r' : 'p', symbol, offset);\n\t\telse\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_0x%p\",\n\t\t\t\t is_return ? 'r' : 'p', addr);\n\t\tsanitize_event_name(buf);\n\t\tevent = buf;\n\t}\n\n\t/* setup a probe */\n\ttk = alloc_trace_kprobe(group, event, addr, symbol, offset, maxactive,\n\t\t\t       argc - 2, is_return);\n\tif (IS_ERR(tk)) {\n\t\tret = PTR_ERR(tk);\n\t\t/* This must return -ENOMEM, else there is a bug */\n\t\tWARN_ON_ONCE(ret != -ENOMEM);\n\t\tgoto out;\t/* We know tk is not allocated */\n\t}\n\targc -= 2; argv += 2;\n\n\t/* parse arguments */\n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\ttrace_probe_log_set_index(i + 2);\n\t\tret = traceprobe_parse_probe_arg(&tk->tp, i, argv[i], flags);\n\t\tif (ret)\n\t\t\tgoto error;\t/* This can be -ENOMEM */\n\t}\n\n\tptype = is_return ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tret = traceprobe_set_print_fmt(&tk->tp, ptype);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = register_trace_kprobe(tk);\n\tif (ret) {\n\t\ttrace_probe_log_set_index(1);\n\t\tif (ret == -EILSEQ)\n\t\t\ttrace_probe_log_err(0, BAD_INSN_BNDRY);\n\t\telse if (ret == -ENOENT)\n\t\t\ttrace_probe_log_err(0, BAD_PROBE_ADDR);\n\t\telse if (ret != -ENOMEM && ret != -EEXIST)\n\t\t\ttrace_probe_log_err(0, FAIL_REG_PROBE);\n\t\tgoto error;\n\t}\n\nout:\n\ttrace_probe_log_clear();\n\tkfree(symbol);\n\treturn ret;\n\nparse_error:\n\tret = -EINVAL;\nerror:\n\tfree_trace_kprobe(tk);\n\tgoto out;\n}"
  },
  {
    "function_name": "trace_kprobe_module_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "672-699",
    "snippet": "static int trace_kprobe_module_callback(struct notifier_block *nb,\n\t\t\t\t       unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tstruct dyn_event *pos;\n\tstruct trace_kprobe *tk;\n\tint ret;\n\n\tif (val != MODULE_STATE_COMING)\n\t\treturn NOTIFY_DONE;\n\n\t/* Update probes on coming module */\n\tmutex_lock(&event_mutex);\n\tfor_each_trace_kprobe(tk, pos) {\n\t\tif (trace_kprobe_within_module(tk, mod)) {\n\t\t\t/* Don't need to check busy - this should have gone. */\n\t\t\t__unregister_trace_kprobe(tk);\n\t\t\tret = __register_trace_kprobe(tk);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to re-register probe %s on %s: %d\\n\",\n\t\t\t\t\ttrace_probe_name(&tk->tp),\n\t\t\t\t\tmodule_name(mod), ret);\n\t\t}\n\t}\n\tmutex_unlock(&event_mutex);\n\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to re-register probe %s on %s: %d\\n\"",
            "trace_probe_name(&tk->tp)",
            "module_name(mod)",
            "ret"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_name",
          "args": [
            "mod"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "pi_get_module_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/index.c",
          "lines": "133-136",
          "snippet": "static const char *pi_get_module_name(struct module *mod)\n{\n\treturn \"vmlinux\";\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/string_helpers.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/string_helpers.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n\nstatic const char *pi_get_module_name(struct module *mod)\n{\n\treturn \"vmlinux\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tk->tp"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "__register_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "476-511",
          "snippet": "static int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tret = security_locked_down(LOCKDOWN_KPROBES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trace_kprobe_is_registered(tk))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tret = security_locked_down(LOCKDOWN_KPROBES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trace_kprobe_is_registered(tk))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "514-527",
          "snippet": "static void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_kprobe_is_registered(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\t/* Cleanup kprobe for reuse and mark it unregistered */\n\t\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\t\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_kprobe_is_registered(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\t/* Cleanup kprobe for reuse and mark it unregistered */\n\t\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\t\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_within_module",
          "args": [
            "tk",
            "mod"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_within_module",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "104-111",
          "snippet": "static nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(module_name(mod));\n\tconst char *name = trace_kprobe_symbol(tk);\n\n\treturn strncmp(module_name(mod), name, len) == 0 && name[len] == ':';\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(module_name(mod));\n\tconst char *name = trace_kprobe_symbol(tk);\n\n\treturn strncmp(module_name(mod), name, len) == 0 && name[len] == ':';\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_trace_kprobe",
          "args": [
            "tk",
            "pos"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int trace_kprobe_module_callback(struct notifier_block *nb,\n\t\t\t\t       unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tstruct dyn_event *pos;\n\tstruct trace_kprobe *tk;\n\tint ret;\n\n\tif (val != MODULE_STATE_COMING)\n\t\treturn NOTIFY_DONE;\n\n\t/* Update probes on coming module */\n\tmutex_lock(&event_mutex);\n\tfor_each_trace_kprobe(tk, pos) {\n\t\tif (trace_kprobe_within_module(tk, mod)) {\n\t\t\t/* Don't need to check busy - this should have gone. */\n\t\t\t__unregister_trace_kprobe(tk);\n\t\t\tret = __register_trace_kprobe(tk);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to re-register probe %s on %s: %d\\n\",\n\t\t\t\t\ttrace_probe_name(&tk->tp),\n\t\t\t\t\tmodule_name(mod), ret);\n\t\t}\n\t}\n\tmutex_unlock(&event_mutex);\n\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "register_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "623-669",
    "snippet": "static int register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tstruct trace_kprobe *old_tk;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\told_tk = find_trace_kprobe(trace_probe_name(&tk->tp),\n\t\t\t\t   trace_probe_group_name(&tk->tp));\n\tif (old_tk) {\n\t\tif (trace_kprobe_is_return(tk) != trace_kprobe_is_return(old_tk)) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, DIFF_PROBE_TYPE);\n\t\t\tret = -EEXIST;\n\t\t} else {\n\t\t\tret = append_trace_kprobe(tk, old_tk);\n\t\t}\n\t\tgoto end;\n\t}\n\n\t/* Register new event */\n\tret = register_kprobe_event(tk);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t} else\n\t\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret < 0)\n\t\tunregister_kprobe_event(tk);\n\telse\n\t\tdyn_event_add(&tk->devent, trace_probe_event_call(&tk->tp));\n\nend:\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_add",
          "args": [
            "&tk->devent",
            "trace_probe_event_call(&tk->tp)"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "79-90",
          "snippet": "static inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_kprobe_event",
          "args": [
            "tk"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1778-1781",
          "snippet": "static int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\treturn trace_probe_unregister_event_call(&tk->tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\treturn trace_probe_unregister_event_call(&tk->tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"This probe might be able to register after target module is loaded. Continue.\\n\""
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_module_exist",
          "args": [
            "tk"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_module_exist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "113-130",
          "snippet": "static nokprobe_inline bool trace_kprobe_module_exist(struct trace_kprobe *tk)\n{\n\tchar *p;\n\tbool ret;\n\n\tif (!tk->symbol)\n\t\treturn false;\n\tp = strchr(tk->symbol, ':');\n\tif (!p)\n\t\treturn true;\n\t*p = '\\0';\n\trcu_read_lock_sched();\n\tret = !!find_module(tk->symbol);\n\trcu_read_unlock_sched();\n\t*p = ':';\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_module_exist(struct trace_kprobe *tk)\n{\n\tchar *p;\n\tbool ret;\n\n\tif (!tk->symbol)\n\t\treturn false;\n\tp = strchr(tk->symbol, ':');\n\tif (!p)\n\t\treturn true;\n\t*p = '\\0';\n\trcu_read_lock_sched();\n\tret = !!find_module(tk->symbol);\n\trcu_read_unlock_sched();\n\t*p = ':';\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "__register_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "476-511",
          "snippet": "static int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tret = security_locked_down(LOCKDOWN_KPROBES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trace_kprobe_is_registered(tk))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tret = security_locked_down(LOCKDOWN_KPROBES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trace_kprobe_is_registered(tk))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to register probe event(%d)\\n\"",
            "ret"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "0",
            "EVENT_EXIST"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_set_index",
          "args": [
            "0"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_set_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "158-161",
          "snippet": "void trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_trace_kprobe",
          "args": [
            "tk",
            "old_tk"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "append_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "585-620",
          "snippet": "static int append_trace_kprobe(struct trace_kprobe *tk, struct trace_kprobe *to)\n{\n\tint ret;\n\n\tret = trace_probe_compare_arg_type(&tk->tp, &to->tp);\n\tif (ret) {\n\t\t/* Note that argument starts index = 2 */\n\t\ttrace_probe_log_set_index(ret + 1);\n\t\ttrace_probe_log_err(0, DIFF_ARG_TYPE);\n\t\treturn -EEXIST;\n\t}\n\tif (trace_kprobe_has_same_kprobe(to, tk)) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(0, SAME_PROBE);\n\t\treturn -EEXIST;\n\t}\n\n\t/* Append to existing event */\n\tret = trace_probe_append(&tk->tp, &to->tp);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret)\n\t\ttrace_probe_unlink(&tk->tp);\n\telse\n\t\tdyn_event_add(&tk->devent, trace_probe_event_call(&tk->tp));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int append_trace_kprobe(struct trace_kprobe *tk, struct trace_kprobe *to)\n{\n\tint ret;\n\n\tret = trace_probe_compare_arg_type(&tk->tp, &to->tp);\n\tif (ret) {\n\t\t/* Note that argument starts index = 2 */\n\t\ttrace_probe_log_set_index(ret + 1);\n\t\ttrace_probe_log_err(0, DIFF_ARG_TYPE);\n\t\treturn -EEXIST;\n\t}\n\tif (trace_kprobe_has_same_kprobe(to, tk)) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(0, SAME_PROBE);\n\t\treturn -EEXIST;\n\t}\n\n\t/* Append to existing event */\n\tret = trace_probe_append(&tk->tp, &to->tp);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret)\n\t\ttrace_probe_unlink(&tk->tp);\n\telse\n\t\tdyn_event_add(&tk->devent, trace_probe_event_call(&tk->tp));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "old_tk"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-87",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_trace_kprobe",
          "args": [
            "trace_probe_name(&tk->tp)",
            "trace_probe_group_name(&tk->tp)"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "find_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "302-313",
          "snippet": "static struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_kprobe *tk;\n\n\tfor_each_trace_kprobe(tk, pos)\n\t\tif (strcmp(trace_probe_name(&tk->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tk->tp), group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_kprobe *tk;\n\n\tfor_each_trace_kprobe(tk, pos)\n\t\tif (strcmp(trace_probe_name(&tk->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tk->tp), group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_group_name",
          "args": [
            "&tk->tp"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_group_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "284-287",
          "snippet": "static inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tk->tp"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tstruct trace_kprobe *old_tk;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\told_tk = find_trace_kprobe(trace_probe_name(&tk->tp),\n\t\t\t\t   trace_probe_group_name(&tk->tp));\n\tif (old_tk) {\n\t\tif (trace_kprobe_is_return(tk) != trace_kprobe_is_return(old_tk)) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, DIFF_PROBE_TYPE);\n\t\t\tret = -EEXIST;\n\t\t} else {\n\t\t\tret = append_trace_kprobe(tk, old_tk);\n\t\t}\n\t\tgoto end;\n\t}\n\n\t/* Register new event */\n\tret = register_kprobe_event(tk);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t} else\n\t\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret < 0)\n\t\tunregister_kprobe_event(tk);\n\telse\n\t\tdyn_event_add(&tk->devent, trace_probe_event_call(&tk->tp));\n\nend:\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "append_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "585-620",
    "snippet": "static int append_trace_kprobe(struct trace_kprobe *tk, struct trace_kprobe *to)\n{\n\tint ret;\n\n\tret = trace_probe_compare_arg_type(&tk->tp, &to->tp);\n\tif (ret) {\n\t\t/* Note that argument starts index = 2 */\n\t\ttrace_probe_log_set_index(ret + 1);\n\t\ttrace_probe_log_err(0, DIFF_ARG_TYPE);\n\t\treturn -EEXIST;\n\t}\n\tif (trace_kprobe_has_same_kprobe(to, tk)) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(0, SAME_PROBE);\n\t\treturn -EEXIST;\n\t}\n\n\t/* Append to existing event */\n\tret = trace_probe_append(&tk->tp, &to->tp);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret)\n\t\ttrace_probe_unlink(&tk->tp);\n\telse\n\t\tdyn_event_add(&tk->devent, trace_probe_event_call(&tk->tp));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dyn_event_add",
          "args": [
            "&tk->devent",
            "trace_probe_event_call(&tk->tp)"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "79-90",
          "snippet": "static inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_unlink",
          "args": [
            "&tk->tp"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_unlink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1001-1007",
          "snippet": "void trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"This probe might be able to register after target module is loaded. Continue.\\n\""
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_module_exist",
          "args": [
            "tk"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_module_exist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "113-130",
          "snippet": "static nokprobe_inline bool trace_kprobe_module_exist(struct trace_kprobe *tk)\n{\n\tchar *p;\n\tbool ret;\n\n\tif (!tk->symbol)\n\t\treturn false;\n\tp = strchr(tk->symbol, ':');\n\tif (!p)\n\t\treturn true;\n\t*p = '\\0';\n\trcu_read_lock_sched();\n\tret = !!find_module(tk->symbol);\n\trcu_read_unlock_sched();\n\t*p = ':';\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_module_exist(struct trace_kprobe *tk)\n{\n\tchar *p;\n\tbool ret;\n\n\tif (!tk->symbol)\n\t\treturn false;\n\tp = strchr(tk->symbol, ':');\n\tif (!p)\n\t\treturn true;\n\t*p = '\\0';\n\trcu_read_lock_sched();\n\tret = !!find_module(tk->symbol);\n\trcu_read_unlock_sched();\n\t*p = ':';\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "__register_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "476-511",
          "snippet": "static int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tret = security_locked_down(LOCKDOWN_KPROBES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trace_kprobe_is_registered(tk))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tret = security_locked_down(LOCKDOWN_KPROBES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trace_kprobe_is_registered(tk))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_append",
          "args": [
            "&tk->tp",
            "&to->tp"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_append",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "987-999",
          "snippet": "int trace_probe_append(struct trace_probe *tp, struct trace_probe *to)\n{\n\tif (trace_probe_has_sibling(tp))\n\t\treturn -EBUSY;\n\n\tlist_del_init(&tp->list);\n\ttrace_probe_event_free(tp->event);\n\n\ttp->event = to->event;\n\tlist_add_tail(&tp->list, trace_probe_probe_list(to));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_append(struct trace_probe *tp, struct trace_probe *to)\n{\n\tif (trace_probe_has_sibling(tp))\n\t\treturn -EBUSY;\n\n\tlist_del_init(&tp->list);\n\ttrace_probe_event_free(tp->event);\n\n\ttp->event = to->event;\n\tlist_add_tail(&tp->list, trace_probe_probe_list(to));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "0",
            "SAME_PROBE"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_set_index",
          "args": [
            "0"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_set_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "158-161",
          "snippet": "void trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_has_same_kprobe",
          "args": [
            "to",
            "tk"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_has_same_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "556-583",
          "snippet": "static bool trace_kprobe_has_same_kprobe(struct trace_kprobe *orig,\n\t\t\t\t\t struct trace_kprobe *comp)\n{\n\tstruct trace_probe_event *tpe = orig->tp.event;\n\tint i;\n\n\tlist_for_each_entry(orig, &tpe->probes, tp.list) {\n\t\tif (strcmp(trace_kprobe_symbol(orig),\n\t\t\t   trace_kprobe_symbol(comp)) ||\n\t\t    trace_kprobe_offset(orig) != trace_kprobe_offset(comp))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * trace_probe_compare_arg_type() ensured that nr_args and\n\t\t * each argument name and type are same. Let's compare comm.\n\t\t */\n\t\tfor (i = 0; i < orig->tp.nr_args; i++) {\n\t\t\tif (strcmp(orig->tp.args[i].comm,\n\t\t\t\t   comp->tp.args[i].comm))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == orig->tp.nr_args)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic bool trace_kprobe_has_same_kprobe(struct trace_kprobe *orig,\n\t\t\t\t\t struct trace_kprobe *comp)\n{\n\tstruct trace_probe_event *tpe = orig->tp.event;\n\tint i;\n\n\tlist_for_each_entry(orig, &tpe->probes, tp.list) {\n\t\tif (strcmp(trace_kprobe_symbol(orig),\n\t\t\t   trace_kprobe_symbol(comp)) ||\n\t\t    trace_kprobe_offset(orig) != trace_kprobe_offset(comp))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * trace_probe_compare_arg_type() ensured that nr_args and\n\t\t * each argument name and type are same. Let's compare comm.\n\t\t */\n\t\tfor (i = 0; i < orig->tp.nr_args; i++) {\n\t\t\tif (strcmp(orig->tp.args[i].comm,\n\t\t\t\t   comp->tp.args[i].comm))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == orig->tp.nr_args)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_compare_arg_type",
          "args": [
            "&tk->tp",
            "&to->tp"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_compare_arg_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1155-1174",
          "snippet": "int trace_probe_compare_arg_type(struct trace_probe *a, struct trace_probe *b)\n{\n\tint i;\n\n\t/* In case of more arguments */\n\tif (a->nr_args < b->nr_args)\n\t\treturn a->nr_args + 1;\n\tif (a->nr_args > b->nr_args)\n\t\treturn b->nr_args + 1;\n\n\tfor (i = 0; i < a->nr_args; i++) {\n\t\tif ((b->nr_args <= i) ||\n\t\t    ((a->args[i].type != b->args[i].type) ||\n\t\t     (a->args[i].count != b->args[i].count) ||\n\t\t     strcmp(a->args[i].name, b->args[i].name)))\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_compare_arg_type(struct trace_probe *a, struct trace_probe *b)\n{\n\tint i;\n\n\t/* In case of more arguments */\n\tif (a->nr_args < b->nr_args)\n\t\treturn a->nr_args + 1;\n\tif (a->nr_args > b->nr_args)\n\t\treturn b->nr_args + 1;\n\n\tfor (i = 0; i < a->nr_args; i++) {\n\t\tif ((b->nr_args <= i) ||\n\t\t    ((a->args[i].type != b->args[i].type) ||\n\t\t     (a->args[i].count != b->args[i].count) ||\n\t\t     strcmp(a->args[i].name, b->args[i].name)))\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int append_trace_kprobe(struct trace_kprobe *tk, struct trace_kprobe *to)\n{\n\tint ret;\n\n\tret = trace_probe_compare_arg_type(&tk->tp, &to->tp);\n\tif (ret) {\n\t\t/* Note that argument starts index = 2 */\n\t\ttrace_probe_log_set_index(ret + 1);\n\t\ttrace_probe_log_err(0, DIFF_ARG_TYPE);\n\t\treturn -EEXIST;\n\t}\n\tif (trace_kprobe_has_same_kprobe(to, tk)) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(0, SAME_PROBE);\n\t\treturn -EEXIST;\n\t}\n\n\t/* Append to existing event */\n\tret = trace_probe_append(&tk->tp, &to->tp);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Register k*probe */\n\tret = __register_trace_kprobe(tk);\n\tif (ret == -ENOENT && !trace_kprobe_module_exist(tk)) {\n\t\tpr_warn(\"This probe might be able to register after target module is loaded. Continue.\\n\");\n\t\tret = 0;\n\t}\n\n\tif (ret)\n\t\ttrace_probe_unlink(&tk->tp);\n\telse\n\t\tdyn_event_add(&tk->devent, trace_probe_event_call(&tk->tp));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_kprobe_has_same_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "556-583",
    "snippet": "static bool trace_kprobe_has_same_kprobe(struct trace_kprobe *orig,\n\t\t\t\t\t struct trace_kprobe *comp)\n{\n\tstruct trace_probe_event *tpe = orig->tp.event;\n\tint i;\n\n\tlist_for_each_entry(orig, &tpe->probes, tp.list) {\n\t\tif (strcmp(trace_kprobe_symbol(orig),\n\t\t\t   trace_kprobe_symbol(comp)) ||\n\t\t    trace_kprobe_offset(orig) != trace_kprobe_offset(comp))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * trace_probe_compare_arg_type() ensured that nr_args and\n\t\t * each argument name and type are same. Let's compare comm.\n\t\t */\n\t\tfor (i = 0; i < orig->tp.nr_args; i++) {\n\t\t\tif (strcmp(orig->tp.args[i].comm,\n\t\t\t\t   comp->tp.args[i].comm))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == orig->tp.nr_args)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->tp.args[i].comm",
            "comp->tp.args[i].comm"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_offset",
          "args": [
            "comp"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "94-97",
          "snippet": "static nokprobe_inline unsigned long trace_kprobe_offset(struct trace_kprobe *tk)\n{\n\treturn tk->rp.kp.offset;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline unsigned long trace_kprobe_offset(struct trace_kprobe *tk)\n{\n\treturn tk->rp.kp.offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_symbol",
          "args": [
            "comp"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "89-92",
          "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "orig",
            "&tpe->probes",
            "tp.list"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic bool trace_kprobe_has_same_kprobe(struct trace_kprobe *orig,\n\t\t\t\t\t struct trace_kprobe *comp)\n{\n\tstruct trace_probe_event *tpe = orig->tp.event;\n\tint i;\n\n\tlist_for_each_entry(orig, &tpe->probes, tp.list) {\n\t\tif (strcmp(trace_kprobe_symbol(orig),\n\t\t\t   trace_kprobe_symbol(comp)) ||\n\t\t    trace_kprobe_offset(orig) != trace_kprobe_offset(comp))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * trace_probe_compare_arg_type() ensured that nr_args and\n\t\t * each argument name and type are same. Let's compare comm.\n\t\t */\n\t\tfor (i = 0; i < orig->tp.nr_args; i++) {\n\t\t\tif (strcmp(orig->tp.args[i].comm,\n\t\t\t\t   comp->tp.args[i].comm))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == orig->tp.nr_args)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "unregister_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "530-554",
    "snippet": "static int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* If other probes are on the event, just unregister kprobe */\n\tif (trace_probe_has_sibling(&tk->tp))\n\t\tgoto unreg;\n\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* If there's a reference to the dynamic event */\n\tif (trace_event_dyn_busy(trace_probe_event_call(&tk->tp)))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\nunreg:\n\t__unregister_trace_kprobe(tk);\n\tdyn_event_remove(&tk->devent);\n\ttrace_probe_unlink(&tk->tp);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_unlink",
          "args": [
            "&tk->tp"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_unlink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1001-1007",
          "snippet": "void trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_remove",
          "args": [
            "&tk->devent"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "92-96",
          "snippet": "static inline void dyn_event_remove(struct dyn_event *ev)\n{\n\tlockdep_assert_held(&event_mutex);\n\tlist_del_init(&ev->list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline void dyn_event_remove(struct dyn_event *ev)\n{\n\tlockdep_assert_held(&event_mutex);\n\tlist_del_init(&ev->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "514-527",
          "snippet": "static void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_kprobe_is_registered(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\t/* Cleanup kprobe for reuse and mark it unregistered */\n\t\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\t\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_kprobe_is_registered(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\t/* Cleanup kprobe for reuse and mark it unregistered */\n\t\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\t\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_kprobe_event",
          "args": [
            "tk"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1778-1781",
          "snippet": "static int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\treturn trace_probe_unregister_event_call(&tk->tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\treturn trace_probe_unregister_event_call(&tk->tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_dyn_busy",
          "args": [
            "trace_probe_event_call(&tk->tp)"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_dyn_busy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "54-57",
          "snippet": "bool trace_event_dyn_busy(struct trace_event_call *call)\n{\n\treturn atomic_read(&call->refcnt) != 0;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nbool trace_event_dyn_busy(struct trace_event_call *call)\n{\n\treturn atomic_read(&call->refcnt) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&tk->tp"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tk->tp"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_has_sibling",
          "args": [
            "&tk->tp"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_has_sibling",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "314-319",
          "snippet": "static inline bool trace_probe_has_sibling(struct trace_probe *tp)\n{\n\tstruct list_head *list = trace_probe_probe_list(tp);\n\n\treturn !list_empty(list) && !list_is_singular(list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_has_sibling(struct trace_probe *tp)\n{\n\tstruct list_head *list = trace_probe_probe_list(tp);\n\n\treturn !list_empty(list) && !list_is_singular(list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\t/* If other probes are on the event, just unregister kprobe */\n\tif (trace_probe_has_sibling(&tk->tp))\n\t\tgoto unreg;\n\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\treturn -EBUSY;\n\n\t/* If there's a reference to the dynamic event */\n\tif (trace_event_dyn_busy(trace_probe_event_call(&tk->tp)))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (unregister_kprobe_event(tk))\n\t\treturn -EBUSY;\n\nunreg:\n\t__unregister_trace_kprobe(tk);\n\tdyn_event_remove(&tk->devent);\n\ttrace_probe_unlink(&tk->tp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__unregister_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "514-527",
    "snippet": "static void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_kprobe_is_registered(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\t/* Cleanup kprobe for reuse and mark it unregistered */\n\t\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\t\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tk->rp.kp.list"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&tk->rp.kp.hlist"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_kprobe",
          "args": [
            "&tk->rp.kp"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1778-1781",
          "snippet": "static int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\treturn trace_probe_unregister_event_call(&tk->tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\treturn trace_probe_unregister_event_call(&tk->tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_kretprobe",
          "args": [
            "&tk->rp"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kretprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2213-2215",
          "snippet": "void unregister_kretprobe(struct kretprobe *rp)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobe(struct kretprobe *rp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-87",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_registered",
          "args": [
            "tk"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_registered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "182-186",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_registered(struct trace_kprobe *tk)\n{\n\treturn !(list_empty(&tk->rp.kp.list) &&\n\t\t hlist_unhashed(&tk->rp.kp.hlist));\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_registered(struct trace_kprobe *tk)\n{\n\treturn !(list_empty(&tk->rp.kp.list) &&\n\t\t hlist_unhashed(&tk->rp.kp.hlist));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void __unregister_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (trace_kprobe_is_registered(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tunregister_kretprobe(&tk->rp);\n\t\telse\n\t\t\tunregister_kprobe(&tk->rp.kp);\n\t\t/* Cleanup kprobe for reuse and mark it unregistered */\n\t\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\t\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\t\tif (tk->rp.kp.symbol_name)\n\t\t\ttk->rp.kp.addr = NULL;\n\t}\n}"
  },
  {
    "function_name": "__register_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "476-511",
    "snippet": "static int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tret = security_locked_down(LOCKDOWN_KPROBES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trace_kprobe_is_registered(tk))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_kprobe",
          "args": [
            "&tk->rp.kp"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1778-1781",
          "snippet": "static int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\treturn trace_probe_unregister_event_call(&tk->tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int unregister_kprobe_event(struct trace_kprobe *tk)\n{\n\treturn trace_probe_unregister_event_call(&tk->tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_kretprobe",
          "args": [
            "&tk->rp"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kretprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2213-2215",
          "snippet": "void unregister_kretprobe(struct kretprobe *rp)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobe(struct kretprobe *rp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-87",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tk->tp"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_update_arg",
          "args": [
            "&tk->tp.args[i]"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_update_arg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "827-859",
          "snippet": "int traceprobe_update_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\tlong offset;\n\tchar *tmp;\n\tchar c;\n\tint ret = 0;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL) {\n\t\t\tif (code[1].op != FETCH_OP_IMM)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttmp = strpbrk(code->data, \"+-\");\n\t\t\tif (tmp)\n\t\t\t\tc = *tmp;\n\t\t\tret = traceprobe_split_symbol_offset(code->data,\n\t\t\t\t\t\t\t     &offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcode[1].immediate =\n\t\t\t\t(unsigned long)kallsyms_lookup_name(code->data);\n\t\t\tif (tmp)\n\t\t\t\t*tmp = c;\n\t\t\tif (!code[1].immediate)\n\t\t\t\treturn -ENOENT;\n\t\t\tcode[1].immediate += offset;\n\t\t}\n\t\tcode++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_update_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\tlong offset;\n\tchar *tmp;\n\tchar c;\n\tint ret = 0;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL) {\n\t\t\tif (code[1].op != FETCH_OP_IMM)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttmp = strpbrk(code->data, \"+-\");\n\t\t\tif (tmp)\n\t\t\t\tc = *tmp;\n\t\t\tret = traceprobe_split_symbol_offset(code->data,\n\t\t\t\t\t\t\t     &offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcode[1].immediate =\n\t\t\t\t(unsigned long)kallsyms_lookup_name(code->data);\n\t\t\tif (tmp)\n\t\t\t\t*tmp = c;\n\t\t\tif (!code[1].immediate)\n\t\t\t\treturn -ENOENT;\n\t\t\tcode[1].immediate += offset;\n\t\t}\n\t\tcode++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not probe notrace function %s\\n\"",
            "trace_kprobe_symbol(tk)"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_symbol",
          "args": [
            "tk"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "89-92",
          "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_notrace_func",
          "args": [
            "tk"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "within_notrace_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "450-470",
          "snippet": "static bool within_notrace_func(struct trace_kprobe *tk)\n{\n\tunsigned long addr = trace_kprobe_address(tk);\n\tchar symname[KSYM_NAME_LEN], *p;\n\n\tif (!__within_notrace_func(addr))\n\t\treturn false;\n\n\t/* Check if the address is on a suffixed-symbol */\n\tif (!lookup_symbol_name(addr, symname)) {\n\t\tp = strchr(symname, '.');\n\t\tif (!p)\n\t\t\treturn true;\n\t\t*p = '\\0';\n\t\taddr = (unsigned long)kprobe_lookup_name(symname, 0);\n\t\tif (addr)\n\t\t\treturn __within_notrace_func(addr);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic bool within_notrace_func(struct trace_kprobe *tk)\n{\n\tunsigned long addr = trace_kprobe_address(tk);\n\tchar symname[KSYM_NAME_LEN], *p;\n\n\tif (!__within_notrace_func(addr))\n\t\treturn false;\n\n\t/* Check if the address is on a suffixed-symbol */\n\tif (!lookup_symbol_name(addr, symname)) {\n\t\tp = strchr(symname, '.');\n\t\tif (!p)\n\t\t\treturn true;\n\t\t*p = '\\0';\n\t\taddr = (unsigned long)kprobe_lookup_name(symname, 0);\n\t\tif (addr)\n\t\t\treturn __within_notrace_func(addr);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_registered",
          "args": [
            "tk"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_registered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "182-186",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_registered(struct trace_kprobe *tk)\n{\n\treturn !(list_empty(&tk->rp.kp.list) &&\n\t\t hlist_unhashed(&tk->rp.kp.hlist));\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_registered(struct trace_kprobe *tk)\n{\n\treturn !(list_empty(&tk->rp.kp.list) &&\n\t\t hlist_unhashed(&tk->rp.kp.hlist));\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_KPROBES"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int __register_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint i, ret;\n\n\tret = security_locked_down(LOCKDOWN_KPROBES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trace_kprobe_is_registered(tk))\n\t\treturn -EINVAL;\n\n\tif (within_notrace_func(tk)) {\n\t\tpr_warn(\"Could not probe notrace function %s\\n\",\n\t\t\ttrace_kprobe_symbol(tk));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tk->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tk->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Set/clear disabled flag according to tp->flag */\n\tif (trace_probe_is_enabled(&tk->tp))\n\t\ttk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\n\telse\n\t\ttk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\n\n\tif (trace_kprobe_is_return(tk))\n\t\tret = register_kretprobe(&tk->rp);\n\telse\n\t\tret = register_kprobe(&tk->rp.kp);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "within_notrace_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "450-470",
    "snippet": "static bool within_notrace_func(struct trace_kprobe *tk)\n{\n\tunsigned long addr = trace_kprobe_address(tk);\n\tchar symname[KSYM_NAME_LEN], *p;\n\n\tif (!__within_notrace_func(addr))\n\t\treturn false;\n\n\t/* Check if the address is on a suffixed-symbol */\n\tif (!lookup_symbol_name(addr, symname)) {\n\t\tp = strchr(symname, '.');\n\t\tif (!p)\n\t\t\treturn true;\n\t\t*p = '\\0';\n\t\taddr = (unsigned long)kprobe_lookup_name(symname, 0);\n\t\tif (addr)\n\t\t\treturn __within_notrace_func(addr);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__within_notrace_func",
          "args": [
            "addr"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "__within_notrace_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "433-448",
          "snippet": "static bool __within_notrace_func(unsigned long addr)\n{\n\tunsigned long offset, size;\n\n\tif (!addr || !kallsyms_lookup_size_offset(addr, &size, &offset))\n\t\treturn false;\n\n\t/* Get the entry address of the target function */\n\taddr -= offset;\n\n\t/*\n\t * Since ftrace_location_range() does inclusive range check, we need\n\t * to subtract 1 byte from the end address.\n\t */\n\treturn !ftrace_location_range(addr, addr + size - 1);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic bool __within_notrace_func(unsigned long addr)\n{\n\tunsigned long offset, size;\n\n\tif (!addr || !kallsyms_lookup_size_offset(addr, &size, &offset))\n\t\treturn false;\n\n\t/* Get the entry address of the target function */\n\taddr -= offset;\n\n\t/*\n\t * Since ftrace_location_range() does inclusive range check, we need\n\t * to subtract 1 byte from the end address.\n\t */\n\treturn !ftrace_location_range(addr, addr + size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_lookup_name",
          "args": [
            "symname",
            "0"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "symname",
            "'.'"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_symbol_name",
          "args": [
            "addr",
            "symname"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_symbol_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "386-410",
          "snippet": "int lookup_symbol_name(unsigned long addr, char *symname)\n{\n\tint res;\n\n\tsymname[0] = '\\0';\n\tsymname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, NULL, NULL);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       symname, KSYM_NAME_LEN);\n\t\tgoto found;\n\t}\n\t/* See if it's in a module. */\n\tres = lookup_module_symbol_name(addr, symname);\n\tif (res)\n\t\treturn res;\n\nfound:\n\tcleanup_symbol_name(symname);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint lookup_symbol_name(unsigned long addr, char *symname)\n{\n\tint res;\n\n\tsymname[0] = '\\0';\n\tsymname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, NULL, NULL);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       symname, KSYM_NAME_LEN);\n\t\tgoto found;\n\t}\n\t/* See if it's in a module. */\n\tres = lookup_module_symbol_name(addr, symname);\n\tif (res)\n\t\treturn res;\n\nfound:\n\tcleanup_symbol_name(symname);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_address",
          "args": [
            "tk"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "189-203",
          "snippet": "static nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic bool within_notrace_func(struct trace_kprobe *tk)\n{\n\tunsigned long addr = trace_kprobe_address(tk);\n\tchar symname[KSYM_NAME_LEN], *p;\n\n\tif (!__within_notrace_func(addr))\n\t\treturn false;\n\n\t/* Check if the address is on a suffixed-symbol */\n\tif (!lookup_symbol_name(addr, symname)) {\n\t\tp = strchr(symname, '.');\n\t\tif (!p)\n\t\t\treturn true;\n\t\t*p = '\\0';\n\t\taddr = (unsigned long)kprobe_lookup_name(symname, 0);\n\t\tif (addr)\n\t\t\treturn __within_notrace_func(addr);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "__within_notrace_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "433-448",
    "snippet": "static bool __within_notrace_func(unsigned long addr)\n{\n\tunsigned long offset, size;\n\n\tif (!addr || !kallsyms_lookup_size_offset(addr, &size, &offset))\n\t\treturn false;\n\n\t/* Get the entry address of the target function */\n\taddr -= offset;\n\n\t/*\n\t * Since ftrace_location_range() does inclusive range check, we need\n\t * to subtract 1 byte from the end address.\n\t */\n\treturn !ftrace_location_range(addr, addr + size - 1);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_location_range",
          "args": [
            "addr",
            "addr + size - 1"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_location_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "1559-1568",
          "snippet": "unsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(start, end);\n\tif (rec)\n\t\treturn rec->ip;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nunsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct dyn_ftrace *rec;\n\n\trec = lookup_rec(start, end);\n\tif (rec)\n\t\treturn rec->ip;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_size_offset",
          "args": [
            "addr",
            "&size",
            "&offset"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup_size_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "315-326",
          "snippet": "int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic bool __within_notrace_func(unsigned long addr)\n{\n\tunsigned long offset, size;\n\n\tif (!addr || !kallsyms_lookup_size_offset(addr, &size, &offset))\n\t\treturn false;\n\n\t/* Get the entry address of the target function */\n\taddr -= offset;\n\n\t/*\n\t * Since ftrace_location_range() does inclusive range check, we need\n\t * to subtract 1 byte from the end address.\n\t */\n\treturn !ftrace_location_range(addr, addr + size - 1);\n}"
  },
  {
    "function_name": "disable_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "397-429",
    "snippet": "static int disable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp))\n\t\t__disable_trace_kprobe(tp);\n\n out:\n\tif (file)\n\t\t/*\n\t\t * Synchronization is done in below function. For perf event,\n\t\t * file == NULL and perf_trace_event_unreg() calls\n\t\t * tracepoint_synchronize_unregister() to ensure synchronize\n\t\t * event. We don't need to care about it.\n\t\t */\n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_remove_file",
          "args": [
            "tp",
            "file"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_remove_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1133-1149",
          "snippet": "int trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__disable_trace_kprobe",
          "args": [
            "tp"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "329-341",
          "snippet": "static void __disable_trace_kprobe(struct trace_probe *tp)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!trace_kprobe_is_registered(tk))\n\t\t\tcontinue;\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void __disable_trace_kprobe(struct trace_probe *tp)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!trace_kprobe_is_registered(tk))\n\t\t\tcontinue;\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "tp"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_clear_flag",
          "args": [
            "tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_clear_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "268-272",
          "snippet": "static inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_has_single_file",
          "args": [
            "tp"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_has_single_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "327-330",
          "snippet": "static inline bool trace_probe_has_single_file(struct trace_probe *tp)\n{\n\treturn !!list_is_singular(&tp->event->files);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_has_single_file(struct trace_probe *tp)\n{\n\treturn !!list_is_singular(&tp->event->files);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_get_file_link",
          "args": [
            "tp",
            "file"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_get_file_link",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1120-1131",
          "snippet": "struct event_file_link *trace_probe_get_file_link(struct trace_probe *tp,\n\t\t\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link(link, tp) {\n\t\tif (link->file == file)\n\t\t\treturn link;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstruct event_file_link *trace_probe_get_file_link(struct trace_probe *tp,\n\t\t\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link(link, tp) {\n\t\tif (link->file == file)\n\t\t\treturn link;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\nstatic int disable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp))\n\t\t__disable_trace_kprobe(tp);\n\n out:\n\tif (file)\n\t\t/*\n\t\t * Synchronization is done in below function. For perf event,\n\t\t * file == NULL and perf_trace_event_unreg() calls\n\t\t * tracepoint_synchronize_unregister() to ensure synchronize\n\t\t * event. We don't need to care about it.\n\t\t */\n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "enable_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "347-391",
    "snippet": "static int enable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_kprobe *tk;\n\tbool enabled;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This also changes \"enabled\" state */\n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (enabled)\n\t\treturn 0;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (trace_kprobe_has_gone(tk))\n\t\t\tcontinue;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tenabled = true;\n\t}\n\n\tif (ret) {\n\t\t/* Failed to enable one of them. Roll back all */\n\t\tif (enabled)\n\t\t\t__disable_trace_kprobe(tp);\n\t\tif (file)\n\t\t\ttrace_probe_remove_file(tp, file);\n\t\telse\n\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_clear_flag",
          "args": [
            "tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_clear_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "268-272",
          "snippet": "static inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_remove_file",
          "args": [
            "tp",
            "file"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_remove_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1133-1149",
          "snippet": "int trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__disable_trace_kprobe",
          "args": [
            "tp"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "329-341",
          "snippet": "static void __disable_trace_kprobe(struct trace_probe *tp)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!trace_kprobe_is_registered(tk))\n\t\t\tcontinue;\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void __disable_trace_kprobe(struct trace_probe *tp)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!trace_kprobe_is_registered(tk))\n\t\t\tcontinue;\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__enable_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "__enable_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "315-327",
          "snippet": "static inline int __enable_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint ret = 0;\n\n\tif (trace_kprobe_is_registered(tk) && !trace_kprobe_has_gone(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tret = enable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tret = enable_kprobe(&tk->rp.kp);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic inline int __enable_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint ret = 0;\n\n\tif (trace_kprobe_is_registered(tk) && !trace_kprobe_has_gone(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tret = enable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tret = enable_kprobe(&tk->rp.kp);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_has_gone",
          "args": [
            "tk"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_has_gone",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "99-102",
          "snippet": "static nokprobe_inline bool trace_kprobe_has_gone(struct trace_kprobe *tk)\n{\n\treturn kprobe_gone(&tk->rp.kp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_has_gone(struct trace_kprobe *tk)\n{\n\treturn kprobe_gone(&tk->rp.kp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tk",
            "trace_probe_probe_list(tp)",
            "tp.list"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_probe_list",
          "args": [
            "tp"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_probe_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "309-312",
          "snippet": "static inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_set_flag",
          "args": [
            "tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_set_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "262-266",
          "snippet": "static inline void trace_probe_set_flag(struct trace_probe *tp,\n\t\t\t\t\tunsigned int flag)\n{\n\ttp->event->flags |= flag;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline void trace_probe_set_flag(struct trace_probe *tp,\n\t\t\t\t\tunsigned int flag)\n{\n\ttp->event->flags |= flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_add_file",
          "args": [
            "tp",
            "file"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_add_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1105-1118",
          "snippet": "int trace_probe_add_file(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->file = file;\n\tINIT_LIST_HEAD(&link->list);\n\tlist_add_tail_rcu(&link->list, &tp->event->files);\n\ttrace_probe_set_flag(tp, TP_FLAG_TRACE);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_add_file(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->file = file;\n\tINIT_LIST_HEAD(&link->list);\n\tlist_add_tail_rcu(&link->list, &tp->event->files);\n\ttrace_probe_set_flag(tp, TP_FLAG_TRACE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "tp"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic int enable_trace_kprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_kprobe *tk;\n\tbool enabled;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This also changes \"enabled\" state */\n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (enabled)\n\t\treturn 0;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (trace_kprobe_has_gone(tk))\n\t\t\tcontinue;\n\t\tret = __enable_trace_kprobe(tk);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tenabled = true;\n\t}\n\n\tif (ret) {\n\t\t/* Failed to enable one of them. Roll back all */\n\t\tif (enabled)\n\t\t\t__disable_trace_kprobe(tp);\n\t\tif (file)\n\t\t\ttrace_probe_remove_file(tp, file);\n\t\telse\n\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__disable_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "329-341",
    "snippet": "static void __disable_trace_kprobe(struct trace_probe *tp)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!trace_kprobe_is_registered(tk))\n\t\t\tcontinue;\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t}\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_kprobe",
          "args": [
            "&tk->rp.kp"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "disable_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2265-2279",
          "snippet": "int disable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Disable this kprobe */\n\tp = __disable_kprobe(kp);\n\tif (IS_ERR(p))\n\t\tret = PTR_ERR(p);\n\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nint disable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Disable this kprobe */\n\tp = __disable_kprobe(kp);\n\tif (IS_ERR(p))\n\t\tret = PTR_ERR(p);\n\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_kretprobe",
          "args": [
            "&tk->rp"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-87",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_registered",
          "args": [
            "tk"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_registered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "182-186",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_registered(struct trace_kprobe *tk)\n{\n\treturn !(list_empty(&tk->rp.kp.list) &&\n\t\t hlist_unhashed(&tk->rp.kp.hlist));\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_registered(struct trace_kprobe *tk)\n{\n\treturn !(list_empty(&tk->rp.kp.list) &&\n\t\t hlist_unhashed(&tk->rp.kp.hlist));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tk",
            "trace_probe_probe_list(tp)",
            "tp.list"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_probe_list",
          "args": [
            "tp"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_probe_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "309-312",
          "snippet": "static inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void __disable_trace_kprobe(struct trace_probe *tp)\n{\n\tstruct trace_kprobe *tk;\n\n\tlist_for_each_entry(tk, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!trace_kprobe_is_registered(tk))\n\t\t\tcontinue;\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tdisable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tdisable_kprobe(&tk->rp.kp);\n\t}\n}"
  },
  {
    "function_name": "__enable_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "315-327",
    "snippet": "static inline int __enable_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint ret = 0;\n\n\tif (trace_kprobe_is_registered(tk) && !trace_kprobe_has_gone(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tret = enable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tret = enable_kprobe(&tk->rp.kp);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_kprobe",
          "args": [
            "&tk->rp.kp"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "enable_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2283-2315",
          "snippet": "int enable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Check whether specified probe is valid. */\n\tp = __get_valid_kprobe(kp);\n\tif (unlikely(p == NULL)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(kp)) {\n\t\t/* This kprobe has gone, we couldn't enable it. */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (p != kp)\n\t\tkp->flags &= ~KPROBE_FLAG_DISABLED;\n\n\tif (!kprobes_all_disarmed && kprobe_disabled(p)) {\n\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tret = arm_kprobe(p);\n\t\tif (ret)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\t}\nout:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nint enable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Check whether specified probe is valid. */\n\tp = __get_valid_kprobe(kp);\n\tif (unlikely(p == NULL)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(kp)) {\n\t\t/* This kprobe has gone, we couldn't enable it. */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (p != kp)\n\t\tkp->flags &= ~KPROBE_FLAG_DISABLED;\n\n\tif (!kprobes_all_disarmed && kprobe_disabled(p)) {\n\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tret = arm_kprobe(p);\n\t\tif (ret)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\t}\nout:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_kretprobe",
          "args": [
            "&tk->rp"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_return",
          "args": [
            "tk"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "84-87",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_has_gone",
          "args": [
            "tk"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_has_gone",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "99-102",
          "snippet": "static nokprobe_inline bool trace_kprobe_has_gone(struct trace_kprobe *tk)\n{\n\treturn kprobe_gone(&tk->rp.kp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_has_gone(struct trace_kprobe *tk)\n{\n\treturn kprobe_gone(&tk->rp.kp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_is_registered",
          "args": [
            "tk"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_is_registered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "182-186",
          "snippet": "static nokprobe_inline bool trace_kprobe_is_registered(struct trace_kprobe *tk)\n{\n\treturn !(list_empty(&tk->rp.kp.list) &&\n\t\t hlist_unhashed(&tk->rp.kp.hlist));\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_registered(struct trace_kprobe *tk)\n{\n\treturn !(list_empty(&tk->rp.kp.list) &&\n\t\t hlist_unhashed(&tk->rp.kp.hlist));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic inline int __enable_trace_kprobe(struct trace_kprobe *tk)\n{\n\tint ret = 0;\n\n\tif (trace_kprobe_is_registered(tk) && !trace_kprobe_has_gone(tk)) {\n\t\tif (trace_kprobe_is_return(tk))\n\t\t\tret = enable_kretprobe(&tk->rp);\n\t\telse\n\t\t\tret = enable_kprobe(&tk->rp.kp);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "302-313",
    "snippet": "static struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_kprobe *tk;\n\n\tfor_each_trace_kprobe(tk, pos)\n\t\tif (strcmp(trace_probe_name(&tk->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tk->tp), group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "trace_probe_group_name(&tk->tp)",
            "group"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_group_name",
          "args": [
            "&tk->tp"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_group_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "284-287",
          "snippet": "static inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tk->tp"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_trace_kprobe",
          "args": [
            "tk",
            "pos"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic struct trace_kprobe *find_trace_kprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_kprobe *tk;\n\n\tfor_each_trace_kprobe(tk, pos)\n\t\tif (strcmp(trace_probe_name(&tk->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tk->tp), group) == 0)\n\t\t\treturn tk;\n\treturn NULL;\n}"
  },
  {
    "function_name": "alloc_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "254-300",
    "snippet": "static struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(struct_size(tk, tp.args, nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\n\tret = trace_probe_init(&tk->tp, event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tk->devent, &trace_kprobe_ops);\n\treturn tk;\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};",
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_trace_kprobe",
          "args": [
            "tk"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "free_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "241-249",
          "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_init",
          "args": [
            "&tk->devent",
            "&trace_kprobe_ops"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "68-77",
          "snippet": "static inline\nint dyn_event_init(struct dyn_event *ev, struct dyn_event_operations *ops)\n{\n\tif (!ev || !ops)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ev->list);\n\tev->ops = ops;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline\nint dyn_event_init(struct dyn_event *ev, struct dyn_event_operations *ops)\n{\n\tif (!ev || !ops)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ev->list);\n\tev->ops = ops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_init",
          "args": [
            "&tk->tp",
            "event",
            "group",
            "false"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1020-1062",
          "snippet": "int trace_probe_init(struct trace_probe *tp, const char *event,\n\t\t     const char *group, bool alloc_filter)\n{\n\tstruct trace_event_call *call;\n\tsize_t size = sizeof(struct trace_probe_event);\n\tint ret = 0;\n\n\tif (!event || !group)\n\t\treturn -EINVAL;\n\n\tif (alloc_filter)\n\t\tsize += sizeof(struct trace_uprobe_filter);\n\n\ttp->event = kzalloc(size, GFP_KERNEL);\n\tif (!tp->event)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&tp->event->files);\n\tINIT_LIST_HEAD(&tp->event->class.fields);\n\tINIT_LIST_HEAD(&tp->event->probes);\n\tINIT_LIST_HEAD(&tp->list);\n\tlist_add(&tp->list, &tp->event->probes);\n\n\tcall = trace_probe_event_call(tp);\n\tcall->class = &tp->event->class;\n\tcall->name = kstrdup(event, GFP_KERNEL);\n\tif (!call->name) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ttp->event->class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tp->event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\ttrace_probe_cleanup(tp);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_init(struct trace_probe *tp, const char *event,\n\t\t     const char *group, bool alloc_filter)\n{\n\tstruct trace_event_call *call;\n\tsize_t size = sizeof(struct trace_probe_event);\n\tint ret = 0;\n\n\tif (!event || !group)\n\t\treturn -EINVAL;\n\n\tif (alloc_filter)\n\t\tsize += sizeof(struct trace_uprobe_filter);\n\n\ttp->event = kzalloc(size, GFP_KERNEL);\n\tif (!tp->event)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&tp->event->files);\n\tINIT_LIST_HEAD(&tp->event->class.fields);\n\tINIT_LIST_HEAD(&tp->event->probes);\n\tINIT_LIST_HEAD(&tp->list);\n\tlist_add(&tp->list, &tp->event->probes);\n\n\tcall = trace_probe_event_call(tp);\n\tcall->class = &tp->event->class;\n\tcall->name = kstrdup(event, GFP_KERNEL);\n\tif (!call->name) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ttp->event->class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tp->event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\ttrace_probe_cleanup(tp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tk->rp.kp.list"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&tk->rp.kp.hlist"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "symbol",
            "GFP_KERNEL"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "unsignedlong"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "struct_size(tk, tp.args, nargs)",
            "GFP_KERNEL"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "tk",
            "tp.args",
            "nargs"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic struct trace_kprobe *alloc_trace_kprobe(const char *group,\n\t\t\t\t\t     const char *event,\n\t\t\t\t\t     void *addr,\n\t\t\t\t\t     const char *symbol,\n\t\t\t\t\t     unsigned long offs,\n\t\t\t\t\t     int maxactive,\n\t\t\t\t\t     int nargs, bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret = -ENOMEM;\n\n\ttk = kzalloc(struct_size(tk, tp.args, nargs), GFP_KERNEL);\n\tif (!tk)\n\t\treturn ERR_PTR(ret);\n\n\ttk->nhit = alloc_percpu(unsigned long);\n\tif (!tk->nhit)\n\t\tgoto error;\n\n\tif (symbol) {\n\t\ttk->symbol = kstrdup(symbol, GFP_KERNEL);\n\t\tif (!tk->symbol)\n\t\t\tgoto error;\n\t\ttk->rp.kp.symbol_name = tk->symbol;\n\t\ttk->rp.kp.offset = offs;\n\t} else\n\t\ttk->rp.kp.addr = addr;\n\n\tif (is_return)\n\t\ttk->rp.handler = kretprobe_dispatcher;\n\telse\n\t\ttk->rp.kp.pre_handler = kprobe_dispatcher;\n\n\ttk->rp.maxactive = maxactive;\n\tINIT_HLIST_NODE(&tk->rp.kp.hlist);\n\tINIT_LIST_HEAD(&tk->rp.kp.list);\n\n\tret = trace_probe_init(&tk->tp, event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tk->devent, &trace_kprobe_ops);\n\treturn tk;\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "free_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "241-249",
    "snippet": "static void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tk"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "tk->nhit"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_cleanup",
          "args": [
            "&tk->tp"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1009-1018",
          "snippet": "void trace_probe_cleanup(struct trace_probe *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tp->args[i]);\n\n\tif (tp->event)\n\t\ttrace_probe_unlink(tp);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid trace_probe_cleanup(struct trace_probe *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tp->args[i]);\n\n\tif (tp->event)\n\t\ttrace_probe_unlink(tp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\n{\n\tif (tk) {\n\t\ttrace_probe_cleanup(&tk->tp);\n\t\tkfree(tk->symbol);\n\t\tfree_percpu(tk->nhit);\n\t\tkfree(tk);\n\t}\n}"
  },
  {
    "function_name": "trace_kprobe_error_injectable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "226-232",
    "snippet": "bool trace_kprobe_error_injectable(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = trace_kprobe_primary_from_call(call);\n\n\treturn tk ? within_error_injection_list(trace_kprobe_address(tk)) :\n\t       false;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "within_error_injection_list",
          "args": [
            "trace_kprobe_address(tk)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_address",
          "args": [
            "tk"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "189-203",
          "snippet": "static nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "205-215",
          "snippet": "trace_kprobe *\ntrace_kprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_kprobe, tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\ntrace_kprobe *\ntrace_kprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_kprobe, tp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nbool trace_kprobe_error_injectable(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = trace_kprobe_primary_from_call(call);\n\n\treturn tk ? within_error_injection_list(trace_kprobe_address(tk)) :\n\t       false;\n}"
  },
  {
    "function_name": "trace_kprobe_on_func_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "217-224",
    "snippet": "bool trace_kprobe_on_func_entry(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = trace_kprobe_primary_from_call(call);\n\n\treturn tk ? (kprobe_on_func_entry(tk->rp.kp.addr,\n\t\t\ttk->rp.kp.addr ? NULL : tk->rp.kp.symbol_name,\n\t\t\ttk->rp.kp.addr ? 0 : tk->rp.kp.offset) == 0) : false;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_on_func_entry",
          "args": [
            "tk->rp.kp.addr",
            "tk->rp.kp.addr ? NULL : tk->rp.kp.symbol_name",
            "tk->rp.kp.addr ? 0 : tk->rp.kp.offset"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_on_func_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2068-2082",
          "snippet": "int kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn PTR_ERR(kp_addr);\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset))\n\t\treturn -ENOENT;\n\n\tif (!arch_kprobe_on_func_entry(offset))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn PTR_ERR(kp_addr);\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset))\n\t\treturn -ENOENT;\n\n\tif (!arch_kprobe_on_func_entry(offset))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "205-215",
          "snippet": "trace_kprobe *\ntrace_kprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_kprobe, tp);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\ntrace_kprobe *\ntrace_kprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_kprobe, tp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nbool trace_kprobe_on_func_entry(struct trace_event_call *call)\n{\n\tstruct trace_kprobe *tk = trace_kprobe_primary_from_call(call);\n\n\treturn tk ? (kprobe_on_func_entry(tk->rp.kp.addr,\n\t\t\ttk->rp.kp.addr ? NULL : tk->rp.kp.symbol_name,\n\t\t\ttk->rp.kp.addr ? 0 : tk->rp.kp.offset) == 0) : false;\n}"
  },
  {
    "function_name": "trace_kprobe_primary_from_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "205-215",
    "snippet": "trace_kprobe *\ntrace_kprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_kprobe, tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "tp",
            "structtrace_kprobe",
            "tp"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\n\ntrace_kprobe *\ntrace_kprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_kprobe, tp);\n}"
  },
  {
    "function_name": "trace_kprobe_address",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "189-203",
    "snippet": "static nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "trace_kprobe_symbol(tk)"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4466-4487",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_symbol",
          "args": [
            "tk"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "89-92",
          "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline\nunsigned long trace_kprobe_address(struct trace_kprobe *tk)\n{\n\tunsigned long addr;\n\n\tif (tk->symbol) {\n\t\taddr = (unsigned long)\n\t\t\tkallsyms_lookup_name(trace_kprobe_symbol(tk));\n\t\tif (addr)\n\t\t\taddr += tk->rp.kp.offset;\n\t} else {\n\t\taddr = (unsigned long)tk->rp.kp.addr;\n\t}\n\treturn addr;\n}"
  },
  {
    "function_name": "trace_kprobe_is_registered",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "182-186",
    "snippet": "static nokprobe_inline bool trace_kprobe_is_registered(struct trace_kprobe *tk)\n{\n\treturn !(list_empty(&tk->rp.kp.list) &&\n\t\t hlist_unhashed(&tk->rp.kp.hlist));\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&tk->rp.kp.hlist"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tk->rp.kp.list"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_registered(struct trace_kprobe *tk)\n{\n\treturn !(list_empty(&tk->rp.kp.list) &&\n\t\t hlist_unhashed(&tk->rp.kp.hlist));\n}"
  },
  {
    "function_name": "trace_kprobe_nhit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "171-180",
    "snippet": "static nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\n{\n\tunsigned long nhit = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tnhit += *per_cpu_ptr(tk->nhit, cpu);\n\n\treturn nhit;\n}"
  },
  {
    "function_name": "trace_kprobe_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "161-169",
    "snippet": "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct trace_kprobe *tk = to_trace_kprobe(ev);\n\n\treturn strcmp(trace_probe_name(&tk->tp), event) == 0 &&\n\t    (!system || strcmp(trace_probe_group_name(&tk->tp), system) == 0) &&\n\t    trace_kprobe_match_command_head(tk, argc, argv);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_kprobe_release(struct dyn_event *ev);",
      "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kprobe_match_command_head",
          "args": [
            "tk",
            "argc",
            "argv"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_match_command_head",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "139-159",
          "snippet": "static bool trace_kprobe_match_command_head(struct trace_kprobe *tk,\n\t\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\n\tif (!argc)\n\t\treturn true;\n\n\tif (!tk->symbol)\n\t\tsnprintf(buf, sizeof(buf), \"0x%p\", tk->rp.kp.addr);\n\telse if (tk->rp.kp.offset)\n\t\tsnprintf(buf, sizeof(buf), \"%s+%u\",\n\t\t\t trace_kprobe_symbol(tk), tk->rp.kp.offset);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"%s\", trace_kprobe_symbol(tk));\n\tif (strcmp(buf, argv[0]))\n\t\treturn false;\n\targc--; argv++;\n\n\treturn trace_probe_match_command_args(&tk->tp, argc, argv);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic bool trace_kprobe_match_command_head(struct trace_kprobe *tk,\n\t\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\n\tif (!argc)\n\t\treturn true;\n\n\tif (!tk->symbol)\n\t\tsnprintf(buf, sizeof(buf), \"0x%p\", tk->rp.kp.addr);\n\telse if (tk->rp.kp.offset)\n\t\tsnprintf(buf, sizeof(buf), \"%s+%u\",\n\t\t\t trace_kprobe_symbol(tk), tk->rp.kp.offset);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"%s\", trace_kprobe_symbol(tk));\n\tif (strcmp(buf, argv[0]))\n\t\treturn false;\n\targc--; argv++;\n\n\treturn trace_probe_match_command_args(&tk->tp, argc, argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "trace_probe_group_name(&tk->tp)",
            "system"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_group_name",
          "args": [
            "&tk->tp"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_group_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "284-287",
          "snippet": "static inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&tk->tp"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_kprobe",
          "args": [
            "ev"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "70-73",
          "snippet": "static struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_kprobe_release(struct dyn_event *ev);",
            "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct trace_kprobe *tk = to_trace_kprobe(ev);\n\n\treturn strcmp(trace_probe_name(&tk->tp), event) == 0 &&\n\t    (!system || strcmp(trace_probe_group_name(&tk->tp), system) == 0) &&\n\t    trace_kprobe_match_command_head(tk, argc, argv);\n}"
  },
  {
    "function_name": "trace_kprobe_match_command_head",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "139-159",
    "snippet": "static bool trace_kprobe_match_command_head(struct trace_kprobe *tk,\n\t\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\n\tif (!argc)\n\t\treturn true;\n\n\tif (!tk->symbol)\n\t\tsnprintf(buf, sizeof(buf), \"0x%p\", tk->rp.kp.addr);\n\telse if (tk->rp.kp.offset)\n\t\tsnprintf(buf, sizeof(buf), \"%s+%u\",\n\t\t\t trace_kprobe_symbol(tk), tk->rp.kp.offset);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"%s\", trace_kprobe_symbol(tk));\n\tif (strcmp(buf, argv[0]))\n\t\treturn false;\n\targc--; argv++;\n\n\treturn trace_probe_match_command_args(&tk->tp, argc, argv);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_match_command_args",
          "args": [
            "&tk->tp",
            "argc",
            "argv"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_match_command_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1176-1192",
          "snippet": "bool trace_probe_match_command_args(struct trace_probe *tp,\n\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint i;\n\n\tif (tp->nr_args < argc)\n\t\treturn false;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"%s=%s\",\n\t\t\t tp->args[i].name, tp->args[i].comm);\n\t\tif (strcmp(buf, argv[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nbool trace_probe_match_command_args(struct trace_probe *tp,\n\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint i;\n\n\tif (tp->nr_args < argc)\n\t\treturn false;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"%s=%s\",\n\t\t\t tp->args[i].name, tp->args[i].comm);\n\t\tif (strcmp(buf, argv[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "argv[0]"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%s\"",
            "trace_kprobe_symbol(tk)"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kprobe_symbol",
          "args": [
            "tk"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "89-92",
          "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%s+%u\"",
            "trace_kprobe_symbol(tk)",
            "tk->rp.kp.offset"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"0x%p\"",
            "tk->rp.kp.addr"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic bool trace_kprobe_match_command_head(struct trace_kprobe *tk,\n\t\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\n\tif (!argc)\n\t\treturn true;\n\n\tif (!tk->symbol)\n\t\tsnprintf(buf, sizeof(buf), \"0x%p\", tk->rp.kp.addr);\n\telse if (tk->rp.kp.offset)\n\t\tsnprintf(buf, sizeof(buf), \"%s+%u\",\n\t\t\t trace_kprobe_symbol(tk), tk->rp.kp.offset);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"%s\", trace_kprobe_symbol(tk));\n\tif (strcmp(buf, argv[0]))\n\t\treturn false;\n\targc--; argv++;\n\n\treturn trace_probe_match_command_args(&tk->tp, argc, argv);\n}"
  },
  {
    "function_name": "trace_kprobe_is_busy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "132-137",
    "snippet": "static bool trace_kprobe_is_busy(struct dyn_event *ev)\n{\n\tstruct trace_kprobe *tk = to_trace_kprobe(ev);\n\n\treturn trace_probe_is_enabled(&tk->tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_kprobe_release(struct dyn_event *ev);",
      "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&tk->tp"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_kprobe",
          "args": [
            "ev"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "70-73",
          "snippet": "static struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
            "static int trace_kprobe_release(struct dyn_event *ev);",
            "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
            "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static nokprobe_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev)\n{\n\tstruct trace_kprobe *tk = to_trace_kprobe(ev);\n\n\treturn trace_probe_is_enabled(&tk->tp);\n}"
  },
  {
    "function_name": "trace_kprobe_module_exist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "113-130",
    "snippet": "static nokprobe_inline bool trace_kprobe_module_exist(struct trace_kprobe *tk)\n{\n\tchar *p;\n\tbool ret;\n\n\tif (!tk->symbol)\n\t\treturn false;\n\tp = strchr(tk->symbol, ':');\n\tif (!p)\n\t\treturn true;\n\t*p = '\\0';\n\trcu_read_lock_sched();\n\tret = !!find_module(tk->symbol);\n\trcu_read_unlock_sched();\n\t*p = ':';\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_module",
          "args": [
            "tk->symbol"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "find_module",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "578-581",
          "snippet": "struct module *find_module(const char *name)\n{\n\treturn find_module_all(name, strlen(name), false);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstruct module *find_module(const char *name)\n{\n\treturn find_module_all(name, strlen(name), false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tk->symbol",
            "':'"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_module_exist(struct trace_kprobe *tk)\n{\n\tchar *p;\n\tbool ret;\n\n\tif (!tk->symbol)\n\t\treturn false;\n\tp = strchr(tk->symbol, ':');\n\tif (!p)\n\t\treturn true;\n\t*p = '\\0';\n\trcu_read_lock_sched();\n\tret = !!find_module(tk->symbol);\n\trcu_read_unlock_sched();\n\t*p = ':';\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_kprobe_within_module",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "104-111",
    "snippet": "static nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(module_name(mod));\n\tconst char *name = trace_kprobe_symbol(tk);\n\n\treturn strncmp(module_name(mod), name, len) == 0 && name[len] == ':';\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "module_name(mod)",
            "name",
            "len"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_name",
          "args": [
            "mod"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "pi_get_module_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/index.c",
          "lines": "133-136",
          "snippet": "static const char *pi_get_module_name(struct module *mod)\n{\n\treturn \"vmlinux\";\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/string_helpers.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/string_helpers.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n\nstatic const char *pi_get_module_name(struct module *mod)\n{\n\treturn \"vmlinux\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kprobe_symbol",
          "args": [
            "tk"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "89-92",
          "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline struct",
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "module_name(mod)"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
          "lines": "1228-1245",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(module_name(mod));\n\tconst char *name = trace_kprobe_symbol(tk);\n\n\treturn strncmp(module_name(mod), name, len) == 0 && name[len] == ':';\n}"
  },
  {
    "function_name": "trace_kprobe_has_gone",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "99-102",
    "snippet": "static nokprobe_inline bool trace_kprobe_has_gone(struct trace_kprobe *tk)\n{\n\treturn kprobe_gone(&tk->rp.kp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "&tk->rp.kp"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_has_gone(struct trace_kprobe *tk)\n{\n\treturn kprobe_gone(&tk->rp.kp);\n}"
  },
  {
    "function_name": "trace_kprobe_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "94-97",
    "snippet": "static nokprobe_inline unsigned long trace_kprobe_offset(struct trace_kprobe *tk)\n{\n\treturn tk->rp.kp.offset;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline unsigned long trace_kprobe_offset(struct trace_kprobe *tk)\n{\n\treturn tk->rp.kp.offset;\n}"
  },
  {
    "function_name": "trace_kprobe_symbol",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "89-92",
    "snippet": "static nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\n{\n\treturn tk->symbol ? tk->symbol : \"unknown\";\n}"
  },
  {
    "function_name": "trace_kprobe_is_return",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "84-87",
    "snippet": "static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nokprobe_inline struct",
      "static int register_kprobe_event(struct trace_kprobe *tk);",
      "static int unregister_kprobe_event(struct trace_kprobe *tk);",
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic nokprobe_inline struct;\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\n{\n\treturn tk->rp.handler != NULL;\n}"
  },
  {
    "function_name": "to_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "70-73",
    "snippet": "static struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_kprobe_release(struct dyn_event *ev);",
      "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static nokprobe_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ev",
            "structtrace_kprobe",
            "devent"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic nokprobe_inline struct;\n\nstatic struct trace_kprobe *to_trace_kprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_kprobe, devent);\n}"
  },
  {
    "function_name": "is_trace_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "65-68",
    "snippet": "static bool is_trace_kprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_kprobe_ops;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);",
      "static int trace_kprobe_release(struct dyn_event *ev);",
      "static bool trace_kprobe_is_busy(struct dyn_event *ev);",
      "static bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};",
      "static nokprobe_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int trace_kprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_kprobe_release(struct dyn_event *ev);\nstatic bool trace_kprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_kprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic struct dyn_event_operations trace_kprobe_ops = {\n\t.create = trace_kprobe_create,\n\t.show = trace_kprobe_show,\n\t.is_busy = trace_kprobe_is_busy,\n\t.free = trace_kprobe_release,\n\t.match = trace_kprobe_match,\n};\nstatic nokprobe_inline struct;\n\nstatic bool is_trace_kprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_kprobe_ops;\n}"
  },
  {
    "function_name": "set_kprobe_boot_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kprobe.c",
    "lines": "30-36",
    "snippet": "static int __init set_kprobe_boot_events(char *str)\n{\n\tstrlcpy(kprobe_boot_events_buf, str, COMMAND_LINE_SIZE);\n\tdisable_tracing_selftest(\"running kprobe events\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_kprobe_selftest.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */",
      "#include <linux/error-injection.h>",
      "#include <linux/rculist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char kprobe_boot_events_buf[COMMAND_LINE_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_tracing_selftest",
          "args": [
            "\"running kprobe events\""
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "disable_tracing_selftest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "78-84",
          "snippet": "void __init disable_tracing_selftest(const char *reason)\n{\n\tif (!tracing_selftest_disabled) {\n\t\ttracing_selftest_disabled = true;\n\t\tpr_info(\"Ftrace startup test is disabled due to %s\\n\", reason);\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nvoid __init disable_tracing_selftest(const char *reason)\n{\n\tif (!tracing_selftest_disabled) {\n\t\ttracing_selftest_disabled = true;\n\t\tpr_info(\"Ftrace startup test is disabled due to %s\\n\", reason);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "kprobe_boot_events_buf",
            "str",
            "COMMAND_LINE_SIZE"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include \"trace_dynevent.h\"\n#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/bpf-cgroup.h>\n\nstatic char kprobe_boot_events_buf[COMMAND_LINE_SIZE];\n\nstatic int __init set_kprobe_boot_events(char *str)\n{\n\tstrlcpy(kprobe_boot_events_buf, str, COMMAND_LINE_SIZE);\n\tdisable_tracing_selftest(\"running kprobe events\");\n\n\treturn 0;\n}"
  }
]