[
  {
    "function_name": "irq_work_init_threads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "311-316",
    "snippet": "static __init int irq_work_init_threads(void)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tBUG_ON(smpboot_register_percpu_thread(&irqwork_threads));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct smp_hotplug_thread irqwork_threads = {\n\t.store                  = &irq_workd,\n\t.setup\t\t\t= irq_workd_setup,\n\t.thread_should_run      = irq_workd_should_run,\n\t.thread_fn              = run_irq_workd,\n\t.thread_comm            = \"irq_work/%u\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "smpboot_register_percpu_thread(&irqwork_threads)"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smpboot_register_percpu_thread",
          "args": [
            "&irqwork_threads"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "smpboot_register_percpu_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smpboot.c",
          "lines": "289-309",
          "snippet": "int smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(hotplug_threads);",
            "static DEFINE_MUTEX(smpboot_threads_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic LIST_HEAD(hotplug_threads);\nstatic DEFINE_MUTEX(smpboot_threads_lock);\n\nint smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic struct smp_hotplug_thread irqwork_threads = {\n\t.store                  = &irq_workd,\n\t.setup\t\t\t= irq_workd_setup,\n\t.thread_should_run      = irq_workd_should_run,\n\t.thread_fn              = run_irq_workd,\n\t.thread_comm            = \"irq_work/%u\",\n};\n\nstatic __init int irq_work_init_threads(void)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tBUG_ON(smpboot_register_percpu_thread(&irqwork_threads));\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_workd_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "298-301",
    "snippet": "static void irq_workd_setup(unsigned int cpu)\n{\n\tsched_set_fifo_low(current);\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_set_fifo_low",
          "args": [
            "current"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_fifo_low",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7599-7603",
          "snippet": "void sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic void irq_workd_setup(unsigned int cpu)\n{\n\tsched_set_fifo_low(current);\n}"
  },
  {
    "function_name": "run_irq_workd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "293-296",
    "snippet": "static void run_irq_workd(unsigned int cpu)\n{\n\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_run_list",
          "args": [
            "this_cpu_ptr(&lazy_list)"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_run_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "225-243",
          "snippet": "static void irq_work_run_list(struct llist_head *list)\n{\n\tstruct irq_work *work, *tmp;\n\tstruct llist_node *llnode;\n\n\t/*\n\t * On PREEMPT_RT IRQ-work which is not marked as HARD will be processed\n\t * in a per-CPU thread in preemptible context. Only the items which are\n\t * marked as IRQ_WORK_HARD_IRQ will be processed in hardirq context.\n\t */\n\tBUG_ON(!irqs_disabled() && !IS_ENABLED(CONFIG_PREEMPT_RT));\n\n\tif (llist_empty(list))\n\t\treturn;\n\n\tllnode = llist_del_all(list);\n\tllist_for_each_entry_safe(work, tmp, llnode, node.llist)\n\t\tirq_work_single(work);\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic void irq_work_run_list(struct llist_head *list)\n{\n\tstruct irq_work *work, *tmp;\n\tstruct llist_node *llnode;\n\n\t/*\n\t * On PREEMPT_RT IRQ-work which is not marked as HARD will be processed\n\t * in a per-CPU thread in preemptible context. Only the items which are\n\t * marked as IRQ_WORK_HARD_IRQ will be processed in hardirq context.\n\t */\n\tBUG_ON(!irqs_disabled() && !IS_ENABLED(CONFIG_PREEMPT_RT));\n\n\tif (llist_empty(list))\n\t\treturn;\n\n\tllnode = llist_del_all(list);\n\tllist_for_each_entry_safe(work, tmp, llnode, node.llist)\n\t\tirq_work_single(work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&lazy_list"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nstatic void run_irq_workd(unsigned int cpu)\n{\n\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n}"
  },
  {
    "function_name": "irq_work_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "276-290",
    "snippet": "void irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\tmight_sleep();\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt()) {\n\t\trcuwait_wait_event(&work->irqwait, !irq_work_is_busy(work),\n\t\t\t\t   TASK_UNINTERRUPTIBLE);\n\t\treturn;\n\t}\n\n\twhile (irq_work_is_busy(work))\n\t\tcpu_relax();\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_is_busy",
          "args": [
            "work"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcuwait_wait_event",
          "args": [
            "&work->irqwait",
            "!irq_work_is_busy(work)",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_is_busy",
          "args": [
            "work"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_work_has_interrupt",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_is_hard",
          "args": [
            "work"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\tmight_sleep();\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt()) {\n\t\trcuwait_wait_event(&work->irqwait, !irq_work_is_busy(work),\n\t\t\t\t   TASK_UNINTERRUPTIBLE);\n\t\treturn;\n\t}\n\n\twhile (irq_work_is_busy(work))\n\t\tcpu_relax();\n}"
  },
  {
    "function_name": "irq_work_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "259-270",
    "snippet": "void irq_work_tick(void)\n{\n\tstruct llist_head *raised = this_cpu_ptr(&raised_list);\n\n\tif (!llist_empty(raised) && !arch_irq_work_has_interrupt())\n\t\tirq_work_run_list(raised);\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n\telse\n\t\twake_irq_workd();\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct llist_head, raised_list);",
      "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_irq_workd",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "wake_irq_workd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "29-35",
          "snippet": "static void wake_irq_workd(void)\n{\n\tstruct task_struct *tsk = __this_cpu_read(irq_workd);\n\n\tif (!llist_empty(this_cpu_ptr(&lazy_list)) && tsk)\n\t\twake_up_process(tsk);\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);",
            "static DEFINE_PER_CPU(struct task_struct *, irq_workd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\nstatic DEFINE_PER_CPU(struct task_struct *, irq_workd);\n\nstatic void wake_irq_workd(void)\n{\n\tstruct task_struct *tsk = __this_cpu_read(irq_workd);\n\n\tif (!llist_empty(this_cpu_ptr(&lazy_list)) && tsk)\n\t\twake_up_process(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_work_run_list",
          "args": [
            "this_cpu_ptr(&lazy_list)"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_run_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "225-243",
          "snippet": "static void irq_work_run_list(struct llist_head *list)\n{\n\tstruct irq_work *work, *tmp;\n\tstruct llist_node *llnode;\n\n\t/*\n\t * On PREEMPT_RT IRQ-work which is not marked as HARD will be processed\n\t * in a per-CPU thread in preemptible context. Only the items which are\n\t * marked as IRQ_WORK_HARD_IRQ will be processed in hardirq context.\n\t */\n\tBUG_ON(!irqs_disabled() && !IS_ENABLED(CONFIG_PREEMPT_RT));\n\n\tif (llist_empty(list))\n\t\treturn;\n\n\tllnode = llist_del_all(list);\n\tllist_for_each_entry_safe(work, tmp, llnode, node.llist)\n\t\tirq_work_single(work);\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic void irq_work_run_list(struct llist_head *list)\n{\n\tstruct irq_work *work, *tmp;\n\tstruct llist_node *llnode;\n\n\t/*\n\t * On PREEMPT_RT IRQ-work which is not marked as HARD will be processed\n\t * in a per-CPU thread in preemptible context. Only the items which are\n\t * marked as IRQ_WORK_HARD_IRQ will be processed in hardirq context.\n\t */\n\tBUG_ON(!irqs_disabled() && !IS_ENABLED(CONFIG_PREEMPT_RT));\n\n\tif (llist_empty(list))\n\t\treturn;\n\n\tllnode = llist_del_all(list);\n\tllist_for_each_entry_safe(work, tmp, llnode, node.llist)\n\t\tirq_work_single(work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&lazy_list"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_work_has_interrupt",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "raised"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&raised_list"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nvoid irq_work_tick(void)\n{\n\tstruct llist_head *raised = this_cpu_ptr(&raised_list);\n\n\tif (!llist_empty(raised) && !arch_irq_work_has_interrupt())\n\t\tirq_work_run_list(raised);\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n\telse\n\t\twake_irq_workd();\n}"
  },
  {
    "function_name": "irq_work_run",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "249-256",
    "snippet": "void irq_work_run(void)\n{\n\tirq_work_run_list(this_cpu_ptr(&raised_list));\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n\telse\n\t\twake_irq_workd();\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct llist_head, raised_list);",
      "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_irq_workd",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "wake_irq_workd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "29-35",
          "snippet": "static void wake_irq_workd(void)\n{\n\tstruct task_struct *tsk = __this_cpu_read(irq_workd);\n\n\tif (!llist_empty(this_cpu_ptr(&lazy_list)) && tsk)\n\t\twake_up_process(tsk);\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);",
            "static DEFINE_PER_CPU(struct task_struct *, irq_workd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\nstatic DEFINE_PER_CPU(struct task_struct *, irq_workd);\n\nstatic void wake_irq_workd(void)\n{\n\tstruct task_struct *tsk = __this_cpu_read(irq_workd);\n\n\tif (!llist_empty(this_cpu_ptr(&lazy_list)) && tsk)\n\t\twake_up_process(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_work_run_list",
          "args": [
            "this_cpu_ptr(&lazy_list)"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_run_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "225-243",
          "snippet": "static void irq_work_run_list(struct llist_head *list)\n{\n\tstruct irq_work *work, *tmp;\n\tstruct llist_node *llnode;\n\n\t/*\n\t * On PREEMPT_RT IRQ-work which is not marked as HARD will be processed\n\t * in a per-CPU thread in preemptible context. Only the items which are\n\t * marked as IRQ_WORK_HARD_IRQ will be processed in hardirq context.\n\t */\n\tBUG_ON(!irqs_disabled() && !IS_ENABLED(CONFIG_PREEMPT_RT));\n\n\tif (llist_empty(list))\n\t\treturn;\n\n\tllnode = llist_del_all(list);\n\tllist_for_each_entry_safe(work, tmp, llnode, node.llist)\n\t\tirq_work_single(work);\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic void irq_work_run_list(struct llist_head *list)\n{\n\tstruct irq_work *work, *tmp;\n\tstruct llist_node *llnode;\n\n\t/*\n\t * On PREEMPT_RT IRQ-work which is not marked as HARD will be processed\n\t * in a per-CPU thread in preemptible context. Only the items which are\n\t * marked as IRQ_WORK_HARD_IRQ will be processed in hardirq context.\n\t */\n\tBUG_ON(!irqs_disabled() && !IS_ENABLED(CONFIG_PREEMPT_RT));\n\n\tif (llist_empty(list))\n\t\treturn;\n\n\tllnode = llist_del_all(list);\n\tllist_for_each_entry_safe(work, tmp, llnode, node.llist)\n\t\tirq_work_single(work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&lazy_list"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&raised_list"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nvoid irq_work_run(void)\n{\n\tirq_work_run_list(this_cpu_ptr(&raised_list));\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n\telse\n\t\twake_irq_workd();\n}"
  },
  {
    "function_name": "irq_work_run_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "225-243",
    "snippet": "static void irq_work_run_list(struct llist_head *list)\n{\n\tstruct irq_work *work, *tmp;\n\tstruct llist_node *llnode;\n\n\t/*\n\t * On PREEMPT_RT IRQ-work which is not marked as HARD will be processed\n\t * in a per-CPU thread in preemptible context. Only the items which are\n\t * marked as IRQ_WORK_HARD_IRQ will be processed in hardirq context.\n\t */\n\tBUG_ON(!irqs_disabled() && !IS_ENABLED(CONFIG_PREEMPT_RT));\n\n\tif (llist_empty(list))\n\t\treturn;\n\n\tllnode = llist_del_all(list);\n\tllist_for_each_entry_safe(work, tmp, llnode, node.llist)\n\t\tirq_work_single(work);\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_single",
          "args": [
            "work"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "191-223",
          "snippet": "void irq_work_single(void *arg)\n{\n\tstruct irq_work *work = arg;\n\tint flags;\n\n\t/*\n\t * Clear the PENDING bit, after this point the @work can be re-used.\n\t * The PENDING bit acts as a lock, and we own it, so we can clear it\n\t * without atomic ops.\n\t */\n\tflags = atomic_read(&work->node.a_flags);\n\tflags &= ~IRQ_WORK_PENDING;\n\tatomic_set(&work->node.a_flags, flags);\n\n\t/*\n\t * See irq_work_claim().\n\t */\n\tsmp_mb();\n\n\tlockdep_irq_work_enter(flags);\n\twork->func(work);\n\tlockdep_irq_work_exit(flags);\n\n\t/*\n\t * Clear the BUSY bit, if set, and return to the free state if no-one\n\t * else claimed it meanwhile.\n\t */\n\t(void)atomic_cmpxchg(&work->node.a_flags, flags, flags & ~IRQ_WORK_BUSY);\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt())\n\t\trcuwait_wake_up(&work->irqwait);\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid irq_work_single(void *arg)\n{\n\tstruct irq_work *work = arg;\n\tint flags;\n\n\t/*\n\t * Clear the PENDING bit, after this point the @work can be re-used.\n\t * The PENDING bit acts as a lock, and we own it, so we can clear it\n\t * without atomic ops.\n\t */\n\tflags = atomic_read(&work->node.a_flags);\n\tflags &= ~IRQ_WORK_PENDING;\n\tatomic_set(&work->node.a_flags, flags);\n\n\t/*\n\t * See irq_work_claim().\n\t */\n\tsmp_mb();\n\n\tlockdep_irq_work_enter(flags);\n\twork->func(work);\n\tlockdep_irq_work_exit(flags);\n\n\t/*\n\t * Clear the BUSY bit, if set, and return to the free state if no-one\n\t * else claimed it meanwhile.\n\t */\n\t(void)atomic_cmpxchg(&work->node.a_flags, flags, flags & ~IRQ_WORK_BUSY);\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt())\n\t\trcuwait_wake_up(&work->irqwait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry_safe",
          "args": [
            "work",
            "tmp",
            "llnode",
            "node.llist"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_del_all",
          "args": [
            "list"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "list"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!irqs_disabled() && !IS_ENABLED(CONFIG_PREEMPT_RT)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic void irq_work_run_list(struct llist_head *list)\n{\n\tstruct irq_work *work, *tmp;\n\tstruct llist_node *llnode;\n\n\t/*\n\t * On PREEMPT_RT IRQ-work which is not marked as HARD will be processed\n\t * in a per-CPU thread in preemptible context. Only the items which are\n\t * marked as IRQ_WORK_HARD_IRQ will be processed in hardirq context.\n\t */\n\tBUG_ON(!irqs_disabled() && !IS_ENABLED(CONFIG_PREEMPT_RT));\n\n\tif (llist_empty(list))\n\t\treturn;\n\n\tllnode = llist_del_all(list);\n\tllist_for_each_entry_safe(work, tmp, llnode, node.llist)\n\t\tirq_work_single(work);\n}"
  },
  {
    "function_name": "irq_work_single",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "191-223",
    "snippet": "void irq_work_single(void *arg)\n{\n\tstruct irq_work *work = arg;\n\tint flags;\n\n\t/*\n\t * Clear the PENDING bit, after this point the @work can be re-used.\n\t * The PENDING bit acts as a lock, and we own it, so we can clear it\n\t * without atomic ops.\n\t */\n\tflags = atomic_read(&work->node.a_flags);\n\tflags &= ~IRQ_WORK_PENDING;\n\tatomic_set(&work->node.a_flags, flags);\n\n\t/*\n\t * See irq_work_claim().\n\t */\n\tsmp_mb();\n\n\tlockdep_irq_work_enter(flags);\n\twork->func(work);\n\tlockdep_irq_work_exit(flags);\n\n\t/*\n\t * Clear the BUSY bit, if set, and return to the free state if no-one\n\t * else claimed it meanwhile.\n\t */\n\t(void)atomic_cmpxchg(&work->node.a_flags, flags, flags & ~IRQ_WORK_BUSY);\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt())\n\t\trcuwait_wake_up(&work->irqwait);\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcuwait_wake_up",
          "args": [
            "&work->irqwait"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "rcuwait_wake_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "234-260",
          "snippet": "int rcuwait_wake_up(struct rcuwait *w)\n{\n\tint ret = 0;\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\n\t/*\n\t * Order condition vs @task, such that everything prior to the load\n\t * of @task is visible. This is the condition as to why the user called\n\t * rcuwait_wake() in the first place. Pairs with set_current_state()\n\t * barrier (A) in rcuwait_wait_event().\n\t *\n\t *    WAIT                WAKE\n\t *    [S] tsk = current\t  [S] cond = true\n\t *        MB (A)\t      MB (B)\n\t *    [L] cond\t\t  [L] tsk\n\t */\n\tsmp_mb(); /* (B) */\n\n\ttask = rcu_dereference(w->task);\n\tif (task)\n\t\tret = wake_up_process(task);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint rcuwait_wake_up(struct rcuwait *w)\n{\n\tint ret = 0;\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\n\t/*\n\t * Order condition vs @task, such that everything prior to the load\n\t * of @task is visible. This is the condition as to why the user called\n\t * rcuwait_wake() in the first place. Pairs with set_current_state()\n\t * barrier (A) in rcuwait_wait_event().\n\t *\n\t *    WAIT                WAKE\n\t *    [S] tsk = current\t  [S] cond = true\n\t *        MB (A)\t      MB (B)\n\t *    [L] cond\t\t  [L] tsk\n\t */\n\tsmp_mb(); /* (B) */\n\n\ttask = rcu_dereference(w->task);\n\tif (task)\n\t\tret = wake_up_process(task);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_irq_work_has_interrupt",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_is_hard",
          "args": [
            "work"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&work->node.a_flags",
            "flags",
            "flags & ~IRQ_WORK_BUSY"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_irq_work_exit",
          "args": [
            "flags"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work->func",
          "args": [
            "work"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_irq_work_enter",
          "args": [
            "flags"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&work->node.a_flags",
            "flags"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&work->node.a_flags"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid irq_work_single(void *arg)\n{\n\tstruct irq_work *work = arg;\n\tint flags;\n\n\t/*\n\t * Clear the PENDING bit, after this point the @work can be re-used.\n\t * The PENDING bit acts as a lock, and we own it, so we can clear it\n\t * without atomic ops.\n\t */\n\tflags = atomic_read(&work->node.a_flags);\n\tflags &= ~IRQ_WORK_PENDING;\n\tatomic_set(&work->node.a_flags, flags);\n\n\t/*\n\t * See irq_work_claim().\n\t */\n\tsmp_mb();\n\n\tlockdep_irq_work_enter(flags);\n\twork->func(work);\n\tlockdep_irq_work_exit(flags);\n\n\t/*\n\t * Clear the BUSY bit, if set, and return to the free state if no-one\n\t * else claimed it meanwhile.\n\t */\n\t(void)atomic_cmpxchg(&work->node.a_flags, flags, flags & ~IRQ_WORK_BUSY);\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt())\n\t\trcuwait_wake_up(&work->irqwait);\n}"
  },
  {
    "function_name": "irq_work_needs_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "174-189",
    "snippet": "bool irq_work_needs_cpu(void)\n{\n\tstruct llist_head *raised, *lazy;\n\n\traised = this_cpu_ptr(&raised_list);\n\tlazy = this_cpu_ptr(&lazy_list);\n\n\tif (llist_empty(raised) || arch_irq_work_has_interrupt())\n\t\tif (llist_empty(lazy))\n\t\t\treturn false;\n\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct llist_head, raised_list);",
      "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu_is_offline(smp_processor_id())"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "smp_processor_id()"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "lazy"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_work_has_interrupt",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "raised"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&lazy_list"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&raised_list"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_needs_cpu(void)\n{\n\tstruct llist_head *raised, *lazy;\n\n\traised = this_cpu_ptr(&raised_list);\n\tlazy = this_cpu_ptr(&lazy_list);\n\n\tif (llist_empty(raised) || arch_irq_work_has_interrupt())\n\t\tif (llist_empty(lazy))\n\t\t\treturn false;\n\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\n\treturn true;\n}"
  },
  {
    "function_name": "irq_work_queue_on",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "127-172",
    "snippet": "bool irq_work_queue_on(struct irq_work *work, int cpu)\n{\n#ifndef CONFIG_SMP\n\treturn irq_work_queue(work);\n\n#else /* CONFIG_SMP: */\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(cpu));\n\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\tkasan_record_aux_stack(work);\n\n\tpreempt_disable();\n\tif (cpu != smp_processor_id()) {\n\t\t/* Arch remote IPI send/receive backend aren't NMI safe */\n\t\tWARN_ON_ONCE(in_nmi());\n\n\t\t/*\n\t\t * On PREEMPT_RT the items which are not marked as\n\t\t * IRQ_WORK_HARD_IRQ are added to the lazy list and a HARD work\n\t\t * item is used on the remote CPU to wake the thread.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t    !(atomic_read(&work->node.a_flags) & IRQ_WORK_HARD_IRQ)) {\n\n\t\t\tif (!llist_add(&work->node.llist, &per_cpu(lazy_list, cpu)))\n\t\t\t\tgoto out;\n\n\t\t\twork = &per_cpu(irq_work_wakeup, cpu);\n\t\t\tif (!irq_work_claim(work))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t__smp_call_single_queue(cpu, &work->node.llist);\n\t} else {\n\t\t__irq_work_queue_local(work);\n\t}\nout:\n\tpreempt_enable();\n\n\treturn true;\n#endif /* CONFIG_SMP */\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_work_queue_local",
          "args": [
            "work"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_work_queue_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "78-103",
          "snippet": "static void __irq_work_queue_local(struct irq_work *work)\n{\n\tstruct llist_head *list;\n\tbool rt_lazy_work = false;\n\tbool lazy_work = false;\n\tint work_flags;\n\n\twork_flags = atomic_read(&work->node.a_flags);\n\tif (work_flags & IRQ_WORK_LAZY)\n\t\tlazy_work = true;\n\telse if (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t !(work_flags & IRQ_WORK_HARD_IRQ))\n\t\trt_lazy_work = true;\n\n\tif (lazy_work || rt_lazy_work)\n\t\tlist = this_cpu_ptr(&lazy_list);\n\telse\n\t\tlist = this_cpu_ptr(&raised_list);\n\n\tif (!llist_add(&work->node.llist, list))\n\t\treturn;\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (!lazy_work || tick_nohz_tick_stopped())\n\t\tarch_irq_work_raise();\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nstatic void __irq_work_queue_local(struct irq_work *work)\n{\n\tstruct llist_head *list;\n\tbool rt_lazy_work = false;\n\tbool lazy_work = false;\n\tint work_flags;\n\n\twork_flags = atomic_read(&work->node.a_flags);\n\tif (work_flags & IRQ_WORK_LAZY)\n\t\tlazy_work = true;\n\telse if (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t !(work_flags & IRQ_WORK_HARD_IRQ))\n\t\trt_lazy_work = true;\n\n\tif (lazy_work || rt_lazy_work)\n\t\tlist = this_cpu_ptr(&lazy_list);\n\telse\n\t\tlist = this_cpu_ptr(&raised_list);\n\n\tif (!llist_add(&work->node.llist, list))\n\t\treturn;\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (!lazy_work || tick_nohz_tick_stopped())\n\t\tarch_irq_work_raise();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__smp_call_single_queue",
          "args": [
            "cpu",
            "&work->node.llist"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__smp_call_single_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "469-497",
          "snippet": "void __smp_call_single_queue(int cpu, struct llist_node *node)\n{\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\tif (static_branch_unlikely(&csdlock_debug_extended)) {\n\t\tunsigned int type;\n\n\t\ttype = CSD_TYPE(container_of(node, call_single_data_t,\n\t\t\t\t\t     node.llist));\n\t\tif (type == CSD_TYPE_SYNC || type == CSD_TYPE_ASYNC) {\n\t\t\t__smp_call_single_queue_debug(cpu, node);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(node, &per_cpu(call_single_queue, cpu)))\n\t\tsend_call_function_single_ipi(cpu);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\n\nvoid __smp_call_single_queue(int cpu, struct llist_node *node)\n{\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\tif (static_branch_unlikely(&csdlock_debug_extended)) {\n\t\tunsigned int type;\n\n\t\ttype = CSD_TYPE(container_of(node, call_single_data_t,\n\t\t\t\t\t     node.llist));\n\t\tif (type == CSD_TYPE_SYNC || type == CSD_TYPE_ASYNC) {\n\t\t\t__smp_call_single_queue_debug(cpu, node);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(node, &per_cpu(call_single_queue, cpu)))\n\t\tsend_call_function_single_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_work_claim",
          "args": [
            "work"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_claim",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "55-68",
          "snippet": "static bool irq_work_claim(struct irq_work *work)\n{\n\tint oflags;\n\n\toflags = atomic_fetch_or(IRQ_WORK_CLAIMED | CSD_TYPE_IRQ_WORK, &work->node.a_flags);\n\t/*\n\t * If the work is already pending, no need to raise the IPI.\n\t * The pairing smp_mb() in irq_work_single() makes sure\n\t * everything we did before is visible.\n\t */\n\tif (oflags & IRQ_WORK_PENDING)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic bool irq_work_claim(struct irq_work *work)\n{\n\tint oflags;\n\n\toflags = atomic_fetch_or(IRQ_WORK_CLAIMED | CSD_TYPE_IRQ_WORK, &work->node.a_flags);\n\t/*\n\t * If the work is already pending, no need to raise the IPI.\n\t * The pairing smp_mb() in irq_work_single() makes sure\n\t * everything we did before is visible.\n\t */\n\tif (oflags & IRQ_WORK_PENDING)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_work_wakeup",
            "cpu"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "&work->node.llist",
            "&per_cpu(lazy_list, cpu)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&work->node.a_flags"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_nmi()"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_record_aux_stack",
          "args": [
            "work"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu_is_offline(cpu)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "cpu"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "work"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "106-118",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue_on(struct irq_work *work, int cpu)\n{\n#ifndef CONFIG_SMP\n\treturn irq_work_queue(work);\n\n#else /* CONFIG_SMP: */\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(cpu));\n\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\tkasan_record_aux_stack(work);\n\n\tpreempt_disable();\n\tif (cpu != smp_processor_id()) {\n\t\t/* Arch remote IPI send/receive backend aren't NMI safe */\n\t\tWARN_ON_ONCE(in_nmi());\n\n\t\t/*\n\t\t * On PREEMPT_RT the items which are not marked as\n\t\t * IRQ_WORK_HARD_IRQ are added to the lazy list and a HARD work\n\t\t * item is used on the remote CPU to wake the thread.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t    !(atomic_read(&work->node.a_flags) & IRQ_WORK_HARD_IRQ)) {\n\n\t\t\tif (!llist_add(&work->node.llist, &per_cpu(lazy_list, cpu)))\n\t\t\t\tgoto out;\n\n\t\t\twork = &per_cpu(irq_work_wakeup, cpu);\n\t\t\tif (!irq_work_claim(work))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t__smp_call_single_queue(cpu, &work->node.llist);\n\t} else {\n\t\t__irq_work_queue_local(work);\n\t}\nout:\n\tpreempt_enable();\n\n\treturn true;\n#endif /* CONFIG_SMP */\n}"
  },
  {
    "function_name": "irq_work_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "106-118",
    "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_work_queue_local",
          "args": [
            "work"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_work_queue_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "78-103",
          "snippet": "static void __irq_work_queue_local(struct irq_work *work)\n{\n\tstruct llist_head *list;\n\tbool rt_lazy_work = false;\n\tbool lazy_work = false;\n\tint work_flags;\n\n\twork_flags = atomic_read(&work->node.a_flags);\n\tif (work_flags & IRQ_WORK_LAZY)\n\t\tlazy_work = true;\n\telse if (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t !(work_flags & IRQ_WORK_HARD_IRQ))\n\t\trt_lazy_work = true;\n\n\tif (lazy_work || rt_lazy_work)\n\t\tlist = this_cpu_ptr(&lazy_list);\n\telse\n\t\tlist = this_cpu_ptr(&raised_list);\n\n\tif (!llist_add(&work->node.llist, list))\n\t\treturn;\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (!lazy_work || tick_nohz_tick_stopped())\n\t\tarch_irq_work_raise();\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nstatic void __irq_work_queue_local(struct irq_work *work)\n{\n\tstruct llist_head *list;\n\tbool rt_lazy_work = false;\n\tbool lazy_work = false;\n\tint work_flags;\n\n\twork_flags = atomic_read(&work->node.a_flags);\n\tif (work_flags & IRQ_WORK_LAZY)\n\t\tlazy_work = true;\n\telse if (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t !(work_flags & IRQ_WORK_HARD_IRQ))\n\t\trt_lazy_work = true;\n\n\tif (lazy_work || rt_lazy_work)\n\t\tlist = this_cpu_ptr(&lazy_list);\n\telse\n\t\tlist = this_cpu_ptr(&raised_list);\n\n\tif (!llist_add(&work->node.llist, list))\n\t\treturn;\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (!lazy_work || tick_nohz_tick_stopped())\n\t\tarch_irq_work_raise();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_work_claim",
          "args": [
            "work"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_claim",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "55-68",
          "snippet": "static bool irq_work_claim(struct irq_work *work)\n{\n\tint oflags;\n\n\toflags = atomic_fetch_or(IRQ_WORK_CLAIMED | CSD_TYPE_IRQ_WORK, &work->node.a_flags);\n\t/*\n\t * If the work is already pending, no need to raise the IPI.\n\t * The pairing smp_mb() in irq_work_single() makes sure\n\t * everything we did before is visible.\n\t */\n\tif (oflags & IRQ_WORK_PENDING)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic bool irq_work_claim(struct irq_work *work)\n{\n\tint oflags;\n\n\toflags = atomic_fetch_or(IRQ_WORK_CLAIMED | CSD_TYPE_IRQ_WORK, &work->node.a_flags);\n\t/*\n\t * If the work is already pending, no need to raise the IPI.\n\t * The pairing smp_mb() in irq_work_single() makes sure\n\t * everything we did before is visible.\n\t */\n\tif (oflags & IRQ_WORK_PENDING)\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}"
  },
  {
    "function_name": "__irq_work_queue_local",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "78-103",
    "snippet": "static void __irq_work_queue_local(struct irq_work *work)\n{\n\tstruct llist_head *list;\n\tbool rt_lazy_work = false;\n\tbool lazy_work = false;\n\tint work_flags;\n\n\twork_flags = atomic_read(&work->node.a_flags);\n\tif (work_flags & IRQ_WORK_LAZY)\n\t\tlazy_work = true;\n\telse if (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t !(work_flags & IRQ_WORK_HARD_IRQ))\n\t\trt_lazy_work = true;\n\n\tif (lazy_work || rt_lazy_work)\n\t\tlist = this_cpu_ptr(&lazy_list);\n\telse\n\t\tlist = this_cpu_ptr(&raised_list);\n\n\tif (!llist_add(&work->node.llist, list))\n\t\treturn;\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (!lazy_work || tick_nohz_tick_stopped())\n\t\tarch_irq_work_raise();\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct llist_head, raised_list);",
      "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_irq_work_raise",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "arch_irq_work_raise",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "70-75",
          "snippet": "void __weak arch_irq_work_raise(void)\n{\n\t/*\n\t * Lame architectures will get the timer tick callback\n\t */\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid __weak arch_irq_work_raise(void)\n{\n\t/*\n\t * Lame architectures will get the timer tick callback\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_tick_stopped",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_tick_stopped",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "587-592",
          "snippet": "bool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nbool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "&work->node.llist",
            "list"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&raised_list"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&lazy_list"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&work->node.a_flags"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nstatic void __irq_work_queue_local(struct irq_work *work)\n{\n\tstruct llist_head *list;\n\tbool rt_lazy_work = false;\n\tbool lazy_work = false;\n\tint work_flags;\n\n\twork_flags = atomic_read(&work->node.a_flags);\n\tif (work_flags & IRQ_WORK_LAZY)\n\t\tlazy_work = true;\n\telse if (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t !(work_flags & IRQ_WORK_HARD_IRQ))\n\t\trt_lazy_work = true;\n\n\tif (lazy_work || rt_lazy_work)\n\t\tlist = this_cpu_ptr(&lazy_list);\n\telse\n\t\tlist = this_cpu_ptr(&raised_list);\n\n\tif (!llist_add(&work->node.llist, list))\n\t\treturn;\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (!lazy_work || tick_nohz_tick_stopped())\n\t\tarch_irq_work_raise();\n}"
  },
  {
    "function_name": "arch_irq_work_raise",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "70-75",
    "snippet": "void __weak arch_irq_work_raise(void)\n{\n\t/*\n\t * Lame architectures will get the timer tick callback\n\t */\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid __weak arch_irq_work_raise(void)\n{\n\t/*\n\t * Lame architectures will get the timer tick callback\n\t */\n}"
  },
  {
    "function_name": "irq_work_claim",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "55-68",
    "snippet": "static bool irq_work_claim(struct irq_work *work)\n{\n\tint oflags;\n\n\toflags = atomic_fetch_or(IRQ_WORK_CLAIMED | CSD_TYPE_IRQ_WORK, &work->node.a_flags);\n\t/*\n\t * If the work is already pending, no need to raise the IPI.\n\t * The pairing smp_mb() in irq_work_single() makes sure\n\t * everything we did before is visible.\n\t */\n\tif (oflags & IRQ_WORK_PENDING)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_fetch_or",
          "args": [
            "IRQ_WORK_CLAIMED | CSD_TYPE_IRQ_WORK",
            "&work->node.a_flags"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic bool irq_work_claim(struct irq_work *work)\n{\n\tint oflags;\n\n\toflags = atomic_fetch_or(IRQ_WORK_CLAIMED | CSD_TYPE_IRQ_WORK, &work->node.a_flags);\n\t/*\n\t * If the work is already pending, no need to raise the IPI.\n\t * The pairing smp_mb() in irq_work_single() makes sure\n\t * everything we did before is visible.\n\t */\n\tif (oflags & IRQ_WORK_PENDING)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "irq_workd_should_run",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "47-50",
    "snippet": "static int irq_workd_should_run(unsigned int cpu)\n{\n\treturn !llist_empty(this_cpu_ptr(&lazy_list));\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "this_cpu_ptr(&lazy_list)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&lazy_list"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nstatic int irq_workd_should_run(unsigned int cpu)\n{\n\treturn !llist_empty(this_cpu_ptr(&lazy_list));\n}"
  },
  {
    "function_name": "irq_work_wake",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "38-41",
    "snippet": "static void irq_work_wake(struct irq_work *entry)\n{\n\twake_irq_workd();\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_irq_workd",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "wake_irq_workd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "29-35",
          "snippet": "static void wake_irq_workd(void)\n{\n\tstruct task_struct *tsk = __this_cpu_read(irq_workd);\n\n\tif (!llist_empty(this_cpu_ptr(&lazy_list)) && tsk)\n\t\twake_up_process(tsk);\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);",
            "static DEFINE_PER_CPU(struct task_struct *, irq_workd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\nstatic DEFINE_PER_CPU(struct task_struct *, irq_workd);\n\nstatic void wake_irq_workd(void)\n{\n\tstruct task_struct *tsk = __this_cpu_read(irq_workd);\n\n\tif (!llist_empty(this_cpu_ptr(&lazy_list)) && tsk)\n\t\twake_up_process(tsk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic void irq_work_wake(struct irq_work *entry)\n{\n\twake_irq_workd();\n}"
  },
  {
    "function_name": "wake_irq_workd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
    "lines": "29-35",
    "snippet": "static void wake_irq_workd(void)\n{\n\tstruct task_struct *tsk = __this_cpu_read(irq_workd);\n\n\tif (!llist_empty(this_cpu_ptr(&lazy_list)) && tsk)\n\t\twake_up_process(tsk);\n}",
    "includes": [
      "#include <linux/kasan.h>",
      "#include <asm/processor.h>",
      "#include <linux/smpboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h>",
      "#include <linux/irqflags.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/percpu.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/bug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct llist_head, lazy_list);",
      "static DEFINE_PER_CPU(struct task_struct *, irq_workd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "tsk"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "this_cpu_ptr(&lazy_list)"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&lazy_list"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "irq_workd"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\nstatic DEFINE_PER_CPU(struct task_struct *, irq_workd);\n\nstatic void wake_irq_workd(void)\n{\n\tstruct task_struct *tsk = __this_cpu_read(irq_workd);\n\n\tif (!llist_empty(this_cpu_ptr(&lazy_list)) && tsk)\n\t\twake_up_process(tsk);\n}"
  }
]