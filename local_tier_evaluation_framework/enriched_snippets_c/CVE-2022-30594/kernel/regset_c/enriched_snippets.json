[
  {
    "function_name": "copy_regset_to_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/regset.c",
    "lines": "61-76",
    "snippet": "int copy_regset_to_user(struct task_struct *target,\n\t\t\tconst struct user_regset_view *view,\n\t\t\tunsigned int setno,\n\t\t\tunsigned int offset, unsigned int size,\n\t\t\tvoid __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\tvoid *buf;\n\tint ret;\n\n\tret = regset_get_alloc(target, regset, size, &buf);\n\tif (ret > 0)\n\t\tret = copy_to_user(data, buf, ret) ? -EFAULT : 0;\n\tkfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "data",
            "buf",
            "ret"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regset_get_alloc",
          "args": [
            "target",
            "regset",
            "size",
            "&buf"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "regset_get_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/regset.c",
          "lines": "42-49",
          "snippet": "int regset_get_alloc(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int size,\n\t\t     void **data)\n{\n\t*data = NULL;\n\treturn __regset_get(target, regset, size, data);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nint regset_get_alloc(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int size,\n\t\t     void **data)\n{\n\t*data = NULL;\n\treturn __regset_get(target, regset, size, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nint copy_regset_to_user(struct task_struct *target,\n\t\t\tconst struct user_regset_view *view,\n\t\t\tunsigned int setno,\n\t\t\tunsigned int offset, unsigned int size,\n\t\t\tvoid __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\tvoid *buf;\n\tint ret;\n\n\tret = regset_get_alloc(target, regset, size, &buf);\n\tif (ret > 0)\n\t\tret = copy_to_user(data, buf, ret) ? -EFAULT : 0;\n\tkfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "regset_get_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/regset.c",
    "lines": "42-49",
    "snippet": "int regset_get_alloc(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int size,\n\t\t     void **data)\n{\n\t*data = NULL;\n\treturn __regset_get(target, regset, size, data);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__regset_get",
          "args": [
            "target",
            "regset",
            "size",
            "data"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "__regset_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/regset.c",
          "lines": "6-31",
          "snippet": "static int __regset_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int size,\n\t\t\tvoid **data)\n{\n\tvoid *p = *data, *to_free = NULL;\n\tint res;\n\n\tif (!regset->regset_get)\n\t\treturn -EOPNOTSUPP;\n\tif (size > regset->n * regset->size)\n\t\tsize = regset->n * regset->size;\n\tif (!p) {\n\t\tto_free = p = kzalloc(size, GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\tres = regset->regset_get(target, regset,\n\t\t\t   (struct membuf){.p = p, .left = size});\n\tif (res < 0) {\n\t\tkfree(to_free);\n\t\treturn res;\n\t}\n\t*data = p;\n\treturn size - res;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int __regset_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int size,\n\t\t\tvoid **data)\n{\n\tvoid *p = *data, *to_free = NULL;\n\tint res;\n\n\tif (!regset->regset_get)\n\t\treturn -EOPNOTSUPP;\n\tif (size > regset->n * regset->size)\n\t\tsize = regset->n * regset->size;\n\tif (!p) {\n\t\tto_free = p = kzalloc(size, GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\tres = regset->regset_get(target, regset,\n\t\t\t   (struct membuf){.p = p, .left = size});\n\tif (res < 0) {\n\t\tkfree(to_free);\n\t\treturn res;\n\t}\n\t*data = p;\n\treturn size - res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nint regset_get_alloc(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int size,\n\t\t     void **data)\n{\n\t*data = NULL;\n\treturn __regset_get(target, regset, size, data);\n}"
  },
  {
    "function_name": "regset_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/regset.c",
    "lines": "33-39",
    "snippet": "int regset_get(struct task_struct *target,\n\t       const struct user_regset *regset,\n\t       unsigned int size,\n\t       void *data)\n{\n\treturn __regset_get(target, regset, size, &data);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__regset_get",
          "args": [
            "target",
            "regset",
            "size",
            "&data"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "__regset_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/regset.c",
          "lines": "6-31",
          "snippet": "static int __regset_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int size,\n\t\t\tvoid **data)\n{\n\tvoid *p = *data, *to_free = NULL;\n\tint res;\n\n\tif (!regset->regset_get)\n\t\treturn -EOPNOTSUPP;\n\tif (size > regset->n * regset->size)\n\t\tsize = regset->n * regset->size;\n\tif (!p) {\n\t\tto_free = p = kzalloc(size, GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\tres = regset->regset_get(target, regset,\n\t\t\t   (struct membuf){.p = p, .left = size});\n\tif (res < 0) {\n\t\tkfree(to_free);\n\t\treturn res;\n\t}\n\t*data = p;\n\treturn size - res;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int __regset_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int size,\n\t\t\tvoid **data)\n{\n\tvoid *p = *data, *to_free = NULL;\n\tint res;\n\n\tif (!regset->regset_get)\n\t\treturn -EOPNOTSUPP;\n\tif (size > regset->n * regset->size)\n\t\tsize = regset->n * regset->size;\n\tif (!p) {\n\t\tto_free = p = kzalloc(size, GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\tres = regset->regset_get(target, regset,\n\t\t\t   (struct membuf){.p = p, .left = size});\n\tif (res < 0) {\n\t\tkfree(to_free);\n\t\treturn res;\n\t}\n\t*data = p;\n\treturn size - res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nint regset_get(struct task_struct *target,\n\t       const struct user_regset *regset,\n\t       unsigned int size,\n\t       void *data)\n{\n\treturn __regset_get(target, regset, size, &data);\n}"
  },
  {
    "function_name": "__regset_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/regset.c",
    "lines": "6-31",
    "snippet": "static int __regset_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int size,\n\t\t\tvoid **data)\n{\n\tvoid *p = *data, *to_free = NULL;\n\tint res;\n\n\tif (!regset->regset_get)\n\t\treturn -EOPNOTSUPP;\n\tif (size > regset->n * regset->size)\n\t\tsize = regset->n * regset->size;\n\tif (!p) {\n\t\tto_free = p = kzalloc(size, GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\tres = regset->regset_get(target, regset,\n\t\t\t   (struct membuf){.p = p, .left = size});\n\tif (res < 0) {\n\t\tkfree(to_free);\n\t\treturn res;\n\t}\n\t*data = p;\n\treturn size - res;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "to_free"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "regset->regset_get",
          "args": [
            "target",
            "regset",
            "(struct membuf){.p = p, .left = size}"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int __regset_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int size,\n\t\t\tvoid **data)\n{\n\tvoid *p = *data, *to_free = NULL;\n\tint res;\n\n\tif (!regset->regset_get)\n\t\treturn -EOPNOTSUPP;\n\tif (size > regset->n * regset->size)\n\t\tsize = regset->n * regset->size;\n\tif (!p) {\n\t\tto_free = p = kzalloc(size, GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\tres = regset->regset_get(target, regset,\n\t\t\t   (struct membuf){.p = p, .left = size});\n\tif (res < 0) {\n\t\tkfree(to_free);\n\t\treturn res;\n\t}\n\t*data = p;\n\treturn size - res;\n}"
  }
]