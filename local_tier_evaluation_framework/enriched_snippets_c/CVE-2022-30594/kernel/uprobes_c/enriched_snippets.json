[
  {
    "function_name": "uprobes_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2352-2360",
    "snippet": "void __init uprobes_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < UPROBES_HASH_SZ; i++)\n\t\tmutex_init(&uprobes_mmap_mutex[i]);\n\n\tBUG_ON(register_die_notifier(&uprobe_exception_nb));\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UPROBES_HASH_SZ\t13"
    ],
    "globals_used": [
      "static struct mutex uprobes_mmap_mutex[UPROBES_HASH_SZ];",
      "static struct notifier_block uprobe_exception_nb = {\n\t.notifier_call\t\t= arch_uprobe_exception_notify,\n\t.priority\t\t= INT_MAX-1,\t/* notified after kprobes, kgdb */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "register_die_notifier(&uprobe_exception_nb)"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_die_notifier",
          "args": [
            "&uprobe_exception_nb"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_die_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "540-543",
          "snippet": "int unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ATOMIC_NOTIFIER_HEAD(die_chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(die_chain);\n\nint unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&uprobes_mmap_mutex[i]"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UPROBES_HASH_SZ\t13\n\nstatic struct mutex uprobes_mmap_mutex[UPROBES_HASH_SZ];\nstatic struct notifier_block uprobe_exception_nb = {\n\t.notifier_call\t\t= arch_uprobe_exception_notify,\n\t.priority\t\t= INT_MAX-1,\t/* notified after kprobes, kgdb */\n};\n\nvoid __init uprobes_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < UPROBES_HASH_SZ; i++)\n\t\tmutex_init(&uprobes_mmap_mutex[i]);\n\n\tBUG_ON(register_die_notifier(&uprobe_exception_nb));\n}"
  },
  {
    "function_name": "uprobe_post_sstep_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2334-2345",
    "snippet": "int uprobe_post_sstep_notifier(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tif (!current->mm || !utask || !utask->active_uprobe)\n\t\t/* task is currently not uprobed */\n\t\treturn 0;\n\n\tutask->state = UTASK_SSTEP_ACK;\n\tset_thread_flag(TIF_UPROBE);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_UPROBE"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_post_sstep_notifier(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tif (!current->mm || !utask || !utask->active_uprobe)\n\t\t/* task is currently not uprobed */\n\t\treturn 0;\n\n\tutask->state = UTASK_SSTEP_ACK;\n\tset_thread_flag(TIF_UPROBE);\n\treturn 1;\n}"
  },
  {
    "function_name": "uprobe_pre_sstep_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2317-2328",
    "snippet": "int uprobe_pre_sstep_notifier(struct pt_regs *regs)\n{\n\tif (!current->mm)\n\t\treturn 0;\n\n\tif (!test_bit(MMF_HAS_UPROBES, &current->mm->flags) &&\n\t    (!current->utask || !current->utask->return_instances))\n\t\treturn 0;\n\n\tset_thread_flag(TIF_UPROBE);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_UPROBE"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&current->mm->flags"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_pre_sstep_notifier(struct pt_regs *regs)\n{\n\tif (!current->mm)\n\t\treturn 0;\n\n\tif (!test_bit(MMF_HAS_UPROBES, &current->mm->flags) &&\n\t    (!current->utask || !current->utask->return_instances))\n\t\treturn 0;\n\n\tset_thread_flag(TIF_UPROBE);\n\treturn 1;\n}"
  },
  {
    "function_name": "uprobe_notify_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2300-2311",
    "snippet": "void uprobe_notify_resume(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\n\tclear_thread_flag(TIF_UPROBE);\n\n\tutask = current->utask;\n\tif (utask && utask->active_uprobe)\n\t\thandle_singlestep(utask, regs);\n\telse\n\t\thandle_swbp(regs);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_swbp",
          "args": [
            "regs"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "handle_swbp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2188-2255",
          "snippet": "static void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint is_swbp;\n\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\t/* No matching uprobe; signal SIGTRAP. */\n\t\t\tforce_sig(SIGTRAP);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Either we raced with uprobe_unregister() or we can't\n\t\t\t * access this memory. The latter is only possible if\n\t\t\t * another thread plays with our ->mm. In both cases\n\t\t\t * we can simply restart. If this vma was unmapped we\n\t\t\t * can pretend this insn was not executed yet and get\n\t\t\t * the (correct) SIGSEGV after restart.\n\t\t\t */\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* change it in advance for ->handler() and restart */\n\tinstruction_pointer_set(regs, bp_vaddr);\n\n\t/*\n\t * TODO: move copy_insn/etc into _register and remove this hack.\n\t * After we hit the bp, _unregister + _register can install the\n\t * new and not-yet-analyzed uprobe at the same address, restart.\n\t */\n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\n\t/*\n\t * Pairs with the smp_wmb() in prepare_uprobe().\n\t *\n\t * Guarantees that if we see the UPROBE_COPY_INSN bit set, then\n\t * we must also see the stores to &uprobe->arch performed by the\n\t * prepare_uprobe() call.\n\t */\n\tsmp_rmb();\n\n\t/* Tracing handlers use ->utask to communicate with fetch methods */\n\tif (!get_utask())\n\t\tgoto out;\n\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\n\thandler_chain(uprobe, regs);\n\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\n\n\t/* arch_uprobe_skip_sstep() succeeded, or restart if can't singlestep */\nout:\n\tput_uprobe(uprobe);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UPROBE_COPY_INSN\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UPROBE_COPY_INSN\t0\n\nstatic void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint is_swbp;\n\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\t/* No matching uprobe; signal SIGTRAP. */\n\t\t\tforce_sig(SIGTRAP);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Either we raced with uprobe_unregister() or we can't\n\t\t\t * access this memory. The latter is only possible if\n\t\t\t * another thread plays with our ->mm. In both cases\n\t\t\t * we can simply restart. If this vma was unmapped we\n\t\t\t * can pretend this insn was not executed yet and get\n\t\t\t * the (correct) SIGSEGV after restart.\n\t\t\t */\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* change it in advance for ->handler() and restart */\n\tinstruction_pointer_set(regs, bp_vaddr);\n\n\t/*\n\t * TODO: move copy_insn/etc into _register and remove this hack.\n\t * After we hit the bp, _unregister + _register can install the\n\t * new and not-yet-analyzed uprobe at the same address, restart.\n\t */\n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\n\t/*\n\t * Pairs with the smp_wmb() in prepare_uprobe().\n\t *\n\t * Guarantees that if we see the UPROBE_COPY_INSN bit set, then\n\t * we must also see the stores to &uprobe->arch performed by the\n\t * prepare_uprobe() call.\n\t */\n\tsmp_rmb();\n\n\t/* Tracing handlers use ->utask to communicate with fetch methods */\n\tif (!get_utask())\n\t\tgoto out;\n\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\n\thandler_chain(uprobe, regs);\n\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\n\n\t/* arch_uprobe_skip_sstep() succeeded, or restart if can't singlestep */\nout:\n\tput_uprobe(uprobe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_singlestep",
          "args": [
            "utask",
            "regs"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "handle_singlestep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2261-2287",
          "snippet": "static void handle_singlestep(struct uprobe_task *utask, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tint err = 0;\n\n\tuprobe = utask->active_uprobe;\n\tif (utask->state == UTASK_SSTEP_ACK)\n\t\terr = arch_uprobe_post_xol(&uprobe->arch, regs);\n\telse if (utask->state == UTASK_SSTEP_TRAPPED)\n\t\tarch_uprobe_abort_xol(&uprobe->arch, regs);\n\telse\n\t\tWARN_ON_ONCE(1);\n\n\tput_uprobe(uprobe);\n\tutask->active_uprobe = NULL;\n\tutask->state = UTASK_RUNNING;\n\txol_free_insn_slot(current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\trecalc_sigpending(); /* see uprobe_deny_signal() */\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (unlikely(err)) {\n\t\tuprobe_warn(current, \"execute the probed insn, sending SIGILL.\");\n\t\tforce_sig(SIGILL);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handle_singlestep(struct uprobe_task *utask, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tint err = 0;\n\n\tuprobe = utask->active_uprobe;\n\tif (utask->state == UTASK_SSTEP_ACK)\n\t\terr = arch_uprobe_post_xol(&uprobe->arch, regs);\n\telse if (utask->state == UTASK_SSTEP_TRAPPED)\n\t\tarch_uprobe_abort_xol(&uprobe->arch, regs);\n\telse\n\t\tWARN_ON_ONCE(1);\n\n\tput_uprobe(uprobe);\n\tutask->active_uprobe = NULL;\n\tutask->state = UTASK_RUNNING;\n\txol_free_insn_slot(current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\trecalc_sigpending(); /* see uprobe_deny_signal() */\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (unlikely(err)) {\n\t\tuprobe_warn(current, \"execute the probed insn, sending SIGILL.\");\n\t\tforce_sig(SIGILL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_thread_flag",
          "args": [
            "TIF_UPROBE"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_notify_resume(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\n\tclear_thread_flag(TIF_UPROBE);\n\n\tutask = current->utask;\n\tif (utask && utask->active_uprobe)\n\t\thandle_singlestep(utask, regs);\n\telse\n\t\thandle_swbp(regs);\n}"
  },
  {
    "function_name": "handle_singlestep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2261-2287",
    "snippet": "static void handle_singlestep(struct uprobe_task *utask, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tint err = 0;\n\n\tuprobe = utask->active_uprobe;\n\tif (utask->state == UTASK_SSTEP_ACK)\n\t\terr = arch_uprobe_post_xol(&uprobe->arch, regs);\n\telse if (utask->state == UTASK_SSTEP_TRAPPED)\n\t\tarch_uprobe_abort_xol(&uprobe->arch, regs);\n\telse\n\t\tWARN_ON_ONCE(1);\n\n\tput_uprobe(uprobe);\n\tutask->active_uprobe = NULL;\n\tutask->state = UTASK_RUNNING;\n\txol_free_insn_slot(current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\trecalc_sigpending(); /* see uprobe_deny_signal() */\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (unlikely(err)) {\n\t\tuprobe_warn(current, \"execute the probed insn, sending SIGILL.\");\n\t\tforce_sig(SIGILL);\n\t}\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGILL"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "force_sigsegv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1696-1702",
          "snippet": "void force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_warn",
          "args": [
            "current",
            "\"execute the probed insn, sending SIGILL.\""
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_warn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1780-1784",
          "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "182-187",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xol_free_insn_slot",
          "args": [
            "current"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "xol_free_insn_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1635-1667",
          "snippet": "static void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "603-616",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uprobe_abort_xol",
          "args": [
            "&uprobe->arch",
            "regs"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uprobe_post_xol",
          "args": [
            "&uprobe->arch",
            "regs"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handle_singlestep(struct uprobe_task *utask, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tint err = 0;\n\n\tuprobe = utask->active_uprobe;\n\tif (utask->state == UTASK_SSTEP_ACK)\n\t\terr = arch_uprobe_post_xol(&uprobe->arch, regs);\n\telse if (utask->state == UTASK_SSTEP_TRAPPED)\n\t\tarch_uprobe_abort_xol(&uprobe->arch, regs);\n\telse\n\t\tWARN_ON_ONCE(1);\n\n\tput_uprobe(uprobe);\n\tutask->active_uprobe = NULL;\n\tutask->state = UTASK_RUNNING;\n\txol_free_insn_slot(current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\trecalc_sigpending(); /* see uprobe_deny_signal() */\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tif (unlikely(err)) {\n\t\tuprobe_warn(current, \"execute the probed insn, sending SIGILL.\");\n\t\tforce_sig(SIGILL);\n\t}\n}"
  },
  {
    "function_name": "handle_swbp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2188-2255",
    "snippet": "static void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint is_swbp;\n\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\t/* No matching uprobe; signal SIGTRAP. */\n\t\t\tforce_sig(SIGTRAP);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Either we raced with uprobe_unregister() or we can't\n\t\t\t * access this memory. The latter is only possible if\n\t\t\t * another thread plays with our ->mm. In both cases\n\t\t\t * we can simply restart. If this vma was unmapped we\n\t\t\t * can pretend this insn was not executed yet and get\n\t\t\t * the (correct) SIGSEGV after restart.\n\t\t\t */\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* change it in advance for ->handler() and restart */\n\tinstruction_pointer_set(regs, bp_vaddr);\n\n\t/*\n\t * TODO: move copy_insn/etc into _register and remove this hack.\n\t * After we hit the bp, _unregister + _register can install the\n\t * new and not-yet-analyzed uprobe at the same address, restart.\n\t */\n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\n\t/*\n\t * Pairs with the smp_wmb() in prepare_uprobe().\n\t *\n\t * Guarantees that if we see the UPROBE_COPY_INSN bit set, then\n\t * we must also see the stores to &uprobe->arch performed by the\n\t * prepare_uprobe() call.\n\t */\n\tsmp_rmb();\n\n\t/* Tracing handlers use ->utask to communicate with fetch methods */\n\tif (!get_utask())\n\t\tgoto out;\n\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\n\thandler_chain(uprobe, regs);\n\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\n\n\t/* arch_uprobe_skip_sstep() succeeded, or restart if can't singlestep */\nout:\n\tput_uprobe(uprobe);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UPROBE_COPY_INSN\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "603-616",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pre_ssout",
          "args": [
            "uprobe",
            "regs",
            "bp_vaddr"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "pre_ssout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1928-1955",
          "snippet": "static int\npre_ssout(struct uprobe *uprobe, struct pt_regs *regs, unsigned long bp_vaddr)\n{\n\tstruct uprobe_task *utask;\n\tunsigned long xol_vaddr;\n\tint err;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn -ENOMEM;\n\n\txol_vaddr = xol_get_insn_slot(uprobe);\n\tif (!xol_vaddr)\n\t\treturn -ENOMEM;\n\n\tutask->xol_vaddr = xol_vaddr;\n\tutask->vaddr = bp_vaddr;\n\n\terr = arch_uprobe_pre_xol(&uprobe->arch, regs);\n\tif (unlikely(err)) {\n\t\txol_free_insn_slot(current);\n\t\treturn err;\n\t}\n\n\tutask->active_uprobe = uprobe;\n\tutask->state = UTASK_SSTEP;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\npre_ssout(struct uprobe *uprobe, struct pt_regs *regs, unsigned long bp_vaddr)\n{\n\tstruct uprobe_task *utask;\n\tunsigned long xol_vaddr;\n\tint err;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn -ENOMEM;\n\n\txol_vaddr = xol_get_insn_slot(uprobe);\n\tif (!xol_vaddr)\n\t\treturn -ENOMEM;\n\n\tutask->xol_vaddr = xol_vaddr;\n\tutask->vaddr = bp_vaddr;\n\n\terr = arch_uprobe_pre_xol(&uprobe->arch, regs);\n\tif (unlikely(err)) {\n\t\txol_free_insn_slot(current);\n\t\treturn err;\n\t}\n\n\tutask->active_uprobe = uprobe;\n\tutask->state = UTASK_SSTEP;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_uprobe_skip_sstep",
          "args": [
            "&uprobe->arch",
            "regs"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler_chain",
          "args": [
            "uprobe",
            "regs"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "handler_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2073-2103",
          "snippet": "static void handler_chain(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_consumer *uc;\n\tint remove = UPROBE_HANDLER_REMOVE;\n\tbool need_prep = false; /* prepare return uprobe, when needed */\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tint rc = 0;\n\n\t\tif (uc->handler) {\n\t\t\trc = uc->handler(uc, regs);\n\t\t\tWARN(rc & ~UPROBE_HANDLER_MASK,\n\t\t\t\t\"bad rc=0x%x from %ps()\\n\", rc, uc->handler);\n\t\t}\n\n\t\tif (uc->ret_handler)\n\t\t\tneed_prep = true;\n\n\t\tremove &= rc;\n\t}\n\n\tif (need_prep && !remove)\n\t\tprepare_uretprobe(uprobe, regs); /* put bp at return */\n\n\tif (remove && uprobe->consumers) {\n\t\tWARN_ON(!uprobe_is_active(uprobe));\n\t\tunapply_uprobe(uprobe, current->mm);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handler_chain(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_consumer *uc;\n\tint remove = UPROBE_HANDLER_REMOVE;\n\tbool need_prep = false; /* prepare return uprobe, when needed */\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tint rc = 0;\n\n\t\tif (uc->handler) {\n\t\t\trc = uc->handler(uc, regs);\n\t\t\tWARN(rc & ~UPROBE_HANDLER_MASK,\n\t\t\t\t\"bad rc=0x%x from %ps()\\n\", rc, uc->handler);\n\t\t}\n\n\t\tif (uc->ret_handler)\n\t\t\tneed_prep = true;\n\n\t\tremove &= rc;\n\t}\n\n\tif (need_prep && !remove)\n\t\tprepare_uretprobe(uprobe, regs); /* put bp at return */\n\n\tif (remove && uprobe->consumers) {\n\t\tWARN_ON(!uprobe_is_active(uprobe));\n\t\tunapply_uprobe(uprobe, current->mm);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_uprobe_ignore",
          "args": [
            "&uprobe->arch",
            "regs"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "arch_uprobe_ignore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2173-2176",
          "snippet": "bool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_utask",
          "args": [],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "get_utask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1745-1750",
          "snippet": "static struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!test_bit(UPROBE_COPY_INSN, &uprobe->flags)"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "UPROBE_COPY_INSN",
            "&uprobe->flags"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer_set",
          "args": [
            "regs",
            "bp_vaddr"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer_set",
          "args": [
            "regs",
            "bp_vaddr"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGTRAP"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "force_sigsegv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1696-1702",
          "snippet": "void force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_active_uprobe",
          "args": [
            "bp_vaddr",
            "&is_swbp"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "find_active_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2044-2071",
          "snippet": "static struct uprobe *find_active_uprobe(unsigned long bp_vaddr, int *is_swbp)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct uprobe *uprobe = NULL;\n\tstruct vm_area_struct *vma;\n\n\tmmap_read_lock(mm);\n\tvma = vma_lookup(mm, bp_vaddr);\n\tif (vma) {\n\t\tif (valid_vma(vma, false)) {\n\t\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\t\tloff_t offset = vaddr_to_offset(vma, bp_vaddr);\n\n\t\t\tuprobe = find_uprobe(inode, offset);\n\t\t}\n\n\t\tif (!uprobe)\n\t\t\t*is_swbp = is_trap_at_addr(mm, bp_vaddr);\n\t} else {\n\t\t*is_swbp = -EFAULT;\n\t}\n\n\tif (!uprobe && test_and_clear_bit(MMF_RECALC_UPROBES, &mm->flags))\n\t\tmmf_recalc_uprobes(mm);\n\tmmap_read_unlock(mm);\n\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *find_active_uprobe(unsigned long bp_vaddr, int *is_swbp)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct uprobe *uprobe = NULL;\n\tstruct vm_area_struct *vma;\n\n\tmmap_read_lock(mm);\n\tvma = vma_lookup(mm, bp_vaddr);\n\tif (vma) {\n\t\tif (valid_vma(vma, false)) {\n\t\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\t\tloff_t offset = vaddr_to_offset(vma, bp_vaddr);\n\n\t\t\tuprobe = find_uprobe(inode, offset);\n\t\t}\n\n\t\tif (!uprobe)\n\t\t\t*is_swbp = is_trap_at_addr(mm, bp_vaddr);\n\t} else {\n\t\t*is_swbp = -EFAULT;\n\t}\n\n\tif (!uprobe && test_and_clear_bit(MMF_RECALC_UPROBES, &mm->flags))\n\t\tmmf_recalc_uprobes(mm);\n\tmmap_read_unlock(mm);\n\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_trampoline",
          "args": [
            "regs"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "handle_trampoline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2131-2171",
          "snippet": "static void handle_trampoline(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\tstruct return_instance *ri, *next;\n\tbool valid;\n\n\tutask = current->utask;\n\tif (!utask)\n\t\tgoto sigill;\n\n\tri = utask->return_instances;\n\tif (!ri)\n\t\tgoto sigill;\n\n\tdo {\n\t\t/*\n\t\t * We should throw out the frames invalidated by longjmp().\n\t\t * If this chain is valid, then the next one should be alive\n\t\t * or NULL; the latter case means that nobody but ri->func\n\t\t * could hit this trampoline on return. TODO: sigaltstack().\n\t\t */\n\t\tnext = find_next_ret_chain(ri);\n\t\tvalid = !next || arch_uretprobe_is_alive(next, RP_CHECK_RET, regs);\n\n\t\tinstruction_pointer_set(regs, ri->orig_ret_vaddr);\n\t\tdo {\n\t\t\tif (valid)\n\t\t\t\thandle_uretprobe_chain(ri, regs);\n\t\t\tri = free_ret_instance(ri);\n\t\t\tutask->depth--;\n\t\t} while (ri != next);\n\t} while (!valid);\n\n\tutask->return_instances = ri;\n\treturn;\n\n sigill:\n\tuprobe_warn(current, \"handle uretprobe, sending SIGILL.\");\n\tforce_sig(SIGILL);\n\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handle_trampoline(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\tstruct return_instance *ri, *next;\n\tbool valid;\n\n\tutask = current->utask;\n\tif (!utask)\n\t\tgoto sigill;\n\n\tri = utask->return_instances;\n\tif (!ri)\n\t\tgoto sigill;\n\n\tdo {\n\t\t/*\n\t\t * We should throw out the frames invalidated by longjmp().\n\t\t * If this chain is valid, then the next one should be alive\n\t\t * or NULL; the latter case means that nobody but ri->func\n\t\t * could hit this trampoline on return. TODO: sigaltstack().\n\t\t */\n\t\tnext = find_next_ret_chain(ri);\n\t\tvalid = !next || arch_uretprobe_is_alive(next, RP_CHECK_RET, regs);\n\n\t\tinstruction_pointer_set(regs, ri->orig_ret_vaddr);\n\t\tdo {\n\t\t\tif (valid)\n\t\t\t\thandle_uretprobe_chain(ri, regs);\n\t\t\tri = free_ret_instance(ri);\n\t\t\tutask->depth--;\n\t\t} while (ri != next);\n\t} while (!valid);\n\n\tutask->return_instances = ri;\n\treturn;\n\n sigill:\n\tuprobe_warn(current, \"handle uretprobe, sending SIGILL.\");\n\tforce_sig(SIGILL);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_trampoline_vaddr",
          "args": [],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "get_trampoline_vaddr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1835-1846",
          "snippet": "static unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_get_swbp_addr",
          "args": [
            "regs"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_get_swbp_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1690-1693",
          "snippet": "unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs) - UPROBE_SWBP_INSN_SIZE;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nunsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs) - UPROBE_SWBP_INSN_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UPROBE_COPY_INSN\t0\n\nstatic void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint is_swbp;\n\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\t/* No matching uprobe; signal SIGTRAP. */\n\t\t\tforce_sig(SIGTRAP);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Either we raced with uprobe_unregister() or we can't\n\t\t\t * access this memory. The latter is only possible if\n\t\t\t * another thread plays with our ->mm. In both cases\n\t\t\t * we can simply restart. If this vma was unmapped we\n\t\t\t * can pretend this insn was not executed yet and get\n\t\t\t * the (correct) SIGSEGV after restart.\n\t\t\t */\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* change it in advance for ->handler() and restart */\n\tinstruction_pointer_set(regs, bp_vaddr);\n\n\t/*\n\t * TODO: move copy_insn/etc into _register and remove this hack.\n\t * After we hit the bp, _unregister + _register can install the\n\t * new and not-yet-analyzed uprobe at the same address, restart.\n\t */\n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\n\t/*\n\t * Pairs with the smp_wmb() in prepare_uprobe().\n\t *\n\t * Guarantees that if we see the UPROBE_COPY_INSN bit set, then\n\t * we must also see the stores to &uprobe->arch performed by the\n\t * prepare_uprobe() call.\n\t */\n\tsmp_rmb();\n\n\t/* Tracing handlers use ->utask to communicate with fetch methods */\n\tif (!get_utask())\n\t\tgoto out;\n\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\n\thandler_chain(uprobe, regs);\n\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\n\n\t/* arch_uprobe_skip_sstep() succeeded, or restart if can't singlestep */\nout:\n\tput_uprobe(uprobe);\n}"
  },
  {
    "function_name": "arch_uretprobe_is_alive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2178-2182",
    "snippet": "bool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "arch_uprobe_ignore",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2173-2176",
    "snippet": "bool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs)\n{\n\treturn false;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "handle_trampoline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2131-2171",
    "snippet": "static void handle_trampoline(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\tstruct return_instance *ri, *next;\n\tbool valid;\n\n\tutask = current->utask;\n\tif (!utask)\n\t\tgoto sigill;\n\n\tri = utask->return_instances;\n\tif (!ri)\n\t\tgoto sigill;\n\n\tdo {\n\t\t/*\n\t\t * We should throw out the frames invalidated by longjmp().\n\t\t * If this chain is valid, then the next one should be alive\n\t\t * or NULL; the latter case means that nobody but ri->func\n\t\t * could hit this trampoline on return. TODO: sigaltstack().\n\t\t */\n\t\tnext = find_next_ret_chain(ri);\n\t\tvalid = !next || arch_uretprobe_is_alive(next, RP_CHECK_RET, regs);\n\n\t\tinstruction_pointer_set(regs, ri->orig_ret_vaddr);\n\t\tdo {\n\t\t\tif (valid)\n\t\t\t\thandle_uretprobe_chain(ri, regs);\n\t\t\tri = free_ret_instance(ri);\n\t\t\tutask->depth--;\n\t\t} while (ri != next);\n\t} while (!valid);\n\n\tutask->return_instances = ri;\n\treturn;\n\n sigill:\n\tuprobe_warn(current, \"handle uretprobe, sending SIGILL.\");\n\tforce_sig(SIGILL);\n\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGILL"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "force_sigsegv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1696-1702",
          "snippet": "void force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_warn",
          "args": [
            "current",
            "\"handle uretprobe, sending SIGILL.\""
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_warn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1780-1784",
          "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ret_instance",
          "args": [
            "ri"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "free_ret_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1705-1711",
          "snippet": "static struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_uretprobe_chain",
          "args": [
            "ri",
            "regs"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "handle_uretprobe_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2105-2117",
          "snippet": "static void\nhandle_uretprobe_chain(struct return_instance *ri, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe = ri->uprobe;\n\tstruct uprobe_consumer *uc;\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tif (uc->ret_handler)\n\t\t\tuc->ret_handler(uc, ri->func, regs);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\nhandle_uretprobe_chain(struct return_instance *ri, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe = ri->uprobe;\n\tstruct uprobe_consumer *uc;\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tif (uc->ret_handler)\n\t\t\tuc->ret_handler(uc, ri->func, regs);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer_set",
          "args": [
            "regs",
            "ri->orig_ret_vaddr"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uretprobe_is_alive",
          "args": [
            "next",
            "RP_CHECK_RET",
            "regs"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "arch_uretprobe_is_alive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2178-2182",
          "snippet": "bool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_ret_chain",
          "args": [
            "ri"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_ret_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2119-2129",
          "snippet": "static struct return_instance *find_next_ret_chain(struct return_instance *ri)\n{\n\tbool chained;\n\n\tdo {\n\t\tchained = ri->chained;\n\t\tri = ri->next;\t/* can't be NULL if chained */\n\t} while (chained);\n\n\treturn ri;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *find_next_ret_chain(struct return_instance *ri)\n{\n\tbool chained;\n\n\tdo {\n\t\tchained = ri->chained;\n\t\tri = ri->next;\t/* can't be NULL if chained */\n\t} while (chained);\n\n\treturn ri;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handle_trampoline(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask;\n\tstruct return_instance *ri, *next;\n\tbool valid;\n\n\tutask = current->utask;\n\tif (!utask)\n\t\tgoto sigill;\n\n\tri = utask->return_instances;\n\tif (!ri)\n\t\tgoto sigill;\n\n\tdo {\n\t\t/*\n\t\t * We should throw out the frames invalidated by longjmp().\n\t\t * If this chain is valid, then the next one should be alive\n\t\t * or NULL; the latter case means that nobody but ri->func\n\t\t * could hit this trampoline on return. TODO: sigaltstack().\n\t\t */\n\t\tnext = find_next_ret_chain(ri);\n\t\tvalid = !next || arch_uretprobe_is_alive(next, RP_CHECK_RET, regs);\n\n\t\tinstruction_pointer_set(regs, ri->orig_ret_vaddr);\n\t\tdo {\n\t\t\tif (valid)\n\t\t\t\thandle_uretprobe_chain(ri, regs);\n\t\t\tri = free_ret_instance(ri);\n\t\t\tutask->depth--;\n\t\t} while (ri != next);\n\t} while (!valid);\n\n\tutask->return_instances = ri;\n\treturn;\n\n sigill:\n\tuprobe_warn(current, \"handle uretprobe, sending SIGILL.\");\n\tforce_sig(SIGILL);\n\n}"
  },
  {
    "function_name": "find_next_ret_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2119-2129",
    "snippet": "static struct return_instance *find_next_ret_chain(struct return_instance *ri)\n{\n\tbool chained;\n\n\tdo {\n\t\tchained = ri->chained;\n\t\tri = ri->next;\t/* can't be NULL if chained */\n\t} while (chained);\n\n\treturn ri;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *find_next_ret_chain(struct return_instance *ri)\n{\n\tbool chained;\n\n\tdo {\n\t\tchained = ri->chained;\n\t\tri = ri->next;\t/* can't be NULL if chained */\n\t} while (chained);\n\n\treturn ri;\n}"
  },
  {
    "function_name": "handle_uretprobe_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2105-2117",
    "snippet": "static void\nhandle_uretprobe_chain(struct return_instance *ri, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe = ri->uprobe;\n\tstruct uprobe_consumer *uc;\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tif (uc->ret_handler)\n\t\t\tuc->ret_handler(uc, ri->func, regs);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uc->ret_handler",
          "args": [
            "uc",
            "ri->func",
            "regs"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\nhandle_uretprobe_chain(struct return_instance *ri, struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe = ri->uprobe;\n\tstruct uprobe_consumer *uc;\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tif (uc->ret_handler)\n\t\t\tuc->ret_handler(uc, ri->func, regs);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}"
  },
  {
    "function_name": "handler_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2073-2103",
    "snippet": "static void handler_chain(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_consumer *uc;\n\tint remove = UPROBE_HANDLER_REMOVE;\n\tbool need_prep = false; /* prepare return uprobe, when needed */\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tint rc = 0;\n\n\t\tif (uc->handler) {\n\t\t\trc = uc->handler(uc, regs);\n\t\t\tWARN(rc & ~UPROBE_HANDLER_MASK,\n\t\t\t\t\"bad rc=0x%x from %ps()\\n\", rc, uc->handler);\n\t\t}\n\n\t\tif (uc->ret_handler)\n\t\t\tneed_prep = true;\n\n\t\tremove &= rc;\n\t}\n\n\tif (need_prep && !remove)\n\t\tprepare_uretprobe(uprobe, regs); /* put bp at return */\n\n\tif (remove && uprobe->consumers) {\n\t\tWARN_ON(!uprobe_is_active(uprobe));\n\t\tunapply_uprobe(uprobe, current->mm);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unapply_uprobe",
          "args": [
            "uprobe",
            "current->mm"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "unapply_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1238-1263",
          "snippet": "static int unapply_uprobe(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tmmap_read_lock(mm);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tunsigned long vaddr;\n\t\tloff_t offset;\n\n\t\tif (!valid_vma(vma, false) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tcontinue;\n\n\t\toffset = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t\tif (uprobe->offset <  offset ||\n\t\t    uprobe->offset >= offset + vma->vm_end - vma->vm_start)\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\terr |= remove_breakpoint(uprobe, mm, vaddr);\n\t}\n\tmmap_read_unlock(mm);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int unapply_uprobe(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tmmap_read_lock(mm);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tunsigned long vaddr;\n\t\tloff_t offset;\n\n\t\tif (!valid_vma(vma, false) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tcontinue;\n\n\t\toffset = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t\tif (uprobe->offset <  offset ||\n\t\t    uprobe->offset >= offset + vma->vm_end - vma->vm_start)\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\terr |= remove_breakpoint(uprobe, mm, vaddr);\n\t}\n\tmmap_read_unlock(mm);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe_is_active(uprobe)"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_is_active",
          "args": [
            "uprobe"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_is_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "931-934",
          "snippet": "static inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_uretprobe",
          "args": [
            "uprobe",
            "regs"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_uretprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1861-1925",
          "snippet": "static void prepare_uretprobe(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct return_instance *ri;\n\tstruct uprobe_task *utask;\n\tunsigned long orig_ret_vaddr, trampoline_vaddr;\n\tbool chained;\n\n\tif (!get_xol_area())\n\t\treturn;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->depth >= MAX_URETPROBE_DEPTH) {\n\t\tprintk_ratelimited(KERN_INFO \"uprobe: omit uretprobe due to\"\n\t\t\t\t\" nestedness limit pid/tgid=%d/%d\\n\",\n\t\t\t\tcurrent->pid, current->tgid);\n\t\treturn;\n\t}\n\n\tri = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\tif (!ri)\n\t\treturn;\n\n\ttrampoline_vaddr = get_trampoline_vaddr();\n\torig_ret_vaddr = arch_uretprobe_hijack_return_addr(trampoline_vaddr, regs);\n\tif (orig_ret_vaddr == -1)\n\t\tgoto fail;\n\n\t/* drop the entries invalidated by longjmp() */\n\tchained = (orig_ret_vaddr == trampoline_vaddr);\n\tcleanup_return_instances(utask, chained, regs);\n\n\t/*\n\t * We don't want to keep trampoline address in stack, rather keep the\n\t * original return address of first caller thru all the consequent\n\t * instances. This also makes breakpoint unwrapping easier.\n\t */\n\tif (chained) {\n\t\tif (!utask->return_instances) {\n\t\t\t/*\n\t\t\t * This situation is not possible. Likely we have an\n\t\t\t * attack from user-space.\n\t\t\t */\n\t\t\tuprobe_warn(current, \"handle tail call\");\n\t\t\tgoto fail;\n\t\t}\n\t\torig_ret_vaddr = utask->return_instances->orig_ret_vaddr;\n\t}\n\n\tri->uprobe = get_uprobe(uprobe);\n\tri->func = instruction_pointer(regs);\n\tri->stack = user_stack_pointer(regs);\n\tri->orig_ret_vaddr = orig_ret_vaddr;\n\tri->chained = chained;\n\n\tutask->depth++;\n\tri->next = utask->return_instances;\n\tutask->return_instances = ri;\n\n\treturn;\n fail:\n\tkfree(ri);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void prepare_uretprobe(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct return_instance *ri;\n\tstruct uprobe_task *utask;\n\tunsigned long orig_ret_vaddr, trampoline_vaddr;\n\tbool chained;\n\n\tif (!get_xol_area())\n\t\treturn;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->depth >= MAX_URETPROBE_DEPTH) {\n\t\tprintk_ratelimited(KERN_INFO \"uprobe: omit uretprobe due to\"\n\t\t\t\t\" nestedness limit pid/tgid=%d/%d\\n\",\n\t\t\t\tcurrent->pid, current->tgid);\n\t\treturn;\n\t}\n\n\tri = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\tif (!ri)\n\t\treturn;\n\n\ttrampoline_vaddr = get_trampoline_vaddr();\n\torig_ret_vaddr = arch_uretprobe_hijack_return_addr(trampoline_vaddr, regs);\n\tif (orig_ret_vaddr == -1)\n\t\tgoto fail;\n\n\t/* drop the entries invalidated by longjmp() */\n\tchained = (orig_ret_vaddr == trampoline_vaddr);\n\tcleanup_return_instances(utask, chained, regs);\n\n\t/*\n\t * We don't want to keep trampoline address in stack, rather keep the\n\t * original return address of first caller thru all the consequent\n\t * instances. This also makes breakpoint unwrapping easier.\n\t */\n\tif (chained) {\n\t\tif (!utask->return_instances) {\n\t\t\t/*\n\t\t\t * This situation is not possible. Likely we have an\n\t\t\t * attack from user-space.\n\t\t\t */\n\t\t\tuprobe_warn(current, \"handle tail call\");\n\t\t\tgoto fail;\n\t\t}\n\t\torig_ret_vaddr = utask->return_instances->orig_ret_vaddr;\n\t}\n\n\tri->uprobe = get_uprobe(uprobe);\n\tri->func = instruction_pointer(regs);\n\tri->stack = user_stack_pointer(regs);\n\tri->orig_ret_vaddr = orig_ret_vaddr;\n\tri->chained = chained;\n\n\tutask->depth++;\n\tri->next = utask->return_instances;\n\tutask->return_instances = ri;\n\n\treturn;\n fail:\n\tkfree(ri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "rc & ~UPROBE_HANDLER_MASK",
            "\"bad rc=0x%x from %ps()\\n\"",
            "rc",
            "uc->handler"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uc->handler",
          "args": [
            "uc",
            "regs"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void handler_chain(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct uprobe_consumer *uc;\n\tint remove = UPROBE_HANDLER_REMOVE;\n\tbool need_prep = false; /* prepare return uprobe, when needed */\n\n\tdown_read(&uprobe->register_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tint rc = 0;\n\n\t\tif (uc->handler) {\n\t\t\trc = uc->handler(uc, regs);\n\t\t\tWARN(rc & ~UPROBE_HANDLER_MASK,\n\t\t\t\t\"bad rc=0x%x from %ps()\\n\", rc, uc->handler);\n\t\t}\n\n\t\tif (uc->ret_handler)\n\t\t\tneed_prep = true;\n\n\t\tremove &= rc;\n\t}\n\n\tif (need_prep && !remove)\n\t\tprepare_uretprobe(uprobe, regs); /* put bp at return */\n\n\tif (remove && uprobe->consumers) {\n\t\tWARN_ON(!uprobe_is_active(uprobe));\n\t\tunapply_uprobe(uprobe, current->mm);\n\t}\n\tup_read(&uprobe->register_rwsem);\n}"
  },
  {
    "function_name": "find_active_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2044-2071",
    "snippet": "static struct uprobe *find_active_uprobe(unsigned long bp_vaddr, int *is_swbp)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct uprobe *uprobe = NULL;\n\tstruct vm_area_struct *vma;\n\n\tmmap_read_lock(mm);\n\tvma = vma_lookup(mm, bp_vaddr);\n\tif (vma) {\n\t\tif (valid_vma(vma, false)) {\n\t\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\t\tloff_t offset = vaddr_to_offset(vma, bp_vaddr);\n\n\t\t\tuprobe = find_uprobe(inode, offset);\n\t\t}\n\n\t\tif (!uprobe)\n\t\t\t*is_swbp = is_trap_at_addr(mm, bp_vaddr);\n\t} else {\n\t\t*is_swbp = -EFAULT;\n\t}\n\n\tif (!uprobe && test_and_clear_bit(MMF_RECALC_UPROBES, &mm->flags))\n\t\tmmf_recalc_uprobes(mm);\n\tmmap_read_unlock(mm);\n\n\treturn uprobe;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmap_read_unlock",
          "args": [
            "mm"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmf_recalc_uprobes",
          "args": [
            "mm"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "mmf_recalc_uprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1990-2008",
          "snippet": "static void mmf_recalc_uprobes(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (!valid_vma(vma, false))\n\t\t\tcontinue;\n\t\t/*\n\t\t * This is not strictly accurate, we can race with\n\t\t * uprobe_unregister() and see the already removed\n\t\t * uprobe if delete_uprobe() was not yet called.\n\t\t * Or this uprobe can be filtered out.\n\t\t */\n\t\tif (vma_has_uprobes(vma, vma->vm_start, vma->vm_end))\n\t\t\treturn;\n\t}\n\n\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void mmf_recalc_uprobes(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (!valid_vma(vma, false))\n\t\t\tcontinue;\n\t\t/*\n\t\t * This is not strictly accurate, we can race with\n\t\t * uprobe_unregister() and see the already removed\n\t\t * uprobe if delete_uprobe() was not yet called.\n\t\t * Or this uprobe can be filtered out.\n\t\t */\n\t\tif (vma_has_uprobes(vma, vma->vm_start, vma->vm_end))\n\t\t\treturn;\n\t}\n\n\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "MMF_RECALC_UPROBES",
            "&mm->flags"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_trap_at_addr",
          "args": [
            "mm",
            "bp_vaddr"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "is_trap_at_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2010-2042",
          "snippet": "static int is_trap_at_addr(struct mm_struct *mm, unsigned long vaddr)\n{\n\tstruct page *page;\n\tuprobe_opcode_t opcode;\n\tint result;\n\n\tif (WARN_ON_ONCE(!IS_ALIGNED(vaddr, UPROBE_SWBP_INSN_SIZE)))\n\t\treturn -EINVAL;\n\n\tpagefault_disable();\n\tresult = __get_user(opcode, (uprobe_opcode_t __user *)vaddr);\n\tpagefault_enable();\n\n\tif (likely(result == 0))\n\t\tgoto out;\n\n\t/*\n\t * The NULL 'tsk' here ensures that any faults that occur here\n\t * will not be accounted to the task.  'mm' *is* current->mm,\n\t * but we treat this as a 'remote' access since it is\n\t * essentially a kernel access to the memory.\n\t */\n\tresult = get_user_pages_remote(mm, vaddr, 1, FOLL_FORCE, &page,\n\t\t\tNULL, NULL);\n\tif (result < 0)\n\t\treturn result;\n\n\tcopy_from_page(page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\tput_page(page);\n out:\n\t/* This needs to return true for any variant of the trap insn */\n\treturn is_trap_insn(&opcode);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int is_trap_at_addr(struct mm_struct *mm, unsigned long vaddr)\n{\n\tstruct page *page;\n\tuprobe_opcode_t opcode;\n\tint result;\n\n\tif (WARN_ON_ONCE(!IS_ALIGNED(vaddr, UPROBE_SWBP_INSN_SIZE)))\n\t\treturn -EINVAL;\n\n\tpagefault_disable();\n\tresult = __get_user(opcode, (uprobe_opcode_t __user *)vaddr);\n\tpagefault_enable();\n\n\tif (likely(result == 0))\n\t\tgoto out;\n\n\t/*\n\t * The NULL 'tsk' here ensures that any faults that occur here\n\t * will not be accounted to the task.  'mm' *is* current->mm,\n\t * but we treat this as a 'remote' access since it is\n\t * essentially a kernel access to the memory.\n\t */\n\tresult = get_user_pages_remote(mm, vaddr, 1, FOLL_FORCE, &page,\n\t\t\tNULL, NULL);\n\tif (result < 0)\n\t\treturn result;\n\n\tcopy_from_page(page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\tput_page(page);\n out:\n\t/* This needs to return true for any variant of the trap insn */\n\treturn is_trap_insn(&opcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_uprobe",
          "args": [
            "inode",
            "offset"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "find_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "675-684",
          "snippet": "static struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vaddr_to_offset",
          "args": [
            "vma",
            "bp_vaddr"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "vaddr_to_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "136-139",
          "snippet": "static loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "false"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "121-129",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_lookup",
          "args": [
            "mm",
            "bp_vaddr"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap_read_lock",
          "args": [
            "mm"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *find_active_uprobe(unsigned long bp_vaddr, int *is_swbp)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct uprobe *uprobe = NULL;\n\tstruct vm_area_struct *vma;\n\n\tmmap_read_lock(mm);\n\tvma = vma_lookup(mm, bp_vaddr);\n\tif (vma) {\n\t\tif (valid_vma(vma, false)) {\n\t\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\t\tloff_t offset = vaddr_to_offset(vma, bp_vaddr);\n\n\t\t\tuprobe = find_uprobe(inode, offset);\n\t\t}\n\n\t\tif (!uprobe)\n\t\t\t*is_swbp = is_trap_at_addr(mm, bp_vaddr);\n\t} else {\n\t\t*is_swbp = -EFAULT;\n\t}\n\n\tif (!uprobe && test_and_clear_bit(MMF_RECALC_UPROBES, &mm->flags))\n\t\tmmf_recalc_uprobes(mm);\n\tmmap_read_unlock(mm);\n\n\treturn uprobe;\n}"
  },
  {
    "function_name": "is_trap_at_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "2010-2042",
    "snippet": "static int is_trap_at_addr(struct mm_struct *mm, unsigned long vaddr)\n{\n\tstruct page *page;\n\tuprobe_opcode_t opcode;\n\tint result;\n\n\tif (WARN_ON_ONCE(!IS_ALIGNED(vaddr, UPROBE_SWBP_INSN_SIZE)))\n\t\treturn -EINVAL;\n\n\tpagefault_disable();\n\tresult = __get_user(opcode, (uprobe_opcode_t __user *)vaddr);\n\tpagefault_enable();\n\n\tif (likely(result == 0))\n\t\tgoto out;\n\n\t/*\n\t * The NULL 'tsk' here ensures that any faults that occur here\n\t * will not be accounted to the task.  'mm' *is* current->mm,\n\t * but we treat this as a 'remote' access since it is\n\t * essentially a kernel access to the memory.\n\t */\n\tresult = get_user_pages_remote(mm, vaddr, 1, FOLL_FORCE, &page,\n\t\t\tNULL, NULL);\n\tif (result < 0)\n\t\treturn result;\n\n\tcopy_from_page(page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\tput_page(page);\n out:\n\t/* This needs to return true for any variant of the trap insn */\n\treturn is_trap_insn(&opcode);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_trap_insn",
          "args": [
            "&opcode"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "is_trap_insn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "240-243",
          "snippet": "bool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_page",
          "args": [
            "page",
            "vaddr",
            "&opcode",
            "UPROBE_SWBP_INSN_SIZE"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "copy_from_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "245-250",
          "snippet": "static void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_pages_remote",
          "args": [
            "mm",
            "vaddr",
            "1",
            "FOLL_FORCE",
            "&page",
            "NULL",
            "NULL"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "result == 0"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagefault_enable",
          "args": [],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "opcode",
            "(uprobe_opcode_t __user *)vaddr"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagefault_disable",
          "args": [],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!IS_ALIGNED(vaddr, UPROBE_SWBP_INSN_SIZE)"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "vaddr",
            "UPROBE_SWBP_INSN_SIZE"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int is_trap_at_addr(struct mm_struct *mm, unsigned long vaddr)\n{\n\tstruct page *page;\n\tuprobe_opcode_t opcode;\n\tint result;\n\n\tif (WARN_ON_ONCE(!IS_ALIGNED(vaddr, UPROBE_SWBP_INSN_SIZE)))\n\t\treturn -EINVAL;\n\n\tpagefault_disable();\n\tresult = __get_user(opcode, (uprobe_opcode_t __user *)vaddr);\n\tpagefault_enable();\n\n\tif (likely(result == 0))\n\t\tgoto out;\n\n\t/*\n\t * The NULL 'tsk' here ensures that any faults that occur here\n\t * will not be accounted to the task.  'mm' *is* current->mm,\n\t * but we treat this as a 'remote' access since it is\n\t * essentially a kernel access to the memory.\n\t */\n\tresult = get_user_pages_remote(mm, vaddr, 1, FOLL_FORCE, &page,\n\t\t\tNULL, NULL);\n\tif (result < 0)\n\t\treturn result;\n\n\tcopy_from_page(page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\tput_page(page);\n out:\n\t/* This needs to return true for any variant of the trap insn */\n\treturn is_trap_insn(&opcode);\n}"
  },
  {
    "function_name": "mmf_recalc_uprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1990-2008",
    "snippet": "static void mmf_recalc_uprobes(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (!valid_vma(vma, false))\n\t\t\tcontinue;\n\t\t/*\n\t\t * This is not strictly accurate, we can race with\n\t\t * uprobe_unregister() and see the already removed\n\t\t * uprobe if delete_uprobe() was not yet called.\n\t\t * Or this uprobe can be filtered out.\n\t\t */\n\t\tif (vma_has_uprobes(vma, vma->vm_start, vma->vm_end))\n\t\t\treturn;\n\t}\n\n\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&mm->flags"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_has_uprobes",
          "args": [
            "vma",
            "vma->vm_start",
            "vma->vm_end"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "vma_has_uprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1403-1420",
          "snippet": "static bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "false"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "121-129",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void mmf_recalc_uprobes(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (!valid_vma(vma, false))\n\t\t\tcontinue;\n\t\t/*\n\t\t * This is not strictly accurate, we can race with\n\t\t * uprobe_unregister() and see the already removed\n\t\t * uprobe if delete_uprobe() was not yet called.\n\t\t * Or this uprobe can be filtered out.\n\t\t */\n\t\tif (vma_has_uprobes(vma, vma->vm_start, vma->vm_end))\n\t\t\treturn;\n\t}\n\n\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n}"
  },
  {
    "function_name": "uprobe_deny_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1966-1988",
    "snippet": "bool uprobe_deny_signal(void)\n{\n\tstruct task_struct *t = current;\n\tstruct uprobe_task *utask = t->utask;\n\n\tif (likely(!utask || !utask->active_uprobe))\n\t\treturn false;\n\n\tWARN_ON_ONCE(utask->state != UTASK_SSTEP);\n\n\tif (task_sigpending(t)) {\n\t\tspin_lock_irq(&t->sighand->siglock);\n\t\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\tspin_unlock_irq(&t->sighand->siglock);\n\n\t\tif (__fatal_signal_pending(t) || arch_uprobe_xol_was_trapped(t)) {\n\t\t\tutask->state = UTASK_SSTEP_TRAPPED;\n\t\t\tset_tsk_thread_flag(t, TIF_UPROBE);\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "t",
            "TIF_UPROBE"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uprobe_xol_was_trapped",
          "args": [
            "t"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fatal_signal_pending",
          "args": [
            "t"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "t",
            "TIF_SIGPENDING"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_sigpending",
          "args": [
            "t"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "utask->state != UTASK_SSTEP"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!utask || !utask->active_uprobe"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool uprobe_deny_signal(void)\n{\n\tstruct task_struct *t = current;\n\tstruct uprobe_task *utask = t->utask;\n\n\tif (likely(!utask || !utask->active_uprobe))\n\t\treturn false;\n\n\tWARN_ON_ONCE(utask->state != UTASK_SSTEP);\n\n\tif (task_sigpending(t)) {\n\t\tspin_lock_irq(&t->sighand->siglock);\n\t\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\tspin_unlock_irq(&t->sighand->siglock);\n\n\t\tif (__fatal_signal_pending(t) || arch_uprobe_xol_was_trapped(t)) {\n\t\t\tutask->state = UTASK_SSTEP_TRAPPED;\n\t\t\tset_tsk_thread_flag(t, TIF_UPROBE);\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "pre_ssout",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1928-1955",
    "snippet": "static int\npre_ssout(struct uprobe *uprobe, struct pt_regs *regs, unsigned long bp_vaddr)\n{\n\tstruct uprobe_task *utask;\n\tunsigned long xol_vaddr;\n\tint err;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn -ENOMEM;\n\n\txol_vaddr = xol_get_insn_slot(uprobe);\n\tif (!xol_vaddr)\n\t\treturn -ENOMEM;\n\n\tutask->xol_vaddr = xol_vaddr;\n\tutask->vaddr = bp_vaddr;\n\n\terr = arch_uprobe_pre_xol(&uprobe->arch, regs);\n\tif (unlikely(err)) {\n\t\txol_free_insn_slot(current);\n\t\treturn err;\n\t}\n\n\tutask->active_uprobe = uprobe;\n\tutask->state = UTASK_SSTEP;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xol_free_insn_slot",
          "args": [
            "current"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "xol_free_insn_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1635-1667",
          "snippet": "static void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uprobe_pre_xol",
          "args": [
            "&uprobe->arch",
            "regs"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xol_get_insn_slot",
          "args": [
            "uprobe"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "xol_get_insn_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1611-1628",
          "snippet": "static unsigned long xol_get_insn_slot(struct uprobe *uprobe)\n{\n\tstruct xol_area *area;\n\tunsigned long xol_vaddr;\n\n\tarea = get_xol_area();\n\tif (!area)\n\t\treturn 0;\n\n\txol_vaddr = xol_take_insn_slot(area);\n\tif (unlikely(!xol_vaddr))\n\t\treturn 0;\n\n\tarch_uprobe_copy_ixol(area->pages[0], xol_vaddr,\n\t\t\t      &uprobe->arch.ixol, sizeof(uprobe->arch.ixol));\n\n\treturn xol_vaddr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long xol_get_insn_slot(struct uprobe *uprobe)\n{\n\tstruct xol_area *area;\n\tunsigned long xol_vaddr;\n\n\tarea = get_xol_area();\n\tif (!area)\n\t\treturn 0;\n\n\txol_vaddr = xol_take_insn_slot(area);\n\tif (unlikely(!xol_vaddr))\n\t\treturn 0;\n\n\tarch_uprobe_copy_ixol(area->pages[0], xol_vaddr,\n\t\t\t      &uprobe->arch.ixol, sizeof(uprobe->arch.ixol));\n\n\treturn xol_vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_utask",
          "args": [],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "get_utask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1745-1750",
          "snippet": "static struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\npre_ssout(struct uprobe *uprobe, struct pt_regs *regs, unsigned long bp_vaddr)\n{\n\tstruct uprobe_task *utask;\n\tunsigned long xol_vaddr;\n\tint err;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn -ENOMEM;\n\n\txol_vaddr = xol_get_insn_slot(uprobe);\n\tif (!xol_vaddr)\n\t\treturn -ENOMEM;\n\n\tutask->xol_vaddr = xol_vaddr;\n\tutask->vaddr = bp_vaddr;\n\n\terr = arch_uprobe_pre_xol(&uprobe->arch, regs);\n\tif (unlikely(err)) {\n\t\txol_free_insn_slot(current);\n\t\treturn err;\n\t}\n\n\tutask->active_uprobe = uprobe;\n\tutask->state = UTASK_SSTEP;\n\treturn 0;\n}"
  },
  {
    "function_name": "prepare_uretprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1861-1925",
    "snippet": "static void prepare_uretprobe(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct return_instance *ri;\n\tstruct uprobe_task *utask;\n\tunsigned long orig_ret_vaddr, trampoline_vaddr;\n\tbool chained;\n\n\tif (!get_xol_area())\n\t\treturn;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->depth >= MAX_URETPROBE_DEPTH) {\n\t\tprintk_ratelimited(KERN_INFO \"uprobe: omit uretprobe due to\"\n\t\t\t\t\" nestedness limit pid/tgid=%d/%d\\n\",\n\t\t\t\tcurrent->pid, current->tgid);\n\t\treturn;\n\t}\n\n\tri = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\tif (!ri)\n\t\treturn;\n\n\ttrampoline_vaddr = get_trampoline_vaddr();\n\torig_ret_vaddr = arch_uretprobe_hijack_return_addr(trampoline_vaddr, regs);\n\tif (orig_ret_vaddr == -1)\n\t\tgoto fail;\n\n\t/* drop the entries invalidated by longjmp() */\n\tchained = (orig_ret_vaddr == trampoline_vaddr);\n\tcleanup_return_instances(utask, chained, regs);\n\n\t/*\n\t * We don't want to keep trampoline address in stack, rather keep the\n\t * original return address of first caller thru all the consequent\n\t * instances. This also makes breakpoint unwrapping easier.\n\t */\n\tif (chained) {\n\t\tif (!utask->return_instances) {\n\t\t\t/*\n\t\t\t * This situation is not possible. Likely we have an\n\t\t\t * attack from user-space.\n\t\t\t */\n\t\t\tuprobe_warn(current, \"handle tail call\");\n\t\t\tgoto fail;\n\t\t}\n\t\torig_ret_vaddr = utask->return_instances->orig_ret_vaddr;\n\t}\n\n\tri->uprobe = get_uprobe(uprobe);\n\tri->func = instruction_pointer(regs);\n\tri->stack = user_stack_pointer(regs);\n\tri->orig_ret_vaddr = orig_ret_vaddr;\n\tri->chained = chained;\n\n\tutask->depth++;\n\tri->next = utask->return_instances;\n\tutask->return_instances = ri;\n\n\treturn;\n fail:\n\tkfree(ri);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_stack_pointer",
          "args": [
            "regs"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "get_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "597-601",
          "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_warn",
          "args": [
            "current",
            "\"handle tail call\""
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_warn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1780-1784",
          "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_return_instances",
          "args": [
            "utask",
            "chained",
            "regs"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_return_instances",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1848-1859",
          "snippet": "static void cleanup_return_instances(struct uprobe_task *utask, bool chained,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct return_instance *ri = utask->return_instances;\n\tenum rp_check ctx = chained ? RP_CHECK_CHAIN_CALL : RP_CHECK_CALL;\n\n\twhile (ri && !arch_uretprobe_is_alive(ri, ctx, regs)) {\n\t\tri = free_ret_instance(ri);\n\t\tutask->depth--;\n\t}\n\tutask->return_instances = ri;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void cleanup_return_instances(struct uprobe_task *utask, bool chained,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct return_instance *ri = utask->return_instances;\n\tenum rp_check ctx = chained ? RP_CHECK_CHAIN_CALL : RP_CHECK_CALL;\n\n\twhile (ri && !arch_uretprobe_is_alive(ri, ctx, regs)) {\n\t\tri = free_ret_instance(ri);\n\t\tutask->depth--;\n\t}\n\tutask->return_instances = ri;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_uretprobe_hijack_return_addr",
          "args": [
            "trampoline_vaddr",
            "regs"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_trampoline_vaddr",
          "args": [],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "get_trampoline_vaddr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1835-1846",
          "snippet": "static unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct return_instance)",
            "GFP_KERNEL"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_INFO \"uprobe: omit uretprobe due to\"\n\t\t\t\t\" nestedness limit pid/tgid=%d/%d\\n\"",
            "current->pid",
            "current->tgid"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_utask",
          "args": [],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "get_utask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1745-1750",
          "snippet": "static struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xol_area",
          "args": [],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "get_xol_area",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1530-1541",
          "snippet": "static struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void prepare_uretprobe(struct uprobe *uprobe, struct pt_regs *regs)\n{\n\tstruct return_instance *ri;\n\tstruct uprobe_task *utask;\n\tunsigned long orig_ret_vaddr, trampoline_vaddr;\n\tbool chained;\n\n\tif (!get_xol_area())\n\t\treturn;\n\n\tutask = get_utask();\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->depth >= MAX_URETPROBE_DEPTH) {\n\t\tprintk_ratelimited(KERN_INFO \"uprobe: omit uretprobe due to\"\n\t\t\t\t\" nestedness limit pid/tgid=%d/%d\\n\",\n\t\t\t\tcurrent->pid, current->tgid);\n\t\treturn;\n\t}\n\n\tri = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\tif (!ri)\n\t\treturn;\n\n\ttrampoline_vaddr = get_trampoline_vaddr();\n\torig_ret_vaddr = arch_uretprobe_hijack_return_addr(trampoline_vaddr, regs);\n\tif (orig_ret_vaddr == -1)\n\t\tgoto fail;\n\n\t/* drop the entries invalidated by longjmp() */\n\tchained = (orig_ret_vaddr == trampoline_vaddr);\n\tcleanup_return_instances(utask, chained, regs);\n\n\t/*\n\t * We don't want to keep trampoline address in stack, rather keep the\n\t * original return address of first caller thru all the consequent\n\t * instances. This also makes breakpoint unwrapping easier.\n\t */\n\tif (chained) {\n\t\tif (!utask->return_instances) {\n\t\t\t/*\n\t\t\t * This situation is not possible. Likely we have an\n\t\t\t * attack from user-space.\n\t\t\t */\n\t\t\tuprobe_warn(current, \"handle tail call\");\n\t\t\tgoto fail;\n\t\t}\n\t\torig_ret_vaddr = utask->return_instances->orig_ret_vaddr;\n\t}\n\n\tri->uprobe = get_uprobe(uprobe);\n\tri->func = instruction_pointer(regs);\n\tri->stack = user_stack_pointer(regs);\n\tri->orig_ret_vaddr = orig_ret_vaddr;\n\tri->chained = chained;\n\n\tutask->depth++;\n\tri->next = utask->return_instances;\n\tutask->return_instances = ri;\n\n\treturn;\n fail:\n\tkfree(ri);\n}"
  },
  {
    "function_name": "cleanup_return_instances",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1848-1859",
    "snippet": "static void cleanup_return_instances(struct uprobe_task *utask, bool chained,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct return_instance *ri = utask->return_instances;\n\tenum rp_check ctx = chained ? RP_CHECK_CHAIN_CALL : RP_CHECK_CALL;\n\n\twhile (ri && !arch_uretprobe_is_alive(ri, ctx, regs)) {\n\t\tri = free_ret_instance(ri);\n\t\tutask->depth--;\n\t}\n\tutask->return_instances = ri;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ret_instance",
          "args": [
            "ri"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "free_ret_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1705-1711",
          "snippet": "static struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_uretprobe_is_alive",
          "args": [
            "ri",
            "ctx",
            "regs"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "arch_uretprobe_is_alive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "2178-2182",
          "snippet": "bool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void cleanup_return_instances(struct uprobe_task *utask, bool chained,\n\t\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct return_instance *ri = utask->return_instances;\n\tenum rp_check ctx = chained ? RP_CHECK_CHAIN_CALL : RP_CHECK_CALL;\n\n\twhile (ri && !arch_uretprobe_is_alive(ri, ctx, regs)) {\n\t\tri = free_ret_instance(ri);\n\t\tutask->depth--;\n\t}\n\tutask->return_instances = ri;\n}"
  },
  {
    "function_name": "get_trampoline_vaddr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1835-1846",
    "snippet": "static unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "current->mm->uprobes_state.xol_area"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(current->mm->uprobes_state.xol_area); /* ^^^ */\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\n\treturn trampoline_vaddr;\n}"
  },
  {
    "function_name": "uprobe_copy_process",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1799-1827",
    "snippet": "void uprobe_copy_process(struct task_struct *t, unsigned long flags)\n{\n\tstruct uprobe_task *utask = current->utask;\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tt->utask = NULL;\n\n\tif (!utask || !utask->return_instances)\n\t\treturn;\n\n\tif (mm == t->mm && !(flags & CLONE_VFORK))\n\t\treturn;\n\n\tif (dup_utask(t, utask))\n\t\treturn uprobe_warn(t, \"dup ret instances\");\n\n\t/* The task can fork() after dup_xol_work() fails */\n\tarea = mm->uprobes_state.xol_area;\n\tif (!area)\n\t\treturn uprobe_warn(t, \"dup xol area\");\n\n\tif (mm == t->mm)\n\t\treturn;\n\n\tt->utask->dup_xol_addr = area->vaddr;\n\tinit_task_work(&t->utask->dup_xol_work, dup_xol_work);\n\ttask_work_add(t, &t->utask->dup_xol_work, TWA_RESUME);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_work_add",
          "args": [
            "t",
            "&t->utask->dup_xol_work",
            "TWA_RESUME"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/task_work.c",
          "lines": "32-62",
          "snippet": "int task_work_add(struct task_struct *task, struct callback_head *work,\n\t\t  enum task_work_notify_mode notify)\n{\n\tstruct callback_head *head;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack(work);\n\n\tdo {\n\t\thead = READ_ONCE(task->task_works);\n\t\tif (unlikely(head == &work_exited))\n\t\t\treturn -ESRCH;\n\t\twork->next = head;\n\t} while (cmpxchg(&task->task_works, head, work) != head);\n\n\tswitch (notify) {\n\tcase TWA_NONE:\n\t\tbreak;\n\tcase TWA_RESUME:\n\t\tset_notify_resume(task);\n\t\tbreak;\n\tcase TWA_SIGNAL:\n\t\tset_notify_signal(task);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/resume_user_mode.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_head work_exited;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/resume_user_mode.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nint task_work_add(struct task_struct *task, struct callback_head *work,\n\t\t  enum task_work_notify_mode notify)\n{\n\tstruct callback_head *head;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack(work);\n\n\tdo {\n\t\thead = READ_ONCE(task->task_works);\n\t\tif (unlikely(head == &work_exited))\n\t\t\treturn -ESRCH;\n\t\twork->next = head;\n\t} while (cmpxchg(&task->task_works, head, work) != head);\n\n\tswitch (notify) {\n\tcase TWA_NONE:\n\t\tbreak;\n\tcase TWA_RESUME:\n\t\tset_notify_resume(task);\n\t\tbreak;\n\tcase TWA_SIGNAL:\n\t\tset_notify_signal(task);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_task_work",
          "args": [
            "&t->utask->dup_xol_work",
            "dup_xol_work"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_warn",
          "args": [
            "t",
            "\"dup xol area\""
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_warn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1780-1784",
          "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup_utask",
          "args": [
            "t",
            "utask"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "dup_utask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1752-1778",
          "snippet": "static int dup_utask(struct task_struct *t, struct uprobe_task *o_utask)\n{\n\tstruct uprobe_task *n_utask;\n\tstruct return_instance **p, *o, *n;\n\n\tn_utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\tif (!n_utask)\n\t\treturn -ENOMEM;\n\tt->utask = n_utask;\n\n\tp = &n_utask->return_instances;\n\tfor (o = o_utask->return_instances; o; o = o->next) {\n\t\tn = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\t\tif (!n)\n\t\t\treturn -ENOMEM;\n\n\t\t*n = *o;\n\t\tget_uprobe(n->uprobe);\n\t\tn->next = NULL;\n\n\t\t*p = n;\n\t\tp = &n->next;\n\t\tn_utask->depth++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int dup_utask(struct task_struct *t, struct uprobe_task *o_utask)\n{\n\tstruct uprobe_task *n_utask;\n\tstruct return_instance **p, *o, *n;\n\n\tn_utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\tif (!n_utask)\n\t\treturn -ENOMEM;\n\tt->utask = n_utask;\n\n\tp = &n_utask->return_instances;\n\tfor (o = o_utask->return_instances; o; o = o->next) {\n\t\tn = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\t\tif (!n)\n\t\t\treturn -ENOMEM;\n\n\t\t*n = *o;\n\t\tget_uprobe(n->uprobe);\n\t\tn->next = NULL;\n\n\t\t*p = n;\n\t\tp = &n->next;\n\t\tn_utask->depth++;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_copy_process(struct task_struct *t, unsigned long flags)\n{\n\tstruct uprobe_task *utask = current->utask;\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tt->utask = NULL;\n\n\tif (!utask || !utask->return_instances)\n\t\treturn;\n\n\tif (mm == t->mm && !(flags & CLONE_VFORK))\n\t\treturn;\n\n\tif (dup_utask(t, utask))\n\t\treturn uprobe_warn(t, \"dup ret instances\");\n\n\t/* The task can fork() after dup_xol_work() fails */\n\tarea = mm->uprobes_state.xol_area;\n\tif (!area)\n\t\treturn uprobe_warn(t, \"dup xol area\");\n\n\tif (mm == t->mm)\n\t\treturn;\n\n\tt->utask->dup_xol_addr = area->vaddr;\n\tinit_task_work(&t->utask->dup_xol_work, dup_xol_work);\n\ttask_work_add(t, &t->utask->dup_xol_work, TWA_RESUME);\n}"
  },
  {
    "function_name": "dup_xol_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1786-1794",
    "snippet": "static void dup_xol_work(struct callback_head *work)\n{\n\tif (current->flags & PF_EXITING)\n\t\treturn;\n\n\tif (!__create_xol_area(current->utask->dup_xol_addr) &&\n\t\t\t!fatal_signal_pending(current))\n\t\tuprobe_warn(current, \"dup xol area\");\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_warn",
          "args": [
            "current",
            "\"dup xol area\""
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_warn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1780-1784",
          "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__create_xol_area",
          "args": [
            "current->utask->dup_xol_addr"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "__create_xol_area",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1482-1522",
          "snippet": "static struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void dup_xol_work(struct callback_head *work)\n{\n\tif (current->flags & PF_EXITING)\n\t\treturn;\n\n\tif (!__create_xol_area(current->utask->dup_xol_addr) &&\n\t\t\t!fatal_signal_pending(current))\n\t\tuprobe_warn(current, \"dup xol area\");\n}"
  },
  {
    "function_name": "uprobe_warn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1780-1784",
    "snippet": "static void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"uprobe: %s:%d failed to %s\\n\"",
            "current->comm",
            "current->pid",
            "msg"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void uprobe_warn(struct task_struct *t, const char *msg)\n{\n\tpr_warn(\"uprobe: %s:%d failed to %s\\n\",\n\t\t\tcurrent->comm, current->pid, msg);\n}"
  },
  {
    "function_name": "dup_utask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1752-1778",
    "snippet": "static int dup_utask(struct task_struct *t, struct uprobe_task *o_utask)\n{\n\tstruct uprobe_task *n_utask;\n\tstruct return_instance **p, *o, *n;\n\n\tn_utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\tif (!n_utask)\n\t\treturn -ENOMEM;\n\tt->utask = n_utask;\n\n\tp = &n_utask->return_instances;\n\tfor (o = o_utask->return_instances; o; o = o->next) {\n\t\tn = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\t\tif (!n)\n\t\t\treturn -ENOMEM;\n\n\t\t*n = *o;\n\t\tget_uprobe(n->uprobe);\n\t\tn->next = NULL;\n\n\t\t*p = n;\n\t\tp = &n->next;\n\t\tn_utask->depth++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_uprobe",
          "args": [
            "n->uprobe"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "get_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "597-601",
          "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct return_instance)",
            "GFP_KERNEL"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct uprobe_task)",
            "GFP_KERNEL"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int dup_utask(struct task_struct *t, struct uprobe_task *o_utask)\n{\n\tstruct uprobe_task *n_utask;\n\tstruct return_instance **p, *o, *n;\n\n\tn_utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\tif (!n_utask)\n\t\treturn -ENOMEM;\n\tt->utask = n_utask;\n\n\tp = &n_utask->return_instances;\n\tfor (o = o_utask->return_instances; o; o = o->next) {\n\t\tn = kmalloc(sizeof(struct return_instance), GFP_KERNEL);\n\t\tif (!n)\n\t\t\treturn -ENOMEM;\n\n\t\t*n = *o;\n\t\tget_uprobe(n->uprobe);\n\t\tn->next = NULL;\n\n\t\t*p = n;\n\t\tp = &n->next;\n\t\tn_utask->depth++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_utask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1745-1750",
    "snippet": "static struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct uprobe_task)",
            "GFP_KERNEL"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe_task *get_utask(void)\n{\n\tif (!current->utask)\n\t\tcurrent->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);\n\treturn current->utask;\n}"
  },
  {
    "function_name": "uprobe_free_utask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1717-1735",
    "snippet": "void uprobe_free_utask(struct task_struct *t)\n{\n\tstruct uprobe_task *utask = t->utask;\n\tstruct return_instance *ri;\n\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->active_uprobe)\n\t\tput_uprobe(utask->active_uprobe);\n\n\tri = utask->return_instances;\n\twhile (ri)\n\t\tri = free_ret_instance(ri);\n\n\txol_free_insn_slot(t);\n\tkfree(utask);\n\tt->utask = NULL;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utask"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xol_free_insn_slot",
          "args": [
            "t"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "xol_free_insn_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1635-1667",
          "snippet": "static void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ret_instance",
          "args": [
            "ri"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "free_ret_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1705-1711",
          "snippet": "static struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "utask->active_uprobe"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "603-616",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_free_utask(struct task_struct *t)\n{\n\tstruct uprobe_task *utask = t->utask;\n\tstruct return_instance *ri;\n\n\tif (!utask)\n\t\treturn;\n\n\tif (utask->active_uprobe)\n\t\tput_uprobe(utask->active_uprobe);\n\n\tri = utask->return_instances;\n\twhile (ri)\n\t\tri = free_ret_instance(ri);\n\n\txol_free_insn_slot(t);\n\tkfree(utask);\n\tt->utask = NULL;\n}"
  },
  {
    "function_name": "free_ret_instance",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1705-1711",
    "snippet": "static struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "ri->uprobe"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "603-616",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct return_instance *free_ret_instance(struct return_instance *ri)\n{\n\tstruct return_instance *next = ri->next;\n\tput_uprobe(ri->uprobe);\n\tkfree(ri);\n\treturn next;\n}"
  },
  {
    "function_name": "uprobe_get_trap_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1695-1703",
    "snippet": "unsigned long uprobe_get_trap_addr(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tif (unlikely(utask && utask->active_uprobe))\n\t\treturn utask->vaddr;\n\n\treturn instruction_pointer(regs);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "utask && utask->active_uprobe"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nunsigned long uprobe_get_trap_addr(struct pt_regs *regs)\n{\n\tstruct uprobe_task *utask = current->utask;\n\n\tif (unlikely(utask && utask->active_uprobe))\n\t\treturn utask->vaddr;\n\n\treturn instruction_pointer(regs);\n}"
  },
  {
    "function_name": "uprobe_get_swbp_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1690-1693",
    "snippet": "unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs) - UPROBE_SWBP_INSN_SIZE;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nunsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs) - UPROBE_SWBP_INSN_SIZE;\n}"
  },
  {
    "function_name": "arch_uprobe_copy_ixol",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1669-1682",
    "snippet": "void __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_page() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_page",
          "args": [
            "page",
            "vaddr",
            "src",
            "len"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "copy_to_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "252-257",
          "snippet": "static void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_page() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}"
  },
  {
    "function_name": "xol_free_insn_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1635-1667",
    "snippet": "static void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&area->wq"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&area->wq"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&area->slot_count"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "slot_nr",
            "area->bitmap"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!slot_addr"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic void xol_free_insn_slot(struct task_struct *tsk)\n{\n\tstruct xol_area *area;\n\tunsigned long vma_end;\n\tunsigned long slot_addr;\n\n\tif (!tsk->mm || !tsk->mm->uprobes_state.xol_area || !tsk->utask)\n\t\treturn;\n\n\tslot_addr = tsk->utask->xol_vaddr;\n\tif (unlikely(!slot_addr))\n\t\treturn;\n\n\tarea = tsk->mm->uprobes_state.xol_area;\n\tvma_end = area->vaddr + PAGE_SIZE;\n\tif (area->vaddr <= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->vaddr;\n\t\tslot_nr = offset / UPROBE_XOL_SLOT_BYTES;\n\t\tif (slot_nr >= UINSNS_PER_PAGE)\n\t\t\treturn;\n\n\t\tclear_bit(slot_nr, area->bitmap);\n\t\tatomic_dec(&area->slot_count);\n\t\tsmp_mb__after_atomic(); /* pairs with prepare_to_wait() */\n\t\tif (waitqueue_active(&area->wq))\n\t\t\twake_up(&area->wq);\n\n\t\ttsk->utask->xol_vaddr = 0;\n\t}\n}"
  },
  {
    "function_name": "xol_get_insn_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1611-1628",
    "snippet": "static unsigned long xol_get_insn_slot(struct uprobe *uprobe)\n{\n\tstruct xol_area *area;\n\tunsigned long xol_vaddr;\n\n\tarea = get_xol_area();\n\tif (!area)\n\t\treturn 0;\n\n\txol_vaddr = xol_take_insn_slot(area);\n\tif (unlikely(!xol_vaddr))\n\t\treturn 0;\n\n\tarch_uprobe_copy_ixol(area->pages[0], xol_vaddr,\n\t\t\t      &uprobe->arch.ixol, sizeof(uprobe->arch.ixol));\n\n\treturn xol_vaddr;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_uprobe_copy_ixol",
          "args": [
            "area->pages[0]",
            "xol_vaddr",
            "&uprobe->arch.ixol",
            "sizeof(uprobe->arch.ixol)"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "arch_uprobe_copy_ixol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1669-1682",
          "snippet": "void __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_page() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_page() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!xol_vaddr"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xol_take_insn_slot",
          "args": [
            "area"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "xol_take_insn_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1584-1605",
          "snippet": "static unsigned long xol_take_insn_slot(struct xol_area *area)\n{\n\tunsigned long slot_addr;\n\tint slot_nr;\n\n\tdo {\n\t\tslot_nr = find_first_zero_bit(area->bitmap, UINSNS_PER_PAGE);\n\t\tif (slot_nr < UINSNS_PER_PAGE) {\n\t\t\tif (!test_and_set_bit(slot_nr, area->bitmap))\n\t\t\t\tbreak;\n\n\t\t\tslot_nr = UINSNS_PER_PAGE;\n\t\t\tcontinue;\n\t\t}\n\t\twait_event(area->wq, (atomic_read(&area->slot_count) < UINSNS_PER_PAGE));\n\t} while (slot_nr >= UINSNS_PER_PAGE);\n\n\tslot_addr = area->vaddr + (slot_nr * UPROBE_XOL_SLOT_BYTES);\n\tatomic_inc(&area->slot_count);\n\n\treturn slot_addr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic unsigned long xol_take_insn_slot(struct xol_area *area)\n{\n\tunsigned long slot_addr;\n\tint slot_nr;\n\n\tdo {\n\t\tslot_nr = find_first_zero_bit(area->bitmap, UINSNS_PER_PAGE);\n\t\tif (slot_nr < UINSNS_PER_PAGE) {\n\t\t\tif (!test_and_set_bit(slot_nr, area->bitmap))\n\t\t\t\tbreak;\n\n\t\t\tslot_nr = UINSNS_PER_PAGE;\n\t\t\tcontinue;\n\t\t}\n\t\twait_event(area->wq, (atomic_read(&area->slot_count) < UINSNS_PER_PAGE));\n\t} while (slot_nr >= UINSNS_PER_PAGE);\n\n\tslot_addr = area->vaddr + (slot_nr * UPROBE_XOL_SLOT_BYTES);\n\tatomic_inc(&area->slot_count);\n\n\treturn slot_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xol_area",
          "args": [],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "get_xol_area",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1530-1541",
          "snippet": "static struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long xol_get_insn_slot(struct uprobe *uprobe)\n{\n\tstruct xol_area *area;\n\tunsigned long xol_vaddr;\n\n\tarea = get_xol_area();\n\tif (!area)\n\t\treturn 0;\n\n\txol_vaddr = xol_take_insn_slot(area);\n\tif (unlikely(!xol_vaddr))\n\t\treturn 0;\n\n\tarch_uprobe_copy_ixol(area->pages[0], xol_vaddr,\n\t\t\t      &uprobe->arch.ixol, sizeof(uprobe->arch.ixol));\n\n\treturn xol_vaddr;\n}"
  },
  {
    "function_name": "xol_take_insn_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1584-1605",
    "snippet": "static unsigned long xol_take_insn_slot(struct xol_area *area)\n{\n\tunsigned long slot_addr;\n\tint slot_nr;\n\n\tdo {\n\t\tslot_nr = find_first_zero_bit(area->bitmap, UINSNS_PER_PAGE);\n\t\tif (slot_nr < UINSNS_PER_PAGE) {\n\t\t\tif (!test_and_set_bit(slot_nr, area->bitmap))\n\t\t\t\tbreak;\n\n\t\t\tslot_nr = UINSNS_PER_PAGE;\n\t\t\tcontinue;\n\t\t}\n\t\twait_event(area->wq, (atomic_read(&area->slot_count) < UINSNS_PER_PAGE));\n\t} while (slot_nr >= UINSNS_PER_PAGE);\n\n\tslot_addr = area->vaddr + (slot_nr * UPROBE_XOL_SLOT_BYTES);\n\tatomic_inc(&area->slot_count);\n\n\treturn slot_addr;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&area->slot_count"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "area->wq",
            "(atomic_read(&area->slot_count) < UINSNS_PER_PAGE)"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&area->slot_count"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "slot_nr",
            "area->bitmap"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "area->bitmap",
            "UINSNS_PER_PAGE"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic unsigned long xol_take_insn_slot(struct xol_area *area)\n{\n\tunsigned long slot_addr;\n\tint slot_nr;\n\n\tdo {\n\t\tslot_nr = find_first_zero_bit(area->bitmap, UINSNS_PER_PAGE);\n\t\tif (slot_nr < UINSNS_PER_PAGE) {\n\t\t\tif (!test_and_set_bit(slot_nr, area->bitmap))\n\t\t\t\tbreak;\n\n\t\t\tslot_nr = UINSNS_PER_PAGE;\n\t\t\tcontinue;\n\t\t}\n\t\twait_event(area->wq, (atomic_read(&area->slot_count) < UINSNS_PER_PAGE));\n\t} while (slot_nr >= UINSNS_PER_PAGE);\n\n\tslot_addr = area->vaddr + (slot_nr * UPROBE_XOL_SLOT_BYTES);\n\tatomic_inc(&area->slot_count);\n\n\treturn slot_addr;\n}"
  },
  {
    "function_name": "uprobe_dup_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1572-1579",
    "snippet": "void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm)\n{\n\tif (test_bit(MMF_HAS_UPROBES, &oldmm->flags)) {\n\t\tset_bit(MMF_HAS_UPROBES, &newmm->flags);\n\t\t/* unconditionally, dup_mmap() skips VM_DONTCOPY vmas */\n\t\tset_bit(MMF_RECALC_UPROBES, &newmm->flags);\n\t}\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_RECALC_UPROBES",
            "&newmm->flags"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&oldmm->flags"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm)\n{\n\tif (test_bit(MMF_HAS_UPROBES, &oldmm->flags)) {\n\t\tset_bit(MMF_HAS_UPROBES, &newmm->flags);\n\t\t/* unconditionally, dup_mmap() skips VM_DONTCOPY vmas */\n\t\tset_bit(MMF_RECALC_UPROBES, &newmm->flags);\n\t}\n}"
  },
  {
    "function_name": "uprobe_end_dup_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1567-1570",
    "snippet": "void uprobe_end_dup_mmap(void)\n{\n\tpercpu_up_read(&dup_mmap_sem);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_read",
          "args": [
            "&dup_mmap_sem"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_end_dup_mmap(void)\n{\n\tpercpu_up_read(&dup_mmap_sem);\n}"
  },
  {
    "function_name": "uprobe_start_dup_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1562-1565",
    "snippet": "void uprobe_start_dup_mmap(void)\n{\n\tpercpu_down_read(&dup_mmap_sem);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_read",
          "args": [
            "&dup_mmap_sem"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_start_dup_mmap(void)\n{\n\tpercpu_down_read(&dup_mmap_sem);\n}"
  },
  {
    "function_name": "uprobe_clear_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1546-1560",
    "snippet": "void uprobe_clear_state(struct mm_struct *mm)\n{\n\tstruct xol_area *area = mm->uprobes_state.xol_area;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tdelayed_uprobe_remove(NULL, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\tif (!area)\n\t\treturn;\n\n\tput_page(area->pages[0]);\n\tkfree(area->bitmap);\n\tkfree(area);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(delayed_uprobe_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "area"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "area->pages[0]"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_remove",
          "args": [
            "NULL",
            "mm"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "323-341",
          "snippet": "static void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\n\nvoid uprobe_clear_state(struct mm_struct *mm)\n{\n\tstruct xol_area *area = mm->uprobes_state.xol_area;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tdelayed_uprobe_remove(NULL, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\tif (!area)\n\t\treturn;\n\n\tput_page(area->pages[0]);\n\tkfree(area->bitmap);\n\tkfree(area);\n}"
  },
  {
    "function_name": "get_xol_area",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1530-1541",
    "snippet": "static struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "mm->uprobes_state.xol_area"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__create_xol_area",
          "args": [
            "0"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "__create_xol_area",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1482-1522",
          "snippet": "static struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}"
  },
  {
    "function_name": "__create_xol_area",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1482-1522",
    "snippet": "static struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "area"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "area->pages[0]"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xol_add_vma",
          "args": [
            "mm",
            "area"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "xol_add_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1442-1480",
          "snippet": "static int xol_add_vma(struct mm_struct *mm, struct xol_area *area)\n{\n\tstruct vm_area_struct *vma;\n\tint ret;\n\n\tif (mmap_write_lock_killable(mm))\n\t\treturn -EINTR;\n\n\tif (mm->uprobes_state.xol_area) {\n\t\tret = -EALREADY;\n\t\tgoto fail;\n\t}\n\n\tif (!area->vaddr) {\n\t\t/* Try to map as high as possible, this is only a hint. */\n\t\tarea->vaddr = get_unmapped_area(NULL, TASK_SIZE - PAGE_SIZE,\n\t\t\t\t\t\tPAGE_SIZE, 0, 0);\n\t\tif (IS_ERR_VALUE(area->vaddr)) {\n\t\t\tret = area->vaddr;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tvma = _install_special_mapping(mm, area->vaddr, PAGE_SIZE,\n\t\t\t\tVM_EXEC|VM_MAYEXEC|VM_DONTCOPY|VM_IO,\n\t\t\t\t&area->xol_mapping);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto fail;\n\t}\n\n\tret = 0;\n\t/* pairs with get_xol_area() */\n\tsmp_store_release(&mm->uprobes_state.xol_area, area); /* ^^^ */\n fail:\n\tmmap_write_unlock(mm);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int xol_add_vma(struct mm_struct *mm, struct xol_area *area)\n{\n\tstruct vm_area_struct *vma;\n\tint ret;\n\n\tif (mmap_write_lock_killable(mm))\n\t\treturn -EINTR;\n\n\tif (mm->uprobes_state.xol_area) {\n\t\tret = -EALREADY;\n\t\tgoto fail;\n\t}\n\n\tif (!area->vaddr) {\n\t\t/* Try to map as high as possible, this is only a hint. */\n\t\tarea->vaddr = get_unmapped_area(NULL, TASK_SIZE - PAGE_SIZE,\n\t\t\t\t\t\tPAGE_SIZE, 0, 0);\n\t\tif (IS_ERR_VALUE(area->vaddr)) {\n\t\t\tret = area->vaddr;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tvma = _install_special_mapping(mm, area->vaddr, PAGE_SIZE,\n\t\t\t\tVM_EXEC|VM_MAYEXEC|VM_DONTCOPY|VM_IO,\n\t\t\t\t&area->xol_mapping);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto fail;\n\t}\n\n\tret = 0;\n\t/* pairs with get_xol_area() */\n\tsmp_store_release(&mm->uprobes_state.xol_area, area); /* ^^^ */\n fail:\n\tmmap_write_unlock(mm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_uprobe_copy_ixol",
          "args": [
            "area->pages[0]",
            "0",
            "&insn",
            "UPROBE_SWBP_INSN_SIZE"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "arch_uprobe_copy_ixol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1669-1682",
          "snippet": "void __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_page() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\n\t\t\t\t  void *src, unsigned long len)\n{\n\t/* Initialize the slot */\n\tcopy_to_page(page, vaddr, src, len);\n\n\t/*\n\t * We probably need flush_icache_user_page() but it needs vma.\n\t * This should work on most of architectures by default. If\n\t * architecture needs to do something different it can define\n\t * its own version of the function.\n\t */\n\tflush_dcache_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&area->slot_count",
            "1"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "0",
            "area->bitmap"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&area->wq"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_HIGHUSER"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mmap_alloc_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "784-795",
          "snippet": "static void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "BITS_TO_LONGS(UINSNS_PER_PAGE)",
            "sizeof(long)",
            "GFP_KERNEL"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "UINSNS_PER_PAGE"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!area"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*area)",
            "GFP_KERNEL"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UINSNS_PER_PAGE\t\t\t(PAGE_SIZE/UPROBE_XOL_SLOT_BYTES)\n\nstatic struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\n\tarea->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),\n\t\t\t       GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\t/* Reserve the 1st slot for get_trampoline_vaddr() */\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}"
  },
  {
    "function_name": "xol_add_vma",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1442-1480",
    "snippet": "static int xol_add_vma(struct mm_struct *mm, struct xol_area *area)\n{\n\tstruct vm_area_struct *vma;\n\tint ret;\n\n\tif (mmap_write_lock_killable(mm))\n\t\treturn -EINTR;\n\n\tif (mm->uprobes_state.xol_area) {\n\t\tret = -EALREADY;\n\t\tgoto fail;\n\t}\n\n\tif (!area->vaddr) {\n\t\t/* Try to map as high as possible, this is only a hint. */\n\t\tarea->vaddr = get_unmapped_area(NULL, TASK_SIZE - PAGE_SIZE,\n\t\t\t\t\t\tPAGE_SIZE, 0, 0);\n\t\tif (IS_ERR_VALUE(area->vaddr)) {\n\t\t\tret = area->vaddr;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tvma = _install_special_mapping(mm, area->vaddr, PAGE_SIZE,\n\t\t\t\tVM_EXEC|VM_MAYEXEC|VM_DONTCOPY|VM_IO,\n\t\t\t\t&area->xol_mapping);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto fail;\n\t}\n\n\tret = 0;\n\t/* pairs with get_xol_area() */\n\tsmp_store_release(&mm->uprobes_state.xol_area, area); /* ^^^ */\n fail:\n\tmmap_write_unlock(mm);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmap_write_unlock",
          "args": [
            "mm"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&mm->uprobes_state.xol_area",
            "area"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vma"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vma"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_install_special_mapping",
          "args": [
            "mm",
            "area->vaddr",
            "PAGE_SIZE",
            "VM_EXEC|VM_MAYEXEC|VM_DONTCOPY|VM_IO",
            "&area->xol_mapping"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "area->vaddr"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unmapped_area",
          "args": [
            "NULL",
            "TASK_SIZE - PAGE_SIZE",
            "PAGE_SIZE",
            "0",
            "0"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap_write_lock_killable",
          "args": [
            "mm"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int xol_add_vma(struct mm_struct *mm, struct xol_area *area)\n{\n\tstruct vm_area_struct *vma;\n\tint ret;\n\n\tif (mmap_write_lock_killable(mm))\n\t\treturn -EINTR;\n\n\tif (mm->uprobes_state.xol_area) {\n\t\tret = -EALREADY;\n\t\tgoto fail;\n\t}\n\n\tif (!area->vaddr) {\n\t\t/* Try to map as high as possible, this is only a hint. */\n\t\tarea->vaddr = get_unmapped_area(NULL, TASK_SIZE - PAGE_SIZE,\n\t\t\t\t\t\tPAGE_SIZE, 0, 0);\n\t\tif (IS_ERR_VALUE(area->vaddr)) {\n\t\t\tret = area->vaddr;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tvma = _install_special_mapping(mm, area->vaddr, PAGE_SIZE,\n\t\t\t\tVM_EXEC|VM_MAYEXEC|VM_DONTCOPY|VM_IO,\n\t\t\t\t&area->xol_mapping);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto fail;\n\t}\n\n\tret = 0;\n\t/* pairs with get_xol_area() */\n\tsmp_store_release(&mm->uprobes_state.xol_area, area); /* ^^^ */\n fail:\n\tmmap_write_unlock(mm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "uprobe_munmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1425-1439",
    "snippet": "void uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tif (no_uprobe_events() || !valid_vma(vma, false))\n\t\treturn;\n\n\tif (!atomic_read(&vma->vm_mm->mm_users)) /* called by mmput() ? */\n\t\treturn;\n\n\tif (!test_bit(MMF_HAS_UPROBES, &vma->vm_mm->flags) ||\n\t     test_bit(MMF_RECALC_UPROBES, &vma->vm_mm->flags))\n\t\treturn;\n\n\tif (vma_has_uprobes(vma, start, end))\n\t\tset_bit(MMF_RECALC_UPROBES, &vma->vm_mm->flags);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_RECALC_UPROBES",
            "&vma->vm_mm->flags"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_has_uprobes",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "vma_has_uprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1403-1420",
          "snippet": "static bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_RECALC_UPROBES",
            "&vma->vm_mm->flags"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&vma->vm_mm->mm_users"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "false"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "121-129",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_uprobe_events",
          "args": [],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tif (no_uprobe_events() || !valid_vma(vma, false))\n\t\treturn;\n\n\tif (!atomic_read(&vma->vm_mm->mm_users)) /* called by mmput() ? */\n\t\treturn;\n\n\tif (!test_bit(MMF_HAS_UPROBES, &vma->vm_mm->flags) ||\n\t     test_bit(MMF_RECALC_UPROBES, &vma->vm_mm->flags))\n\t\treturn;\n\n\tif (vma_has_uprobes(vma, start, end))\n\t\tset_bit(MMF_RECALC_UPROBES, &vma->vm_mm->flags);\n}"
  },
  {
    "function_name": "vma_has_uprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1403-1420",
    "snippet": "static bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(uprobes_treelock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_node_in_range",
          "args": [
            "inode",
            "min",
            "max"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "find_node_in_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1265-1288",
          "snippet": "static struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vaddr_to_offset",
          "args": [
            "vma",
            "start"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "vaddr_to_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "136-139",
          "snippet": "static loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic bool\nvma_has_uprobes(struct vm_area_struct *vma, unsigned long start, unsigned long end)\n{\n\tloff_t min, max;\n\tstruct inode *inode;\n\tstruct rb_node *n;\n\n\tinode = file_inode(vma->vm_file);\n\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn !!n;\n}"
  },
  {
    "function_name": "uprobe_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1362-1401",
    "snippet": "int uprobe_mmap(struct vm_area_struct *vma)\n{\n\tstruct list_head tmp_list;\n\tstruct uprobe *uprobe, *u;\n\tstruct inode *inode;\n\n\tif (no_uprobe_events())\n\t\treturn 0;\n\n\tif (vma->vm_file &&\n\t    (vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t    test_bit(MMF_HAS_UPROBES, &vma->vm_mm->flags))\n\t\tdelayed_ref_ctr_inc(vma);\n\n\tif (!valid_vma(vma, true))\n\t\treturn 0;\n\n\tinode = file_inode(vma->vm_file);\n\tif (!inode)\n\t\treturn 0;\n\n\tmutex_lock(uprobes_mmap_hash(inode));\n\tbuild_probe_list(inode, vma, vma->vm_start, vma->vm_end, &tmp_list);\n\t/*\n\t * We can race with uprobe_unregister(), this uprobe can be already\n\t * removed. But in this case filter_chain() must return false, all\n\t * consumers have gone away.\n\t */\n\tlist_for_each_entry_safe(uprobe, u, &tmp_list, pending_list) {\n\t\tif (!fatal_signal_pending(current) &&\n\t\t    filter_chain(uprobe, UPROBE_FILTER_MMAP, vma->vm_mm)) {\n\t\t\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\t\tinstall_breakpoint(uprobe, vma->vm_mm, vma, vaddr);\n\t\t}\n\t\tput_uprobe(uprobe);\n\t}\n\tmutex_unlock(uprobes_mmap_hash(inode));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "uprobes_mmap_hash(inode)"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobes_mmap_hash",
          "args": [
            "inode"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "603-616",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_breakpoint",
          "args": [
            "uprobe",
            "vma->vm_mm",
            "vma",
            "vaddr"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "install_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "896-922",
          "snippet": "static int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "vma",
            "uprobe->offset"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "131-134",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_chain",
          "args": [
            "uprobe",
            "UPROBE_FILTER_MMAP",
            "vma->vm_mm"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "filter_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "879-894",
          "snippet": "static bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "uprobe",
            "u",
            "&tmp_list",
            "pending_list"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_probe_list",
          "args": [
            "inode",
            "vma",
            "vma->vm_start",
            "vma->vm_end",
            "&tmp_list"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "build_probe_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1293-1325",
          "snippet": "static void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "uprobes_mmap_hash(inode)"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobes_mmap_hash",
          "args": [
            "inode"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "true"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "121-129",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_ref_ctr_inc",
          "args": [
            "vma"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_ref_ctr_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1328-1354",
          "snippet": "static int delayed_ref_ctr_inc(struct vm_area_struct *vma)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\tunsigned long vaddr;\n\tint ret = 0, err = 0;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (du->mm != vma->vm_mm ||\n\t\t    !valid_ref_ctr_vma(du->uprobe, vma))\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, du->uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(vma->vm_mm, vaddr, 1);\n\t\tif (ret) {\n\t\t\tupdate_ref_ctr_warn(du->uprobe, vma->vm_mm, 1);\n\t\t\tif (!err)\n\t\t\t\terr = ret;\n\t\t}\n\t\tdelayed_uprobe_delete(du);\n\t}\n\tmutex_unlock(&delayed_uprobe_lock);\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic int delayed_ref_ctr_inc(struct vm_area_struct *vma)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\tunsigned long vaddr;\n\tint ret = 0, err = 0;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (du->mm != vma->vm_mm ||\n\t\t    !valid_ref_ctr_vma(du->uprobe, vma))\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, du->uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(vma->vm_mm, vaddr, 1);\n\t\tif (ret) {\n\t\t\tupdate_ref_ctr_warn(du->uprobe, vma->vm_mm, 1);\n\t\t\tif (!err)\n\t\t\t\terr = ret;\n\t\t}\n\t\tdelayed_uprobe_delete(du);\n\t}\n\tmutex_unlock(&delayed_uprobe_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&vma->vm_mm->flags"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_uprobe_events",
          "args": [],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_mmap(struct vm_area_struct *vma)\n{\n\tstruct list_head tmp_list;\n\tstruct uprobe *uprobe, *u;\n\tstruct inode *inode;\n\n\tif (no_uprobe_events())\n\t\treturn 0;\n\n\tif (vma->vm_file &&\n\t    (vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t    test_bit(MMF_HAS_UPROBES, &vma->vm_mm->flags))\n\t\tdelayed_ref_ctr_inc(vma);\n\n\tif (!valid_vma(vma, true))\n\t\treturn 0;\n\n\tinode = file_inode(vma->vm_file);\n\tif (!inode)\n\t\treturn 0;\n\n\tmutex_lock(uprobes_mmap_hash(inode));\n\tbuild_probe_list(inode, vma, vma->vm_start, vma->vm_end, &tmp_list);\n\t/*\n\t * We can race with uprobe_unregister(), this uprobe can be already\n\t * removed. But in this case filter_chain() must return false, all\n\t * consumers have gone away.\n\t */\n\tlist_for_each_entry_safe(uprobe, u, &tmp_list, pending_list) {\n\t\tif (!fatal_signal_pending(current) &&\n\t\t    filter_chain(uprobe, UPROBE_FILTER_MMAP, vma->vm_mm)) {\n\t\t\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\t\tinstall_breakpoint(uprobe, vma->vm_mm, vma, vaddr);\n\t\t}\n\t\tput_uprobe(uprobe);\n\t}\n\tmutex_unlock(uprobes_mmap_hash(inode));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "delayed_ref_ctr_inc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1328-1354",
    "snippet": "static int delayed_ref_ctr_inc(struct vm_area_struct *vma)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\tunsigned long vaddr;\n\tint ret = 0, err = 0;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (du->mm != vma->vm_mm ||\n\t\t    !valid_ref_ctr_vma(du->uprobe, vma))\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, du->uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(vma->vm_mm, vaddr, 1);\n\t\tif (ret) {\n\t\t\tupdate_ref_ctr_warn(du->uprobe, vma->vm_mm, 1);\n\t\t\tif (!err)\n\t\t\t\terr = ret;\n\t\t}\n\t\tdelayed_uprobe_delete(du);\n\t}\n\tmutex_unlock(&delayed_uprobe_lock);\n\treturn err;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(delayed_uprobe_lock);",
      "static LIST_HEAD(delayed_uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_delete",
          "args": [
            "du"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "315-321",
          "snippet": "static void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_ref_ctr_warn",
          "args": [
            "du->uprobe",
            "vma->vm_mm",
            "1"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "update_ref_ctr_warn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "408-416",
          "snippet": "static void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_ref_ctr",
          "args": [
            "vma->vm_mm",
            "vaddr",
            "1"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "__update_ref_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "368-406",
          "snippet": "static int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "vma",
            "du->uprobe->ref_ctr_offset"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "131-134",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_ref_ctr_vma",
          "args": [
            "du->uprobe",
            "vma"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "valid_ref_ctr_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "343-354",
          "snippet": "static bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structdelayed_uprobe",
            "list"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "q",
            "&delayed_uprobe_list"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic int delayed_ref_ctr_inc(struct vm_area_struct *vma)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\tunsigned long vaddr;\n\tint ret = 0, err = 0;\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (du->mm != vma->vm_mm ||\n\t\t    !valid_ref_ctr_vma(du->uprobe, vma))\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, du->uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(vma->vm_mm, vaddr, 1);\n\t\tif (ret) {\n\t\t\tupdate_ref_ctr_warn(du->uprobe, vma->vm_mm, 1);\n\t\t\tif (!err)\n\t\t\t\terr = ret;\n\t\t}\n\t\tdelayed_uprobe_delete(du);\n\t}\n\tmutex_unlock(&delayed_uprobe_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "build_probe_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1293-1325",
    "snippet": "static void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(uprobes_treelock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_uprobe",
          "args": [
            "u"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "get_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "597-601",
          "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&u->pending_list",
            "head"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "1789-1820",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->hw.flags & PERF_EVENT_FLAG_USER_READ_CNT)\n\t\tctx->nr_user++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tif (event->state > PERF_EVENT_STATE_OFF)\n\t\tperf_cgroup_event_enable(event, ctx);\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->hw.flags & PERF_EVENT_FLAG_USER_READ_CNT)\n\t\tctx->nr_user++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tif (event->state > PERF_EVENT_STATE_OFF)\n\t\tperf_cgroup_event_enable(event, ctx);\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "t",
            "structuprobe",
            "rb_node"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "t"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "prb_next_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_ringbuffer.c",
          "lines": "2006-2015",
          "snippet": "u64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}",
          "includes": [
            "#include \"printk_ringbuffer.h\"",
            "#include <linux/bug.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"printk_ringbuffer.h\"\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/irqflags.h>\n#include <linux/kernel.h>\n\nu64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "t",
            "structuprobe",
            "rb_node"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "t"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_node_in_range",
          "args": [
            "inode",
            "min",
            "max"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "find_node_in_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1265-1288",
          "snippet": "static struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vaddr_to_offset",
          "args": [
            "vma",
            "start"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "vaddr_to_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "136-139",
          "snippet": "static loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "head"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}"
  },
  {
    "function_name": "find_node_in_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1265-1288",
    "snippet": "static struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root uprobes_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structuprobe",
            "rb_node"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct rb_node *\nfind_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n;\n}"
  },
  {
    "function_name": "unapply_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1238-1263",
    "snippet": "static int unapply_uprobe(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tmmap_read_lock(mm);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tunsigned long vaddr;\n\t\tloff_t offset;\n\n\t\tif (!valid_vma(vma, false) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tcontinue;\n\n\t\toffset = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t\tif (uprobe->offset <  offset ||\n\t\t    uprobe->offset >= offset + vma->vm_end - vma->vm_start)\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\terr |= remove_breakpoint(uprobe, mm, vaddr);\n\t}\n\tmmap_read_unlock(mm);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmap_read_unlock",
          "args": [
            "mm"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_breakpoint",
          "args": [
            "uprobe",
            "mm",
            "vaddr"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "remove_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "924-929",
          "snippet": "static int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "vma",
            "uprobe->offset"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "131-134",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "false"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "121-129",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmap_read_lock",
          "args": [
            "mm"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int unapply_uprobe(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tmmap_read_lock(mm);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tunsigned long vaddr;\n\t\tloff_t offset;\n\n\t\tif (!valid_vma(vma, false) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tcontinue;\n\n\t\toffset = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t\tif (uprobe->offset <  offset ||\n\t\t    uprobe->offset >= offset + vma->vm_end - vma->vm_start)\n\t\t\tcontinue;\n\n\t\tvaddr = offset_to_vaddr(vma, uprobe->offset);\n\t\terr |= remove_breakpoint(uprobe, mm, vaddr);\n\t}\n\tmmap_read_unlock(mm);\n\n\treturn err;\n}"
  },
  {
    "function_name": "uprobe_apply",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1216-1236",
    "snippet": "int uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "603-616",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_for_each_vma",
          "args": [
            "uprobe",
            "add ? uc : NULL"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "register_for_each_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1035-1087",
          "snippet": "static int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tmmap_write_lock(mm);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tmmap_write_unlock(mm);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tmmap_write_lock(mm);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tmmap_write_unlock(mm);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_uprobe",
          "args": [
            "inode",
            "offset"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "find_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "675-684",
          "snippet": "static struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_apply(struct inode *inode, loff_t offset,\n\t\t\tstruct uprobe_consumer *uc, bool add)\n{\n\tstruct uprobe *uprobe;\n\tstruct uprobe_consumer *con;\n\tint ret = -ENOENT;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn ret;\n\n\tdown_write(&uprobe->register_rwsem);\n\tfor (con = uprobe->consumers; con && con != uc ; con = con->next)\n\t\t;\n\tif (con)\n\t\tret = register_for_each_vma(uprobe, add ? uc : NULL);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "uprobe_register_refctr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1202-1206",
    "snippet": "int uprobe_register_refctr(struct inode *inode, loff_t offset,\n\t\t\t   loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, ref_ctr_offset, uc);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__uprobe_register",
          "args": [
            "inode",
            "offset",
            "ref_ctr_offset",
            "uc"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1142-1193",
          "snippet": "static int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n\t/*\n\t * This ensures that copy_from_page(), copy_to_page() and\n\t * __update_ref_ctr() can't cross page boundary.\n\t */\n\tif (!IS_ALIGNED(offset, UPROBE_SWBP_INSN_SIZE))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(ref_ctr_offset, sizeof(short)))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n\t/*\n\t * This ensures that copy_from_page(), copy_to_page() and\n\t * __update_ref_ctr() can't cross page boundary.\n\t */\n\tif (!IS_ALIGNED(offset, UPROBE_SWBP_INSN_SIZE))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(ref_ctr_offset, sizeof(short)))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_register_refctr(struct inode *inode, loff_t offset,\n\t\t\t   loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, ref_ctr_offset, uc);\n}"
  },
  {
    "function_name": "uprobe_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1195-1199",
    "snippet": "int uprobe_register(struct inode *inode, loff_t offset,\n\t\t    struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, 0, uc);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__uprobe_register",
          "args": [
            "inode",
            "offset",
            "0",
            "uc"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1142-1193",
          "snippet": "static int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n\t/*\n\t * This ensures that copy_from_page(), copy_to_page() and\n\t * __update_ref_ctr() can't cross page boundary.\n\t */\n\tif (!IS_ALIGNED(offset, UPROBE_SWBP_INSN_SIZE))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(ref_ctr_offset, sizeof(short)))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n\t/*\n\t * This ensures that copy_from_page(), copy_to_page() and\n\t * __update_ref_ctr() can't cross page boundary.\n\t */\n\tif (!IS_ALIGNED(offset, UPROBE_SWBP_INSN_SIZE))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(ref_ctr_offset, sizeof(short)))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_register(struct inode *inode, loff_t offset,\n\t\t    struct uprobe_consumer *uc)\n{\n\treturn __uprobe_register(inode, offset, 0, uc);\n}"
  },
  {
    "function_name": "__uprobe_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1142-1193",
    "snippet": "static int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n\t/*\n\t * This ensures that copy_from_page(), copy_to_page() and\n\t * __update_ref_ctr() can't cross page boundary.\n\t */\n\tif (!IS_ALIGNED(offset, UPROBE_SWBP_INSN_SIZE))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(ref_ctr_offset, sizeof(short)))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -EAGAIN"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "603-616",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__uprobe_unregister",
          "args": [
            "uprobe",
            "uc"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1089-1101",
          "snippet": "static void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_for_each_vma",
          "args": [
            "uprobe",
            "uc"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "register_for_each_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1035-1087",
          "snippet": "static int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tmmap_write_lock(mm);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tmmap_write_unlock(mm);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tmmap_write_lock(mm);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tmmap_write_unlock(mm);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "consumer_add",
          "args": [
            "uprobe",
            "uc"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "consumer_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "760-766",
          "snippet": "static void consumer_add(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tdown_write(&uprobe->consumer_rwsem);\n\tuc->next = uprobe->consumers;\n\tuprobe->consumers = uc;\n\tup_write(&uprobe->consumer_rwsem);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void consumer_add(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tdown_write(&uprobe->consumer_rwsem);\n\tuc->next = uprobe->consumers;\n\tuprobe->consumers = uc;\n\tup_write(&uprobe->consumer_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "uprobe_is_active(uprobe)"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_is_active",
          "args": [
            "uprobe"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_is_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "931-934",
          "snippet": "static inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "uprobe"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "uprobe"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_uprobe",
          "args": [
            "inode",
            "offset",
            "ref_ctr_offset"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "728-758",
          "snippet": "static struct uprobe *alloc_uprobe(struct inode *inode, loff_t offset,\n\t\t\t\t   loff_t ref_ctr_offset)\n{\n\tstruct uprobe *uprobe, *cur_uprobe;\n\n\tuprobe = kzalloc(sizeof(struct uprobe), GFP_KERNEL);\n\tif (!uprobe)\n\t\treturn NULL;\n\n\tuprobe->inode = inode;\n\tuprobe->offset = offset;\n\tuprobe->ref_ctr_offset = ref_ctr_offset;\n\tinit_rwsem(&uprobe->register_rwsem);\n\tinit_rwsem(&uprobe->consumer_rwsem);\n\n\t/* add to uprobes_tree, sorted on inode:offset */\n\tcur_uprobe = insert_uprobe(uprobe);\n\t/* a uprobe exists for this inode:offset combination */\n\tif (cur_uprobe) {\n\t\tif (cur_uprobe->ref_ctr_offset != uprobe->ref_ctr_offset) {\n\t\t\tref_ctr_mismatch_warn(cur_uprobe, uprobe);\n\t\t\tput_uprobe(cur_uprobe);\n\t\t\tkfree(uprobe);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tkfree(uprobe);\n\t\tuprobe = cur_uprobe;\n\t}\n\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *alloc_uprobe(struct inode *inode, loff_t offset,\n\t\t\t\t   loff_t ref_ctr_offset)\n{\n\tstruct uprobe *uprobe, *cur_uprobe;\n\n\tuprobe = kzalloc(sizeof(struct uprobe), GFP_KERNEL);\n\tif (!uprobe)\n\t\treturn NULL;\n\n\tuprobe->inode = inode;\n\tuprobe->offset = offset;\n\tuprobe->ref_ctr_offset = ref_ctr_offset;\n\tinit_rwsem(&uprobe->register_rwsem);\n\tinit_rwsem(&uprobe->consumer_rwsem);\n\n\t/* add to uprobes_tree, sorted on inode:offset */\n\tcur_uprobe = insert_uprobe(uprobe);\n\t/* a uprobe exists for this inode:offset combination */\n\tif (cur_uprobe) {\n\t\tif (cur_uprobe->ref_ctr_offset != uprobe->ref_ctr_offset) {\n\t\t\tref_ctr_mismatch_warn(cur_uprobe, uprobe);\n\t\t\tput_uprobe(cur_uprobe);\n\t\t\tkfree(uprobe);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tkfree(uprobe);\n\t\tuprobe = cur_uprobe;\n\t}\n\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "ref_ctr_offset",
            "sizeof(short)"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "offset",
            "UPROBE_SWBP_INSN_SIZE"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_mapping",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __uprobe_register(struct inode *inode, loff_t offset,\n\t\t\t     loff_t ref_ctr_offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\tint ret;\n\n\t/* Uprobe must have at least one set consumer */\n\tif (!uc->handler && !uc->ret_handler)\n\t\treturn -EINVAL;\n\n\t/* copy_insn() uses read_mapping_page() or shmem_read_mapping_page() */\n\tif (!inode->i_mapping->a_ops->readpage && !shmem_mapping(inode->i_mapping))\n\t\treturn -EIO;\n\t/* Racy, just to catch the obvious mistakes */\n\tif (offset > i_size_read(inode))\n\t\treturn -EINVAL;\n\n\t/*\n\t * This ensures that copy_from_page(), copy_to_page() and\n\t * __update_ref_ctr() can't cross page boundary.\n\t */\n\tif (!IS_ALIGNED(offset, UPROBE_SWBP_INSN_SIZE))\n\t\treturn -EINVAL;\n\tif (!IS_ALIGNED(ref_ctr_offset, sizeof(short)))\n\t\treturn -EINVAL;\n\n retry:\n\tuprobe = alloc_uprobe(inode, offset, ref_ctr_offset);\n\tif (!uprobe)\n\t\treturn -ENOMEM;\n\tif (IS_ERR(uprobe))\n\t\treturn PTR_ERR(uprobe);\n\n\t/*\n\t * We can race with uprobe_unregister()->delete_uprobe().\n\t * Check uprobe_is_active() and retry if it is false.\n\t */\n\tdown_write(&uprobe->register_rwsem);\n\tret = -EAGAIN;\n\tif (likely(uprobe_is_active(uprobe))) {\n\t\tconsumer_add(uprobe, uc);\n\t\tret = register_for_each_vma(uprobe, uc);\n\t\tif (ret)\n\t\t\t__uprobe_unregister(uprobe, uc);\n\t}\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\treturn ret;\n}"
  },
  {
    "function_name": "uprobe_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1109-1121",
    "snippet": "void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn;\n\n\tdown_write(&uprobe->register_rwsem);\n\t__uprobe_unregister(uprobe, uc);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "603-616",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__uprobe_unregister",
          "args": [
            "uprobe",
            "uc"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "__uprobe_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1089-1101",
          "snippet": "static void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_uprobe",
          "args": [
            "inode",
            "offset"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "find_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "675-684",
          "snippet": "static struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nvoid uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)\n{\n\tstruct uprobe *uprobe;\n\n\tuprobe = find_uprobe(inode, offset);\n\tif (WARN_ON(!uprobe))\n\t\treturn;\n\n\tdown_write(&uprobe->register_rwsem);\n\t__uprobe_unregister(uprobe, uc);\n\tup_write(&uprobe->register_rwsem);\n\tput_uprobe(uprobe);\n}"
  },
  {
    "function_name": "__uprobe_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1089-1101",
    "snippet": "static void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delete_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "delete_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "940-950",
          "snippet": "static void delete_uprobe(struct uprobe *uprobe)\n{\n\tif (WARN_ON(!uprobe_is_active(uprobe)))\n\t\treturn;\n\n\tspin_lock(&uprobes_treelock);\n\trb_erase(&uprobe->rb_node, &uprobes_tree);\n\tspin_unlock(&uprobes_treelock);\n\tRB_CLEAR_NODE(&uprobe->rb_node); /* for uprobe_is_active() */\n\tput_uprobe(uprobe);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;",
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic void delete_uprobe(struct uprobe *uprobe)\n{\n\tif (WARN_ON(!uprobe_is_active(uprobe)))\n\t\treturn;\n\n\tspin_lock(&uprobes_treelock);\n\trb_erase(&uprobe->rb_node, &uprobes_tree);\n\tspin_unlock(&uprobes_treelock);\n\tRB_CLEAR_NODE(&uprobe->rb_node); /* for uprobe_is_active() */\n\tput_uprobe(uprobe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_for_each_vma",
          "args": [
            "uprobe",
            "NULL"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "register_for_each_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1035-1087",
          "snippet": "static int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tmmap_write_lock(mm);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tmmap_write_unlock(mm);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tmmap_write_lock(mm);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tmmap_write_unlock(mm);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!consumer_del(uprobe, uc)"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "consumer_del",
          "args": [
            "uprobe",
            "uc"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "consumer_del",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "773-789",
          "snippet": "static bool consumer_del(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tstruct uprobe_consumer **con;\n\tbool ret = false;\n\n\tdown_write(&uprobe->consumer_rwsem);\n\tfor (con = &uprobe->consumers; *con; con = &(*con)->next) {\n\t\tif (*con == uc) {\n\t\t\t*con = uc->next;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool consumer_del(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tstruct uprobe_consumer **con;\n\tbool ret = false;\n\n\tdown_write(&uprobe->consumer_rwsem);\n\tfor (con = &uprobe->consumers; *con; con = &(*con)->next) {\n\t\tif (*con == uc) {\n\t\t\t*con = uc->next;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\n__uprobe_unregister(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tint err;\n\n\tif (WARN_ON(!consumer_del(uprobe, uc)))\n\t\treturn;\n\n\terr = register_for_each_vma(uprobe, NULL);\n\t/* TODO : cant unregister? schedule a worker thread */\n\tif (!uprobe->consumers && !err)\n\t\tdelete_uprobe(uprobe);\n}"
  },
  {
    "function_name": "register_for_each_vma",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "1035-1087",
    "snippet": "static int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tmmap_write_lock(mm);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tmmap_write_unlock(mm);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&dup_mmap_sem"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_map_info",
          "args": [
            "info"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "free_map_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "958-963",
          "snippet": "static inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1148-1154",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmap_write_unlock",
          "args": [
            "mm"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_breakpoint",
          "args": [
            "uprobe",
            "mm",
            "info->vaddr"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "remove_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "924-929",
          "snippet": "static int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_chain",
          "args": [
            "uprobe",
            "UPROBE_FILTER_UNREGISTER",
            "mm"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "filter_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "879-894",
          "snippet": "static bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&mm->flags"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_breakpoint",
          "args": [
            "uprobe",
            "mm",
            "vma",
            "info->vaddr"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "install_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "896-922",
          "snippet": "static int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "consumer_filter",
          "args": [
            "new",
            "UPROBE_FILTER_REGISTER",
            "mm"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "consumer_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "873-877",
          "snippet": "static inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vaddr_to_offset",
          "args": [
            "vma",
            "info->vaddr"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "vaddr_to_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "136-139",
          "snippet": "static loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "is_register"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "121-129",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "info->vaddr"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap_write_lock",
          "args": [
            "mm"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "info"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "info"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_map_info",
          "args": [
            "uprobe->inode->i_mapping",
            "uprobe->offset",
            "is_register"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "build_map_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "965-1033",
          "snippet": "static struct map_info *\nbuild_map_info(struct address_space *mapping, loff_t offset, bool is_register)\n{\n\tunsigned long pgoff = offset >> PAGE_SHIFT;\n\tstruct vm_area_struct *vma;\n\tstruct map_info *curr = NULL;\n\tstruct map_info *prev = NULL;\n\tstruct map_info *info;\n\tint more = 0;\n\n again:\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\tif (!valid_vma(vma, is_register))\n\t\t\tcontinue;\n\n\t\tif (!prev && !more) {\n\t\t\t/*\n\t\t\t * Needs GFP_NOWAIT to avoid i_mmap_rwsem recursion through\n\t\t\t * reclaim. This is optimistic, no harm done if it fails.\n\t\t\t */\n\t\t\tprev = kmalloc(sizeof(struct map_info),\n\t\t\t\t\tGFP_NOWAIT | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\tif (prev)\n\t\t\t\tprev->next = NULL;\n\t\t}\n\t\tif (!prev) {\n\t\t\tmore++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mmget_not_zero(vma->vm_mm))\n\t\t\tcontinue;\n\n\t\tinfo = prev;\n\t\tprev = prev->next;\n\t\tinfo->next = curr;\n\t\tcurr = info;\n\n\t\tinfo->mm = vma->vm_mm;\n\t\tinfo->vaddr = offset_to_vaddr(vma, offset);\n\t}\n\ti_mmap_unlock_read(mapping);\n\n\tif (!more)\n\t\tgoto out;\n\n\tprev = curr;\n\twhile (curr) {\n\t\tmmput(curr->mm);\n\t\tcurr = curr->next;\n\t}\n\n\tdo {\n\t\tinfo = kmalloc(sizeof(struct map_info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tcurr = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tinfo->next = prev;\n\t\tprev = info;\n\t} while (--more);\n\n\tgoto again;\n out:\n\twhile (prev)\n\t\tprev = free_map_info(prev);\n\treturn curr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct map_info *\nbuild_map_info(struct address_space *mapping, loff_t offset, bool is_register)\n{\n\tunsigned long pgoff = offset >> PAGE_SHIFT;\n\tstruct vm_area_struct *vma;\n\tstruct map_info *curr = NULL;\n\tstruct map_info *prev = NULL;\n\tstruct map_info *info;\n\tint more = 0;\n\n again:\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\tif (!valid_vma(vma, is_register))\n\t\t\tcontinue;\n\n\t\tif (!prev && !more) {\n\t\t\t/*\n\t\t\t * Needs GFP_NOWAIT to avoid i_mmap_rwsem recursion through\n\t\t\t * reclaim. This is optimistic, no harm done if it fails.\n\t\t\t */\n\t\t\tprev = kmalloc(sizeof(struct map_info),\n\t\t\t\t\tGFP_NOWAIT | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\tif (prev)\n\t\t\t\tprev->next = NULL;\n\t\t}\n\t\tif (!prev) {\n\t\t\tmore++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mmget_not_zero(vma->vm_mm))\n\t\t\tcontinue;\n\n\t\tinfo = prev;\n\t\tprev = prev->next;\n\t\tinfo->next = curr;\n\t\tcurr = info;\n\n\t\tinfo->mm = vma->vm_mm;\n\t\tinfo->vaddr = offset_to_vaddr(vma, offset);\n\t}\n\ti_mmap_unlock_read(mapping);\n\n\tif (!more)\n\t\tgoto out;\n\n\tprev = curr;\n\twhile (curr) {\n\t\tmmput(curr->mm);\n\t\tcurr = curr->next;\n\t}\n\n\tdo {\n\t\tinfo = kmalloc(sizeof(struct map_info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tcurr = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tinfo->next = prev;\n\t\tprev = info;\n\t} while (--more);\n\n\tgoto again;\n out:\n\twhile (prev)\n\t\tprev = free_map_info(prev);\n\treturn curr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&dup_mmap_sem"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\nregister_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\n\t\tmmap_write_lock(mm);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\n\t\tif (is_register) {\n\t\t\t/* consult only the \"caller\", new consumer. */\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n\n unlock:\n\t\tmmap_write_unlock(mm);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}"
  },
  {
    "function_name": "build_map_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "965-1033",
    "snippet": "static struct map_info *\nbuild_map_info(struct address_space *mapping, loff_t offset, bool is_register)\n{\n\tunsigned long pgoff = offset >> PAGE_SHIFT;\n\tstruct vm_area_struct *vma;\n\tstruct map_info *curr = NULL;\n\tstruct map_info *prev = NULL;\n\tstruct map_info *info;\n\tint more = 0;\n\n again:\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\tif (!valid_vma(vma, is_register))\n\t\t\tcontinue;\n\n\t\tif (!prev && !more) {\n\t\t\t/*\n\t\t\t * Needs GFP_NOWAIT to avoid i_mmap_rwsem recursion through\n\t\t\t * reclaim. This is optimistic, no harm done if it fails.\n\t\t\t */\n\t\t\tprev = kmalloc(sizeof(struct map_info),\n\t\t\t\t\tGFP_NOWAIT | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\tif (prev)\n\t\t\t\tprev->next = NULL;\n\t\t}\n\t\tif (!prev) {\n\t\t\tmore++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mmget_not_zero(vma->vm_mm))\n\t\t\tcontinue;\n\n\t\tinfo = prev;\n\t\tprev = prev->next;\n\t\tinfo->next = curr;\n\t\tcurr = info;\n\n\t\tinfo->mm = vma->vm_mm;\n\t\tinfo->vaddr = offset_to_vaddr(vma, offset);\n\t}\n\ti_mmap_unlock_read(mapping);\n\n\tif (!more)\n\t\tgoto out;\n\n\tprev = curr;\n\twhile (curr) {\n\t\tmmput(curr->mm);\n\t\tcurr = curr->next;\n\t}\n\n\tdo {\n\t\tinfo = kmalloc(sizeof(struct map_info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tcurr = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tinfo->next = prev;\n\t\tprev = info;\n\t} while (--more);\n\n\tgoto again;\n out:\n\twhile (prev)\n\t\tprev = free_map_info(prev);\n\treturn curr;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_map_info",
          "args": [
            "prev"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "free_map_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "958-963",
          "snippet": "static inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct map_info)",
            "GFP_KERNEL"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "curr->mm"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1148-1154",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_mmap_unlock_read",
          "args": [
            "mapping"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "vma",
            "offset"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "131-134",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmget_not_zero",
          "args": [
            "vma->vm_mm"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct map_info)",
            "GFP_NOWAIT | __GFP_NOMEMALLOC | __GFP_NOWARN"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_vma",
          "args": [
            "vma",
            "is_register"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "valid_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "121-129",
          "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_foreach",
          "args": [
            "vma",
            "&mapping->i_mmap",
            "pgoff",
            "pgoff"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_read",
          "args": [
            "mapping"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct map_info *\nbuild_map_info(struct address_space *mapping, loff_t offset, bool is_register)\n{\n\tunsigned long pgoff = offset >> PAGE_SHIFT;\n\tstruct vm_area_struct *vma;\n\tstruct map_info *curr = NULL;\n\tstruct map_info *prev = NULL;\n\tstruct map_info *info;\n\tint more = 0;\n\n again:\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\tif (!valid_vma(vma, is_register))\n\t\t\tcontinue;\n\n\t\tif (!prev && !more) {\n\t\t\t/*\n\t\t\t * Needs GFP_NOWAIT to avoid i_mmap_rwsem recursion through\n\t\t\t * reclaim. This is optimistic, no harm done if it fails.\n\t\t\t */\n\t\t\tprev = kmalloc(sizeof(struct map_info),\n\t\t\t\t\tGFP_NOWAIT | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\tif (prev)\n\t\t\t\tprev->next = NULL;\n\t\t}\n\t\tif (!prev) {\n\t\t\tmore++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mmget_not_zero(vma->vm_mm))\n\t\t\tcontinue;\n\n\t\tinfo = prev;\n\t\tprev = prev->next;\n\t\tinfo->next = curr;\n\t\tcurr = info;\n\n\t\tinfo->mm = vma->vm_mm;\n\t\tinfo->vaddr = offset_to_vaddr(vma, offset);\n\t}\n\ti_mmap_unlock_read(mapping);\n\n\tif (!more)\n\t\tgoto out;\n\n\tprev = curr;\n\twhile (curr) {\n\t\tmmput(curr->mm);\n\t\tcurr = curr->next;\n\t}\n\n\tdo {\n\t\tinfo = kmalloc(sizeof(struct map_info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tcurr = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tinfo->next = prev;\n\t\tprev = info;\n\t} while (--more);\n\n\tgoto again;\n out:\n\twhile (prev)\n\t\tprev = free_map_info(prev);\n\treturn curr;\n}"
  },
  {
    "function_name": "free_map_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "958-963",
    "snippet": "static inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline struct map_info *free_map_info(struct map_info *info)\n{\n\tstruct map_info *next = info->next;\n\tkfree(info);\n\treturn next;\n}"
  },
  {
    "function_name": "delete_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "940-950",
    "snippet": "static void delete_uprobe(struct uprobe *uprobe)\n{\n\tif (WARN_ON(!uprobe_is_active(uprobe)))\n\t\treturn;\n\n\tspin_lock(&uprobes_treelock);\n\trb_erase(&uprobe->rb_node, &uprobes_tree);\n\tspin_unlock(&uprobes_treelock);\n\tRB_CLEAR_NODE(&uprobe->rb_node); /* for uprobe_is_active() */\n\tput_uprobe(uprobe);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root uprobes_tree = RB_ROOT;",
      "static DEFINE_SPINLOCK(uprobes_treelock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "603-616",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&uprobe->rb_node"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&uprobe->rb_node",
            "&uprobes_tree"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!uprobe_is_active(uprobe)"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_is_active",
          "args": [
            "uprobe"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_is_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "931-934",
          "snippet": "static inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic void delete_uprobe(struct uprobe *uprobe)\n{\n\tif (WARN_ON(!uprobe_is_active(uprobe)))\n\t\treturn;\n\n\tspin_lock(&uprobes_treelock);\n\trb_erase(&uprobe->rb_node, &uprobes_tree);\n\tspin_unlock(&uprobes_treelock);\n\tRB_CLEAR_NODE(&uprobe->rb_node); /* for uprobe_is_active() */\n\tput_uprobe(uprobe);\n}"
  },
  {
    "function_name": "uprobe_is_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "931-934",
    "snippet": "static inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&uprobe->rb_node"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool uprobe_is_active(struct uprobe *uprobe)\n{\n\treturn !RB_EMPTY_NODE(&uprobe->rb_node);\n}"
  },
  {
    "function_name": "remove_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "924-929",
    "snippet": "static int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_orig_insn",
          "args": [
            "&uprobe->arch",
            "mm",
            "vaddr"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "set_orig_insn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "590-595",
          "snippet": "int __weak\nset_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr,\n\t\t\t*(uprobe_opcode_t *)&auprobe->insn);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint __weak\nset_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr,\n\t\t\t*(uprobe_opcode_t *)&auprobe->insn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_RECALC_UPROBES",
            "&mm->flags"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\nremove_breakpoint(struct uprobe *uprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\tset_bit(MMF_RECALC_UPROBES, &mm->flags);\n\treturn set_orig_insn(&uprobe->arch, mm, vaddr);\n}"
  },
  {
    "function_name": "install_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "896-922",
    "snippet": "static int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&mm->flags"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_swbp",
          "args": [
            "&uprobe->arch",
            "mm",
            "vaddr"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "set_swbp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "576-579",
          "snippet": "int __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr, UPROBE_SWBP_INSN);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr, UPROBE_SWBP_INSN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&mm->flags"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HAS_UPROBES",
            "&mm->flags"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_uprobe",
          "args": [
            "uprobe",
            "vma->vm_file",
            "mm",
            "vaddr"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "839-871",
          "snippet": "static int prepare_uprobe(struct uprobe *uprobe, struct file *file,\n\t\t\t\tstruct mm_struct *mm, unsigned long vaddr)\n{\n\tint ret = 0;\n\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\treturn ret;\n\n\t/* TODO: move this into _register, until then we abuse this sem. */\n\tdown_write(&uprobe->consumer_rwsem);\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\tgoto out;\n\n\tret = copy_insn(uprobe, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -ENOTSUPP;\n\tif (is_trap_insn((uprobe_opcode_t *)&uprobe->arch.insn))\n\t\tgoto out;\n\n\tret = arch_uprobe_analyze_insn(&uprobe->arch, mm, vaddr);\n\tif (ret)\n\t\tgoto out;\n\n\tsmp_wmb(); /* pairs with the smp_rmb() in handle_swbp() */\n\tset_bit(UPROBE_COPY_INSN, &uprobe->flags);\n\n out:\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define UPROBE_COPY_INSN\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UPROBE_COPY_INSN\t0\n\nstatic int prepare_uprobe(struct uprobe *uprobe, struct file *file,\n\t\t\t\tstruct mm_struct *mm, unsigned long vaddr)\n{\n\tint ret = 0;\n\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\treturn ret;\n\n\t/* TODO: move this into _register, until then we abuse this sem. */\n\tdown_write(&uprobe->consumer_rwsem);\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\tgoto out;\n\n\tret = copy_insn(uprobe, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -ENOTSUPP;\n\tif (is_trap_insn((uprobe_opcode_t *)&uprobe->arch.insn))\n\t\tgoto out;\n\n\tret = arch_uprobe_analyze_insn(&uprobe->arch, mm, vaddr);\n\tif (ret)\n\t\tgoto out;\n\n\tsmp_wmb(); /* pairs with the smp_rmb() in handle_swbp() */\n\tset_bit(UPROBE_COPY_INSN, &uprobe->flags);\n\n out:\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\ninstall_breakpoint(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long vaddr)\n{\n\tbool first_uprobe;\n\tint ret;\n\n\tret = prepare_uprobe(uprobe, vma->vm_file, mm, vaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * set MMF_HAS_UPROBES in advance for uprobe_pre_sstep_notifier(),\n\t * the task can hit this breakpoint right after __replace_page().\n\t */\n\tfirst_uprobe = !test_bit(MMF_HAS_UPROBES, &mm->flags);\n\tif (first_uprobe)\n\t\tset_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\tret = set_swbp(&uprobe->arch, mm, vaddr);\n\tif (!ret)\n\t\tclear_bit(MMF_RECALC_UPROBES, &mm->flags);\n\telse if (first_uprobe)\n\t\tclear_bit(MMF_HAS_UPROBES, &mm->flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "filter_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "879-894",
    "snippet": "static bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "consumer_filter",
          "args": [
            "uc",
            "ctx",
            "mm"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "consumer_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "873-877",
          "snippet": "static inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool filter_chain(struct uprobe *uprobe,\n\t\t\t enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct uprobe_consumer *uc;\n\tbool ret = false;\n\n\tdown_read(&uprobe->consumer_rwsem);\n\tfor (uc = uprobe->consumers; uc; uc = uc->next) {\n\t\tret = consumer_filter(uc, ctx, mm);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tup_read(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "consumer_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "873-877",
    "snippet": "static inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uc->filter",
          "args": [
            "uc",
            "ctx",
            "mm"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline bool consumer_filter(struct uprobe_consumer *uc,\n\t\t\t\t   enum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\treturn !uc->filter || uc->filter(uc, ctx, mm);\n}"
  },
  {
    "function_name": "prepare_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "839-871",
    "snippet": "static int prepare_uprobe(struct uprobe *uprobe, struct file *file,\n\t\t\t\tstruct mm_struct *mm, unsigned long vaddr)\n{\n\tint ret = 0;\n\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\treturn ret;\n\n\t/* TODO: move this into _register, until then we abuse this sem. */\n\tdown_write(&uprobe->consumer_rwsem);\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\tgoto out;\n\n\tret = copy_insn(uprobe, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -ENOTSUPP;\n\tif (is_trap_insn((uprobe_opcode_t *)&uprobe->arch.insn))\n\t\tgoto out;\n\n\tret = arch_uprobe_analyze_insn(&uprobe->arch, mm, vaddr);\n\tif (ret)\n\t\tgoto out;\n\n\tsmp_wmb(); /* pairs with the smp_rmb() in handle_swbp() */\n\tset_bit(UPROBE_COPY_INSN, &uprobe->flags);\n\n out:\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UPROBE_COPY_INSN\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "UPROBE_COPY_INSN",
            "&uprobe->flags"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_uprobe_analyze_insn",
          "args": [
            "&uprobe->arch",
            "mm",
            "vaddr"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_trap_insn",
          "args": [
            "(uprobe_opcode_t *)&uprobe->arch.insn"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "is_trap_insn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "240-243",
          "snippet": "bool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_insn",
          "args": [
            "uprobe",
            "file"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "copy_insn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "813-837",
          "snippet": "static int copy_insn(struct uprobe *uprobe, struct file *filp)\n{\n\tstruct address_space *mapping = uprobe->inode->i_mapping;\n\tloff_t offs = uprobe->offset;\n\tvoid *insn = &uprobe->arch.insn;\n\tint size = sizeof(uprobe->arch.insn);\n\tint len, err = -EIO;\n\n\t/* Copy only available bytes, -EIO if nothing was read */\n\tdo {\n\t\tif (offs >= i_size_read(uprobe->inode))\n\t\t\tbreak;\n\n\t\tlen = min_t(int, size, PAGE_SIZE - (offs & ~PAGE_MASK));\n\t\terr = __copy_insn(mapping, filp, insn, len, offs);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tinsn += len;\n\t\toffs += len;\n\t\tsize -= len;\n\t} while (size);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int copy_insn(struct uprobe *uprobe, struct file *filp)\n{\n\tstruct address_space *mapping = uprobe->inode->i_mapping;\n\tloff_t offs = uprobe->offset;\n\tvoid *insn = &uprobe->arch.insn;\n\tint size = sizeof(uprobe->arch.insn);\n\tint len, err = -EIO;\n\n\t/* Copy only available bytes, -EIO if nothing was read */\n\tdo {\n\t\tif (offs >= i_size_read(uprobe->inode))\n\t\t\tbreak;\n\n\t\tlen = min_t(int, size, PAGE_SIZE - (offs & ~PAGE_MASK));\n\t\terr = __copy_insn(mapping, filp, insn, len, offs);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tinsn += len;\n\t\toffs += len;\n\t\tsize -= len;\n\t} while (size);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "UPROBE_COPY_INSN",
            "&uprobe->flags"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\n#define UPROBE_COPY_INSN\t0\n\nstatic int prepare_uprobe(struct uprobe *uprobe, struct file *file,\n\t\t\t\tstruct mm_struct *mm, unsigned long vaddr)\n{\n\tint ret = 0;\n\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\treturn ret;\n\n\t/* TODO: move this into _register, until then we abuse this sem. */\n\tdown_write(&uprobe->consumer_rwsem);\n\tif (test_bit(UPROBE_COPY_INSN, &uprobe->flags))\n\t\tgoto out;\n\n\tret = copy_insn(uprobe, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -ENOTSUPP;\n\tif (is_trap_insn((uprobe_opcode_t *)&uprobe->arch.insn))\n\t\tgoto out;\n\n\tret = arch_uprobe_analyze_insn(&uprobe->arch, mm, vaddr);\n\tif (ret)\n\t\tgoto out;\n\n\tsmp_wmb(); /* pairs with the smp_rmb() in handle_swbp() */\n\tset_bit(UPROBE_COPY_INSN, &uprobe->flags);\n\n out:\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "copy_insn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "813-837",
    "snippet": "static int copy_insn(struct uprobe *uprobe, struct file *filp)\n{\n\tstruct address_space *mapping = uprobe->inode->i_mapping;\n\tloff_t offs = uprobe->offset;\n\tvoid *insn = &uprobe->arch.insn;\n\tint size = sizeof(uprobe->arch.insn);\n\tint len, err = -EIO;\n\n\t/* Copy only available bytes, -EIO if nothing was read */\n\tdo {\n\t\tif (offs >= i_size_read(uprobe->inode))\n\t\t\tbreak;\n\n\t\tlen = min_t(int, size, PAGE_SIZE - (offs & ~PAGE_MASK));\n\t\terr = __copy_insn(mapping, filp, insn, len, offs);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tinsn += len;\n\t\toffs += len;\n\t\tsize -= len;\n\t} while (size);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_insn",
          "args": [
            "mapping",
            "filp",
            "insn",
            "len",
            "offs"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "__copy_insn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "791-811",
          "snippet": "static int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\t/*\n\t * Ensure that the page that has the original instruction is populated\n\t * and in page-cache. If ->readpage == NULL it must be shmem_mapping(),\n\t * see uprobe_register().\n\t */\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\t/*\n\t * Ensure that the page that has the original instruction is populated\n\t * and in page-cache. If ->readpage == NULL it must be shmem_mapping(),\n\t * see uprobe_register().\n\t */\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "size",
            "PAGE_SIZE - (offs & ~PAGE_MASK)"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "uprobe->inode"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int copy_insn(struct uprobe *uprobe, struct file *filp)\n{\n\tstruct address_space *mapping = uprobe->inode->i_mapping;\n\tloff_t offs = uprobe->offset;\n\tvoid *insn = &uprobe->arch.insn;\n\tint size = sizeof(uprobe->arch.insn);\n\tint len, err = -EIO;\n\n\t/* Copy only available bytes, -EIO if nothing was read */\n\tdo {\n\t\tif (offs >= i_size_read(uprobe->inode))\n\t\t\tbreak;\n\n\t\tlen = min_t(int, size, PAGE_SIZE - (offs & ~PAGE_MASK));\n\t\terr = __copy_insn(mapping, filp, insn, len, offs);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tinsn += len;\n\t\toffs += len;\n\t\tsize -= len;\n\t} while (size);\n\n\treturn err;\n}"
  },
  {
    "function_name": "__copy_insn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "791-811",
    "snippet": "static int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\t/*\n\t * Ensure that the page that has the original instruction is populated\n\t * and in page-cache. If ->readpage == NULL it must be shmem_mapping(),\n\t * see uprobe_register().\n\t */\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_page",
          "args": [
            "page",
            "offset",
            "insn",
            "nbytes"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "copy_from_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "245-250",
          "snippet": "static void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_read_mapping_page",
          "args": [
            "mapping",
            "offset >> PAGE_SHIFT"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "offset >> PAGE_SHIFT",
            "filp"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\t/*\n\t * Ensure that the page that has the original instruction is populated\n\t * and in page-cache. If ->readpage == NULL it must be shmem_mapping(),\n\t * see uprobe_register().\n\t */\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "consumer_del",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "773-789",
    "snippet": "static bool consumer_del(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tstruct uprobe_consumer **con;\n\tbool ret = false;\n\n\tdown_write(&uprobe->consumer_rwsem);\n\tfor (con = &uprobe->consumers; *con; con = &(*con)->next) {\n\t\tif (*con == uc) {\n\t\t\t*con = uc->next;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool consumer_del(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tstruct uprobe_consumer **con;\n\tbool ret = false;\n\n\tdown_write(&uprobe->consumer_rwsem);\n\tfor (con = &uprobe->consumers; *con; con = &(*con)->next) {\n\t\tif (*con == uc) {\n\t\t\t*con = uc->next;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&uprobe->consumer_rwsem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "consumer_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "760-766",
    "snippet": "static void consumer_add(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tdown_write(&uprobe->consumer_rwsem);\n\tuc->next = uprobe->consumers;\n\tuprobe->consumers = uc;\n\tup_write(&uprobe->consumer_rwsem);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void consumer_add(struct uprobe *uprobe, struct uprobe_consumer *uc)\n{\n\tdown_write(&uprobe->consumer_rwsem);\n\tuc->next = uprobe->consumers;\n\tuprobe->consumers = uc;\n\tup_write(&uprobe->consumer_rwsem);\n}"
  },
  {
    "function_name": "alloc_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "728-758",
    "snippet": "static struct uprobe *alloc_uprobe(struct inode *inode, loff_t offset,\n\t\t\t\t   loff_t ref_ctr_offset)\n{\n\tstruct uprobe *uprobe, *cur_uprobe;\n\n\tuprobe = kzalloc(sizeof(struct uprobe), GFP_KERNEL);\n\tif (!uprobe)\n\t\treturn NULL;\n\n\tuprobe->inode = inode;\n\tuprobe->offset = offset;\n\tuprobe->ref_ctr_offset = ref_ctr_offset;\n\tinit_rwsem(&uprobe->register_rwsem);\n\tinit_rwsem(&uprobe->consumer_rwsem);\n\n\t/* add to uprobes_tree, sorted on inode:offset */\n\tcur_uprobe = insert_uprobe(uprobe);\n\t/* a uprobe exists for this inode:offset combination */\n\tif (cur_uprobe) {\n\t\tif (cur_uprobe->ref_ctr_offset != uprobe->ref_ctr_offset) {\n\t\t\tref_ctr_mismatch_warn(cur_uprobe, uprobe);\n\t\t\tput_uprobe(cur_uprobe);\n\t\t\tkfree(uprobe);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tkfree(uprobe);\n\t\tuprobe = cur_uprobe;\n\t}\n\n\treturn uprobe;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root uprobes_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "uprobe"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_uprobe",
          "args": [
            "cur_uprobe"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "put_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "603-616",
          "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);",
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref_ctr_mismatch_warn",
          "args": [
            "cur_uprobe",
            "uprobe"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "ref_ctr_mismatch_warn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "718-726",
          "snippet": "static void\nref_ctr_mismatch_warn(struct uprobe *cur_uprobe, struct uprobe *uprobe)\n{\n\tpr_warn(\"ref_ctr_offset mismatch. inode: 0x%lx offset: 0x%llx \"\n\t\t\"ref_ctr_offset(old): 0x%llx ref_ctr_offset(new): 0x%llx\\n\",\n\t\tuprobe->inode->i_ino, (unsigned long long) uprobe->offset,\n\t\t(unsigned long long) cur_uprobe->ref_ctr_offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\nref_ctr_mismatch_warn(struct uprobe *cur_uprobe, struct uprobe *uprobe)\n{\n\tpr_warn(\"ref_ctr_offset mismatch. inode: 0x%lx offset: 0x%llx \"\n\t\t\"ref_ctr_offset(old): 0x%llx ref_ctr_offset(new): 0x%llx\\n\",\n\t\tuprobe->inode->i_ino, (unsigned long long) uprobe->offset,\n\t\t(unsigned long long) cur_uprobe->ref_ctr_offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "insert_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "707-716",
          "snippet": "static struct uprobe *insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct uprobe *u;\n\n\tspin_lock(&uprobes_treelock);\n\tu = __insert_uprobe(uprobe);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn u;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uprobes_treelock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct uprobe *u;\n\n\tspin_lock(&uprobes_treelock);\n\tu = __insert_uprobe(uprobe);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn u;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&uprobe->consumer_rwsem"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&uprobe->register_rwsem"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct uprobe)",
            "GFP_KERNEL"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *alloc_uprobe(struct inode *inode, loff_t offset,\n\t\t\t\t   loff_t ref_ctr_offset)\n{\n\tstruct uprobe *uprobe, *cur_uprobe;\n\n\tuprobe = kzalloc(sizeof(struct uprobe), GFP_KERNEL);\n\tif (!uprobe)\n\t\treturn NULL;\n\n\tuprobe->inode = inode;\n\tuprobe->offset = offset;\n\tuprobe->ref_ctr_offset = ref_ctr_offset;\n\tinit_rwsem(&uprobe->register_rwsem);\n\tinit_rwsem(&uprobe->consumer_rwsem);\n\n\t/* add to uprobes_tree, sorted on inode:offset */\n\tcur_uprobe = insert_uprobe(uprobe);\n\t/* a uprobe exists for this inode:offset combination */\n\tif (cur_uprobe) {\n\t\tif (cur_uprobe->ref_ctr_offset != uprobe->ref_ctr_offset) {\n\t\t\tref_ctr_mismatch_warn(cur_uprobe, uprobe);\n\t\t\tput_uprobe(cur_uprobe);\n\t\t\tkfree(uprobe);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tkfree(uprobe);\n\t\tuprobe = cur_uprobe;\n\t}\n\n\treturn uprobe;\n}"
  },
  {
    "function_name": "ref_ctr_mismatch_warn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "718-726",
    "snippet": "static void\nref_ctr_mismatch_warn(struct uprobe *cur_uprobe, struct uprobe *uprobe)\n{\n\tpr_warn(\"ref_ctr_offset mismatch. inode: 0x%lx offset: 0x%llx \"\n\t\t\"ref_ctr_offset(old): 0x%llx ref_ctr_offset(new): 0x%llx\\n\",\n\t\tuprobe->inode->i_ino, (unsigned long long) uprobe->offset,\n\t\t(unsigned long long) cur_uprobe->ref_ctr_offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ref_ctr_offset mismatch. inode: 0x%lx offset: 0x%llx \"\n\t\t\"ref_ctr_offset(old): 0x%llx ref_ctr_offset(new): 0x%llx\\n\"",
            "uprobe->inode->i_ino",
            "(unsigned long long) uprobe->offset",
            "(unsigned long long) cur_uprobe->ref_ctr_offset",
            "(unsigned long long) uprobe->ref_ctr_offset"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void\nref_ctr_mismatch_warn(struct uprobe *cur_uprobe, struct uprobe *uprobe)\n{\n\tpr_warn(\"ref_ctr_offset mismatch. inode: 0x%lx offset: 0x%llx \"\n\t\t\"ref_ctr_offset(old): 0x%llx ref_ctr_offset(new): 0x%llx\\n\",\n\t\tuprobe->inode->i_ino, (unsigned long long) uprobe->offset,\n\t\t(unsigned long long) cur_uprobe->ref_ctr_offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset);\n}"
  },
  {
    "function_name": "insert_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "707-716",
    "snippet": "static struct uprobe *insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct uprobe *u;\n\n\tspin_lock(&uprobes_treelock);\n\tu = __insert_uprobe(uprobe);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn u;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(uprobes_treelock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__insert_uprobe",
          "args": [
            "uprobe"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "686-697",
          "snippet": "static struct uprobe *__insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct rb_node *node;\n\n\tnode = rb_find_add(&uprobe->rb_node, &uprobes_tree, __uprobe_cmp);\n\tif (node)\n\t\treturn get_uprobe(__node_2_uprobe(node));\n\n\t/* get access + creation ref */\n\trefcount_set(&uprobe->ref, 2);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *__insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct rb_node *node;\n\n\tnode = rb_find_add(&uprobe->rb_node, &uprobes_tree, __uprobe_cmp);\n\tif (node)\n\t\treturn get_uprobe(__node_2_uprobe(node));\n\n\t/* get access + creation ref */\n\trefcount_set(&uprobe->ref, 2);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct uprobe *u;\n\n\tspin_lock(&uprobes_treelock);\n\tu = __insert_uprobe(uprobe);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn u;\n}"
  },
  {
    "function_name": "__insert_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "686-697",
    "snippet": "static struct uprobe *__insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct rb_node *node;\n\n\tnode = rb_find_add(&uprobe->rb_node, &uprobes_tree, __uprobe_cmp);\n\tif (node)\n\t\treturn get_uprobe(__node_2_uprobe(node));\n\n\t/* get access + creation ref */\n\trefcount_set(&uprobe->ref, 2);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root uprobes_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&uprobe->ref",
            "2"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uprobe",
          "args": [
            "__node_2_uprobe(node)"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "get_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "597-601",
          "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__node_2_uprobe",
          "args": [
            "node"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_find_add",
          "args": [
            "&uprobe->rb_node",
            "&uprobes_tree",
            "__uprobe_cmp"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *__insert_uprobe(struct uprobe *uprobe)\n{\n\tstruct rb_node *node;\n\n\tnode = rb_find_add(&uprobe->rb_node, &uprobes_tree, __uprobe_cmp);\n\tif (node)\n\t\treturn get_uprobe(__node_2_uprobe(node));\n\n\t/* get access + creation ref */\n\trefcount_set(&uprobe->ref, 2);\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "675-684",
    "snippet": "static struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(uprobes_treelock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_uprobe",
          "args": [
            "inode",
            "offset"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "__find_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "657-669",
          "snippet": "static struct uprobe *__find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct __uprobe_key key = {\n\t\t.inode = inode,\n\t\t.offset = offset,\n\t};\n\tstruct rb_node *node = rb_find(&key, &uprobes_tree, __uprobe_cmp_key);\n\n\tif (node)\n\t\treturn get_uprobe(__node_2_uprobe(node));\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root uprobes_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *__find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct __uprobe_key key = {\n\t\t.inode = inode,\n\t\t.offset = offset,\n\t};\n\tstruct rb_node *node = rb_find(&key, &uprobes_tree, __uprobe_cmp_key);\n\n\tif (node)\n\t\treturn get_uprobe(__node_2_uprobe(node));\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&uprobes_treelock"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(uprobes_treelock);\n\nstatic struct uprobe *find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct uprobe *uprobe;\n\n\tspin_lock(&uprobes_treelock);\n\tuprobe = __find_uprobe(inode, offset);\n\tspin_unlock(&uprobes_treelock);\n\n\treturn uprobe;\n}"
  },
  {
    "function_name": "__find_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "657-669",
    "snippet": "static struct uprobe *__find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct __uprobe_key key = {\n\t\t.inode = inode,\n\t\t.offset = offset,\n\t};\n\tstruct rb_node *node = rb_find(&key, &uprobes_tree, __uprobe_cmp_key);\n\n\tif (node)\n\t\treturn get_uprobe(__node_2_uprobe(node));\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root uprobes_tree = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_uprobe",
          "args": [
            "__node_2_uprobe(node)"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "get_uprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "597-601",
          "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__node_2_uprobe",
          "args": [
            "node"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_find",
          "args": [
            "&key",
            "&uprobes_tree",
            "__uprobe_cmp_key"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct rb_root uprobes_tree = RB_ROOT;\n\nstatic struct uprobe *__find_uprobe(struct inode *inode, loff_t offset)\n{\n\tstruct __uprobe_key key = {\n\t\t.inode = inode,\n\t\t.offset = offset,\n\t};\n\tstruct rb_node *node = rb_find(&key, &uprobes_tree, __uprobe_cmp_key);\n\n\tif (node)\n\t\treturn get_uprobe(__node_2_uprobe(node));\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "__uprobe_cmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "651-655",
    "snippet": "static inline int __uprobe_cmp(struct rb_node *a, const struct rb_node *b)\n{\n\tstruct uprobe *u = __node_2_uprobe(a);\n\treturn uprobe_cmp(u->inode, u->offset, __node_2_uprobe(b));\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_cmp",
          "args": [
            "u->inode",
            "u->offset",
            "__node_2_uprobe(b)"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_cmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "618-635",
          "snippet": "static __always_inline\nint uprobe_cmp(const struct inode *l_inode, const loff_t l_offset,\n\t       const struct uprobe *r)\n{\n\tif (l_inode < r->inode)\n\t\treturn -1;\n\n\tif (l_inode > r->inode)\n\t\treturn 1;\n\n\tif (l_offset < r->offset)\n\t\treturn -1;\n\n\tif (l_offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic __always_inline\nint uprobe_cmp(const struct inode *l_inode, const loff_t l_offset,\n\t       const struct uprobe *r)\n{\n\tif (l_inode < r->inode)\n\t\treturn -1;\n\n\tif (l_inode > r->inode)\n\t\treturn 1;\n\n\tif (l_offset < r->offset)\n\t\treturn -1;\n\n\tif (l_offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__node_2_uprobe",
          "args": [
            "b"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__node_2_uprobe",
          "args": [
            "a"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline int __uprobe_cmp(struct rb_node *a, const struct rb_node *b)\n{\n\tstruct uprobe *u = __node_2_uprobe(a);\n\treturn uprobe_cmp(u->inode, u->offset, __node_2_uprobe(b));\n}"
  },
  {
    "function_name": "__uprobe_cmp_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "645-649",
    "snippet": "static inline int __uprobe_cmp_key(const void *key, const struct rb_node *b)\n{\n\tconst struct __uprobe_key *a = key;\n\treturn uprobe_cmp(a->inode, a->offset, __node_2_uprobe(b));\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_cmp",
          "args": [
            "a->inode",
            "a->offset",
            "__node_2_uprobe(b)"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_cmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "618-635",
          "snippet": "static __always_inline\nint uprobe_cmp(const struct inode *l_inode, const loff_t l_offset,\n\t       const struct uprobe *r)\n{\n\tif (l_inode < r->inode)\n\t\treturn -1;\n\n\tif (l_inode > r->inode)\n\t\treturn 1;\n\n\tif (l_offset < r->offset)\n\t\treturn -1;\n\n\tif (l_offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic __always_inline\nint uprobe_cmp(const struct inode *l_inode, const loff_t l_offset,\n\t       const struct uprobe *r)\n{\n\tif (l_inode < r->inode)\n\t\treturn -1;\n\n\tif (l_inode > r->inode)\n\t\treturn 1;\n\n\tif (l_offset < r->offset)\n\t\treturn -1;\n\n\tif (l_offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__node_2_uprobe",
          "args": [
            "b"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic inline int __uprobe_cmp_key(const void *key, const struct rb_node *b)\n{\n\tconst struct __uprobe_key *a = key;\n\treturn uprobe_cmp(a->inode, a->offset, __node_2_uprobe(b));\n}"
  },
  {
    "function_name": "uprobe_cmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "618-635",
    "snippet": "static __always_inline\nint uprobe_cmp(const struct inode *l_inode, const loff_t l_offset,\n\t       const struct uprobe *r)\n{\n\tif (l_inode < r->inode)\n\t\treturn -1;\n\n\tif (l_inode > r->inode)\n\t\treturn 1;\n\n\tif (l_offset < r->offset)\n\t\treturn -1;\n\n\tif (l_offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic __always_inline\nint uprobe_cmp(const struct inode *l_inode, const loff_t l_offset,\n\t       const struct uprobe *r)\n{\n\tif (l_inode < r->inode)\n\t\treturn -1;\n\n\tif (l_inode > r->inode)\n\t\treturn 1;\n\n\tif (l_offset < r->offset)\n\t\treturn -1;\n\n\tif (l_offset > r->offset)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "put_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "603-616",
    "snippet": "static void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(delayed_uprobe_lock);",
      "static LIST_HEAD(delayed_uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "uprobe"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_remove",
          "args": [
            "uprobe",
            "NULL"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "323-341",
          "snippet": "static void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&uprobe->ref"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void put_uprobe(struct uprobe *uprobe)\n{\n\tif (refcount_dec_and_test(&uprobe->ref)) {\n\t\t/*\n\t\t * If application munmap(exec_vma) before uprobe_unregister()\n\t\t * gets called, we don't get a chance to remove uprobe from\n\t\t * delayed_uprobe_list from remove_breakpoint(). Do it here.\n\t\t */\n\t\tmutex_lock(&delayed_uprobe_lock);\n\t\tdelayed_uprobe_remove(uprobe, NULL);\n\t\tmutex_unlock(&delayed_uprobe_lock);\n\t\tkfree(uprobe);\n\t}\n}"
  },
  {
    "function_name": "get_uprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "597-601",
    "snippet": "static struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&uprobe->ref"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct uprobe *get_uprobe(struct uprobe *uprobe)\n{\n\trefcount_inc(&uprobe->ref);\n\treturn uprobe;\n}"
  },
  {
    "function_name": "set_orig_insn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "590-595",
    "snippet": "int __weak\nset_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr,\n\t\t\t*(uprobe_opcode_t *)&auprobe->insn);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_write_opcode",
          "args": [
            "auprobe",
            "mm",
            "vaddr",
            "*(uprobe_opcode_t *)&auprobe->insn"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_write_opcode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "465-565",
          "snippet": "int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\tbool orig_page_huge = false;\n\tunsigned int gup_flags = FOLL_FORCE;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\tif (is_register)\n\t\tgup_flags |= FOLL_SPLIT_PMD;\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(mm, vaddr, 1, gup_flags,\n\t\t\t\t    &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\tif (WARN(!is_register && PageCompound(old_page),\n\t\t \"uprobe unregister should never work on compound page\\n\")) {\n\t\tret = -EINVAL;\n\t\tgoto put_old;\n\t}\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = 0;\n\tif (!is_register && !PageAnon(old_page))\n\t\tgoto put_old;\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!is_register) {\n\t\tstruct page *orig_page;\n\t\tpgoff_t index;\n\n\t\tVM_BUG_ON_PAGE(!PageAnon(old_page), old_page);\n\n\t\tindex = vaddr_to_offset(vma, vaddr & PAGE_MASK) >> PAGE_SHIFT;\n\t\torig_page = find_get_page(vma->vm_file->f_inode->i_mapping,\n\t\t\t\t\t  index);\n\n\t\tif (orig_page) {\n\t\t\tif (PageUptodate(orig_page) &&\n\t\t\t    pages_identical(new_page, orig_page)) {\n\t\t\t\t/* let go new_page */\n\t\t\t\tput_page(new_page);\n\t\t\t\tnew_page = NULL;\n\n\t\t\t\tif (PageCompound(orig_page))\n\t\t\t\t\torig_page_huge = true;\n\t\t\t}\n\t\t\tput_page(orig_page);\n\t\t}\n\t}\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tif (new_page)\n\t\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\t/* try collapse pmd for compound page */\n\tif (!ret && orig_page_huge)\n\t\tcollapse_pte_mapped_thp(mm, vaddr);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\tbool orig_page_huge = false;\n\tunsigned int gup_flags = FOLL_FORCE;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\tif (is_register)\n\t\tgup_flags |= FOLL_SPLIT_PMD;\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(mm, vaddr, 1, gup_flags,\n\t\t\t\t    &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\tif (WARN(!is_register && PageCompound(old_page),\n\t\t \"uprobe unregister should never work on compound page\\n\")) {\n\t\tret = -EINVAL;\n\t\tgoto put_old;\n\t}\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = 0;\n\tif (!is_register && !PageAnon(old_page))\n\t\tgoto put_old;\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!is_register) {\n\t\tstruct page *orig_page;\n\t\tpgoff_t index;\n\n\t\tVM_BUG_ON_PAGE(!PageAnon(old_page), old_page);\n\n\t\tindex = vaddr_to_offset(vma, vaddr & PAGE_MASK) >> PAGE_SHIFT;\n\t\torig_page = find_get_page(vma->vm_file->f_inode->i_mapping,\n\t\t\t\t\t  index);\n\n\t\tif (orig_page) {\n\t\t\tif (PageUptodate(orig_page) &&\n\t\t\t    pages_identical(new_page, orig_page)) {\n\t\t\t\t/* let go new_page */\n\t\t\t\tput_page(new_page);\n\t\t\t\tnew_page = NULL;\n\n\t\t\t\tif (PageCompound(orig_page))\n\t\t\t\t\torig_page_huge = true;\n\t\t\t}\n\t\t\tput_page(orig_page);\n\t\t}\n\t}\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tif (new_page)\n\t\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\t/* try collapse pmd for compound page */\n\tif (!ret && orig_page_huge)\n\t\tcollapse_pte_mapped_thp(mm, vaddr);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint __weak\nset_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr,\n\t\t\t*(uprobe_opcode_t *)&auprobe->insn);\n}"
  },
  {
    "function_name": "set_swbp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "576-579",
    "snippet": "int __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr, UPROBE_SWBP_INSN);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uprobe_write_opcode",
          "args": [
            "auprobe",
            "mm",
            "vaddr",
            "UPROBE_SWBP_INSN"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_write_opcode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "465-565",
          "snippet": "int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\tbool orig_page_huge = false;\n\tunsigned int gup_flags = FOLL_FORCE;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\tif (is_register)\n\t\tgup_flags |= FOLL_SPLIT_PMD;\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(mm, vaddr, 1, gup_flags,\n\t\t\t\t    &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\tif (WARN(!is_register && PageCompound(old_page),\n\t\t \"uprobe unregister should never work on compound page\\n\")) {\n\t\tret = -EINVAL;\n\t\tgoto put_old;\n\t}\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = 0;\n\tif (!is_register && !PageAnon(old_page))\n\t\tgoto put_old;\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!is_register) {\n\t\tstruct page *orig_page;\n\t\tpgoff_t index;\n\n\t\tVM_BUG_ON_PAGE(!PageAnon(old_page), old_page);\n\n\t\tindex = vaddr_to_offset(vma, vaddr & PAGE_MASK) >> PAGE_SHIFT;\n\t\torig_page = find_get_page(vma->vm_file->f_inode->i_mapping,\n\t\t\t\t\t  index);\n\n\t\tif (orig_page) {\n\t\t\tif (PageUptodate(orig_page) &&\n\t\t\t    pages_identical(new_page, orig_page)) {\n\t\t\t\t/* let go new_page */\n\t\t\t\tput_page(new_page);\n\t\t\t\tnew_page = NULL;\n\n\t\t\t\tif (PageCompound(orig_page))\n\t\t\t\t\torig_page_huge = true;\n\t\t\t}\n\t\t\tput_page(orig_page);\n\t\t}\n\t}\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tif (new_page)\n\t\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\t/* try collapse pmd for compound page */\n\tif (!ret && orig_page_huge)\n\t\tcollapse_pte_mapped_thp(mm, vaddr);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\tbool orig_page_huge = false;\n\tunsigned int gup_flags = FOLL_FORCE;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\tif (is_register)\n\t\tgup_flags |= FOLL_SPLIT_PMD;\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(mm, vaddr, 1, gup_flags,\n\t\t\t\t    &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\tif (WARN(!is_register && PageCompound(old_page),\n\t\t \"uprobe unregister should never work on compound page\\n\")) {\n\t\tret = -EINVAL;\n\t\tgoto put_old;\n\t}\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = 0;\n\tif (!is_register && !PageAnon(old_page))\n\t\tgoto put_old;\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!is_register) {\n\t\tstruct page *orig_page;\n\t\tpgoff_t index;\n\n\t\tVM_BUG_ON_PAGE(!PageAnon(old_page), old_page);\n\n\t\tindex = vaddr_to_offset(vma, vaddr & PAGE_MASK) >> PAGE_SHIFT;\n\t\torig_page = find_get_page(vma->vm_file->f_inode->i_mapping,\n\t\t\t\t\t  index);\n\n\t\tif (orig_page) {\n\t\t\tif (PageUptodate(orig_page) &&\n\t\t\t    pages_identical(new_page, orig_page)) {\n\t\t\t\t/* let go new_page */\n\t\t\t\tput_page(new_page);\n\t\t\t\tnew_page = NULL;\n\n\t\t\t\tif (PageCompound(orig_page))\n\t\t\t\t\torig_page_huge = true;\n\t\t\t}\n\t\t\tput_page(orig_page);\n\t\t}\n\t}\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tif (new_page)\n\t\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\t/* try collapse pmd for compound page */\n\tif (!ret && orig_page_huge)\n\t\tcollapse_pte_mapped_thp(mm, vaddr);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(auprobe, mm, vaddr, UPROBE_SWBP_INSN);\n}"
  },
  {
    "function_name": "uprobe_write_opcode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "465-565",
    "snippet": "int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\tbool orig_page_huge = false;\n\tunsigned int gup_flags = FOLL_FORCE;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\tif (is_register)\n\t\tgup_flags |= FOLL_SPLIT_PMD;\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(mm, vaddr, 1, gup_flags,\n\t\t\t\t    &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\tif (WARN(!is_register && PageCompound(old_page),\n\t\t \"uprobe unregister should never work on compound page\\n\")) {\n\t\tret = -EINVAL;\n\t\tgoto put_old;\n\t}\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = 0;\n\tif (!is_register && !PageAnon(old_page))\n\t\tgoto put_old;\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!is_register) {\n\t\tstruct page *orig_page;\n\t\tpgoff_t index;\n\n\t\tVM_BUG_ON_PAGE(!PageAnon(old_page), old_page);\n\n\t\tindex = vaddr_to_offset(vma, vaddr & PAGE_MASK) >> PAGE_SHIFT;\n\t\torig_page = find_get_page(vma->vm_file->f_inode->i_mapping,\n\t\t\t\t\t  index);\n\n\t\tif (orig_page) {\n\t\t\tif (PageUptodate(orig_page) &&\n\t\t\t    pages_identical(new_page, orig_page)) {\n\t\t\t\t/* let go new_page */\n\t\t\t\tput_page(new_page);\n\t\t\t\tnew_page = NULL;\n\n\t\t\t\tif (PageCompound(orig_page))\n\t\t\t\t\torig_page_huge = true;\n\t\t\t}\n\t\t\tput_page(orig_page);\n\t\t}\n\t}\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tif (new_page)\n\t\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\t/* try collapse pmd for compound page */\n\tif (!ret && orig_page_huge)\n\t\tcollapse_pte_mapped_thp(mm, vaddr);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "collapse_pte_mapped_thp",
          "args": [
            "mm",
            "vaddr"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_ref_ctr",
          "args": [
            "uprobe",
            "mm",
            "-1"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "update_ref_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "418-445",
          "snippet": "static int update_ref_ctr(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\t  short d)\n{\n\tstruct vm_area_struct *rc_vma;\n\tunsigned long rc_vaddr;\n\tint ret = 0;\n\n\trc_vma = find_ref_ctr_vma(uprobe, mm);\n\n\tif (rc_vma) {\n\t\trc_vaddr = offset_to_vaddr(rc_vma, uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(mm, rc_vaddr, d);\n\t\tif (ret)\n\t\t\tupdate_ref_ctr_warn(uprobe, mm, d);\n\n\t\tif (d > 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tif (d > 0)\n\t\tret = delayed_uprobe_add(uprobe, mm);\n\telse\n\t\tdelayed_uprobe_remove(uprobe, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(delayed_uprobe_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\n\nstatic int update_ref_ctr(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\t  short d)\n{\n\tstruct vm_area_struct *rc_vma;\n\tunsigned long rc_vaddr;\n\tint ret = 0;\n\n\trc_vma = find_ref_ctr_vma(uprobe, mm);\n\n\tif (rc_vma) {\n\t\trc_vaddr = offset_to_vaddr(rc_vma, uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(mm, rc_vaddr, d);\n\t\tif (ret)\n\t\t\tupdate_ref_ctr_warn(uprobe, mm, d);\n\n\t\tif (d > 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tif (d > 0)\n\t\tret = delayed_uprobe_add(uprobe, mm);\n\telse\n\t\tdelayed_uprobe_remove(uprobe, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -EAGAIN"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "old_page"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "new_page"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__replace_page",
          "args": [
            "vma",
            "vaddr",
            "old_page",
            "new_page"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "__replace_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "154-218",
          "snippet": "static int __replace_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tstruct page *old_page, struct page *new_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = compound_head(old_page),\n\t\t.vma = vma,\n\t\t.address = addr,\n\t};\n\tint err;\n\tstruct mmu_notifier_range range;\n\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, mm, addr,\n\t\t\t\taddr + PAGE_SIZE);\n\n\tif (new_page) {\n\t\terr = mem_cgroup_charge(page_folio(new_page), vma->vm_mm,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* For try_to_free_swap() and munlock_vma_page() below */\n\tlock_page(old_page);\n\n\tmmu_notifier_invalidate_range_start(&range);\n\terr = -EAGAIN;\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\tgoto unlock;\n\tVM_BUG_ON_PAGE(addr != pvmw.address, old_page);\n\n\tif (new_page) {\n\t\tget_page(new_page);\n\t\tpage_add_new_anon_rmap(new_page, vma, addr, false);\n\t\tlru_cache_add_inactive_or_unevictable(new_page, vma);\n\t} else\n\t\t/* no new page, just dec_mm_counter for old_page */\n\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\n\tif (!PageAnon(old_page)) {\n\t\tdec_mm_counter(mm, mm_counter_file(old_page));\n\t\tinc_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*pvmw.pte));\n\tptep_clear_flush_notify(vma, addr, pvmw.pte);\n\tif (new_page)\n\t\tset_pte_at_notify(mm, addr, pvmw.pte,\n\t\t\t\t  mk_pte(new_page, vma->vm_page_prot));\n\n\tpage_remove_rmap(old_page, false);\n\tif (!page_mapped(old_page))\n\t\ttry_to_free_swap(old_page);\n\tpage_vma_mapped_walk_done(&pvmw);\n\n\tif ((vma->vm_flags & VM_LOCKED) && !PageCompound(old_page))\n\t\tmunlock_vma_page(old_page);\n\tput_page(old_page);\n\n\terr = 0;\n unlock:\n\tmmu_notifier_invalidate_range_end(&range);\n\tunlock_page(old_page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __replace_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tstruct page *old_page, struct page *new_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = compound_head(old_page),\n\t\t.vma = vma,\n\t\t.address = addr,\n\t};\n\tint err;\n\tstruct mmu_notifier_range range;\n\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, mm, addr,\n\t\t\t\taddr + PAGE_SIZE);\n\n\tif (new_page) {\n\t\terr = mem_cgroup_charge(page_folio(new_page), vma->vm_mm,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* For try_to_free_swap() and munlock_vma_page() below */\n\tlock_page(old_page);\n\n\tmmu_notifier_invalidate_range_start(&range);\n\terr = -EAGAIN;\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\tgoto unlock;\n\tVM_BUG_ON_PAGE(addr != pvmw.address, old_page);\n\n\tif (new_page) {\n\t\tget_page(new_page);\n\t\tpage_add_new_anon_rmap(new_page, vma, addr, false);\n\t\tlru_cache_add_inactive_or_unevictable(new_page, vma);\n\t} else\n\t\t/* no new page, just dec_mm_counter for old_page */\n\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\n\tif (!PageAnon(old_page)) {\n\t\tdec_mm_counter(mm, mm_counter_file(old_page));\n\t\tinc_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*pvmw.pte));\n\tptep_clear_flush_notify(vma, addr, pvmw.pte);\n\tif (new_page)\n\t\tset_pte_at_notify(mm, addr, pvmw.pte,\n\t\t\t\t  mk_pte(new_page, vma->vm_page_prot));\n\n\tpage_remove_rmap(old_page, false);\n\tif (!page_mapped(old_page))\n\t\ttry_to_free_swap(old_page);\n\tpage_vma_mapped_walk_done(&pvmw);\n\n\tif ((vma->vm_flags & VM_LOCKED) && !PageCompound(old_page))\n\t\tmunlock_vma_page(old_page);\n\tput_page(old_page);\n\n\terr = 0;\n unlock:\n\tmmu_notifier_invalidate_range_end(&range);\n\tunlock_page(old_page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "orig_page"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "orig_page"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "new_page"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pages_identical",
          "args": [
            "new_page",
            "orig_page"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "orig_page"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "vma->vm_file->f_inode->i_mapping",
            "index"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vaddr_to_offset",
          "args": [
            "vma",
            "vaddr & PAGE_MASK"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "vaddr_to_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "136-139",
          "snippet": "static loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageAnon(old_page)",
            "old_page"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "old_page"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_page",
          "args": [
            "new_page",
            "vaddr",
            "&opcode",
            "UPROBE_SWBP_INSN_SIZE"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "copy_to_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "252-257",
          "snippet": "static void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "new_page",
            "old_page"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "new_page"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page_vma",
          "args": [
            "GFP_HIGHUSER_MOVABLE",
            "vma",
            "vaddr"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_prepare",
          "args": [
            "vma"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "old_page"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!is_register && PageCompound(old_page)",
            "\"uprobe unregister should never work on compound page\\n\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "old_page"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_opcode",
          "args": [
            "old_page",
            "vaddr",
            "&opcode"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "verify_opcode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "259-285",
          "snippet": "static int verify_opcode(struct page *page, unsigned long vaddr, uprobe_opcode_t *new_opcode)\n{\n\tuprobe_opcode_t old_opcode;\n\tbool is_swbp;\n\n\t/*\n\t * Note: We only check if the old_opcode is UPROBE_SWBP_INSN here.\n\t * We do not check if it is any other 'trap variant' which could\n\t * be conditional trap instruction such as the one powerpc supports.\n\t *\n\t * The logic is that we do not care if the underlying instruction\n\t * is a trap variant; uprobes always wins over any other (gdb)\n\t * breakpoint.\n\t */\n\tcopy_from_page(page, vaddr, &old_opcode, UPROBE_SWBP_INSN_SIZE);\n\tis_swbp = is_swbp_insn(&old_opcode);\n\n\tif (is_swbp_insn(new_opcode)) {\n\t\tif (is_swbp)\t\t/* register: already installed? */\n\t\t\treturn 0;\n\t} else {\n\t\tif (!is_swbp)\t\t/* unregister: was it changed by us? */\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int verify_opcode(struct page *page, unsigned long vaddr, uprobe_opcode_t *new_opcode)\n{\n\tuprobe_opcode_t old_opcode;\n\tbool is_swbp;\n\n\t/*\n\t * Note: We only check if the old_opcode is UPROBE_SWBP_INSN here.\n\t * We do not check if it is any other 'trap variant' which could\n\t * be conditional trap instruction such as the one powerpc supports.\n\t *\n\t * The logic is that we do not care if the underlying instruction\n\t * is a trap variant; uprobes always wins over any other (gdb)\n\t * breakpoint.\n\t */\n\tcopy_from_page(page, vaddr, &old_opcode, UPROBE_SWBP_INSN_SIZE);\n\tis_swbp = is_swbp_insn(&old_opcode);\n\n\tif (is_swbp_insn(new_opcode)) {\n\t\tif (is_swbp)\t\t/* register: already installed? */\n\t\t\treturn 0;\n\t} else {\n\t\tif (!is_swbp)\t\t/* unregister: was it changed by us? */\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_pages_remote",
          "args": [
            "mm",
            "vaddr",
            "1",
            "gup_flags",
            "&old_page",
            "&vma",
            "NULL"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "auprobe",
            "structuprobe",
            "arch"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swbp_insn",
          "args": [
            "&opcode"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "is_swbp_insn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "226-229",
          "snippet": "bool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nint uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm,\n\t\t\tunsigned long vaddr, uprobe_opcode_t opcode)\n{\n\tstruct uprobe *uprobe;\n\tstruct page *old_page, *new_page;\n\tstruct vm_area_struct *vma;\n\tint ret, is_register, ref_ctr_updated = 0;\n\tbool orig_page_huge = false;\n\tunsigned int gup_flags = FOLL_FORCE;\n\n\tis_register = is_swbp_insn(&opcode);\n\tuprobe = container_of(auprobe, struct uprobe, arch);\n\nretry:\n\tif (is_register)\n\t\tgup_flags |= FOLL_SPLIT_PMD;\n\t/* Read the page with vaddr into memory */\n\tret = get_user_pages_remote(mm, vaddr, 1, gup_flags,\n\t\t\t\t    &old_page, &vma, NULL);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\tif (WARN(!is_register && PageCompound(old_page),\n\t\t \"uprobe unregister should never work on compound page\\n\")) {\n\t\tret = -EINVAL;\n\t\tgoto put_old;\n\t}\n\n\t/* We are going to replace instruction, update ref_ctr. */\n\tif (!ref_ctr_updated && uprobe->ref_ctr_offset) {\n\t\tret = update_ref_ctr(uprobe, mm, is_register ? 1 : -1);\n\t\tif (ret)\n\t\t\tgoto put_old;\n\n\t\tref_ctr_updated = 1;\n\t}\n\n\tret = 0;\n\tif (!is_register && !PageAnon(old_page))\n\t\tgoto put_old;\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -ENOMEM;\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__SetPageUptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE);\n\n\tif (!is_register) {\n\t\tstruct page *orig_page;\n\t\tpgoff_t index;\n\n\t\tVM_BUG_ON_PAGE(!PageAnon(old_page), old_page);\n\n\t\tindex = vaddr_to_offset(vma, vaddr & PAGE_MASK) >> PAGE_SHIFT;\n\t\torig_page = find_get_page(vma->vm_file->f_inode->i_mapping,\n\t\t\t\t\t  index);\n\n\t\tif (orig_page) {\n\t\t\tif (PageUptodate(orig_page) &&\n\t\t\t    pages_identical(new_page, orig_page)) {\n\t\t\t\t/* let go new_page */\n\t\t\t\tput_page(new_page);\n\t\t\t\tnew_page = NULL;\n\n\t\t\t\tif (PageCompound(orig_page))\n\t\t\t\t\torig_page_huge = true;\n\t\t\t}\n\t\t\tput_page(orig_page);\n\t\t}\n\t}\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tif (new_page)\n\t\tput_page(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -EAGAIN))\n\t\tgoto retry;\n\n\t/* Revert back reference counter if instruction update failed. */\n\tif (ret && is_register && ref_ctr_updated)\n\t\tupdate_ref_ctr(uprobe, mm, -1);\n\n\t/* try collapse pmd for compound page */\n\tif (!ret && orig_page_huge)\n\t\tcollapse_pte_mapped_thp(mm, vaddr);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "update_ref_ctr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "418-445",
    "snippet": "static int update_ref_ctr(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\t  short d)\n{\n\tstruct vm_area_struct *rc_vma;\n\tunsigned long rc_vaddr;\n\tint ret = 0;\n\n\trc_vma = find_ref_ctr_vma(uprobe, mm);\n\n\tif (rc_vma) {\n\t\trc_vaddr = offset_to_vaddr(rc_vma, uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(mm, rc_vaddr, d);\n\t\tif (ret)\n\t\t\tupdate_ref_ctr_warn(uprobe, mm, d);\n\n\t\tif (d > 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tif (d > 0)\n\t\tret = delayed_uprobe_add(uprobe, mm);\n\telse\n\t\tdelayed_uprobe_remove(uprobe, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(delayed_uprobe_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_remove",
          "args": [
            "uprobe",
            "mm"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "323-341",
          "snippet": "static void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_add",
          "args": [
            "uprobe",
            "mm"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "298-313",
          "snippet": "static int delayed_uprobe_add(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tif (delayed_uprobe_check(uprobe, mm))\n\t\treturn 0;\n\n\tdu  = kzalloc(sizeof(*du), GFP_KERNEL);\n\tif (!du)\n\t\treturn -ENOMEM;\n\n\tdu->uprobe = uprobe;\n\tdu->mm = mm;\n\tlist_add(&du->list, &delayed_uprobe_list);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic int delayed_uprobe_add(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tif (delayed_uprobe_check(uprobe, mm))\n\t\treturn 0;\n\n\tdu  = kzalloc(sizeof(*du), GFP_KERNEL);\n\tif (!du)\n\t\treturn -ENOMEM;\n\n\tdu->uprobe = uprobe;\n\tdu->mm = mm;\n\tlist_add(&du->list, &delayed_uprobe_list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&delayed_uprobe_lock"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_ref_ctr_warn",
          "args": [
            "uprobe",
            "mm",
            "d"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "update_ref_ctr_warn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "408-416",
          "snippet": "static void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_ref_ctr",
          "args": [
            "mm",
            "rc_vaddr",
            "d"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "__update_ref_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "368-406",
          "snippet": "static int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "rc_vma",
            "uprobe->ref_ctr_offset"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "131-134",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_ref_ctr_vma",
          "args": [
            "uprobe",
            "mm"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "find_ref_ctr_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "356-366",
          "snippet": "static struct vm_area_struct *\nfind_ref_ctr_vma(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *tmp;\n\n\tfor (tmp = mm->mmap; tmp; tmp = tmp->vm_next)\n\t\tif (valid_ref_ctr_vma(uprobe, tmp))\n\t\t\treturn tmp;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct vm_area_struct *\nfind_ref_ctr_vma(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *tmp;\n\n\tfor (tmp = mm->mmap; tmp; tmp = tmp->vm_next)\n\t\tif (valid_ref_ctr_vma(uprobe, tmp))\n\t\t\treturn tmp;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(delayed_uprobe_lock);\n\nstatic int update_ref_ctr(struct uprobe *uprobe, struct mm_struct *mm,\n\t\t\t  short d)\n{\n\tstruct vm_area_struct *rc_vma;\n\tunsigned long rc_vaddr;\n\tint ret = 0;\n\n\trc_vma = find_ref_ctr_vma(uprobe, mm);\n\n\tif (rc_vma) {\n\t\trc_vaddr = offset_to_vaddr(rc_vma, uprobe->ref_ctr_offset);\n\t\tret = __update_ref_ctr(mm, rc_vaddr, d);\n\t\tif (ret)\n\t\t\tupdate_ref_ctr_warn(uprobe, mm, d);\n\n\t\tif (d > 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&delayed_uprobe_lock);\n\tif (d > 0)\n\t\tret = delayed_uprobe_add(uprobe, mm);\n\telse\n\t\tdelayed_uprobe_remove(uprobe, mm);\n\tmutex_unlock(&delayed_uprobe_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "update_ref_ctr_warn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "408-416",
    "snippet": "static void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\"",
            "d > 0 ? \"increment\" : \"decrement\"",
            "uprobe->inode->i_ino",
            "(unsigned long long) uprobe->offset",
            "(unsigned long long) uprobe->ref_ctr_offset",
            "mm"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void update_ref_ctr_warn(struct uprobe *uprobe,\n\t\t\t\tstruct mm_struct *mm, short d)\n{\n\tpr_warn(\"ref_ctr %s failed for inode: 0x%lx offset: \"\n\t\t\"0x%llx ref_ctr_offset: 0x%llx of mm: 0x%pK\\n\",\n\t\td > 0 ? \"increment\" : \"decrement\", uprobe->inode->i_ino,\n\t\t(unsigned long long) uprobe->offset,\n\t\t(unsigned long long) uprobe->ref_ctr_offset, mm);\n}"
  },
  {
    "function_name": "__update_ref_ctr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "368-406",
    "snippet": "static int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\"",
            "vaddr",
            "*ptr",
            "d"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*ptr + d < 0"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret <= 0"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages_remote",
          "args": [
            "mm",
            "vaddr",
            "1",
            "FOLL_WRITE",
            "&page",
            "&vma",
            "NULL"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int\n__update_ref_ctr(struct mm_struct *mm, unsigned long vaddr, short d)\n{\n\tvoid *kaddr;\n\tstruct page *page;\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tshort *ptr;\n\n\tif (!vaddr || !d)\n\t\treturn -EINVAL;\n\n\tret = get_user_pages_remote(mm, vaddr, 1,\n\t\t\tFOLL_WRITE, &page, &vma, NULL);\n\tif (unlikely(ret <= 0)) {\n\t\t/*\n\t\t * We are asking for 1 page. If get_user_pages_remote() fails,\n\t\t * it may return 0, in that case we have to return error.\n\t\t */\n\t\treturn ret == 0 ? -EBUSY : ret;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tptr = kaddr + (vaddr & ~PAGE_MASK);\n\n\tif (unlikely(*ptr + d < 0)) {\n\t\tpr_warn(\"ref_ctr going negative. vaddr: 0x%lx, \"\n\t\t\t\"curr val: %d, delta: %d\\n\", vaddr, *ptr, d);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ptr += d;\n\tret = 0;\nout:\n\tkunmap_atomic(kaddr);\n\tput_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_ref_ctr_vma",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "356-366",
    "snippet": "static struct vm_area_struct *\nfind_ref_ctr_vma(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *tmp;\n\n\tfor (tmp = mm->mmap; tmp; tmp = tmp->vm_next)\n\t\tif (valid_ref_ctr_vma(uprobe, tmp))\n\t\t\treturn tmp;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "valid_ref_ctr_vma",
          "args": [
            "uprobe",
            "tmp"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "valid_ref_ctr_vma",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "343-354",
          "snippet": "static bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic struct vm_area_struct *\nfind_ref_ctr_vma(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *tmp;\n\n\tfor (tmp = mm->mmap; tmp; tmp = tmp->vm_next)\n\t\tif (valid_ref_ctr_vma(uprobe, tmp))\n\t\t\treturn tmp;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "valid_ref_ctr_vma",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "343-354",
    "snippet": "static bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_to_vaddr",
          "args": [
            "vma",
            "uprobe->ref_ctr_offset"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "offset_to_vaddr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "131-134",
          "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_ref_ctr_vma(struct uprobe *uprobe,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tunsigned long vaddr = offset_to_vaddr(vma, uprobe->ref_ctr_offset);\n\n\treturn uprobe->ref_ctr_offset &&\n\t\tvma->vm_file &&\n\t\tfile_inode(vma->vm_file) == uprobe->inode &&\n\t\t(vma->vm_flags & (VM_WRITE|VM_SHARED)) == VM_WRITE &&\n\t\tvma->vm_start <= vaddr &&\n\t\tvma->vm_end > vaddr;\n}"
  },
  {
    "function_name": "delayed_uprobe_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "323-341",
    "snippet": "static void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(delayed_uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delayed_uprobe_delete",
          "args": [
            "du"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "315-321",
          "snippet": "static void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structdelayed_uprobe",
            "list"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "q",
            "&delayed_uprobe_list"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic void delayed_uprobe_remove(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct list_head *pos, *q;\n\tstruct delayed_uprobe *du;\n\n\tif (!uprobe && !mm)\n\t\treturn;\n\n\tlist_for_each_safe(pos, q, &delayed_uprobe_list) {\n\t\tdu = list_entry(pos, struct delayed_uprobe, list);\n\n\t\tif (uprobe && du->uprobe != uprobe)\n\t\t\tcontinue;\n\t\tif (mm && du->mm != mm)\n\t\t\tcontinue;\n\n\t\tdelayed_uprobe_delete(du);\n\t}\n}"
  },
  {
    "function_name": "delayed_uprobe_delete",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "315-321",
    "snippet": "static void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "du"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&du->list"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!du"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void delayed_uprobe_delete(struct delayed_uprobe *du)\n{\n\tif (WARN_ON(!du))\n\t\treturn;\n\tlist_del(&du->list);\n\tkfree(du);\n}"
  },
  {
    "function_name": "delayed_uprobe_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "298-313",
    "snippet": "static int delayed_uprobe_add(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tif (delayed_uprobe_check(uprobe, mm))\n\t\treturn 0;\n\n\tdu  = kzalloc(sizeof(*du), GFP_KERNEL);\n\tif (!du)\n\t\treturn -ENOMEM;\n\n\tdu->uprobe = uprobe;\n\tdu->mm = mm;\n\tlist_add(&du->list, &delayed_uprobe_list);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(delayed_uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&du->list",
            "&delayed_uprobe_list"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "1789-1820",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->hw.flags & PERF_EVENT_FLAG_USER_READ_CNT)\n\t\tctx->nr_user++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tif (event->state > PERF_EVENT_STATE_OFF)\n\t\tperf_cgroup_event_enable(event, ctx);\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->hw.flags & PERF_EVENT_FLAG_USER_READ_CNT)\n\t\tctx->nr_user++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tif (event->state > PERF_EVENT_STATE_OFF)\n\t\tperf_cgroup_event_enable(event, ctx);\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*du)",
            "GFP_KERNEL"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayed_uprobe_check",
          "args": [
            "uprobe",
            "mm"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_uprobe_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "287-296",
          "snippet": "static struct delayed_uprobe *\ndelayed_uprobe_check(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tlist_for_each_entry(du, &delayed_uprobe_list, list)\n\t\tif (du->uprobe == uprobe && du->mm == mm)\n\t\t\treturn du;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(delayed_uprobe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic struct delayed_uprobe *\ndelayed_uprobe_check(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tlist_for_each_entry(du, &delayed_uprobe_list, list)\n\t\tif (du->uprobe == uprobe && du->mm == mm)\n\t\t\treturn du;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic int delayed_uprobe_add(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tif (delayed_uprobe_check(uprobe, mm))\n\t\treturn 0;\n\n\tdu  = kzalloc(sizeof(*du), GFP_KERNEL);\n\tif (!du)\n\t\treturn -ENOMEM;\n\n\tdu->uprobe = uprobe;\n\tdu->mm = mm;\n\tlist_add(&du->list, &delayed_uprobe_list);\n\treturn 0;\n}"
  },
  {
    "function_name": "delayed_uprobe_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "287-296",
    "snippet": "static struct delayed_uprobe *\ndelayed_uprobe_check(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tlist_for_each_entry(du, &delayed_uprobe_list, list)\n\t\tif (du->uprobe == uprobe && du->mm == mm)\n\t\t\treturn du;\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(delayed_uprobe_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "du",
            "&delayed_uprobe_list",
            "list"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(delayed_uprobe_list);\n\nstatic struct delayed_uprobe *\ndelayed_uprobe_check(struct uprobe *uprobe, struct mm_struct *mm)\n{\n\tstruct delayed_uprobe *du;\n\n\tlist_for_each_entry(du, &delayed_uprobe_list, list)\n\t\tif (du->uprobe == uprobe && du->mm == mm)\n\t\t\treturn du;\n\treturn NULL;\n}"
  },
  {
    "function_name": "verify_opcode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "259-285",
    "snippet": "static int verify_opcode(struct page *page, unsigned long vaddr, uprobe_opcode_t *new_opcode)\n{\n\tuprobe_opcode_t old_opcode;\n\tbool is_swbp;\n\n\t/*\n\t * Note: We only check if the old_opcode is UPROBE_SWBP_INSN here.\n\t * We do not check if it is any other 'trap variant' which could\n\t * be conditional trap instruction such as the one powerpc supports.\n\t *\n\t * The logic is that we do not care if the underlying instruction\n\t * is a trap variant; uprobes always wins over any other (gdb)\n\t * breakpoint.\n\t */\n\tcopy_from_page(page, vaddr, &old_opcode, UPROBE_SWBP_INSN_SIZE);\n\tis_swbp = is_swbp_insn(&old_opcode);\n\n\tif (is_swbp_insn(new_opcode)) {\n\t\tif (is_swbp)\t\t/* register: already installed? */\n\t\t\treturn 0;\n\t} else {\n\t\tif (!is_swbp)\t\t/* unregister: was it changed by us? */\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_swbp_insn",
          "args": [
            "new_opcode"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "is_swbp_insn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "226-229",
          "snippet": "bool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_page",
          "args": [
            "page",
            "vaddr",
            "&old_opcode",
            "UPROBE_SWBP_INSN_SIZE"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "copy_from_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "245-250",
          "snippet": "static void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int verify_opcode(struct page *page, unsigned long vaddr, uprobe_opcode_t *new_opcode)\n{\n\tuprobe_opcode_t old_opcode;\n\tbool is_swbp;\n\n\t/*\n\t * Note: We only check if the old_opcode is UPROBE_SWBP_INSN here.\n\t * We do not check if it is any other 'trap variant' which could\n\t * be conditional trap instruction such as the one powerpc supports.\n\t *\n\t * The logic is that we do not care if the underlying instruction\n\t * is a trap variant; uprobes always wins over any other (gdb)\n\t * breakpoint.\n\t */\n\tcopy_from_page(page, vaddr, &old_opcode, UPROBE_SWBP_INSN_SIZE);\n\tis_swbp = is_swbp_insn(&old_opcode);\n\n\tif (is_swbp_insn(new_opcode)) {\n\t\tif (is_swbp)\t\t/* register: already installed? */\n\t\t\treturn 0;\n\t} else {\n\t\tif (!is_swbp)\t\t/* unregister: was it changed by us? */\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "copy_to_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "252-257",
    "snippet": "static void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr + (vaddr & ~PAGE_MASK)",
            "src",
            "len"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}"
  },
  {
    "function_name": "copy_from_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "245-250",
    "snippet": "static void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "kaddr + (vaddr & ~PAGE_MASK)",
            "len"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len);\n\tkunmap_atomic(kaddr);\n}"
  },
  {
    "function_name": "is_trap_insn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "240-243",
    "snippet": "bool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_swbp_insn",
          "args": [
            "insn"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "is_swbp_insn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "226-229",
          "snippet": "bool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn is_swbp_insn(insn);\n}"
  },
  {
    "function_name": "is_swbp_insn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "226-229",
    "snippet": "bool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool __weak is_swbp_insn(uprobe_opcode_t *insn)\n{\n\treturn *insn == UPROBE_SWBP_INSN;\n}"
  },
  {
    "function_name": "__replace_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "154-218",
    "snippet": "static int __replace_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tstruct page *old_page, struct page *new_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = compound_head(old_page),\n\t\t.vma = vma,\n\t\t.address = addr,\n\t};\n\tint err;\n\tstruct mmu_notifier_range range;\n\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, mm, addr,\n\t\t\t\taddr + PAGE_SIZE);\n\n\tif (new_page) {\n\t\terr = mem_cgroup_charge(page_folio(new_page), vma->vm_mm,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* For try_to_free_swap() and munlock_vma_page() below */\n\tlock_page(old_page);\n\n\tmmu_notifier_invalidate_range_start(&range);\n\terr = -EAGAIN;\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\tgoto unlock;\n\tVM_BUG_ON_PAGE(addr != pvmw.address, old_page);\n\n\tif (new_page) {\n\t\tget_page(new_page);\n\t\tpage_add_new_anon_rmap(new_page, vma, addr, false);\n\t\tlru_cache_add_inactive_or_unevictable(new_page, vma);\n\t} else\n\t\t/* no new page, just dec_mm_counter for old_page */\n\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\n\tif (!PageAnon(old_page)) {\n\t\tdec_mm_counter(mm, mm_counter_file(old_page));\n\t\tinc_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*pvmw.pte));\n\tptep_clear_flush_notify(vma, addr, pvmw.pte);\n\tif (new_page)\n\t\tset_pte_at_notify(mm, addr, pvmw.pte,\n\t\t\t\t  mk_pte(new_page, vma->vm_page_prot));\n\n\tpage_remove_rmap(old_page, false);\n\tif (!page_mapped(old_page))\n\t\ttry_to_free_swap(old_page);\n\tpage_vma_mapped_walk_done(&pvmw);\n\n\tif ((vma->vm_flags & VM_LOCKED) && !PageCompound(old_page))\n\t\tmunlock_vma_page(old_page);\n\tput_page(old_page);\n\n\terr = 0;\n unlock:\n\tmmu_notifier_invalidate_range_end(&range);\n\tunlock_page(old_page);\n\treturn err;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "old_page"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "&range"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "old_page"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munlock_vma_page",
          "args": [
            "old_page"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "old_page"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_free_swap",
          "args": [
            "old_page"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "old_page"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "old_page",
            "false"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at_notify",
          "args": [
            "mm",
            "addr",
            "pvmw.pte",
            "mk_pte(new_page, vma->vm_page_prot)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "new_page",
            "vma->vm_page_prot"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_clear_flush_notify",
          "args": [
            "vma",
            "addr",
            "pvmw.pte"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "addr",
            "pte_pfn(*pvmw.pte)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*pvmw.pte"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_mm_counter",
          "args": [
            "mm",
            "MM_ANONPAGES"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_mm_counter",
          "args": [
            "mm",
            "mm_counter_file(old_page)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter_file",
          "args": [
            "old_page"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "old_page"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_mm_counter",
          "args": [
            "mm",
            "MM_ANONPAGES"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_cache_add_inactive_or_unevictable",
          "args": [
            "new_page",
            "vma"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "new_page",
            "vma",
            "addr",
            "false"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "new_page"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "perf_get_page_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "7266-7295",
          "snippet": "static u64 perf_get_page_size(unsigned long addr)\n{\n\tstruct mm_struct *mm;\n\tunsigned long flags;\n\tu64 size;\n\n\tif (!addr)\n\t\treturn 0;\n\n\t/*\n\t * Software page-table walkers must disable IRQs,\n\t * which prevents any tear down of the page tables.\n\t */\n\tlocal_irq_save(flags);\n\n\tmm = current->mm;\n\tif (!mm) {\n\t\t/*\n\t\t * For kernel threads and the like, use init_mm so that\n\t\t * we can find kernel memory.\n\t\t */\n\t\tmm = &init_mm;\n\t}\n\n\tsize = perf_get_pgtable_size(mm, addr);\n\n\tlocal_irq_restore(flags);\n\n\treturn size;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\n\nstatic u64 perf_get_page_size(unsigned long addr)\n{\n\tstruct mm_struct *mm;\n\tunsigned long flags;\n\tu64 size;\n\n\tif (!addr)\n\t\treturn 0;\n\n\t/*\n\t * Software page-table walkers must disable IRQs,\n\t * which prevents any tear down of the page tables.\n\t */\n\tlocal_irq_save(flags);\n\n\tmm = current->mm;\n\tif (!mm) {\n\t\t/*\n\t\t * For kernel threads and the like, use init_mm so that\n\t\t * we can find kernel memory.\n\t\t */\n\t\tmm = &init_mm;\n\t}\n\n\tsize = perf_get_pgtable_size(mm, addr);\n\n\tlocal_irq_restore(flags);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "addr != pvmw.address",
            "old_page"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk",
          "args": [
            "&pvmw"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "&range"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "old_page"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_charge",
          "args": [
            "page_folio(new_page)",
            "vma->vm_mm",
            "GFP_KERNEL"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_folio",
          "args": [
            "new_page"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_range_init",
          "args": [
            "&range",
            "MMU_NOTIFY_CLEAR",
            "0",
            "vma",
            "mm",
            "addr",
            "addr + PAGE_SIZE"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "old_page"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic int __replace_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tstruct page *old_page, struct page *new_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = compound_head(old_page),\n\t\t.vma = vma,\n\t\t.address = addr,\n\t};\n\tint err;\n\tstruct mmu_notifier_range range;\n\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, mm, addr,\n\t\t\t\taddr + PAGE_SIZE);\n\n\tif (new_page) {\n\t\terr = mem_cgroup_charge(page_folio(new_page), vma->vm_mm,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* For try_to_free_swap() and munlock_vma_page() below */\n\tlock_page(old_page);\n\n\tmmu_notifier_invalidate_range_start(&range);\n\terr = -EAGAIN;\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\tgoto unlock;\n\tVM_BUG_ON_PAGE(addr != pvmw.address, old_page);\n\n\tif (new_page) {\n\t\tget_page(new_page);\n\t\tpage_add_new_anon_rmap(new_page, vma, addr, false);\n\t\tlru_cache_add_inactive_or_unevictable(new_page, vma);\n\t} else\n\t\t/* no new page, just dec_mm_counter for old_page */\n\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\n\tif (!PageAnon(old_page)) {\n\t\tdec_mm_counter(mm, mm_counter_file(old_page));\n\t\tinc_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*pvmw.pte));\n\tptep_clear_flush_notify(vma, addr, pvmw.pte);\n\tif (new_page)\n\t\tset_pte_at_notify(mm, addr, pvmw.pte,\n\t\t\t\t  mk_pte(new_page, vma->vm_page_prot));\n\n\tpage_remove_rmap(old_page, false);\n\tif (!page_mapped(old_page))\n\t\ttry_to_free_swap(old_page);\n\tpage_vma_mapped_walk_done(&pvmw);\n\n\tif ((vma->vm_flags & VM_LOCKED) && !PageCompound(old_page))\n\t\tmunlock_vma_page(old_page);\n\tput_page(old_page);\n\n\terr = 0;\n unlock:\n\tmmu_notifier_invalidate_range_end(&range);\n\tunlock_page(old_page);\n\treturn err;\n}"
  },
  {
    "function_name": "vaddr_to_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "136-139",
    "snippet": "static loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (vaddr - vma->vm_start);\n}"
  },
  {
    "function_name": "offset_to_vaddr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "131-134",
    "snippet": "static unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic unsigned long offset_to_vaddr(struct vm_area_struct *vma, loff_t offset)\n{\n\treturn vma->vm_start + offset - ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n}"
  },
  {
    "function_name": "valid_vma",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
    "lines": "121-129",
    "snippet": "static bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}",
    "includes": [
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
      "#include <linux/kdebug.h>\t/* notifier mechanism */",
      "#include <linux/ptrace.h>\t/* user_enable_single_step */",
      "#include <linux/swap.h>\t\t/* try_to_free_swap */",
      "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
      "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
      "#include <linux/export.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>\t/* read_mapping_page */",
      "#include <linux/highmem.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nstatic bool valid_vma(struct vm_area_struct *vma, bool is_register)\n{\n\tvm_flags_t flags = VM_HUGETLB | VM_MAYEXEC | VM_MAYSHARE;\n\n\tif (is_register)\n\t\tflags |= VM_WRITE;\n\n\treturn vma->vm_file && (vma->vm_flags & flags) == VM_MAYEXEC;\n}"
  }
]