[
  {
    "function_name": "bpf_lru_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "689-695",
    "snippet": "void bpf_lru_destroy(struct bpf_lru *lru)\n{\n\tif (lru->percpu)\n\t\tfree_percpu(lru->percpu_lru);\n\telse\n\t\tfree_percpu(lru->common_lru.local_list);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "lru->common_lru.local_list"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nvoid bpf_lru_destroy(struct bpf_lru *lru)\n{\n\tif (lru->percpu)\n\t\tfree_percpu(lru->percpu_lru);\n\telse\n\t\tfree_percpu(lru->common_lru.local_list);\n}"
  },
  {
    "function_name": "bpf_lru_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "646-687",
    "snippet": "int bpf_lru_init(struct bpf_lru *lru, bool percpu, u32 hash_offset,\n\t\t del_from_htab_func del_from_htab, void *del_arg)\n{\n\tint cpu;\n\n\tif (percpu) {\n\t\tlru->percpu_lru = alloc_percpu(struct bpf_lru_list);\n\t\tif (!lru->percpu_lru)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_list *l;\n\n\t\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\t\t\tbpf_lru_list_init(l);\n\t\t}\n\t\tlru->nr_scans = PERCPU_NR_SCANS;\n\t} else {\n\t\tstruct bpf_common_lru *clru = &lru->common_lru;\n\n\t\tclru->local_list = alloc_percpu(struct bpf_lru_locallist);\n\t\tif (!clru->local_list)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\t\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\t\t\tbpf_lru_locallist_init(loc_l, cpu);\n\t\t}\n\n\t\tbpf_lru_list_init(&clru->lru_list);\n\t\tlru->nr_scans = LOCAL_NR_SCANS;\n\t}\n\n\tlru->percpu = percpu;\n\tlru->del_from_htab = del_from_htab;\n\tlru->del_arg = del_arg;\n\tlru->hash_offset = hash_offset;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [
      "#define PERCPU_NR_SCANS\t\t\tPERCPU_FREE_TARGET",
      "#define LOCAL_NR_SCANS\t\t\tLOCAL_FREE_TARGET"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_lru_list_init",
          "args": [
            "&clru->lru_list"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "631-644",
          "snippet": "static void bpf_lru_list_init(struct bpf_lru_list *l)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&l->lists[i]);\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_COUNT; i++)\n\t\tl->counts[i] = 0;\n\n\tl->next_inactive_rotation = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\n\traw_spin_lock_init(&l->lock);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_init(struct bpf_lru_list *l)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&l->lists[i]);\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_COUNT; i++)\n\t\tl->counts[i] = 0;\n\n\tl->next_inactive_rotation = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\n\traw_spin_lock_init(&l->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_locallist_init",
          "args": [
            "loc_l",
            "cpu"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_locallist_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "619-629",
          "snippet": "static void bpf_lru_locallist_init(struct bpf_lru_locallist *loc_l, int cpu)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LOCAL_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&loc_l->lists[i]);\n\n\tloc_l->next_steal = cpu;\n\n\traw_spin_lock_init(&loc_l->lock);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_locallist_init(struct bpf_lru_locallist *loc_l, int cpu)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LOCAL_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&loc_l->lists[i]);\n\n\tloc_l->next_steal = cpu;\n\n\traw_spin_lock_init(&loc_l->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "clru->local_list",
            "cpu"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structbpf_lru_locallist"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "lru->percpu_lru",
            "cpu"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define PERCPU_NR_SCANS\t\t\tPERCPU_FREE_TARGET\n#define LOCAL_NR_SCANS\t\t\tLOCAL_FREE_TARGET\n\nint bpf_lru_init(struct bpf_lru *lru, bool percpu, u32 hash_offset,\n\t\t del_from_htab_func del_from_htab, void *del_arg)\n{\n\tint cpu;\n\n\tif (percpu) {\n\t\tlru->percpu_lru = alloc_percpu(struct bpf_lru_list);\n\t\tif (!lru->percpu_lru)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_list *l;\n\n\t\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\t\t\tbpf_lru_list_init(l);\n\t\t}\n\t\tlru->nr_scans = PERCPU_NR_SCANS;\n\t} else {\n\t\tstruct bpf_common_lru *clru = &lru->common_lru;\n\n\t\tclru->local_list = alloc_percpu(struct bpf_lru_locallist);\n\t\tif (!clru->local_list)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\t\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\t\t\tbpf_lru_locallist_init(loc_l, cpu);\n\t\t}\n\n\t\tbpf_lru_list_init(&clru->lru_list);\n\t\tlru->nr_scans = LOCAL_NR_SCANS;\n\t}\n\n\tlru->percpu = percpu;\n\tlru->del_from_htab = del_from_htab;\n\tlru->del_arg = del_arg;\n\tlru->hash_offset = hash_offset;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_lru_list_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "631-644",
    "snippet": "static void bpf_lru_list_init(struct bpf_lru_list *l)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&l->lists[i]);\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_COUNT; i++)\n\t\tl->counts[i] = 0;\n\n\tl->next_inactive_rotation = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\n\traw_spin_lock_init(&l->lock);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&l->lock"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&l->lists[i]"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_init(struct bpf_lru_list *l)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&l->lists[i]);\n\n\tfor (i = 0; i < NR_BPF_LRU_LIST_COUNT; i++)\n\t\tl->counts[i] = 0;\n\n\tl->next_inactive_rotation = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\n\traw_spin_lock_init(&l->lock);\n}"
  },
  {
    "function_name": "bpf_lru_locallist_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "619-629",
    "snippet": "static void bpf_lru_locallist_init(struct bpf_lru_locallist *loc_l, int cpu)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LOCAL_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&loc_l->lists[i]);\n\n\tloc_l->next_steal = cpu;\n\n\traw_spin_lock_init(&loc_l->lock);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&loc_l->lock"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&loc_l->lists[i]"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_locallist_init(struct bpf_lru_locallist *loc_l, int cpu)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_BPF_LRU_LOCAL_LIST_T; i++)\n\t\tINIT_LIST_HEAD(&loc_l->lists[i]);\n\n\tloc_l->next_steal = cpu;\n\n\traw_spin_lock_init(&loc_l->lock);\n}"
  },
  {
    "function_name": "bpf_lru_populate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "608-617",
    "snippet": "void bpf_lru_populate(struct bpf_lru *lru, void *buf, u32 node_offset,\n\t\t      u32 elem_size, u32 nr_elems)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n\telse\n\t\tbpf_common_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_common_lru_populate",
          "args": [
            "lru",
            "buf",
            "node_offset",
            "elem_size",
            "nr_elems"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_common_lru_populate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "559-575",
          "snippet": "static void bpf_common_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tu32 i;\n\n\tfor (i = 0; i < nr_elems; i++) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\tbuf += elem_size;\n\t}\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_common_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tu32 i;\n\n\tfor (i = 0; i < nr_elems; i++) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\tbuf += elem_size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_lru_populate",
          "args": [
            "lru",
            "buf",
            "node_offset",
            "elem_size",
            "nr_elems"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_lru_populate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "577-606",
          "snippet": "static void bpf_percpu_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tu32 i, pcpu_entries;\n\tint cpu;\n\tstruct bpf_lru_list *l;\n\n\tpcpu_entries = nr_elems / num_possible_cpus();\n\n\ti = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\nagain:\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->cpu = cpu;\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_percpu_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tu32 i, pcpu_entries;\n\tint cpu;\n\tstruct bpf_lru_list *l;\n\n\tpcpu_entries = nr_elems / num_possible_cpus();\n\n\ti = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\nagain:\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->cpu = cpu;\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nvoid bpf_lru_populate(struct bpf_lru *lru, void *buf, u32 node_offset,\n\t\t      u32 elem_size, u32 nr_elems)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n\telse\n\t\tbpf_common_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n}"
  },
  {
    "function_name": "bpf_percpu_lru_populate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "577-606",
    "snippet": "static void bpf_percpu_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tu32 i, pcpu_entries;\n\tint cpu;\n\tstruct bpf_lru_list *l;\n\n\tpcpu_entries = nr_elems / num_possible_cpus();\n\n\ti = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\nagain:\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->cpu = cpu;\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&node->list",
            "&l->lists[BPF_LRU_LIST_T_FREE]"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "lru->percpu_lru",
            "cpu"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_percpu_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tu32 i, pcpu_entries;\n\tint cpu;\n\tstruct bpf_lru_list *l;\n\n\tpcpu_entries = nr_elems / num_possible_cpus();\n\n\ti = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\nagain:\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->cpu = cpu;\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n}"
  },
  {
    "function_name": "bpf_common_lru_populate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "559-575",
    "snippet": "static void bpf_common_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tu32 i;\n\n\tfor (i = 0; i < nr_elems; i++) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\tbuf += elem_size;\n\t}\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&node->list",
            "&l->lists[BPF_LRU_LIST_T_FREE]"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_common_lru_populate(struct bpf_lru *lru, void *buf,\n\t\t\t\t    u32 node_offset, u32 elem_size,\n\t\t\t\t    u32 nr_elems)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tu32 i;\n\n\tfor (i = 0; i < nr_elems; i++) {\n\t\tstruct bpf_lru_node *node;\n\n\t\tnode = (struct bpf_lru_node *)(buf + node_offset);\n\t\tnode->type = BPF_LRU_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_add(&node->list, &l->lists[BPF_LRU_LIST_T_FREE]);\n\t\tbuf += elem_size;\n\t}\n}"
  },
  {
    "function_name": "bpf_lru_push_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "551-557",
    "snippet": "void bpf_lru_push_free(struct bpf_lru *lru, struct bpf_lru_node *node)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_push_free(lru, node);\n\telse\n\t\tbpf_common_lru_push_free(lru, node);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_common_lru_push_free",
          "args": [
            "lru",
            "node"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_common_lru_push_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "502-534",
          "snippet": "static void bpf_common_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tu8 node_type = READ_ONCE(node->type);\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(node_type == BPF_LRU_LIST_T_FREE) ||\n\t    WARN_ON_ONCE(node_type == BPF_LRU_LOCAL_LIST_T_FREE))\n\t\treturn;\n\n\tif (node_type == BPF_LRU_LOCAL_LIST_T_PENDING) {\n\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\tloc_l = per_cpu_ptr(lru->common_lru.local_list, node->cpu);\n\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\t\tif (unlikely(node->type != BPF_LRU_LOCAL_LIST_T_PENDING)) {\n\t\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\t\tgoto check_lru_list;\n\t\t}\n\n\t\tnode->type = BPF_LRU_LOCAL_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_move(&node->list, local_free_list(loc_l));\n\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\treturn;\n\t}\n\ncheck_lru_list:\n\tbpf_lru_list_push_free(&lru->common_lru.lru_list, node);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_common_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tu8 node_type = READ_ONCE(node->type);\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(node_type == BPF_LRU_LIST_T_FREE) ||\n\t    WARN_ON_ONCE(node_type == BPF_LRU_LOCAL_LIST_T_FREE))\n\t\treturn;\n\n\tif (node_type == BPF_LRU_LOCAL_LIST_T_PENDING) {\n\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\tloc_l = per_cpu_ptr(lru->common_lru.local_list, node->cpu);\n\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\t\tif (unlikely(node->type != BPF_LRU_LOCAL_LIST_T_PENDING)) {\n\t\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\t\tgoto check_lru_list;\n\t\t}\n\n\t\tnode->type = BPF_LRU_LOCAL_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_move(&node->list, local_free_list(loc_l));\n\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\treturn;\n\t}\n\ncheck_lru_list:\n\tbpf_lru_list_push_free(&lru->common_lru.lru_list, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_lru_push_free",
          "args": [
            "lru",
            "node"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_lru_push_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "536-549",
          "snippet": "static void bpf_percpu_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\n\tl = per_cpu_ptr(lru->percpu_lru, node->cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_percpu_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\n\tl = per_cpu_ptr(lru->percpu_lru, node->cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nvoid bpf_lru_push_free(struct bpf_lru *lru, struct bpf_lru_node *node)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_push_free(lru, node);\n\telse\n\t\tbpf_common_lru_push_free(lru, node);\n}"
  },
  {
    "function_name": "bpf_percpu_lru_push_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "536-549",
    "snippet": "static void bpf_percpu_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\n\tl = per_cpu_ptr(lru->percpu_lru, node->cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_FREE"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "100-122",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "lru->percpu_lru",
            "node->cpu"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_percpu_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\n\tl = per_cpu_ptr(lru->percpu_lru, node->cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}"
  },
  {
    "function_name": "bpf_common_lru_push_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "502-534",
    "snippet": "static void bpf_common_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tu8 node_type = READ_ONCE(node->type);\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(node_type == BPF_LRU_LIST_T_FREE) ||\n\t    WARN_ON_ONCE(node_type == BPF_LRU_LOCAL_LIST_T_FREE))\n\t\treturn;\n\n\tif (node_type == BPF_LRU_LOCAL_LIST_T_PENDING) {\n\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\tloc_l = per_cpu_ptr(lru->common_lru.local_list, node->cpu);\n\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\t\tif (unlikely(node->type != BPF_LRU_LOCAL_LIST_T_PENDING)) {\n\t\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\t\tgoto check_lru_list;\n\t\t}\n\n\t\tnode->type = BPF_LRU_LOCAL_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_move(&node->list, local_free_list(loc_l));\n\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\treturn;\n\t}\n\ncheck_lru_list:\n\tbpf_lru_list_push_free(&lru->common_lru.lru_list, node);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_lru_list_push_free",
          "args": [
            "&lru->common_lru.lru_list",
            "node"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_push_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "305-316",
          "snippet": "static void bpf_lru_list_push_free(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_push_free(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&loc_l->lock",
            "flags"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&node->list",
            "local_free_list(loc_l)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_free_list",
          "args": [
            "loc_l"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "local_free_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "31-34",
          "snippet": "static struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)\n\nstatic struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "node->type != BPF_LRU_LOCAL_LIST_T_PENDING"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&loc_l->lock",
            "flags"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "lru->common_lru.local_list",
            "node->cpu"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "node_type == BPF_LRU_LOCAL_LIST_T_FREE"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "node_type == BPF_LRU_LIST_T_FREE"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "node->type"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_common_lru_push_free(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_node *node)\n{\n\tu8 node_type = READ_ONCE(node->type);\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(node_type == BPF_LRU_LIST_T_FREE) ||\n\t    WARN_ON_ONCE(node_type == BPF_LRU_LOCAL_LIST_T_FREE))\n\t\treturn;\n\n\tif (node_type == BPF_LRU_LOCAL_LIST_T_PENDING) {\n\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\tloc_l = per_cpu_ptr(lru->common_lru.local_list, node->cpu);\n\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\t\tif (unlikely(node->type != BPF_LRU_LOCAL_LIST_T_PENDING)) {\n\t\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\t\tgoto check_lru_list;\n\t\t}\n\n\t\tnode->type = BPF_LRU_LOCAL_LIST_T_FREE;\n\t\tnode->ref = 0;\n\t\tlist_move(&node->list, local_free_list(loc_l));\n\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t\treturn;\n\t}\n\ncheck_lru_list:\n\tbpf_lru_list_push_free(&lru->common_lru.lru_list, node);\n}"
  },
  {
    "function_name": "bpf_lru_pop_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "494-500",
    "snippet": "struct bpf_lru_node *bpf_lru_pop_free(struct bpf_lru *lru, u32 hash)\n{\n\tif (lru->percpu)\n\t\treturn bpf_percpu_lru_pop_free(lru, hash);\n\telse\n\t\treturn bpf_common_lru_pop_free(lru, hash);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_common_lru_pop_free",
          "args": [
            "lru",
            "hash"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_common_lru_pop_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "431-492",
          "snippet": "static struct bpf_lru_node *bpf_common_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct bpf_lru_locallist *loc_l, *steal_loc_l;\n\tstruct bpf_common_lru *clru = &lru->common_lru;\n\tstruct bpf_lru_node *node;\n\tint steal, first_steal;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\n\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\tnode = __local_list_pop_free(loc_l);\n\tif (!node) {\n\t\tbpf_lru_list_pop_free_to_local(lru, loc_l);\n\t\tnode = __local_list_pop_free(loc_l);\n\t}\n\n\tif (node)\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\n\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\n\tif (node)\n\t\treturn node;\n\n\t/* No free nodes found from the local free list and\n\t * the global LRU list.\n\t *\n\t * Steal from the local free/pending list of the\n\t * current CPU and remote CPU in RR.  It starts\n\t * with the loc_l->next_steal CPU.\n\t */\n\n\tfirst_steal = loc_l->next_steal;\n\tsteal = first_steal;\n\tdo {\n\t\tsteal_loc_l = per_cpu_ptr(clru->local_list, steal);\n\n\t\traw_spin_lock_irqsave(&steal_loc_l->lock, flags);\n\n\t\tnode = __local_list_pop_free(steal_loc_l);\n\t\tif (!node)\n\t\t\tnode = __local_list_pop_pending(lru, steal_loc_l);\n\n\t\traw_spin_unlock_irqrestore(&steal_loc_l->lock, flags);\n\n\t\tsteal = get_next_cpu(steal);\n\t} while (!node && steal != first_steal);\n\n\tloc_l->next_steal = steal;\n\n\tif (node) {\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t}\n\n\treturn node;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *bpf_common_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct bpf_lru_locallist *loc_l, *steal_loc_l;\n\tstruct bpf_common_lru *clru = &lru->common_lru;\n\tstruct bpf_lru_node *node;\n\tint steal, first_steal;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\n\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\tnode = __local_list_pop_free(loc_l);\n\tif (!node) {\n\t\tbpf_lru_list_pop_free_to_local(lru, loc_l);\n\t\tnode = __local_list_pop_free(loc_l);\n\t}\n\n\tif (node)\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\n\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\n\tif (node)\n\t\treturn node;\n\n\t/* No free nodes found from the local free list and\n\t * the global LRU list.\n\t *\n\t * Steal from the local free/pending list of the\n\t * current CPU and remote CPU in RR.  It starts\n\t * with the loc_l->next_steal CPU.\n\t */\n\n\tfirst_steal = loc_l->next_steal;\n\tsteal = first_steal;\n\tdo {\n\t\tsteal_loc_l = per_cpu_ptr(clru->local_list, steal);\n\n\t\traw_spin_lock_irqsave(&steal_loc_l->lock, flags);\n\n\t\tnode = __local_list_pop_free(steal_loc_l);\n\t\tif (!node)\n\t\t\tnode = __local_list_pop_pending(lru, steal_loc_l);\n\n\t\traw_spin_unlock_irqrestore(&steal_loc_l->lock, flags);\n\n\t\tsteal = get_next_cpu(steal);\n\t} while (!node && steal != first_steal);\n\n\tloc_l->next_steal = steal;\n\n\tif (node) {\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t}\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_lru_pop_free",
          "args": [
            "lru",
            "hash"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_lru_pop_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "399-429",
          "snippet": "static struct bpf_lru_node *bpf_percpu_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct list_head *free_list;\n\tstruct bpf_lru_node *node = NULL;\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tfree_list = &l->lists[BPF_LRU_LIST_T_FREE];\n\tif (list_empty(free_list))\n\t\t__bpf_lru_list_shrink(lru, l, PERCPU_FREE_TARGET, free_list,\n\t\t\t\t      BPF_LRU_LIST_T_FREE);\n\n\tif (!list_empty(free_list)) {\n\t\tnode = list_first_entry(free_list, struct bpf_lru_node, list);\n\t\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\t\tnode->ref = 0;\n\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\t}\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n\n\treturn node;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define PERCPU_FREE_TARGET\t\t(4)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define PERCPU_FREE_TARGET\t\t(4)\n\nstatic struct bpf_lru_node *bpf_percpu_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct list_head *free_list;\n\tstruct bpf_lru_node *node = NULL;\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tfree_list = &l->lists[BPF_LRU_LIST_T_FREE];\n\tif (list_empty(free_list))\n\t\t__bpf_lru_list_shrink(lru, l, PERCPU_FREE_TARGET, free_list,\n\t\t\t\t      BPF_LRU_LIST_T_FREE);\n\n\tif (!list_empty(free_list)) {\n\t\tnode = list_first_entry(free_list, struct bpf_lru_node, list);\n\t\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\t\tnode->ref = 0;\n\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\t}\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n\n\treturn node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstruct bpf_lru_node *bpf_lru_pop_free(struct bpf_lru *lru, u32 hash)\n{\n\tif (lru->percpu)\n\t\treturn bpf_percpu_lru_pop_free(lru, hash);\n\telse\n\t\treturn bpf_common_lru_pop_free(lru, hash);\n}"
  },
  {
    "function_name": "bpf_common_lru_pop_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "431-492",
    "snippet": "static struct bpf_lru_node *bpf_common_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct bpf_lru_locallist *loc_l, *steal_loc_l;\n\tstruct bpf_common_lru *clru = &lru->common_lru;\n\tstruct bpf_lru_node *node;\n\tint steal, first_steal;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\n\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\tnode = __local_list_pop_free(loc_l);\n\tif (!node) {\n\t\tbpf_lru_list_pop_free_to_local(lru, loc_l);\n\t\tnode = __local_list_pop_free(loc_l);\n\t}\n\n\tif (node)\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\n\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\n\tif (node)\n\t\treturn node;\n\n\t/* No free nodes found from the local free list and\n\t * the global LRU list.\n\t *\n\t * Steal from the local free/pending list of the\n\t * current CPU and remote CPU in RR.  It starts\n\t * with the loc_l->next_steal CPU.\n\t */\n\n\tfirst_steal = loc_l->next_steal;\n\tsteal = first_steal;\n\tdo {\n\t\tsteal_loc_l = per_cpu_ptr(clru->local_list, steal);\n\n\t\traw_spin_lock_irqsave(&steal_loc_l->lock, flags);\n\n\t\tnode = __local_list_pop_free(steal_loc_l);\n\t\tif (!node)\n\t\t\tnode = __local_list_pop_pending(lru, steal_loc_l);\n\n\t\traw_spin_unlock_irqrestore(&steal_loc_l->lock, flags);\n\n\t\tsteal = get_next_cpu(steal);\n\t} while (!node && steal != first_steal);\n\n\tloc_l->next_steal = steal;\n\n\tif (node) {\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t}\n\n\treturn node;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&loc_l->lock",
            "flags"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__local_list_add_pending",
          "args": [
            "lru",
            "loc_l",
            "cpu",
            "node",
            "hash"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "__local_list_add_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "347-358",
          "snippet": "static void __local_list_add_pending(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_locallist *loc_l,\n\t\t\t\t     int cpu,\n\t\t\t\t     struct bpf_lru_node *node,\n\t\t\t\t     u32 hash)\n{\n\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\tnode->cpu = cpu;\n\tnode->type = BPF_LRU_LOCAL_LIST_T_PENDING;\n\tnode->ref = 0;\n\tlist_add(&node->list, local_pending_list(loc_l));\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __local_list_add_pending(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_locallist *loc_l,\n\t\t\t\t     int cpu,\n\t\t\t\t     struct bpf_lru_node *node,\n\t\t\t\t     u32 hash)\n{\n\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\tnode->cpu = cpu;\n\tnode->type = BPF_LRU_LOCAL_LIST_T_PENDING;\n\tnode->ref = 0;\n\tlist_add(&node->list, local_pending_list(loc_l));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&loc_l->lock",
            "flags"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_cpu",
          "args": [
            "steal"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "22-28",
          "snippet": "static int get_next_cpu(int cpu)\n{\n\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\tif (cpu >= nr_cpu_ids)\n\t\tcpu = cpumask_first(cpu_possible_mask);\n\treturn cpu;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic int get_next_cpu(int cpu)\n{\n\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\tif (cpu >= nr_cpu_ids)\n\t\tcpu = cpumask_first(cpu_possible_mask);\n\treturn cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__local_list_pop_pending",
          "args": [
            "lru",
            "steal_loc_l"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__local_list_pop_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "374-397",
          "snippet": "static struct bpf_lru_node *\n__local_list_pop_pending(struct bpf_lru *lru, struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\tbool force = false;\n\nignore_ref:\n\t/* Get from the tail (i.e. older element) of the pending list. */\n\tlist_for_each_entry_reverse(node, local_pending_list(loc_l),\n\t\t\t\t    list) {\n\t\tif ((!bpf_lru_node_is_ref(node) || force) &&\n\t\t    lru->del_from_htab(lru->del_arg, node)) {\n\t\t\tlist_del(&node->list);\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tif (!force) {\n\t\tforce = true;\n\t\tgoto ignore_ref;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *\n__local_list_pop_pending(struct bpf_lru *lru, struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\tbool force = false;\n\nignore_ref:\n\t/* Get from the tail (i.e. older element) of the pending list. */\n\tlist_for_each_entry_reverse(node, local_pending_list(loc_l),\n\t\t\t\t    list) {\n\t\tif ((!bpf_lru_node_is_ref(node) || force) &&\n\t\t    lru->del_from_htab(lru->del_arg, node)) {\n\t\t\tlist_del(&node->list);\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tif (!force) {\n\t\tforce = true;\n\t\tgoto ignore_ref;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__local_list_pop_free",
          "args": [
            "steal_loc_l"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "__local_list_pop_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "360-372",
          "snippet": "static struct bpf_lru_node *\n__local_list_pop_free(struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\n\tnode = list_first_entry_or_null(local_free_list(loc_l),\n\t\t\t\t\tstruct bpf_lru_node,\n\t\t\t\t\tlist);\n\tif (node)\n\t\tlist_del(&node->list);\n\n\treturn node;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *\n__local_list_pop_free(struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\n\tnode = list_first_entry_or_null(local_free_list(loc_l),\n\t\t\t\t\tstruct bpf_lru_node,\n\t\t\t\t\tlist);\n\tif (node)\n\t\tlist_del(&node->list);\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "clru->local_list",
            "steal"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_pop_free_to_local",
          "args": [
            "lru",
            "loc_l"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_pop_free_to_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "318-345",
          "snippet": "static void bpf_lru_list_pop_free_to_local(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nfree = 0;\n\n\traw_spin_lock(&l->lock);\n\n\t__local_list_flush(l, loc_l);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tlist_for_each_entry_safe(node, tmp_node, &l->lists[BPF_LRU_LIST_T_FREE],\n\t\t\t\t list) {\n\t\t__bpf_lru_node_move_to_free(l, node, local_free_list(loc_l),\n\t\t\t\t\t    BPF_LRU_LOCAL_LIST_T_FREE);\n\t\tif (++nfree == LOCAL_FREE_TARGET)\n\t\t\tbreak;\n\t}\n\n\tif (nfree < LOCAL_FREE_TARGET)\n\t\t__bpf_lru_list_shrink(lru, l, LOCAL_FREE_TARGET - nfree,\n\t\t\t\t      local_free_list(loc_l),\n\t\t\t\t      BPF_LRU_LOCAL_LIST_T_FREE);\n\n\traw_spin_unlock(&l->lock);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_FREE_TARGET\t\t(128)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_TARGET\t\t(128)\n\nstatic void bpf_lru_list_pop_free_to_local(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nfree = 0;\n\n\traw_spin_lock(&l->lock);\n\n\t__local_list_flush(l, loc_l);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tlist_for_each_entry_safe(node, tmp_node, &l->lists[BPF_LRU_LIST_T_FREE],\n\t\t\t\t list) {\n\t\t__bpf_lru_node_move_to_free(l, node, local_free_list(loc_l),\n\t\t\t\t\t    BPF_LRU_LOCAL_LIST_T_FREE);\n\t\tif (++nfree == LOCAL_FREE_TARGET)\n\t\t\tbreak;\n\t}\n\n\tif (nfree < LOCAL_FREE_TARGET)\n\t\t__bpf_lru_list_shrink(lru, l, LOCAL_FREE_TARGET - nfree,\n\t\t\t\t      local_free_list(loc_l),\n\t\t\t\t      BPF_LRU_LOCAL_LIST_T_FREE);\n\n\traw_spin_unlock(&l->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "clru->local_list",
            "cpu"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *bpf_common_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct bpf_lru_locallist *loc_l, *steal_loc_l;\n\tstruct bpf_common_lru *clru = &lru->common_lru;\n\tstruct bpf_lru_node *node;\n\tint steal, first_steal;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\n\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\n\tnode = __local_list_pop_free(loc_l);\n\tif (!node) {\n\t\tbpf_lru_list_pop_free_to_local(lru, loc_l);\n\t\tnode = __local_list_pop_free(loc_l);\n\t}\n\n\tif (node)\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\n\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\n\tif (node)\n\t\treturn node;\n\n\t/* No free nodes found from the local free list and\n\t * the global LRU list.\n\t *\n\t * Steal from the local free/pending list of the\n\t * current CPU and remote CPU in RR.  It starts\n\t * with the loc_l->next_steal CPU.\n\t */\n\n\tfirst_steal = loc_l->next_steal;\n\tsteal = first_steal;\n\tdo {\n\t\tsteal_loc_l = per_cpu_ptr(clru->local_list, steal);\n\n\t\traw_spin_lock_irqsave(&steal_loc_l->lock, flags);\n\n\t\tnode = __local_list_pop_free(steal_loc_l);\n\t\tif (!node)\n\t\t\tnode = __local_list_pop_pending(lru, steal_loc_l);\n\n\t\traw_spin_unlock_irqrestore(&steal_loc_l->lock, flags);\n\n\t\tsteal = get_next_cpu(steal);\n\t} while (!node && steal != first_steal);\n\n\tloc_l->next_steal = steal;\n\n\tif (node) {\n\t\traw_spin_lock_irqsave(&loc_l->lock, flags);\n\t\t__local_list_add_pending(lru, loc_l, cpu, node, hash);\n\t\traw_spin_unlock_irqrestore(&loc_l->lock, flags);\n\t}\n\n\treturn node;\n}"
  },
  {
    "function_name": "bpf_percpu_lru_pop_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "399-429",
    "snippet": "static struct bpf_lru_node *bpf_percpu_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct list_head *free_list;\n\tstruct bpf_lru_node *node = NULL;\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tfree_list = &l->lists[BPF_LRU_LIST_T_FREE];\n\tif (list_empty(free_list))\n\t\t__bpf_lru_list_shrink(lru, l, PERCPU_FREE_TARGET, free_list,\n\t\t\t\t      BPF_LRU_LIST_T_FREE);\n\n\tif (!list_empty(free_list)) {\n\t\tnode = list_first_entry(free_list, struct bpf_lru_node, list);\n\t\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\t\tnode->ref = 0;\n\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\t}\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n\n\treturn node;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [
      "#define PERCPU_FREE_TARGET\t\t(4)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_INACTIVE"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "100-122",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "free_list",
            "structbpf_lru_node",
            "list"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "free_list"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_shrink",
          "args": [
            "lru",
            "l",
            "PERCPU_FREE_TARGET",
            "free_list",
            "BPF_LRU_LIST_T_FREE"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_shrink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "255-287",
          "snippet": "static unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_rotate",
          "args": [
            "lru",
            "l"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_rotate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "237-243",
          "snippet": "static void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "lru->percpu_lru",
            "cpu"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define PERCPU_FREE_TARGET\t\t(4)\n\nstatic struct bpf_lru_node *bpf_percpu_lru_pop_free(struct bpf_lru *lru,\n\t\t\t\t\t\t    u32 hash)\n{\n\tstruct list_head *free_list;\n\tstruct bpf_lru_node *node = NULL;\n\tstruct bpf_lru_list *l;\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\n\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tfree_list = &l->lists[BPF_LRU_LIST_T_FREE];\n\tif (list_empty(free_list))\n\t\t__bpf_lru_list_shrink(lru, l, PERCPU_FREE_TARGET, free_list,\n\t\t\t\t      BPF_LRU_LIST_T_FREE);\n\n\tif (!list_empty(free_list)) {\n\t\tnode = list_first_entry(free_list, struct bpf_lru_node, list);\n\t\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\t\tnode->ref = 0;\n\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\t}\n\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n\n\treturn node;\n}"
  },
  {
    "function_name": "__local_list_pop_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "374-397",
    "snippet": "static struct bpf_lru_node *\n__local_list_pop_pending(struct bpf_lru *lru, struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\tbool force = false;\n\nignore_ref:\n\t/* Get from the tail (i.e. older element) of the pending list. */\n\tlist_for_each_entry_reverse(node, local_pending_list(loc_l),\n\t\t\t\t    list) {\n\t\tif ((!bpf_lru_node_is_ref(node) || force) &&\n\t\t    lru->del_from_htab(lru->del_arg, node)) {\n\t\t\tlist_del(&node->list);\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tif (!force) {\n\t\tforce = true;\n\t\tgoto ignore_ref;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&node->list"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru->del_from_htab",
          "args": [
            "lru->del_arg",
            "node"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_is_ref",
          "args": [
            "node"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_is_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "42-45",
          "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "node",
            "local_pending_list(loc_l)",
            "list"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_pending_list",
          "args": [
            "loc_l"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "local_pending_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "36-39",
          "snippet": "static struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)\n\nstatic struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *\n__local_list_pop_pending(struct bpf_lru *lru, struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\tbool force = false;\n\nignore_ref:\n\t/* Get from the tail (i.e. older element) of the pending list. */\n\tlist_for_each_entry_reverse(node, local_pending_list(loc_l),\n\t\t\t\t    list) {\n\t\tif ((!bpf_lru_node_is_ref(node) || force) &&\n\t\t    lru->del_from_htab(lru->del_arg, node)) {\n\t\t\tlist_del(&node->list);\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tif (!force) {\n\t\tforce = true;\n\t\tgoto ignore_ref;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "__local_list_pop_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "360-372",
    "snippet": "static struct bpf_lru_node *\n__local_list_pop_free(struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\n\tnode = list_first_entry_or_null(local_free_list(loc_l),\n\t\t\t\t\tstruct bpf_lru_node,\n\t\t\t\t\tlist);\n\tif (node)\n\t\tlist_del(&node->list);\n\n\treturn node;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&node->list"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "local_free_list(loc_l)",
            "structbpf_lru_node",
            "list"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_free_list",
          "args": [
            "loc_l"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "local_free_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "31-34",
          "snippet": "static struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)\n\nstatic struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic struct bpf_lru_node *\n__local_list_pop_free(struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node;\n\n\tnode = list_first_entry_or_null(local_free_list(loc_l),\n\t\t\t\t\tstruct bpf_lru_node,\n\t\t\t\t\tlist);\n\tif (node)\n\t\tlist_del(&node->list);\n\n\treturn node;\n}"
  },
  {
    "function_name": "__local_list_add_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "347-358",
    "snippet": "static void __local_list_add_pending(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_locallist *loc_l,\n\t\t\t\t     int cpu,\n\t\t\t\t     struct bpf_lru_node *node,\n\t\t\t\t     u32 hash)\n{\n\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\tnode->cpu = cpu;\n\tnode->type = BPF_LRU_LOCAL_LIST_T_PENDING;\n\tnode->ref = 0;\n\tlist_add(&node->list, local_pending_list(loc_l));\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&node->list",
            "local_pending_list(loc_l)"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_pending_list",
          "args": [
            "loc_l"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "local_pending_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "36-39",
          "snippet": "static struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)\n\nstatic struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __local_list_add_pending(struct bpf_lru *lru,\n\t\t\t\t     struct bpf_lru_locallist *loc_l,\n\t\t\t\t     int cpu,\n\t\t\t\t     struct bpf_lru_node *node,\n\t\t\t\t     u32 hash)\n{\n\t*(u32 *)((void *)node + lru->hash_offset) = hash;\n\tnode->cpu = cpu;\n\tnode->type = BPF_LRU_LOCAL_LIST_T_PENDING;\n\tnode->ref = 0;\n\tlist_add(&node->list, local_pending_list(loc_l));\n}"
  },
  {
    "function_name": "bpf_lru_list_pop_free_to_local",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "318-345",
    "snippet": "static void bpf_lru_list_pop_free_to_local(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nfree = 0;\n\n\traw_spin_lock(&l->lock);\n\n\t__local_list_flush(l, loc_l);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tlist_for_each_entry_safe(node, tmp_node, &l->lists[BPF_LRU_LIST_T_FREE],\n\t\t\t\t list) {\n\t\t__bpf_lru_node_move_to_free(l, node, local_free_list(loc_l),\n\t\t\t\t\t    BPF_LRU_LOCAL_LIST_T_FREE);\n\t\tif (++nfree == LOCAL_FREE_TARGET)\n\t\t\tbreak;\n\t}\n\n\tif (nfree < LOCAL_FREE_TARGET)\n\t\t__bpf_lru_list_shrink(lru, l, LOCAL_FREE_TARGET - nfree,\n\t\t\t\t      local_free_list(loc_l),\n\t\t\t\t      BPF_LRU_LOCAL_LIST_T_FREE);\n\n\traw_spin_unlock(&l->lock);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [
      "#define LOCAL_FREE_TARGET\t\t(128)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&l->lock"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_shrink",
          "args": [
            "lru",
            "l",
            "LOCAL_FREE_TARGET - nfree",
            "local_free_list(loc_l)",
            "BPF_LRU_LOCAL_LIST_T_FREE"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_shrink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "255-287",
          "snippet": "static unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_free_list",
          "args": [
            "loc_l"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "local_free_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "31-34",
          "snippet": "static struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)\n\nstatic struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_node_move_to_free",
          "args": [
            "l",
            "node",
            "local_free_list(loc_l)",
            "BPF_LRU_LOCAL_LIST_T_FREE"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move_to_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "61-79",
          "snippet": "static void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "node",
            "tmp_node",
            "&l->lists[BPF_LRU_LIST_T_FREE]",
            "list"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_rotate",
          "args": [
            "lru",
            "l"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_rotate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "237-243",
          "snippet": "static void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__local_list_flush",
          "args": [
            "l",
            "loc_l"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "__local_list_flush",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "290-303",
          "snippet": "static void __local_list_flush(struct bpf_lru_list *l,\n\t\t\t       struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node,\n\t\t\t\t\t local_pending_list(loc_l), list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move_in(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move_in(l, node,\n\t\t\t\t\t       BPF_LRU_LIST_T_INACTIVE);\n\t}\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __local_list_flush(struct bpf_lru_list *l,\n\t\t\t       struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node,\n\t\t\t\t\t local_pending_list(loc_l), list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move_in(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move_in(l, node,\n\t\t\t\t\t       BPF_LRU_LIST_T_INACTIVE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&l->lock"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_TARGET\t\t(128)\n\nstatic void bpf_lru_list_pop_free_to_local(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_list *l = &lru->common_lru.lru_list;\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nfree = 0;\n\n\traw_spin_lock(&l->lock);\n\n\t__local_list_flush(l, loc_l);\n\n\t__bpf_lru_list_rotate(lru, l);\n\n\tlist_for_each_entry_safe(node, tmp_node, &l->lists[BPF_LRU_LIST_T_FREE],\n\t\t\t\t list) {\n\t\t__bpf_lru_node_move_to_free(l, node, local_free_list(loc_l),\n\t\t\t\t\t    BPF_LRU_LOCAL_LIST_T_FREE);\n\t\tif (++nfree == LOCAL_FREE_TARGET)\n\t\t\tbreak;\n\t}\n\n\tif (nfree < LOCAL_FREE_TARGET)\n\t\t__bpf_lru_list_shrink(lru, l, LOCAL_FREE_TARGET - nfree,\n\t\t\t\t      local_free_list(loc_l),\n\t\t\t\t      BPF_LRU_LOCAL_LIST_T_FREE);\n\n\traw_spin_unlock(&l->lock);\n}"
  },
  {
    "function_name": "bpf_lru_list_push_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "305-316",
    "snippet": "static void bpf_lru_list_push_free(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_FREE"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "100-122",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&l->lock",
            "flags"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_LOCAL_LIST_TYPE(node->type)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "node->type"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_push_free(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&l->lock, flags);\n\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_FREE);\n\traw_spin_unlock_irqrestore(&l->lock, flags);\n}"
  },
  {
    "function_name": "__local_list_flush",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "290-303",
    "snippet": "static void __local_list_flush(struct bpf_lru_list *l,\n\t\t\t       struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node,\n\t\t\t\t\t local_pending_list(loc_l), list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move_in(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move_in(l, node,\n\t\t\t\t\t       BPF_LRU_LIST_T_INACTIVE);\n\t}\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_node_move_in",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_INACTIVE"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move_in",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "82-94",
          "snippet": "static void __bpf_lru_node_move_in(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node,\n\t\t\t\t   enum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(!IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tbpf_lru_list_count_inc(l, tgt_type);\n\tnode->type = tgt_type;\n\tnode->ref = 0;\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_in(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node,\n\t\t\t\t   enum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(!IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tbpf_lru_list_count_inc(l, tgt_type);\n\tnode->type = tgt_type;\n\tnode->ref = 0;\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_is_ref",
          "args": [
            "node"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_is_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "42-45",
          "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "node",
            "tmp_node",
            "local_pending_list(loc_l)",
            "list"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_pending_list",
          "args": [
            "loc_l"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "local_pending_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "36-39",
          "snippet": "static struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)\n\nstatic struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __local_list_flush(struct bpf_lru_list *l,\n\t\t\t       struct bpf_lru_locallist *loc_l)\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node,\n\t\t\t\t\t local_pending_list(loc_l), list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move_in(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move_in(l, node,\n\t\t\t\t\t       BPF_LRU_LIST_T_INACTIVE);\n\t}\n}"
  },
  {
    "function_name": "__bpf_lru_list_shrink",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "255-287",
    "snippet": "static unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_node_move_to_free",
          "args": [
            "l",
            "node",
            "free_list",
            "tgt_free_type"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move_to_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "61-79",
          "snippet": "static void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru->del_from_htab",
          "args": [
            "lru->del_arg",
            "node"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "node",
            "tmp_node",
            "force_shrink_list",
            "list"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&l->lists[BPF_LRU_LIST_T_INACTIVE]"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_shrink_inactive",
          "args": [
            "lru",
            "l",
            "tgt_nshrink",
            "free_list",
            "tgt_free_type"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_shrink_inactive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "205-232",
          "snippet": "static unsigned int\n__bpf_lru_list_shrink_inactive(struct bpf_lru *lru,\n\t\t\t       struct bpf_lru_list *l,\n\t\t\t       unsigned int tgt_nshrink,\n\t\t\t       struct list_head *free_list,\n\t\t\t       enum bpf_lru_list_type tgt_free_type)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nshrinked = 0;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, inactive, list) {\n\t\tif (bpf_lru_node_is_ref(node)) {\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\t} else if (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\tif (++nshrinked == tgt_nshrink)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++i == lru->nr_scans)\n\t\t\tbreak;\n\t}\n\n\treturn nshrinked;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic unsigned int\n__bpf_lru_list_shrink_inactive(struct bpf_lru *lru,\n\t\t\t       struct bpf_lru_list *l,\n\t\t\t       unsigned int tgt_nshrink,\n\t\t\t       struct list_head *free_list,\n\t\t\t       enum bpf_lru_list_type tgt_free_type)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nshrinked = 0;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, inactive, list) {\n\t\tif (bpf_lru_node_is_ref(node)) {\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\t} else if (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\tif (++nshrinked == tgt_nshrink)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++i == lru->nr_scans)\n\t\t\tbreak;\n\t}\n\n\treturn nshrinked;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic unsigned int __bpf_lru_list_shrink(struct bpf_lru *lru,\n\t\t\t\t\t  struct bpf_lru_list *l,\n\t\t\t\t\t  unsigned int tgt_nshrink,\n\t\t\t\t\t  struct list_head *free_list,\n\t\t\t\t\t  enum bpf_lru_list_type tgt_free_type)\n\n{\n\tstruct bpf_lru_node *node, *tmp_node;\n\tstruct list_head *force_shrink_list;\n\tunsigned int nshrinked;\n\n\tnshrinked = __bpf_lru_list_shrink_inactive(lru, l, tgt_nshrink,\n\t\t\t\t\t\t   free_list, tgt_free_type);\n\tif (nshrinked)\n\t\treturn nshrinked;\n\n\t/* Do a force shrink by ignoring the reference bit */\n\tif (!list_empty(&l->lists[BPF_LRU_LIST_T_INACTIVE]))\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\telse\n\t\tforce_shrink_list = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, force_shrink_list,\n\t\t\t\t\t list) {\n\t\tif (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__bpf_lru_list_rotate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "237-243",
    "snippet": "static void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_list_rotate_inactive",
          "args": [
            "lru",
            "l"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_rotate_inactive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "166-199",
          "snippet": "static void __bpf_lru_list_rotate_inactive(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_list *l)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct list_head *cur, *last, *next = inactive;\n\tstruct bpf_lru_node *node;\n\tunsigned int i = 0;\n\n\tif (list_empty(inactive))\n\t\treturn;\n\n\tlast = l->next_inactive_rotation->next;\n\tif (last == inactive)\n\t\tlast = last->next;\n\n\tcur = l->next_inactive_rotation;\n\twhile (i < lru->nr_scans) {\n\t\tif (cur == inactive) {\n\t\t\tcur = cur->prev;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnode = list_entry(cur, struct bpf_lru_node, list);\n\t\tnext = cur->prev;\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\tif (cur == last)\n\t\t\tbreak;\n\t\tcur = next;\n\t\ti++;\n\t}\n\n\tl->next_inactive_rotation = next;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate_inactive(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_list *l)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct list_head *cur, *last, *next = inactive;\n\tstruct bpf_lru_node *node;\n\tunsigned int i = 0;\n\n\tif (list_empty(inactive))\n\t\treturn;\n\n\tlast = l->next_inactive_rotation->next;\n\tif (last == inactive)\n\t\tlast = last->next;\n\n\tcur = l->next_inactive_rotation;\n\twhile (i < lru->nr_scans) {\n\t\tif (cur == inactive) {\n\t\t\tcur = cur->prev;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnode = list_entry(cur, struct bpf_lru_node, list);\n\t\tnext = cur->prev;\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\tif (cur == last)\n\t\t\tbreak;\n\t\tcur = next;\n\t\ti++;\n\t}\n\n\tl->next_inactive_rotation = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_lru_list_rotate_active",
          "args": [
            "lru",
            "l"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_list_rotate_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "139-156",
          "snippet": "static void __bpf_lru_list_rotate_active(struct bpf_lru *lru,\n\t\t\t\t\t struct bpf_lru_list *l)\n{\n\tstruct list_head *active = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node, *first_node;\n\tunsigned int i = 0;\n\n\tfirst_node = list_first_entry(active, struct bpf_lru_node, list);\n\tlist_for_each_entry_safe_reverse(node, tmp_node, active, list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\n\t\tif (++i == lru->nr_scans || node == first_node)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate_active(struct bpf_lru *lru,\n\t\t\t\t\t struct bpf_lru_list *l)\n{\n\tstruct list_head *active = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node, *first_node;\n\tunsigned int i = 0;\n\n\tfirst_node = list_first_entry(active, struct bpf_lru_node, list);\n\tlist_for_each_entry_safe_reverse(node, tmp_node, active, list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\n\t\tif (++i == lru->nr_scans || node == first_node)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_inactive_low",
          "args": [
            "l"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_inactive_low",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "124-128",
          "snippet": "static bool bpf_lru_list_inactive_low(const struct bpf_lru_list *l)\n{\n\treturn l->counts[BPF_LRU_LIST_T_INACTIVE] <\n\t\tl->counts[BPF_LRU_LIST_T_ACTIVE];\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_list_inactive_low(const struct bpf_lru_list *l)\n{\n\treturn l->counts[BPF_LRU_LIST_T_INACTIVE] <\n\t\tl->counts[BPF_LRU_LIST_T_ACTIVE];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate(struct bpf_lru *lru, struct bpf_lru_list *l)\n{\n\tif (bpf_lru_list_inactive_low(l))\n\t\t__bpf_lru_list_rotate_active(lru, l);\n\n\t__bpf_lru_list_rotate_inactive(lru, l);\n}"
  },
  {
    "function_name": "__bpf_lru_list_shrink_inactive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "205-232",
    "snippet": "static unsigned int\n__bpf_lru_list_shrink_inactive(struct bpf_lru *lru,\n\t\t\t       struct bpf_lru_list *l,\n\t\t\t       unsigned int tgt_nshrink,\n\t\t\t       struct list_head *free_list,\n\t\t\t       enum bpf_lru_list_type tgt_free_type)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nshrinked = 0;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, inactive, list) {\n\t\tif (bpf_lru_node_is_ref(node)) {\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\t} else if (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\tif (++nshrinked == tgt_nshrink)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++i == lru->nr_scans)\n\t\t\tbreak;\n\t}\n\n\treturn nshrinked;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_node_move_to_free",
          "args": [
            "l",
            "node",
            "free_list",
            "tgt_free_type"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move_to_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "61-79",
          "snippet": "static void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru->del_from_htab",
          "args": [
            "lru->del_arg",
            "node"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_ACTIVE"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "100-122",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_is_ref",
          "args": [
            "node"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_is_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "42-45",
          "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "node",
            "tmp_node",
            "inactive",
            "list"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic unsigned int\n__bpf_lru_list_shrink_inactive(struct bpf_lru *lru,\n\t\t\t       struct bpf_lru_list *l,\n\t\t\t       unsigned int tgt_nshrink,\n\t\t\t       struct list_head *free_list,\n\t\t\t       enum bpf_lru_list_type tgt_free_type)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node;\n\tunsigned int nshrinked = 0;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry_safe_reverse(node, tmp_node, inactive, list) {\n\t\tif (bpf_lru_node_is_ref(node)) {\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\t} else if (lru->del_from_htab(lru->del_arg, node)) {\n\t\t\t__bpf_lru_node_move_to_free(l, node, free_list,\n\t\t\t\t\t\t    tgt_free_type);\n\t\t\tif (++nshrinked == tgt_nshrink)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++i == lru->nr_scans)\n\t\t\tbreak;\n\t}\n\n\treturn nshrinked;\n}"
  },
  {
    "function_name": "__bpf_lru_list_rotate_inactive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "166-199",
    "snippet": "static void __bpf_lru_list_rotate_inactive(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_list *l)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct list_head *cur, *last, *next = inactive;\n\tstruct bpf_lru_node *node;\n\tunsigned int i = 0;\n\n\tif (list_empty(inactive))\n\t\treturn;\n\n\tlast = l->next_inactive_rotation->next;\n\tif (last == inactive)\n\t\tlast = last->next;\n\n\tcur = l->next_inactive_rotation;\n\twhile (i < lru->nr_scans) {\n\t\tif (cur == inactive) {\n\t\t\tcur = cur->prev;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnode = list_entry(cur, struct bpf_lru_node, list);\n\t\tnext = cur->prev;\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\tif (cur == last)\n\t\t\tbreak;\n\t\tcur = next;\n\t\ti++;\n\t}\n\n\tl->next_inactive_rotation = next;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_ACTIVE"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "100-122",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_is_ref",
          "args": [
            "node"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_is_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "42-45",
          "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cur",
            "structbpf_lru_node",
            "list"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "inactive"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate_inactive(struct bpf_lru *lru,\n\t\t\t\t\t   struct bpf_lru_list *l)\n{\n\tstruct list_head *inactive = &l->lists[BPF_LRU_LIST_T_INACTIVE];\n\tstruct list_head *cur, *last, *next = inactive;\n\tstruct bpf_lru_node *node;\n\tunsigned int i = 0;\n\n\tif (list_empty(inactive))\n\t\treturn;\n\n\tlast = l->next_inactive_rotation->next;\n\tif (last == inactive)\n\t\tlast = last->next;\n\n\tcur = l->next_inactive_rotation;\n\twhile (i < lru->nr_scans) {\n\t\tif (cur == inactive) {\n\t\t\tcur = cur->prev;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnode = list_entry(cur, struct bpf_lru_node, list);\n\t\tnext = cur->prev;\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\tif (cur == last)\n\t\t\tbreak;\n\t\tcur = next;\n\t\ti++;\n\t}\n\n\tl->next_inactive_rotation = next;\n}"
  },
  {
    "function_name": "__bpf_lru_list_rotate_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "139-156",
    "snippet": "static void __bpf_lru_list_rotate_active(struct bpf_lru *lru,\n\t\t\t\t\t struct bpf_lru_list *l)\n{\n\tstruct list_head *active = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node, *first_node;\n\tunsigned int i = 0;\n\n\tfirst_node = list_first_entry(active, struct bpf_lru_node, list);\n\tlist_for_each_entry_safe_reverse(node, tmp_node, active, list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\n\t\tif (++i == lru->nr_scans || node == first_node)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_lru_node_move",
          "args": [
            "l",
            "node",
            "BPF_LRU_LIST_T_INACTIVE"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_lru_node_move",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "100-122",
          "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_is_ref",
          "args": [
            "node"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_is_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "42-45",
          "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "node",
            "tmp_node",
            "active",
            "list"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "active",
            "structbpf_lru_node",
            "list"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_list_rotate_active(struct bpf_lru *lru,\n\t\t\t\t\t struct bpf_lru_list *l)\n{\n\tstruct list_head *active = &l->lists[BPF_LRU_LIST_T_ACTIVE];\n\tstruct bpf_lru_node *node, *tmp_node, *first_node;\n\tunsigned int i = 0;\n\n\tfirst_node = list_first_entry(active, struct bpf_lru_node, list);\n\tlist_for_each_entry_safe_reverse(node, tmp_node, active, list) {\n\t\tif (bpf_lru_node_is_ref(node))\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_ACTIVE);\n\t\telse\n\t\t\t__bpf_lru_node_move(l, node, BPF_LRU_LIST_T_INACTIVE);\n\n\t\tif (++i == lru->nr_scans || node == first_node)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "bpf_lru_list_inactive_low",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "124-128",
    "snippet": "static bool bpf_lru_list_inactive_low(const struct bpf_lru_list *l)\n{\n\treturn l->counts[BPF_LRU_LIST_T_INACTIVE] <\n\t\tl->counts[BPF_LRU_LIST_T_ACTIVE];\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_list_inactive_low(const struct bpf_lru_list *l)\n{\n\treturn l->counts[BPF_LRU_LIST_T_INACTIVE] <\n\t\tl->counts[BPF_LRU_LIST_T_ACTIVE];\n}"
  },
  {
    "function_name": "__bpf_lru_node_move",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "100-122",
    "snippet": "static void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&node->list",
            "&l->lists[tgt_type]"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_count_inc",
          "args": [
            "l",
            "tgt_type"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_count_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "47-52",
          "snippet": "static void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_count_dec",
          "args": [
            "l",
            "node->type"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_count_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "54-59",
          "snippet": "static void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_LOCAL_LIST_TYPE(tgt_type)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "tgt_type"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_LOCAL_LIST_TYPE(node->type)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "node->type"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move(struct bpf_lru_list *l,\n\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\tenum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tif (node->type != tgt_type) {\n\t\tbpf_lru_list_count_dec(l, node->type);\n\t\tbpf_lru_list_count_inc(l, tgt_type);\n\t\tnode->type = tgt_type;\n\t}\n\tnode->ref = 0;\n\n\t/* If the moving node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
  },
  {
    "function_name": "__bpf_lru_node_move_in",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "82-94",
    "snippet": "static void __bpf_lru_node_move_in(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node,\n\t\t\t\t   enum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(!IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tbpf_lru_list_count_inc(l, tgt_type);\n\tnode->type = tgt_type;\n\tnode->ref = 0;\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&node->list",
            "&l->lists[tgt_type]"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_count_inc",
          "args": [
            "l",
            "tgt_type"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_count_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "47-52",
          "snippet": "static void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_LOCAL_LIST_TYPE(tgt_type)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "tgt_type"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!IS_LOCAL_LIST_TYPE(node->type)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "node->type"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_in(struct bpf_lru_list *l,\n\t\t\t\t   struct bpf_lru_node *node,\n\t\t\t\t   enum bpf_lru_list_type tgt_type)\n{\n\tif (WARN_ON_ONCE(!IS_LOCAL_LIST_TYPE(node->type)) ||\n\t    WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(tgt_type)))\n\t\treturn;\n\n\tbpf_lru_list_count_inc(l, tgt_type);\n\tnode->type = tgt_type;\n\tnode->ref = 0;\n\tlist_move(&node->list, &l->lists[tgt_type]);\n}"
  },
  {
    "function_name": "__bpf_lru_node_move_to_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "61-79",
    "snippet": "static void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&node->list",
            "free_list"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_list_count_dec",
          "args": [
            "l",
            "node->type"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_list_count_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "54-59",
          "snippet": "static void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_LOCAL_LIST_TYPE(node->type)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LOCAL_LIST_TYPE",
          "args": [
            "node->type"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void __bpf_lru_node_move_to_free(struct bpf_lru_list *l,\n\t\t\t\t\tstruct bpf_lru_node *node,\n\t\t\t\t\tstruct list_head *free_list,\n\t\t\t\t\tenum bpf_lru_list_type tgt_free_type)\n{\n\tif (WARN_ON_ONCE(IS_LOCAL_LIST_TYPE(node->type)))\n\t\treturn;\n\n\t/* If the removing node is the next_inactive_rotation candidate,\n\t * move the next_inactive_rotation pointer also.\n\t */\n\tif (&node->list == l->next_inactive_rotation)\n\t\tl->next_inactive_rotation = l->next_inactive_rotation->prev;\n\n\tbpf_lru_list_count_dec(l, node->type);\n\n\tnode->type = tgt_free_type;\n\tlist_move(&node->list, free_list);\n}"
  },
  {
    "function_name": "bpf_lru_list_count_dec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "54-59",
    "snippet": "static void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_dec(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]--;\n}"
  },
  {
    "function_name": "bpf_lru_list_count_inc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "47-52",
    "snippet": "static void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic void bpf_lru_list_count_inc(struct bpf_lru_list *l,\n\t\t\t\t   enum bpf_lru_list_type type)\n{\n\tif (type < NR_BPF_LRU_LIST_COUNT)\n\t\tl->counts[type]++;\n}"
  },
  {
    "function_name": "bpf_lru_node_is_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "42-45",
    "snippet": "static bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic bool bpf_lru_node_is_ref(const struct bpf_lru_node *node)\n{\n\treturn node->ref;\n}"
  },
  {
    "function_name": "local_pending_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "36-39",
    "snippet": "static struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [
      "#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_PENDING_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_PENDING)\n\nstatic struct list_head *local_pending_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_PENDING_LIST_IDX];\n}"
  },
  {
    "function_name": "local_free_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "31-34",
    "snippet": "static struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [
      "#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define LOCAL_FREE_LIST_IDX\tLOCAL_LIST_IDX(BPF_LRU_LOCAL_LIST_T_FREE)\n\nstatic struct list_head *local_free_list(struct bpf_lru_locallist *loc_l)\n{\n\treturn &loc_l->lists[LOCAL_FREE_LIST_IDX];\n}"
  },
  {
    "function_name": "get_next_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_lru_list.c",
    "lines": "22-28",
    "snippet": "static int get_next_cpu(int cpu)\n{\n\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\tif (cpu >= nr_cpu_ids)\n\t\tcpu = cpumask_first(cpu_possible_mask);\n\treturn cpu;\n}",
    "includes": [
      "#include \"bpf_lru_list.h\"",
      "#include <linux/percpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/cpumask.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_possible_mask"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "cpu",
            "cpu_possible_mask"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstatic int get_next_cpu(int cpu)\n{\n\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\tif (cpu >= nr_cpu_ids)\n\t\tcpu = cpumask_first(cpu_possible_mask);\n\treturn cpu;\n}"
  }
]