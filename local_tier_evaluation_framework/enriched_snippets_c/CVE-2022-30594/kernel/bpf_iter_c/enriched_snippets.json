[
  {
    "function_name": "bpf_iter_run_prog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "683-700",
    "snippet": "int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tmigrate_disable();\n\tret = bpf_prog_run(prog, ctx);\n\tmigrate_enable();\n\trcu_read_unlock();\n\n\t/* bpf program can only return 0 or 1:\n\t *  0 : okay\n\t *  1 : retry the same object\n\t * The bpf_iter_run_prog() return value\n\t * will be seq_ops->show() return value.\n\t */\n\treturn ret == 0 ? 0 : -EAGAIN;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_enable",
          "args": [],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2178-2206",
          "snippet": "void migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_run",
          "args": [
            "prog",
            "ctx"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "___bpf_prog_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1383-1747",
          "snippet": "static u64 ___bpf_prog_run(u64 *regs, const struct bpf_insn *insn)\n{\n#define BPF_INSN_2_LBL(x, y)    [BPF_##x | BPF_##y] = &&x##_##y\n#define BPF_INSN_3_LBL(x, y, z) [BPF_##x | BPF_##y | BPF_##z] = &&x##_##y##_##z\n\tstatic const void * const jumptable[256] __annotate_jump_table = {\n\t\t[0 ... 255] = &&default_label,\n\t\t/* Now overwrite non-defaults ... */\n\t\tBPF_INSN_MAP(BPF_INSN_2_LBL, BPF_INSN_3_LBL),\n\t\t/* Non-UAPI available opcodes. */\n\t\t[BPF_JMP | BPF_CALL_ARGS] = &&JMP_CALL_ARGS,\n\t\t[BPF_JMP | BPF_TAIL_CALL] = &&JMP_TAIL_CALL,\n\t\t[BPF_ST  | BPF_NOSPEC] = &&ST_NOSPEC,\n\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_B] = &&LDX_PROBE_MEM_B,\n\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_H] = &&LDX_PROBE_MEM_H,\n\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_W] = &&LDX_PROBE_MEM_W,\n\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_DW] = &&LDX_PROBE_MEM_DW,\n\t};\n#undef BPF_INSN_3_LBL\n#undef BPF_INSN_2_LBL\n\tu32 tail_call_cnt = 0;\n\n#define CONT\t ({ insn++; goto select_insn; })\n#define CONT_JMP ({ insn++; goto select_insn; })\n\nselect_insn:\n\tgoto *jumptable[insn->code];\n\n\t/* Explicitly mask the register-based shift amounts with 63 or 31\n\t * to avoid undefined behavior. Normally this won't affect the\n\t * generated code, for example, in case of native 64 bit archs such\n\t * as x86-64 or arm64, the compiler is optimizing the AND away for\n\t * the interpreter. In case of JITs, each of the JIT backends compiles\n\t * the BPF shift operations to machine instructions which produce\n\t * implementation-defined results in such a case; the resulting\n\t * contents of the register may be arbitrary, but program behaviour\n\t * as a whole remains defined. In other words, in case of JIT backends,\n\t * the AND must /not/ be added to the emitted LSH/RSH/ARSH translation.\n\t */\n\t/* ALU (shifts) */\n#define SHT(OPCODE, OP)\t\t\t\t\t\\\n\tALU64_##OPCODE##_X:\t\t\t\t\\\n\t\tDST = DST OP (SRC & 63);\t\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU_##OPCODE##_X:\t\t\t\t\\\n\t\tDST = (u32) DST OP ((u32) SRC & 31);\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU64_##OPCODE##_K:\t\t\t\t\\\n\t\tDST = DST OP IMM;\t\t\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU_##OPCODE##_K:\t\t\t\t\\\n\t\tDST = (u32) DST OP (u32) IMM;\t\t\\\n\t\tCONT;\n\t/* ALU (rest) */\n#define ALU(OPCODE, OP)\t\t\t\t\t\\\n\tALU64_##OPCODE##_X:\t\t\t\t\\\n\t\tDST = DST OP SRC;\t\t\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU_##OPCODE##_X:\t\t\t\t\\\n\t\tDST = (u32) DST OP (u32) SRC;\t\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU64_##OPCODE##_K:\t\t\t\t\\\n\t\tDST = DST OP IMM;\t\t\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU_##OPCODE##_K:\t\t\t\t\\\n\t\tDST = (u32) DST OP (u32) IMM;\t\t\\\n\t\tCONT;\n\tALU(ADD,  +)\n\tALU(SUB,  -)\n\tALU(AND,  &)\n\tALU(OR,   |)\n\tALU(XOR,  ^)\n\tALU(MUL,  *)\n\tSHT(LSH, <<)\n\tSHT(RSH, >>)\n#undef SHT\n#undef ALU\n\tALU_NEG:\n\t\tDST = (u32) -DST;\n\t\tCONT;\n\tALU64_NEG:\n\t\tDST = -DST;\n\t\tCONT;\n\tALU_MOV_X:\n\t\tDST = (u32) SRC;\n\t\tCONT;\n\tALU_MOV_K:\n\t\tDST = (u32) IMM;\n\t\tCONT;\n\tALU64_MOV_X:\n\t\tDST = SRC;\n\t\tCONT;\n\tALU64_MOV_K:\n\t\tDST = IMM;\n\t\tCONT;\n\tLD_IMM_DW:\n\t\tDST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) << 32;\n\t\tinsn++;\n\t\tCONT;\n\tALU_ARSH_X:\n\t\tDST = (u64) (u32) (((s32) DST) >> (SRC & 31));\n\t\tCONT;\n\tALU_ARSH_K:\n\t\tDST = (u64) (u32) (((s32) DST) >> IMM);\n\t\tCONT;\n\tALU64_ARSH_X:\n\t\t(*(s64 *) &DST) >>= (SRC & 63);\n\t\tCONT;\n\tALU64_ARSH_K:\n\t\t(*(s64 *) &DST) >>= IMM;\n\t\tCONT;\n\tALU64_MOD_X:\n\t\tdiv64_u64_rem(DST, SRC, &AX);\n\t\tDST = AX;\n\t\tCONT;\n\tALU_MOD_X:\n\t\tAX = (u32) DST;\n\t\tDST = do_div(AX, (u32) SRC);\n\t\tCONT;\n\tALU64_MOD_K:\n\t\tdiv64_u64_rem(DST, IMM, &AX);\n\t\tDST = AX;\n\t\tCONT;\n\tALU_MOD_K:\n\t\tAX = (u32) DST;\n\t\tDST = do_div(AX, (u32) IMM);\n\t\tCONT;\n\tALU64_DIV_X:\n\t\tDST = div64_u64(DST, SRC);\n\t\tCONT;\n\tALU_DIV_X:\n\t\tAX = (u32) DST;\n\t\tdo_div(AX, (u32) SRC);\n\t\tDST = (u32) AX;\n\t\tCONT;\n\tALU64_DIV_K:\n\t\tDST = div64_u64(DST, IMM);\n\t\tCONT;\n\tALU_DIV_K:\n\t\tAX = (u32) DST;\n\t\tdo_div(AX, (u32) IMM);\n\t\tDST = (u32) AX;\n\t\tCONT;\n\tALU_END_TO_BE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_be16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_be32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_be64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\tALU_END_TO_LE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_le16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_le32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_le64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\n\t/* CALL */\n\tJMP_CALL:\n\t\t/* Function call scratches BPF_R1-BPF_R5 registers,\n\t\t * preserves BPF_R6-BPF_R9, and stores return value\n\t\t * into BPF_R0.\n\t\t */\n\t\tBPF_R0 = (__bpf_call_base + insn->imm)(BPF_R1, BPF_R2, BPF_R3,\n\t\t\t\t\t\t       BPF_R4, BPF_R5);\n\t\tCONT;\n\n\tJMP_CALL_ARGS:\n\t\tBPF_R0 = (__bpf_call_base_args + insn->imm)(BPF_R1, BPF_R2,\n\t\t\t\t\t\t\t    BPF_R3, BPF_R4,\n\t\t\t\t\t\t\t    BPF_R5,\n\t\t\t\t\t\t\t    insn + insn->off + 1);\n\t\tCONT;\n\n\tJMP_TAIL_CALL: {\n\t\tstruct bpf_map *map = (struct bpf_map *) (unsigned long) BPF_R2;\n\t\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\t\tstruct bpf_prog *prog;\n\t\tu32 index = BPF_R3;\n\n\t\tif (unlikely(index >= array->map.max_entries))\n\t\t\tgoto out;\n\n\t\tif (unlikely(tail_call_cnt >= MAX_TAIL_CALL_CNT))\n\t\t\tgoto out;\n\n\t\ttail_call_cnt++;\n\n\t\tprog = READ_ONCE(array->ptrs[index]);\n\t\tif (!prog)\n\t\t\tgoto out;\n\n\t\t/* ARG1 at this point is guaranteed to point to CTX from\n\t\t * the verifier side due to the fact that the tail call is\n\t\t * handled like a helper, that is, bpf_tail_call_proto,\n\t\t * where arg1_type is ARG_PTR_TO_CTX.\n\t\t */\n\t\tinsn = prog->insnsi;\n\t\tgoto select_insn;\nout:\n\t\tCONT;\n\t}\n\tJMP_JA:\n\t\tinsn += insn->off;\n\t\tCONT;\n\tJMP_EXIT:\n\t\treturn BPF_R0;\n\t/* JMP */\n#define COND_JMP(SIGN, OPCODE, CMP_OP)\t\t\t\t\\\n\tJMP_##OPCODE##_X:\t\t\t\t\t\\\n\t\tif ((SIGN##64) DST CMP_OP (SIGN##64) SRC) {\t\\\n\t\t\tinsn += insn->off;\t\t\t\\\n\t\t\tCONT_JMP;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tJMP32_##OPCODE##_X:\t\t\t\t\t\\\n\t\tif ((SIGN##32) DST CMP_OP (SIGN##32) SRC) {\t\\\n\t\t\tinsn += insn->off;\t\t\t\\\n\t\t\tCONT_JMP;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tJMP_##OPCODE##_K:\t\t\t\t\t\\\n\t\tif ((SIGN##64) DST CMP_OP (SIGN##64) IMM) {\t\\\n\t\t\tinsn += insn->off;\t\t\t\\\n\t\t\tCONT_JMP;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tJMP32_##OPCODE##_K:\t\t\t\t\t\\\n\t\tif ((SIGN##32) DST CMP_OP (SIGN##32) IMM) {\t\\\n\t\t\tinsn += insn->off;\t\t\t\\\n\t\t\tCONT_JMP;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\tCONT;\n\tCOND_JMP(u, JEQ, ==)\n\tCOND_JMP(u, JNE, !=)\n\tCOND_JMP(u, JGT, >)\n\tCOND_JMP(u, JLT, <)\n\tCOND_JMP(u, JGE, >=)\n\tCOND_JMP(u, JLE, <=)\n\tCOND_JMP(u, JSET, &)\n\tCOND_JMP(s, JSGT, >)\n\tCOND_JMP(s, JSLT, <)\n\tCOND_JMP(s, JSGE, >=)\n\tCOND_JMP(s, JSLE, <=)\n#undef COND_JMP\n\t/* ST, STX and LDX*/\n\tST_NOSPEC:\n\t\t/* Speculation barrier for mitigating Speculative Store Bypass.\n\t\t * In case of arm64, we rely on the firmware mitigation as\n\t\t * controlled via the ssbd kernel parameter. Whenever the\n\t\t * mitigation is enabled, it works for all of the kernel code\n\t\t * with no need to provide any additional instructions here.\n\t\t * In case of x86, we use 'lfence' insn for mitigation. We\n\t\t * reuse preexisting logic from Spectre v1 mitigation that\n\t\t * happens to produce the required code on x86 for v4 as well.\n\t\t */\n#ifdef CONFIG_X86\n\t\tbarrier_nospec();\n#endif\n\t\tCONT;\n#define LDST(SIZEOP, SIZE)\t\t\t\t\t\t\\\n\tSTX_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (DST + insn->off) = SRC;\t\\\n\t\tCONT;\t\t\t\t\t\t\t\\\n\tST_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (DST + insn->off) = IMM;\t\\\n\t\tCONT;\t\t\t\t\t\t\t\\\n\tLDX_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\tDST = *(SIZE *)(unsigned long) (SRC + insn->off);\t\\\n\t\tCONT;\n\n\tLDST(B,   u8)\n\tLDST(H,  u16)\n\tLDST(W,  u32)\n\tLDST(DW, u64)\n#undef LDST\n#define LDX_PROBE(SIZEOP, SIZE)\t\t\t\t\t\t\t\\\n\tLDX_PROBE_MEM_##SIZEOP:\t\t\t\t\t\t\t\\\n\t\tbpf_probe_read_kernel(&DST, SIZE, (const void *)(long) (SRC + insn->off));\t\\\n\t\tCONT;\n\tLDX_PROBE(B,  1)\n\tLDX_PROBE(H,  2)\n\tLDX_PROBE(W,  4)\n\tLDX_PROBE(DW, 8)\n#undef LDX_PROBE\n\n#define ATOMIC_ALU_OP(BOP, KOP)\t\t\t\t\t\t\\\n\t\tcase BOP:\t\t\t\t\t\t\\\n\t\t\tif (BPF_SIZE(insn->code) == BPF_W)\t\t\\\n\t\t\t\tatomic_##KOP((u32) SRC, (atomic_t *)(unsigned long) \\\n\t\t\t\t\t     (DST + insn->off));\t\\\n\t\t\telse\t\t\t\t\t\t\\\n\t\t\t\tatomic64_##KOP((u64) SRC, (atomic64_t *)(unsigned long) \\\n\t\t\t\t\t       (DST + insn->off));\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase BOP | BPF_FETCH:\t\t\t\t\t\\\n\t\t\tif (BPF_SIZE(insn->code) == BPF_W)\t\t\\\n\t\t\t\tSRC = (u32) atomic_fetch_##KOP(\t\t\\\n\t\t\t\t\t(u32) SRC,\t\t\t\\\n\t\t\t\t\t(atomic_t *)(unsigned long) (DST + insn->off)); \\\n\t\t\telse\t\t\t\t\t\t\\\n\t\t\t\tSRC = (u64) atomic64_fetch_##KOP(\t\\\n\t\t\t\t\t(u64) SRC,\t\t\t\\\n\t\t\t\t\t(atomic64_t *)(unsigned long) (DST + insn->off)); \\\n\t\t\tbreak;\n\n\tSTX_ATOMIC_DW:\n\tSTX_ATOMIC_W:\n\t\tswitch (IMM) {\n\t\tATOMIC_ALU_OP(BPF_ADD, add)\n\t\tATOMIC_ALU_OP(BPF_AND, and)\n\t\tATOMIC_ALU_OP(BPF_OR, or)\n\t\tATOMIC_ALU_OP(BPF_XOR, xor)\n#undef ATOMIC_ALU_OP\n\n\t\tcase BPF_XCHG:\n\t\t\tif (BPF_SIZE(insn->code) == BPF_W)\n\t\t\t\tSRC = (u32) atomic_xchg(\n\t\t\t\t\t(atomic_t *)(unsigned long) (DST + insn->off),\n\t\t\t\t\t(u32) SRC);\n\t\t\telse\n\t\t\t\tSRC = (u64) atomic64_xchg(\n\t\t\t\t\t(atomic64_t *)(unsigned long) (DST + insn->off),\n\t\t\t\t\t(u64) SRC);\n\t\t\tbreak;\n\t\tcase BPF_CMPXCHG:\n\t\t\tif (BPF_SIZE(insn->code) == BPF_W)\n\t\t\t\tBPF_R0 = (u32) atomic_cmpxchg(\n\t\t\t\t\t(atomic_t *)(unsigned long) (DST + insn->off),\n\t\t\t\t\t(u32) BPF_R0, (u32) SRC);\n\t\t\telse\n\t\t\t\tBPF_R0 = (u64) atomic64_cmpxchg(\n\t\t\t\t\t(atomic64_t *)(unsigned long) (DST + insn->off),\n\t\t\t\t\t(u64) BPF_R0, (u64) SRC);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto default_label;\n\t\t}\n\t\tCONT;\n\n\tdefault_label:\n\t\t/* If we ever reach this, we have a bug somewhere. Die hard here\n\t\t * instead of just returning 0; we could be somewhere in a subprog,\n\t\t * so execution could continue otherwise which we do /not/ want.\n\t\t *\n\t\t * Note, verifier whitelists all opcodes in bpf_opcode_in_insntable().\n\t\t */\n\t\tpr_warn(\"BPF interpreter: unknown opcode %02x (imm: 0x%x)\\n\",\n\t\t\tinsn->code, insn->imm);\n\t\tBUG_ON(1);\n\t\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define CONT_JMP ({ insn++; goto select_insn; })",
            "#define CONT\t ({ insn++; goto select_insn; })",
            "#define IMM\tinsn->imm",
            "#define CTX\tregs[BPF_REG_CTX]",
            "#define ARG1\tregs[BPF_REG_ARG1]",
            "#define AX\tregs[BPF_REG_AX]",
            "#define SRC\tregs[insn->src_reg]",
            "#define DST\tregs[insn->dst_reg]",
            "#define BPF_R9\tregs[BPF_REG_9]",
            "#define BPF_R6\tregs[BPF_REG_6]",
            "#define BPF_R5\tregs[BPF_REG_5]",
            "#define BPF_R4\tregs[BPF_REG_4]",
            "#define BPF_R3\tregs[BPF_REG_3]",
            "#define BPF_R2\tregs[BPF_REG_2]",
            "#define BPF_R1\tregs[BPF_REG_1]",
            "#define BPF_R0\tregs[BPF_REG_0]"
          ],
          "globals_used": [
            "const struct bpf_func_proto bpf_tail_call_proto = {\n\t.func\t\t= NULL,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\n#define CONT_JMP ({ insn++; goto select_insn; })\n#define CONT\t ({ insn++; goto select_insn; })\n#define IMM\tinsn->imm\n#define CTX\tregs[BPF_REG_CTX]\n#define ARG1\tregs[BPF_REG_ARG1]\n#define AX\tregs[BPF_REG_AX]\n#define SRC\tregs[insn->src_reg]\n#define DST\tregs[insn->dst_reg]\n#define BPF_R9\tregs[BPF_REG_9]\n#define BPF_R6\tregs[BPF_REG_6]\n#define BPF_R5\tregs[BPF_REG_5]\n#define BPF_R4\tregs[BPF_REG_4]\n#define BPF_R3\tregs[BPF_REG_3]\n#define BPF_R2\tregs[BPF_REG_2]\n#define BPF_R1\tregs[BPF_REG_1]\n#define BPF_R0\tregs[BPF_REG_0]\n\nconst struct bpf_func_proto bpf_tail_call_proto = {\n\t.func\t\t= NULL,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};\n\nstatic u64 ___bpf_prog_run(u64 *regs, const struct bpf_insn *insn)\n{\n#define BPF_INSN_2_LBL(x, y)    [BPF_##x | BPF_##y] = &&x##_##y\n#define BPF_INSN_3_LBL(x, y, z) [BPF_##x | BPF_##y | BPF_##z] = &&x##_##y##_##z\n\tstatic const void * const jumptable[256] __annotate_jump_table = {\n\t\t[0 ... 255] = &&default_label,\n\t\t/* Now overwrite non-defaults ... */\n\t\tBPF_INSN_MAP(BPF_INSN_2_LBL, BPF_INSN_3_LBL),\n\t\t/* Non-UAPI available opcodes. */\n\t\t[BPF_JMP | BPF_CALL_ARGS] = &&JMP_CALL_ARGS,\n\t\t[BPF_JMP | BPF_TAIL_CALL] = &&JMP_TAIL_CALL,\n\t\t[BPF_ST  | BPF_NOSPEC] = &&ST_NOSPEC,\n\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_B] = &&LDX_PROBE_MEM_B,\n\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_H] = &&LDX_PROBE_MEM_H,\n\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_W] = &&LDX_PROBE_MEM_W,\n\t\t[BPF_LDX | BPF_PROBE_MEM | BPF_DW] = &&LDX_PROBE_MEM_DW,\n\t};\n#undef BPF_INSN_3_LBL\n#undef BPF_INSN_2_LBL\n\tu32 tail_call_cnt = 0;\n\n#define CONT\t ({ insn++; goto select_insn; })\n#define CONT_JMP ({ insn++; goto select_insn; })\n\nselect_insn:\n\tgoto *jumptable[insn->code];\n\n\t/* Explicitly mask the register-based shift amounts with 63 or 31\n\t * to avoid undefined behavior. Normally this won't affect the\n\t * generated code, for example, in case of native 64 bit archs such\n\t * as x86-64 or arm64, the compiler is optimizing the AND away for\n\t * the interpreter. In case of JITs, each of the JIT backends compiles\n\t * the BPF shift operations to machine instructions which produce\n\t * implementation-defined results in such a case; the resulting\n\t * contents of the register may be arbitrary, but program behaviour\n\t * as a whole remains defined. In other words, in case of JIT backends,\n\t * the AND must /not/ be added to the emitted LSH/RSH/ARSH translation.\n\t */\n\t/* ALU (shifts) */\n#define SHT(OPCODE, OP)\t\t\t\t\t\\\n\tALU64_##OPCODE##_X:\t\t\t\t\\\n\t\tDST = DST OP (SRC & 63);\t\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU_##OPCODE##_X:\t\t\t\t\\\n\t\tDST = (u32) DST OP ((u32) SRC & 31);\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU64_##OPCODE##_K:\t\t\t\t\\\n\t\tDST = DST OP IMM;\t\t\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU_##OPCODE##_K:\t\t\t\t\\\n\t\tDST = (u32) DST OP (u32) IMM;\t\t\\\n\t\tCONT;\n\t/* ALU (rest) */\n#define ALU(OPCODE, OP)\t\t\t\t\t\\\n\tALU64_##OPCODE##_X:\t\t\t\t\\\n\t\tDST = DST OP SRC;\t\t\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU_##OPCODE##_X:\t\t\t\t\\\n\t\tDST = (u32) DST OP (u32) SRC;\t\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU64_##OPCODE##_K:\t\t\t\t\\\n\t\tDST = DST OP IMM;\t\t\t\\\n\t\tCONT;\t\t\t\t\t\\\n\tALU_##OPCODE##_K:\t\t\t\t\\\n\t\tDST = (u32) DST OP (u32) IMM;\t\t\\\n\t\tCONT;\n\tALU(ADD,  +)\n\tALU(SUB,  -)\n\tALU(AND,  &)\n\tALU(OR,   |)\n\tALU(XOR,  ^)\n\tALU(MUL,  *)\n\tSHT(LSH, <<)\n\tSHT(RSH, >>)\n#undef SHT\n#undef ALU\n\tALU_NEG:\n\t\tDST = (u32) -DST;\n\t\tCONT;\n\tALU64_NEG:\n\t\tDST = -DST;\n\t\tCONT;\n\tALU_MOV_X:\n\t\tDST = (u32) SRC;\n\t\tCONT;\n\tALU_MOV_K:\n\t\tDST = (u32) IMM;\n\t\tCONT;\n\tALU64_MOV_X:\n\t\tDST = SRC;\n\t\tCONT;\n\tALU64_MOV_K:\n\t\tDST = IMM;\n\t\tCONT;\n\tLD_IMM_DW:\n\t\tDST = (u64) (u32) insn[0].imm | ((u64) (u32) insn[1].imm) << 32;\n\t\tinsn++;\n\t\tCONT;\n\tALU_ARSH_X:\n\t\tDST = (u64) (u32) (((s32) DST) >> (SRC & 31));\n\t\tCONT;\n\tALU_ARSH_K:\n\t\tDST = (u64) (u32) (((s32) DST) >> IMM);\n\t\tCONT;\n\tALU64_ARSH_X:\n\t\t(*(s64 *) &DST) >>= (SRC & 63);\n\t\tCONT;\n\tALU64_ARSH_K:\n\t\t(*(s64 *) &DST) >>= IMM;\n\t\tCONT;\n\tALU64_MOD_X:\n\t\tdiv64_u64_rem(DST, SRC, &AX);\n\t\tDST = AX;\n\t\tCONT;\n\tALU_MOD_X:\n\t\tAX = (u32) DST;\n\t\tDST = do_div(AX, (u32) SRC);\n\t\tCONT;\n\tALU64_MOD_K:\n\t\tdiv64_u64_rem(DST, IMM, &AX);\n\t\tDST = AX;\n\t\tCONT;\n\tALU_MOD_K:\n\t\tAX = (u32) DST;\n\t\tDST = do_div(AX, (u32) IMM);\n\t\tCONT;\n\tALU64_DIV_X:\n\t\tDST = div64_u64(DST, SRC);\n\t\tCONT;\n\tALU_DIV_X:\n\t\tAX = (u32) DST;\n\t\tdo_div(AX, (u32) SRC);\n\t\tDST = (u32) AX;\n\t\tCONT;\n\tALU64_DIV_K:\n\t\tDST = div64_u64(DST, IMM);\n\t\tCONT;\n\tALU_DIV_K:\n\t\tAX = (u32) DST;\n\t\tdo_div(AX, (u32) IMM);\n\t\tDST = (u32) AX;\n\t\tCONT;\n\tALU_END_TO_BE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_be16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_be32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_be64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\tALU_END_TO_LE:\n\t\tswitch (IMM) {\n\t\tcase 16:\n\t\t\tDST = (__force u16) cpu_to_le16(DST);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tDST = (__force u32) cpu_to_le32(DST);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tDST = (__force u64) cpu_to_le64(DST);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\n\t/* CALL */\n\tJMP_CALL:\n\t\t/* Function call scratches BPF_R1-BPF_R5 registers,\n\t\t * preserves BPF_R6-BPF_R9, and stores return value\n\t\t * into BPF_R0.\n\t\t */\n\t\tBPF_R0 = (__bpf_call_base + insn->imm)(BPF_R1, BPF_R2, BPF_R3,\n\t\t\t\t\t\t       BPF_R4, BPF_R5);\n\t\tCONT;\n\n\tJMP_CALL_ARGS:\n\t\tBPF_R0 = (__bpf_call_base_args + insn->imm)(BPF_R1, BPF_R2,\n\t\t\t\t\t\t\t    BPF_R3, BPF_R4,\n\t\t\t\t\t\t\t    BPF_R5,\n\t\t\t\t\t\t\t    insn + insn->off + 1);\n\t\tCONT;\n\n\tJMP_TAIL_CALL: {\n\t\tstruct bpf_map *map = (struct bpf_map *) (unsigned long) BPF_R2;\n\t\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\t\tstruct bpf_prog *prog;\n\t\tu32 index = BPF_R3;\n\n\t\tif (unlikely(index >= array->map.max_entries))\n\t\t\tgoto out;\n\n\t\tif (unlikely(tail_call_cnt >= MAX_TAIL_CALL_CNT))\n\t\t\tgoto out;\n\n\t\ttail_call_cnt++;\n\n\t\tprog = READ_ONCE(array->ptrs[index]);\n\t\tif (!prog)\n\t\t\tgoto out;\n\n\t\t/* ARG1 at this point is guaranteed to point to CTX from\n\t\t * the verifier side due to the fact that the tail call is\n\t\t * handled like a helper, that is, bpf_tail_call_proto,\n\t\t * where arg1_type is ARG_PTR_TO_CTX.\n\t\t */\n\t\tinsn = prog->insnsi;\n\t\tgoto select_insn;\nout:\n\t\tCONT;\n\t}\n\tJMP_JA:\n\t\tinsn += insn->off;\n\t\tCONT;\n\tJMP_EXIT:\n\t\treturn BPF_R0;\n\t/* JMP */\n#define COND_JMP(SIGN, OPCODE, CMP_OP)\t\t\t\t\\\n\tJMP_##OPCODE##_X:\t\t\t\t\t\\\n\t\tif ((SIGN##64) DST CMP_OP (SIGN##64) SRC) {\t\\\n\t\t\tinsn += insn->off;\t\t\t\\\n\t\t\tCONT_JMP;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tJMP32_##OPCODE##_X:\t\t\t\t\t\\\n\t\tif ((SIGN##32) DST CMP_OP (SIGN##32) SRC) {\t\\\n\t\t\tinsn += insn->off;\t\t\t\\\n\t\t\tCONT_JMP;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tJMP_##OPCODE##_K:\t\t\t\t\t\\\n\t\tif ((SIGN##64) DST CMP_OP (SIGN##64) IMM) {\t\\\n\t\t\tinsn += insn->off;\t\t\t\\\n\t\t\tCONT_JMP;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tJMP32_##OPCODE##_K:\t\t\t\t\t\\\n\t\tif ((SIGN##32) DST CMP_OP (SIGN##32) IMM) {\t\\\n\t\t\tinsn += insn->off;\t\t\t\\\n\t\t\tCONT_JMP;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\tCONT;\n\tCOND_JMP(u, JEQ, ==)\n\tCOND_JMP(u, JNE, !=)\n\tCOND_JMP(u, JGT, >)\n\tCOND_JMP(u, JLT, <)\n\tCOND_JMP(u, JGE, >=)\n\tCOND_JMP(u, JLE, <=)\n\tCOND_JMP(u, JSET, &)\n\tCOND_JMP(s, JSGT, >)\n\tCOND_JMP(s, JSLT, <)\n\tCOND_JMP(s, JSGE, >=)\n\tCOND_JMP(s, JSLE, <=)\n#undef COND_JMP\n\t/* ST, STX and LDX*/\n\tST_NOSPEC:\n\t\t/* Speculation barrier for mitigating Speculative Store Bypass.\n\t\t * In case of arm64, we rely on the firmware mitigation as\n\t\t * controlled via the ssbd kernel parameter. Whenever the\n\t\t * mitigation is enabled, it works for all of the kernel code\n\t\t * with no need to provide any additional instructions here.\n\t\t * In case of x86, we use 'lfence' insn for mitigation. We\n\t\t * reuse preexisting logic from Spectre v1 mitigation that\n\t\t * happens to produce the required code on x86 for v4 as well.\n\t\t */\n#ifdef CONFIG_X86\n\t\tbarrier_nospec();\n#endif\n\t\tCONT;\n#define LDST(SIZEOP, SIZE)\t\t\t\t\t\t\\\n\tSTX_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (DST + insn->off) = SRC;\t\\\n\t\tCONT;\t\t\t\t\t\t\t\\\n\tST_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (DST + insn->off) = IMM;\t\\\n\t\tCONT;\t\t\t\t\t\t\t\\\n\tLDX_MEM_##SIZEOP:\t\t\t\t\t\t\\\n\t\tDST = *(SIZE *)(unsigned long) (SRC + insn->off);\t\\\n\t\tCONT;\n\n\tLDST(B,   u8)\n\tLDST(H,  u16)\n\tLDST(W,  u32)\n\tLDST(DW, u64)\n#undef LDST\n#define LDX_PROBE(SIZEOP, SIZE)\t\t\t\t\t\t\t\\\n\tLDX_PROBE_MEM_##SIZEOP:\t\t\t\t\t\t\t\\\n\t\tbpf_probe_read_kernel(&DST, SIZE, (const void *)(long) (SRC + insn->off));\t\\\n\t\tCONT;\n\tLDX_PROBE(B,  1)\n\tLDX_PROBE(H,  2)\n\tLDX_PROBE(W,  4)\n\tLDX_PROBE(DW, 8)\n#undef LDX_PROBE\n\n#define ATOMIC_ALU_OP(BOP, KOP)\t\t\t\t\t\t\\\n\t\tcase BOP:\t\t\t\t\t\t\\\n\t\t\tif (BPF_SIZE(insn->code) == BPF_W)\t\t\\\n\t\t\t\tatomic_##KOP((u32) SRC, (atomic_t *)(unsigned long) \\\n\t\t\t\t\t     (DST + insn->off));\t\\\n\t\t\telse\t\t\t\t\t\t\\\n\t\t\t\tatomic64_##KOP((u64) SRC, (atomic64_t *)(unsigned long) \\\n\t\t\t\t\t       (DST + insn->off));\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase BOP | BPF_FETCH:\t\t\t\t\t\\\n\t\t\tif (BPF_SIZE(insn->code) == BPF_W)\t\t\\\n\t\t\t\tSRC = (u32) atomic_fetch_##KOP(\t\t\\\n\t\t\t\t\t(u32) SRC,\t\t\t\\\n\t\t\t\t\t(atomic_t *)(unsigned long) (DST + insn->off)); \\\n\t\t\telse\t\t\t\t\t\t\\\n\t\t\t\tSRC = (u64) atomic64_fetch_##KOP(\t\\\n\t\t\t\t\t(u64) SRC,\t\t\t\\\n\t\t\t\t\t(atomic64_t *)(unsigned long) (DST + insn->off)); \\\n\t\t\tbreak;\n\n\tSTX_ATOMIC_DW:\n\tSTX_ATOMIC_W:\n\t\tswitch (IMM) {\n\t\tATOMIC_ALU_OP(BPF_ADD, add)\n\t\tATOMIC_ALU_OP(BPF_AND, and)\n\t\tATOMIC_ALU_OP(BPF_OR, or)\n\t\tATOMIC_ALU_OP(BPF_XOR, xor)\n#undef ATOMIC_ALU_OP\n\n\t\tcase BPF_XCHG:\n\t\t\tif (BPF_SIZE(insn->code) == BPF_W)\n\t\t\t\tSRC = (u32) atomic_xchg(\n\t\t\t\t\t(atomic_t *)(unsigned long) (DST + insn->off),\n\t\t\t\t\t(u32) SRC);\n\t\t\telse\n\t\t\t\tSRC = (u64) atomic64_xchg(\n\t\t\t\t\t(atomic64_t *)(unsigned long) (DST + insn->off),\n\t\t\t\t\t(u64) SRC);\n\t\t\tbreak;\n\t\tcase BPF_CMPXCHG:\n\t\t\tif (BPF_SIZE(insn->code) == BPF_W)\n\t\t\t\tBPF_R0 = (u32) atomic_cmpxchg(\n\t\t\t\t\t(atomic_t *)(unsigned long) (DST + insn->off),\n\t\t\t\t\t(u32) BPF_R0, (u32) SRC);\n\t\t\telse\n\t\t\t\tBPF_R0 = (u64) atomic64_cmpxchg(\n\t\t\t\t\t(atomic64_t *)(unsigned long) (DST + insn->off),\n\t\t\t\t\t(u64) BPF_R0, (u64) SRC);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto default_label;\n\t\t}\n\t\tCONT;\n\n\tdefault_label:\n\t\t/* If we ever reach this, we have a bug somewhere. Die hard here\n\t\t * instead of just returning 0; we could be somewhere in a subprog,\n\t\t * so execution could continue otherwise which we do /not/ want.\n\t\t *\n\t\t * Note, verifier whitelists all opcodes in bpf_opcode_in_insntable().\n\t\t */\n\t\tpr_warn(\"BPF interpreter: unknown opcode %02x (imm: 0x%x)\\n\",\n\t\t\tinsn->code, insn->imm);\n\t\tBUG_ON(1);\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_disable",
          "args": [],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2162-2175",
          "snippet": "void migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nint bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tmigrate_disable();\n\tret = bpf_prog_run(prog, ctx);\n\tmigrate_enable();\n\trcu_read_unlock();\n\n\t/* bpf program can only return 0 or 1:\n\t *  0 : okay\n\t *  1 : retry the same object\n\t * The bpf_iter_run_prog() return value\n\t * will be seq_ops->show() return value.\n\t */\n\treturn ret == 0 ? 0 : -EAGAIN;\n}"
  },
  {
    "function_name": "bpf_iter_get_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "660-681",
    "snippet": "struct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\tvoid *seq_priv;\n\n\tseq = meta->seq;\n\tif (seq->file->f_op != &bpf_iter_fops)\n\t\treturn NULL;\n\n\tseq_priv = seq->private;\n\titer_priv = container_of(seq_priv, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (in_stop && iter_priv->done_stop)\n\t\treturn NULL;\n\n\tmeta->session_id = iter_priv->session_id;\n\tmeta->seq_num = iter_priv->seq_num;\n\n\treturn iter_priv->prog;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic64_t session_id;",
      "const struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "seq_priv",
            "structbpf_iter_priv_data",
            "target_private"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic atomic64_t session_id;\nconst struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};\n\nstruct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\tvoid *seq_priv;\n\n\tseq = meta->seq;\n\tif (seq->file->f_op != &bpf_iter_fops)\n\t\treturn NULL;\n\n\tseq_priv = seq->private;\n\titer_priv = container_of(seq_priv, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (in_stop && iter_priv->done_stop)\n\t\treturn NULL;\n\n\tmeta->session_id = iter_priv->session_id;\n\tmeta->seq_num = iter_priv->seq_num;\n\n\treturn iter_priv->prog;\n}"
  },
  {
    "function_name": "bpf_iter_new_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "624-658",
    "snippet": "int bpf_iter_new_fd(struct bpf_link *link)\n{\n\tstruct bpf_iter_link *iter_link;\n\tstruct file *file;\n\tunsigned int flags;\n\tint err, fd;\n\n\tif (link->ops != &bpf_iter_link_lops)\n\t\treturn -EINVAL;\n\n\tflags = O_RDONLY | O_CLOEXEC;\n\tfd = get_unused_fd_flags(flags);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfile = anon_inode_getfile(\"bpf_iter\", &bpf_iter_fops, NULL, flags);\n\tif (IS_ERR(file)) {\n\t\terr = PTR_ERR(file);\n\t\tgoto free_fd;\n\t}\n\n\titer_link = container_of(link, struct bpf_iter_link, link);\n\terr = prepare_seq_file(file, iter_link, __get_seq_info(iter_link));\n\tif (err)\n\t\tgoto free_file;\n\n\tfd_install(fd, file);\n\treturn fd;\n\nfree_file:\n\tfput(file);\nfree_fd:\n\tput_unused_fd(fd);\n\treturn err;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};",
      "static const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd",
            "file"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_seq_file",
          "args": [
            "file",
            "iter_link",
            "__get_seq_info(iter_link)"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_seq_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "579-622",
          "snippet": "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info)\n{\n\tstruct bpf_iter_priv_data *priv_data;\n\tstruct bpf_iter_target_info *tinfo;\n\tstruct bpf_prog *prog;\n\tu32 total_priv_dsize;\n\tstruct seq_file *seq;\n\tint err = 0;\n\n\tmutex_lock(&link_mutex);\n\tprog = link->link.prog;\n\tbpf_prog_inc(prog);\n\tmutex_unlock(&link_mutex);\n\n\ttinfo = link->tinfo;\n\ttotal_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +\n\t\t\t   seq_info->seq_priv_size;\n\tpriv_data = __seq_open_private(file, seq_info->seq_ops,\n\t\t\t\t       total_priv_dsize);\n\tif (!priv_data) {\n\t\terr = -ENOMEM;\n\t\tgoto release_prog;\n\t}\n\n\tif (seq_info->init_seq_private) {\n\t\terr = seq_info->init_seq_private(priv_data->target_private, &link->aux);\n\t\tif (err)\n\t\t\tgoto release_seq_file;\n\t}\n\n\tinit_seq_meta(priv_data, tinfo, seq_info, prog);\n\tseq = file->private_data;\n\tseq->private = priv_data->target_private;\n\n\treturn 0;\n\nrelease_seq_file:\n\tseq_release_private(file->f_inode, file);\n\tfile->private_data = NULL;\nrelease_prog:\n\tbpf_prog_put(prog);\n\treturn err;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(link_mutex);",
            "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic DEFINE_MUTEX(link_mutex);\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);\n\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info)\n{\n\tstruct bpf_iter_priv_data *priv_data;\n\tstruct bpf_iter_target_info *tinfo;\n\tstruct bpf_prog *prog;\n\tu32 total_priv_dsize;\n\tstruct seq_file *seq;\n\tint err = 0;\n\n\tmutex_lock(&link_mutex);\n\tprog = link->link.prog;\n\tbpf_prog_inc(prog);\n\tmutex_unlock(&link_mutex);\n\n\ttinfo = link->tinfo;\n\ttotal_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +\n\t\t\t   seq_info->seq_priv_size;\n\tpriv_data = __seq_open_private(file, seq_info->seq_ops,\n\t\t\t\t       total_priv_dsize);\n\tif (!priv_data) {\n\t\terr = -ENOMEM;\n\t\tgoto release_prog;\n\t}\n\n\tif (seq_info->init_seq_private) {\n\t\terr = seq_info->init_seq_private(priv_data->target_private, &link->aux);\n\t\tif (err)\n\t\t\tgoto release_seq_file;\n\t}\n\n\tinit_seq_meta(priv_data, tinfo, seq_info, prog);\n\tseq = file->private_data;\n\tseq->private = priv_data->target_private;\n\n\treturn 0;\n\nrelease_seq_file:\n\tseq_release_private(file->f_inode, file);\n\tfile->private_data = NULL;\nrelease_prog:\n\tbpf_prog_put(prog);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_seq_info",
          "args": [
            "iter_link"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "__get_seq_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "232-244",
          "snippet": "static const struct bpf_iter_seq_info *\n__get_seq_info(struct bpf_iter_link *link)\n{\n\tconst struct bpf_iter_seq_info *seq_info;\n\n\tif (link->aux.map) {\n\t\tseq_info = link->aux.map->ops->iter_seq_info;\n\t\tif (seq_info)\n\t\t\treturn seq_info;\n\t}\n\n\treturn link->tinfo->reg_info->seq_info;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);\n\nstatic const struct bpf_iter_seq_info *\n__get_seq_info(struct bpf_iter_link *link)\n{\n\tconst struct bpf_iter_seq_info *seq_info;\n\n\tif (link->aux.map) {\n\t\tseq_info = link->aux.map->ops->iter_seq_info;\n\t\tif (seq_info)\n\t\t\treturn seq_info;\n\t}\n\n\treturn link->tinfo->reg_info->seq_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_iter_link",
            "link"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_inode_getfile",
          "args": [
            "\"bpf_iter\"",
            "&bpf_iter_fops",
            "NULL",
            "flags"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "flags"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nconst struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};\nstatic const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};\n\nint bpf_iter_new_fd(struct bpf_link *link)\n{\n\tstruct bpf_iter_link *iter_link;\n\tstruct file *file;\n\tunsigned int flags;\n\tint err, fd;\n\n\tif (link->ops != &bpf_iter_link_lops)\n\t\treturn -EINVAL;\n\n\tflags = O_RDONLY | O_CLOEXEC;\n\tfd = get_unused_fd_flags(flags);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfile = anon_inode_getfile(\"bpf_iter\", &bpf_iter_fops, NULL, flags);\n\tif (IS_ERR(file)) {\n\t\terr = PTR_ERR(file);\n\t\tgoto free_fd;\n\t}\n\n\titer_link = container_of(link, struct bpf_iter_link, link);\n\terr = prepare_seq_file(file, iter_link, __get_seq_info(iter_link));\n\tif (err)\n\t\tgoto free_file;\n\n\tfd_install(fd, file);\n\treturn fd;\n\nfree_file:\n\tfput(file);\nfree_fd:\n\tput_unused_fd(fd);\n\treturn err;\n}"
  },
  {
    "function_name": "prepare_seq_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "579-622",
    "snippet": "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info)\n{\n\tstruct bpf_iter_priv_data *priv_data;\n\tstruct bpf_iter_target_info *tinfo;\n\tstruct bpf_prog *prog;\n\tu32 total_priv_dsize;\n\tstruct seq_file *seq;\n\tint err = 0;\n\n\tmutex_lock(&link_mutex);\n\tprog = link->link.prog;\n\tbpf_prog_inc(prog);\n\tmutex_unlock(&link_mutex);\n\n\ttinfo = link->tinfo;\n\ttotal_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +\n\t\t\t   seq_info->seq_priv_size;\n\tpriv_data = __seq_open_private(file, seq_info->seq_ops,\n\t\t\t\t       total_priv_dsize);\n\tif (!priv_data) {\n\t\terr = -ENOMEM;\n\t\tgoto release_prog;\n\t}\n\n\tif (seq_info->init_seq_private) {\n\t\terr = seq_info->init_seq_private(priv_data->target_private, &link->aux);\n\t\tif (err)\n\t\t\tgoto release_seq_file;\n\t}\n\n\tinit_seq_meta(priv_data, tinfo, seq_info, prog);\n\tseq = file->private_data;\n\tseq->private = priv_data->target_private;\n\n\treturn 0;\n\nrelease_seq_file:\n\tseq_release_private(file->f_inode, file);\n\tfile->private_data = NULL;\nrelease_prog:\n\tbpf_prog_put(prog);\n\treturn err;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(link_mutex);",
      "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_release_private",
          "args": [
            "file->f_inode",
            "file"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_seq_meta",
          "args": [
            "priv_data",
            "tinfo",
            "seq_info",
            "prog"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "init_seq_meta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "566-577",
          "snippet": "static void init_seq_meta(struct bpf_iter_priv_data *priv_data,\n\t\t\t  struct bpf_iter_target_info *tinfo,\n\t\t\t  const struct bpf_iter_seq_info *seq_info,\n\t\t\t  struct bpf_prog *prog)\n{\n\tpriv_data->tinfo = tinfo;\n\tpriv_data->seq_info = seq_info;\n\tpriv_data->prog = prog;\n\tpriv_data->session_id = atomic64_inc_return(&session_id);\n\tpriv_data->seq_num = 0;\n\tpriv_data->done_stop = false;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic64_t session_id;",
            "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic atomic64_t session_id;\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);\n\nstatic void init_seq_meta(struct bpf_iter_priv_data *priv_data,\n\t\t\t  struct bpf_iter_target_info *tinfo,\n\t\t\t  const struct bpf_iter_seq_info *seq_info,\n\t\t\t  struct bpf_prog *prog)\n{\n\tpriv_data->tinfo = tinfo;\n\tpriv_data->seq_info = seq_info;\n\tpriv_data->prog = prog;\n\tpriv_data->session_id = atomic64_inc_return(&session_id);\n\tpriv_data->seq_num = 0;\n\tpriv_data->done_stop = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_info->init_seq_private",
          "args": [
            "priv_data->target_private",
            "&link->aux"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "seq_info->seq_ops",
            "total_priv_dsize"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&link_mutex"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_inc",
          "args": [
            "prog"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1963-1973",
          "snippet": "struct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&link_mutex"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic DEFINE_MUTEX(link_mutex);\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);\n\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info)\n{\n\tstruct bpf_iter_priv_data *priv_data;\n\tstruct bpf_iter_target_info *tinfo;\n\tstruct bpf_prog *prog;\n\tu32 total_priv_dsize;\n\tstruct seq_file *seq;\n\tint err = 0;\n\n\tmutex_lock(&link_mutex);\n\tprog = link->link.prog;\n\tbpf_prog_inc(prog);\n\tmutex_unlock(&link_mutex);\n\n\ttinfo = link->tinfo;\n\ttotal_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +\n\t\t\t   seq_info->seq_priv_size;\n\tpriv_data = __seq_open_private(file, seq_info->seq_ops,\n\t\t\t\t       total_priv_dsize);\n\tif (!priv_data) {\n\t\terr = -ENOMEM;\n\t\tgoto release_prog;\n\t}\n\n\tif (seq_info->init_seq_private) {\n\t\terr = seq_info->init_seq_private(priv_data->target_private, &link->aux);\n\t\tif (err)\n\t\t\tgoto release_seq_file;\n\t}\n\n\tinit_seq_meta(priv_data, tinfo, seq_info, prog);\n\tseq = file->private_data;\n\tseq->private = priv_data->target_private;\n\n\treturn 0;\n\nrelease_seq_file:\n\tseq_release_private(file->f_inode, file);\n\tfile->private_data = NULL;\nrelease_prog:\n\tbpf_prog_put(prog);\n\treturn err;\n}"
  },
  {
    "function_name": "init_seq_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "566-577",
    "snippet": "static void init_seq_meta(struct bpf_iter_priv_data *priv_data,\n\t\t\t  struct bpf_iter_target_info *tinfo,\n\t\t\t  const struct bpf_iter_seq_info *seq_info,\n\t\t\t  struct bpf_prog *prog)\n{\n\tpriv_data->tinfo = tinfo;\n\tpriv_data->seq_info = seq_info;\n\tpriv_data->prog = prog;\n\tpriv_data->session_id = atomic64_inc_return(&session_id);\n\tpriv_data->seq_num = 0;\n\tpriv_data->done_stop = false;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic64_t session_id;",
      "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_inc_return",
          "args": [
            "&session_id"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic atomic64_t session_id;\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);\n\nstatic void init_seq_meta(struct bpf_iter_priv_data *priv_data,\n\t\t\t  struct bpf_iter_target_info *tinfo,\n\t\t\t  const struct bpf_iter_seq_info *seq_info,\n\t\t\t  struct bpf_prog *prog)\n{\n\tpriv_data->tinfo = tinfo;\n\tpriv_data->seq_info = seq_info;\n\tpriv_data->prog = prog;\n\tpriv_data->session_id = atomic64_inc_return(&session_id);\n\tpriv_data->seq_num = 0;\n\tpriv_data->done_stop = false;\n}"
  },
  {
    "function_name": "bpf_iter_link_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "498-564",
    "snippet": "int bpf_iter_link_attach(const union bpf_attr *attr, bpfptr_t uattr,\n\t\t\t struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_iter_target_info *tinfo;\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_iter_link *link;\n\tu32 prog_btf_id, linfo_len;\n\tbool existed = false;\n\tbpfptr_t ulinfo;\n\tint err;\n\n\tif (attr->link_create.target_fd || attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tmemset(&linfo, 0, sizeof(union bpf_iter_link_info));\n\n\tulinfo = make_bpfptr(attr->link_create.iter_info, uattr.is_kernel);\n\tlinfo_len = attr->link_create.iter_info_len;\n\tif (bpfptr_is_null(ulinfo) ^ !linfo_len)\n\t\treturn -EINVAL;\n\n\tif (!bpfptr_is_null(ulinfo)) {\n\t\terr = bpf_check_uarg_tail_zero(ulinfo, sizeof(linfo),\n\t\t\t\t\t       linfo_len);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlinfo_len = min_t(u32, linfo_len, sizeof(linfo));\n\t\tif (copy_from_bpfptr(&linfo, ulinfo, linfo_len))\n\t\t\treturn -EFAULT;\n\t}\n\n\tprog_btf_id = prog->aux->attach_btf_id;\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (tinfo->btf_id == prog_btf_id) {\n\t\t\texisted = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\tif (!existed)\n\t\treturn -ENOENT;\n\n\tlink = kzalloc(sizeof(*link), GFP_USER | __GFP_NOWARN);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_ITER, &bpf_iter_link_lops, prog);\n\tlink->tinfo = tinfo;\n\n\terr  = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\treturn err;\n\t}\n\n\tif (tinfo->reg_info->attach_target) {\n\t\terr = tinfo->reg_info->attach_target(prog, &linfo, &link->aux);\n\t\tif (err) {\n\t\t\tbpf_link_cleanup(&link_primer);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head targets = LIST_HEAD_INIT(targets);",
      "static DEFINE_MUTEX(targets_mutex);",
      "static const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_link_settle",
          "args": [
            "&link_primer"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_settle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2598-2608",
          "snippet": "int bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nint bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_cleanup",
          "args": [
            "&link_primer"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2443-2449",
          "snippet": "void bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tinfo->reg_info->attach_target",
          "args": [
            "prog",
            "&linfo",
            "&link->aux"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_prime",
          "args": [
            "&link->link",
            "&link_primer"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_prime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2568-2596",
          "snippet": "int bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_init",
          "args": [
            "&link->link",
            "BPF_LINK_TYPE_ITER",
            "&bpf_iter_link_lops",
            "prog"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2416-2424",
          "snippet": "void bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*link)",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&targets_mutex"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tinfo",
            "&targets",
            "list"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&targets_mutex"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_bpfptr",
          "args": [
            "&linfo",
            "ulinfo",
            "linfo_len"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "linfo_len",
            "sizeof(linfo)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_check_uarg_tail_zero",
          "args": [
            "ulinfo",
            "sizeof(linfo)",
            "linfo_len"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_uarg_tail_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "77-98",
          "snippet": "int bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpfptr_is_null",
          "args": [
            "ulinfo"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfptr_is_null",
          "args": [
            "ulinfo"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bpfptr",
          "args": [
            "attr->link_create.iter_info",
            "uattr.is_kernel"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&linfo",
            "0",
            "sizeof(union bpf_iter_link_info)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic struct list_head targets = LIST_HEAD_INIT(targets);\nstatic DEFINE_MUTEX(targets_mutex);\nstatic const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};\n\nint bpf_iter_link_attach(const union bpf_attr *attr, bpfptr_t uattr,\n\t\t\t struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_iter_target_info *tinfo;\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_iter_link *link;\n\tu32 prog_btf_id, linfo_len;\n\tbool existed = false;\n\tbpfptr_t ulinfo;\n\tint err;\n\n\tif (attr->link_create.target_fd || attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tmemset(&linfo, 0, sizeof(union bpf_iter_link_info));\n\n\tulinfo = make_bpfptr(attr->link_create.iter_info, uattr.is_kernel);\n\tlinfo_len = attr->link_create.iter_info_len;\n\tif (bpfptr_is_null(ulinfo) ^ !linfo_len)\n\t\treturn -EINVAL;\n\n\tif (!bpfptr_is_null(ulinfo)) {\n\t\terr = bpf_check_uarg_tail_zero(ulinfo, sizeof(linfo),\n\t\t\t\t\t       linfo_len);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlinfo_len = min_t(u32, linfo_len, sizeof(linfo));\n\t\tif (copy_from_bpfptr(&linfo, ulinfo, linfo_len))\n\t\t\treturn -EFAULT;\n\t}\n\n\tprog_btf_id = prog->aux->attach_btf_id;\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (tinfo->btf_id == prog_btf_id) {\n\t\t\texisted = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\tif (!existed)\n\t\treturn -ENOENT;\n\n\tlink = kzalloc(sizeof(*link), GFP_USER | __GFP_NOWARN);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_ITER, &bpf_iter_link_lops, prog);\n\tlink->tinfo = tinfo;\n\n\terr  = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\treturn err;\n\t}\n\n\tif (tinfo->reg_info->attach_target) {\n\t\terr = tinfo->reg_info->attach_target(prog, &linfo, &link->aux);\n\t\tif (err) {\n\t\t\tbpf_link_cleanup(&link_primer);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n}"
  },
  {
    "function_name": "bpf_link_is_iter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "493-496",
    "snippet": "bool bpf_link_is_iter(struct bpf_link *link)\n{\n\treturn link->ops == &bpf_iter_link_lops;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};\n\nbool bpf_link_is_iter(struct bpf_link *link)\n{\n\treturn link->ops == &bpf_iter_link_lops;\n}"
  },
  {
    "function_name": "bpf_iter_link_fill_link_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "445-483",
    "snippet": "static int bpf_iter_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t\tstruct bpf_link_info *info)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\tchar __user *ubuf = u64_to_user_ptr(info->iter.target_name);\n\tbpf_iter_fill_link_info_t fill_link_info;\n\tu32 ulen = info->iter.target_name_len;\n\tconst char *target_name;\n\tu32 target_len;\n\n\tif (!ulen ^ !ubuf)\n\t\treturn -EINVAL;\n\n\ttarget_name = iter_link->tinfo->reg_info->target;\n\ttarget_len =  strlen(target_name);\n\tinfo->iter.target_name_len = target_len + 1;\n\n\tif (ubuf) {\n\t\tif (ulen >= target_len + 1) {\n\t\t\tif (copy_to_user(ubuf, target_name, target_len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (copy_to_user(ubuf, target_name, ulen - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + ulen - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\n\tfill_link_info = iter_link->tinfo->reg_info->fill_link_info;\n\tif (fill_link_info)\n\t\treturn fill_link_info(&iter_link->aux, info);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill_link_info",
          "args": [
            "&iter_link->aux",
            "info"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_link_fill_link_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "445-483",
          "snippet": "static int bpf_iter_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t\tstruct bpf_link_info *info)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\tchar __user *ubuf = u64_to_user_ptr(info->iter.target_name);\n\tbpf_iter_fill_link_info_t fill_link_info;\n\tu32 ulen = info->iter.target_name_len;\n\tconst char *target_name;\n\tu32 target_len;\n\n\tif (!ulen ^ !ubuf)\n\t\treturn -EINVAL;\n\n\ttarget_name = iter_link->tinfo->reg_info->target;\n\ttarget_len =  strlen(target_name);\n\tinfo->iter.target_name_len = target_len + 1;\n\n\tif (ubuf) {\n\t\tif (ulen >= target_len + 1) {\n\t\t\tif (copy_to_user(ubuf, target_name, target_len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (copy_to_user(ubuf, target_name, ulen - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + ulen - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\n\tfill_link_info = iter_link->tinfo->reg_info->fill_link_info;\n\tif (fill_link_info)\n\t\treturn fill_link_info(&iter_link->aux, info);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "zero",
            "ubuf + ulen - 1"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ubuf",
            "target_name",
            "ulen - 1"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target_name"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info->iter.target_name"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_iter_link",
            "link"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic int bpf_iter_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t\tstruct bpf_link_info *info)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\tchar __user *ubuf = u64_to_user_ptr(info->iter.target_name);\n\tbpf_iter_fill_link_info_t fill_link_info;\n\tu32 ulen = info->iter.target_name_len;\n\tconst char *target_name;\n\tu32 target_len;\n\n\tif (!ulen ^ !ubuf)\n\t\treturn -EINVAL;\n\n\ttarget_name = iter_link->tinfo->reg_info->target;\n\ttarget_len =  strlen(target_name);\n\tinfo->iter.target_name_len = target_len + 1;\n\n\tif (ubuf) {\n\t\tif (ulen >= target_len + 1) {\n\t\t\tif (copy_to_user(ubuf, target_name, target_len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (copy_to_user(ubuf, target_name, ulen - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + ulen - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\n\tfill_link_info = iter_link->tinfo->reg_info->fill_link_info;\n\tif (fill_link_info)\n\t\treturn fill_link_info(&iter_link->aux, info);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_iter_link_show_fdinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "429-443",
    "snippet": "static void bpf_iter_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t      struct seq_file *seq)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\tbpf_iter_show_fdinfo_t show_fdinfo;\n\n\tseq_printf(seq,\n\t\t   \"target_name:\\t%s\\n\",\n\t\t   iter_link->tinfo->reg_info->target);\n\n\tshow_fdinfo = iter_link->tinfo->reg_info->show_fdinfo;\n\tif (show_fdinfo)\n\t\tshow_fdinfo(&iter_link->aux, seq);\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_fdinfo",
          "args": [
            "&iter_link->aux",
            "seq"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_link_show_fdinfo",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "429-443",
          "snippet": "static void bpf_iter_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t      struct seq_file *seq)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\tbpf_iter_show_fdinfo_t show_fdinfo;\n\n\tseq_printf(seq,\n\t\t   \"target_name:\\t%s\\n\",\n\t\t   iter_link->tinfo->reg_info->target);\n\n\tshow_fdinfo = iter_link->tinfo->reg_info->show_fdinfo;\n\tif (show_fdinfo)\n\t\tshow_fdinfo(&iter_link->aux, seq);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"target_name:\\t%s\\n\"",
            "iter_link->tinfo->reg_info->target"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_iter_link",
            "link"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic void bpf_iter_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t      struct seq_file *seq)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\tbpf_iter_show_fdinfo_t show_fdinfo;\n\n\tseq_printf(seq,\n\t\t   \"target_name:\\t%s\\n\",\n\t\t   iter_link->tinfo->reg_info->target);\n\n\tshow_fdinfo = iter_link->tinfo->reg_info->show_fdinfo;\n\tif (show_fdinfo)\n\t\tshow_fdinfo(&iter_link->aux, seq);\n}"
  },
  {
    "function_name": "bpf_iter_link_replace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "402-427",
    "snippet": "static int bpf_iter_link_replace(struct bpf_link *link,\n\t\t\t\t struct bpf_prog *new_prog,\n\t\t\t\t struct bpf_prog *old_prog)\n{\n\tint ret = 0;\n\n\tmutex_lock(&link_mutex);\n\tif (old_prog && link->prog != old_prog) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\tif (link->prog->type != new_prog->type ||\n\t    link->prog->expected_attach_type != new_prog->expected_attach_type ||\n\t    link->prog->aux->attach_btf_id != new_prog->aux->attach_btf_id) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\told_prog = xchg(&link->prog, new_prog);\n\tbpf_prog_put(old_prog);\n\nout_unlock:\n\tmutex_unlock(&link_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(link_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&link_mutex"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "old_prog"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&link->prog",
            "new_prog"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&link_mutex"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic DEFINE_MUTEX(link_mutex);\n\nstatic int bpf_iter_link_replace(struct bpf_link *link,\n\t\t\t\t struct bpf_prog *new_prog,\n\t\t\t\t struct bpf_prog *old_prog)\n{\n\tint ret = 0;\n\n\tmutex_lock(&link_mutex);\n\tif (old_prog && link->prog != old_prog) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\tif (link->prog->type != new_prog->type ||\n\t    link->prog->expected_attach_type != new_prog->expected_attach_type ||\n\t    link->prog->aux->attach_btf_id != new_prog->aux->attach_btf_id) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\told_prog = xchg(&link->prog, new_prog);\n\tbpf_prog_put(old_prog);\n\nout_unlock:\n\tmutex_unlock(&link_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_iter_link_dealloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "394-400",
    "snippet": "static void bpf_iter_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\n\tkfree(iter_link);\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iter_link"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_iter_link",
            "link"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic void bpf_iter_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\n\tkfree(iter_link);\n}"
  },
  {
    "function_name": "bpf_iter_link_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "385-392",
    "snippet": "static void bpf_iter_link_release(struct bpf_link *link)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\n\tif (iter_link->tinfo->reg_info->detach_target)\n\t\titer_link->tinfo->reg_info->detach_target(&iter_link->aux);\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter_link->tinfo->reg_info->detach_target",
          "args": [
            "&iter_link->aux"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_iter_link",
            "link"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic void bpf_iter_link_release(struct bpf_link *link)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\n\tif (iter_link->tinfo->reg_info->detach_target)\n\t\titer_link->tinfo->reg_info->detach_target(&iter_link->aux);\n}"
  },
  {
    "function_name": "bpf_iter_get_func_proto",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "363-383",
    "snippet": "const struct bpf_func_proto *\nbpf_iter_get_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tconst struct bpf_iter_target_info *tinfo;\n\tconst struct bpf_func_proto *fn = NULL;\n\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (tinfo->btf_id == prog->aux->attach_btf_id) {\n\t\t\tconst struct bpf_iter_reg *reg_info;\n\n\t\t\treg_info = tinfo->reg_info;\n\t\t\tif (reg_info->get_func_proto)\n\t\t\t\tfn = reg_info->get_func_proto(func_id, prog);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\n\treturn fn;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head targets = LIST_HEAD_INIT(targets);",
      "static DEFINE_MUTEX(targets_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&targets_mutex"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reg_info->get_func_proto",
          "args": [
            "func_id",
            "prog"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tinfo",
            "&targets",
            "list"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&targets_mutex"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic struct list_head targets = LIST_HEAD_INIT(targets);\nstatic DEFINE_MUTEX(targets_mutex);\n\nconst struct bpf_func_proto *\nbpf_iter_get_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tconst struct bpf_iter_target_info *tinfo;\n\tconst struct bpf_func_proto *fn = NULL;\n\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (tinfo->btf_id == prog->aux->attach_btf_id) {\n\t\t\tconst struct bpf_iter_reg *reg_info;\n\n\t\t\treg_info = tinfo->reg_info;\n\t\t\tif (reg_info->get_func_proto)\n\t\t\t\tfn = reg_info->get_func_proto(func_id, prog);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\n\treturn fn;\n}"
  },
  {
    "function_name": "bpf_iter_prog_supported",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "329-361",
    "snippet": "bool bpf_iter_prog_supported(struct bpf_prog *prog)\n{\n\tconst char *attach_fname = prog->aux->attach_func_name;\n\tu32 prog_btf_id = prog->aux->attach_btf_id;\n\tconst char *prefix = BPF_ITER_FUNC_PREFIX;\n\tstruct bpf_iter_target_info *tinfo;\n\tint prefix_len = strlen(prefix);\n\tbool supported = false;\n\n\tif (strncmp(attach_fname, prefix, prefix_len))\n\t\treturn false;\n\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (tinfo->btf_id && tinfo->btf_id == prog_btf_id) {\n\t\t\tsupported = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(attach_fname + prefix_len, tinfo->reg_info->target)) {\n\t\t\tcache_btf_id(tinfo, prog);\n\t\t\tsupported = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\n\tif (supported) {\n\t\tprog->aux->ctx_arg_info_size = tinfo->reg_info->ctx_arg_info_size;\n\t\tprog->aux->ctx_arg_info = tinfo->reg_info->ctx_arg_info;\n\t}\n\n\treturn supported;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head targets = LIST_HEAD_INIT(targets);",
      "static DEFINE_MUTEX(targets_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&targets_mutex"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_btf_id",
          "args": [
            "tinfo",
            "prog"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "cache_btf_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "323-327",
          "snippet": "static void cache_btf_id(struct bpf_iter_target_info *tinfo,\n\t\t\t struct bpf_prog *prog)\n{\n\ttinfo->btf_id = prog->aux->attach_btf_id;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic void cache_btf_id(struct bpf_iter_target_info *tinfo,\n\t\t\t struct bpf_prog *prog)\n{\n\ttinfo->btf_id = prog->aux->attach_btf_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "attach_fname + prefix_len",
            "tinfo->reg_info->target"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tinfo",
            "&targets",
            "list"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&targets_mutex"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "attach_fname",
            "prefix",
            "prefix_len"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic struct list_head targets = LIST_HEAD_INIT(targets);\nstatic DEFINE_MUTEX(targets_mutex);\n\nbool bpf_iter_prog_supported(struct bpf_prog *prog)\n{\n\tconst char *attach_fname = prog->aux->attach_func_name;\n\tu32 prog_btf_id = prog->aux->attach_btf_id;\n\tconst char *prefix = BPF_ITER_FUNC_PREFIX;\n\tstruct bpf_iter_target_info *tinfo;\n\tint prefix_len = strlen(prefix);\n\tbool supported = false;\n\n\tif (strncmp(attach_fname, prefix, prefix_len))\n\t\treturn false;\n\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (tinfo->btf_id && tinfo->btf_id == prog_btf_id) {\n\t\t\tsupported = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(attach_fname + prefix_len, tinfo->reg_info->target)) {\n\t\t\tcache_btf_id(tinfo, prog);\n\t\t\tsupported = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\n\tif (supported) {\n\t\tprog->aux->ctx_arg_info_size = tinfo->reg_info->ctx_arg_info_size;\n\t\tprog->aux->ctx_arg_info = tinfo->reg_info->ctx_arg_info;\n\t}\n\n\treturn supported;\n}"
  },
  {
    "function_name": "cache_btf_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "323-327",
    "snippet": "static void cache_btf_id(struct bpf_iter_target_info *tinfo,\n\t\t\t struct bpf_prog *prog)\n{\n\ttinfo->btf_id = prog->aux->attach_btf_id;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic void cache_btf_id(struct bpf_iter_target_info *tinfo,\n\t\t\t struct bpf_prog *prog)\n{\n\ttinfo->btf_id = prog->aux->attach_btf_id;\n}"
  },
  {
    "function_name": "bpf_iter_unreg_target",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "304-321",
    "snippet": "void bpf_iter_unreg_target(const struct bpf_iter_reg *reg_info)\n{\n\tstruct bpf_iter_target_info *tinfo;\n\tbool found = false;\n\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (reg_info == tinfo->reg_info) {\n\t\t\tlist_del(&tinfo->list);\n\t\t\tkfree(tinfo);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\n\tWARN_ON(found == false);\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head targets = LIST_HEAD_INIT(targets);",
      "static DEFINE_MUTEX(targets_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "found == false"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&targets_mutex"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tinfo"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tinfo->list"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tinfo",
            "&targets",
            "list"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&targets_mutex"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic struct list_head targets = LIST_HEAD_INIT(targets);\nstatic DEFINE_MUTEX(targets_mutex);\n\nvoid bpf_iter_unreg_target(const struct bpf_iter_reg *reg_info)\n{\n\tstruct bpf_iter_target_info *tinfo;\n\tbool found = false;\n\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (reg_info == tinfo->reg_info) {\n\t\t\tlist_del(&tinfo->list);\n\t\t\tkfree(tinfo);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\n\tWARN_ON(found == false);\n}"
  },
  {
    "function_name": "bpf_iter_reg_target",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "286-302",
    "snippet": "int bpf_iter_reg_target(const struct bpf_iter_reg *reg_info)\n{\n\tstruct bpf_iter_target_info *tinfo;\n\n\ttinfo = kzalloc(sizeof(*tinfo), GFP_KERNEL);\n\tif (!tinfo)\n\t\treturn -ENOMEM;\n\n\ttinfo->reg_info = reg_info;\n\tINIT_LIST_HEAD(&tinfo->list);\n\n\tmutex_lock(&targets_mutex);\n\tlist_add(&tinfo->list, &targets);\n\tmutex_unlock(&targets_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head targets = LIST_HEAD_INIT(targets);",
      "static DEFINE_MUTEX(targets_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&targets_mutex"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tinfo->list",
            "&targets"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&targets_mutex"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tinfo->list"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tinfo)",
            "GFP_KERNEL"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic struct list_head targets = LIST_HEAD_INIT(targets);\nstatic DEFINE_MUTEX(targets_mutex);\n\nint bpf_iter_reg_target(const struct bpf_iter_reg *reg_info)\n{\n\tstruct bpf_iter_target_info *tinfo;\n\n\ttinfo = kzalloc(sizeof(*tinfo), GFP_KERNEL);\n\tif (!tinfo)\n\t\treturn -ENOMEM;\n\n\ttinfo->reg_info = reg_info;\n\tINIT_LIST_HEAD(&tinfo->list);\n\n\tmutex_lock(&targets_mutex);\n\tlist_add(&tinfo->list, &targets);\n\tmutex_unlock(&targets_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iter_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "253-272",
    "snippet": "static int iter_release(struct inode *inode, struct file *file)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\tif (!seq)\n\t\treturn 0;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (iter_priv->seq_info->fini_seq_private)\n\t\titer_priv->seq_info->fini_seq_private(seq->private);\n\n\tbpf_prog_put(iter_priv->prog);\n\tseq->private = iter_priv;\n\n\treturn seq_release_private(inode, file);\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release_private",
          "args": [
            "inode",
            "file"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "iter_priv->prog"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_priv->seq_info->fini_seq_private",
          "args": [
            "seq->private"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "seq->private",
            "structbpf_iter_priv_data",
            "target_private"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);\n\nstatic int iter_release(struct inode *inode, struct file *file)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\tif (!seq)\n\t\treturn 0;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (iter_priv->seq_info->fini_seq_private)\n\t\titer_priv->seq_info->fini_seq_private(seq->private);\n\n\tbpf_prog_put(iter_priv->prog);\n\tseq->private = iter_priv;\n\n\treturn seq_release_private(inode, file);\n}"
  },
  {
    "function_name": "iter_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "246-251",
    "snippet": "static int iter_open(struct inode *inode, struct file *file)\n{\n\tstruct bpf_iter_link *link = inode->i_private;\n\n\treturn prepare_seq_file(file, link, __get_seq_info(link));\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prepare_seq_file",
          "args": [
            "file",
            "link",
            "__get_seq_info(link)"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_seq_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "579-622",
          "snippet": "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info)\n{\n\tstruct bpf_iter_priv_data *priv_data;\n\tstruct bpf_iter_target_info *tinfo;\n\tstruct bpf_prog *prog;\n\tu32 total_priv_dsize;\n\tstruct seq_file *seq;\n\tint err = 0;\n\n\tmutex_lock(&link_mutex);\n\tprog = link->link.prog;\n\tbpf_prog_inc(prog);\n\tmutex_unlock(&link_mutex);\n\n\ttinfo = link->tinfo;\n\ttotal_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +\n\t\t\t   seq_info->seq_priv_size;\n\tpriv_data = __seq_open_private(file, seq_info->seq_ops,\n\t\t\t\t       total_priv_dsize);\n\tif (!priv_data) {\n\t\terr = -ENOMEM;\n\t\tgoto release_prog;\n\t}\n\n\tif (seq_info->init_seq_private) {\n\t\terr = seq_info->init_seq_private(priv_data->target_private, &link->aux);\n\t\tif (err)\n\t\t\tgoto release_seq_file;\n\t}\n\n\tinit_seq_meta(priv_data, tinfo, seq_info, prog);\n\tseq = file->private_data;\n\tseq->private = priv_data->target_private;\n\n\treturn 0;\n\nrelease_seq_file:\n\tseq_release_private(file->f_inode, file);\n\tfile->private_data = NULL;\nrelease_prog:\n\tbpf_prog_put(prog);\n\treturn err;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(link_mutex);",
            "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic DEFINE_MUTEX(link_mutex);\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);\n\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info)\n{\n\tstruct bpf_iter_priv_data *priv_data;\n\tstruct bpf_iter_target_info *tinfo;\n\tstruct bpf_prog *prog;\n\tu32 total_priv_dsize;\n\tstruct seq_file *seq;\n\tint err = 0;\n\n\tmutex_lock(&link_mutex);\n\tprog = link->link.prog;\n\tbpf_prog_inc(prog);\n\tmutex_unlock(&link_mutex);\n\n\ttinfo = link->tinfo;\n\ttotal_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +\n\t\t\t   seq_info->seq_priv_size;\n\tpriv_data = __seq_open_private(file, seq_info->seq_ops,\n\t\t\t\t       total_priv_dsize);\n\tif (!priv_data) {\n\t\terr = -ENOMEM;\n\t\tgoto release_prog;\n\t}\n\n\tif (seq_info->init_seq_private) {\n\t\terr = seq_info->init_seq_private(priv_data->target_private, &link->aux);\n\t\tif (err)\n\t\t\tgoto release_seq_file;\n\t}\n\n\tinit_seq_meta(priv_data, tinfo, seq_info, prog);\n\tseq = file->private_data;\n\tseq->private = priv_data->target_private;\n\n\treturn 0;\n\nrelease_seq_file:\n\tseq_release_private(file->f_inode, file);\n\tfile->private_data = NULL;\nrelease_prog:\n\tbpf_prog_put(prog);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_seq_info",
          "args": [
            "link"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "__get_seq_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "232-244",
          "snippet": "static const struct bpf_iter_seq_info *\n__get_seq_info(struct bpf_iter_link *link)\n{\n\tconst struct bpf_iter_seq_info *seq_info;\n\n\tif (link->aux.map) {\n\t\tseq_info = link->aux.map->ops->iter_seq_info;\n\t\tif (seq_info)\n\t\t\treturn seq_info;\n\t}\n\n\treturn link->tinfo->reg_info->seq_info;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);\n\nstatic const struct bpf_iter_seq_info *\n__get_seq_info(struct bpf_iter_link *link)\n{\n\tconst struct bpf_iter_seq_info *seq_info;\n\n\tif (link->aux.map) {\n\t\tseq_info = link->aux.map->ops->iter_seq_info;\n\t\tif (seq_info)\n\t\t\treturn seq_info;\n\t}\n\n\treturn link->tinfo->reg_info->seq_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic int iter_open(struct inode *inode, struct file *file)\n{\n\tstruct bpf_iter_link *link = inode->i_private;\n\n\treturn prepare_seq_file(file, link, __get_seq_info(link));\n}"
  },
  {
    "function_name": "__get_seq_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "232-244",
    "snippet": "static const struct bpf_iter_seq_info *\n__get_seq_info(struct bpf_iter_link *link)\n{\n\tconst struct bpf_iter_seq_info *seq_info;\n\n\tif (link->aux.map) {\n\t\tseq_info = link->aux.map->ops->iter_seq_info;\n\t\tif (seq_info)\n\t\t\treturn seq_info;\n\t}\n\n\treturn link->tinfo->reg_info->seq_info;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);\n\nstatic const struct bpf_iter_seq_info *\n__get_seq_info(struct bpf_iter_link *link)\n{\n\tconst struct bpf_iter_seq_info *seq_info;\n\n\tif (link->aux.map) {\n\t\tseq_info = link->aux.map->ops->iter_seq_info;\n\t\tif (seq_info)\n\t\t\treturn seq_info;\n\t}\n\n\treturn link->tinfo->reg_info->seq_info;\n}"
  },
  {
    "function_name": "bpf_seq_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "89-230",
    "snippet": "static ssize_t bpf_seq_read(struct file *file, char __user *buf, size_t size,\n\t\t\t    loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tsize_t n, offs, copied = 0;\n\tint err = 0, num_objs = 0;\n\tbool can_resched;\n\tvoid *p;\n\n\tmutex_lock(&seq->lock);\n\n\tif (!seq->buf) {\n\t\tseq->size = PAGE_SIZE << 3;\n\t\tseq->buf = kvmalloc(seq->size, GFP_KERNEL);\n\t\tif (!seq->buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (seq->count) {\n\t\tn = min(seq->count, size);\n\t\terr = copy_to_user(buf, seq->buf + seq->from, n);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tseq->count -= n;\n\t\tseq->from += n;\n\t\tcopied = n;\n\t\tgoto done;\n\t}\n\n\tseq->from = 0;\n\tp = seq->op->start(seq, &seq->index);\n\tif (!p)\n\t\tgoto stop;\n\tif (IS_ERR(p)) {\n\t\terr = PTR_ERR(p);\n\t\tseq->op->stop(seq, p);\n\t\tseq->count = 0;\n\t\tgoto done;\n\t}\n\n\terr = seq->op->show(seq, p);\n\tif (err > 0) {\n\t\t/* object is skipped, decrease seq_num, so next\n\t\t * valid object can reuse the same seq_num.\n\t\t */\n\t\tbpf_iter_dec_seq_num(seq);\n\t\tseq->count = 0;\n\t} else if (err < 0 || seq_has_overflowed(seq)) {\n\t\tif (!err)\n\t\t\terr = -E2BIG;\n\t\tseq->op->stop(seq, p);\n\t\tseq->count = 0;\n\t\tgoto done;\n\t}\n\n\tcan_resched = bpf_iter_support_resched(seq);\n\twhile (1) {\n\t\tloff_t pos = seq->index;\n\n\t\tnum_objs++;\n\t\toffs = seq->count;\n\t\tp = seq->op->next(seq, p, &seq->index);\n\t\tif (pos == seq->index) {\n\t\t\tpr_info_ratelimited(\"buggy seq_file .next function %ps \"\n\t\t\t\t\"did not updated position index\\n\",\n\t\t\t\tseq->op->next);\n\t\t\tseq->index++;\n\t\t}\n\n\t\tif (IS_ERR_OR_NULL(p))\n\t\t\tbreak;\n\n\t\t/* got a valid next object, increase seq_num */\n\t\tbpf_iter_inc_seq_num(seq);\n\n\t\tif (seq->count >= size)\n\t\t\tbreak;\n\n\t\tif (num_objs >= MAX_ITER_OBJECTS) {\n\t\t\tif (offs == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tseq->op->stop(seq, p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\terr = seq->op->show(seq, p);\n\t\tif (err > 0) {\n\t\t\tbpf_iter_dec_seq_num(seq);\n\t\t\tseq->count = offs;\n\t\t} else if (err < 0 || seq_has_overflowed(seq)) {\n\t\t\tseq->count = offs;\n\t\t\tif (offs == 0) {\n\t\t\t\tif (!err)\n\t\t\t\t\terr = -E2BIG;\n\t\t\t\tseq->op->stop(seq, p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (can_resched)\n\t\t\tcond_resched();\n\t}\nstop:\n\toffs = seq->count;\n\t/* bpf program called if !p */\n\tseq->op->stop(seq, p);\n\tif (!p) {\n\t\tif (!seq_has_overflowed(seq)) {\n\t\t\tbpf_iter_done_stop(seq);\n\t\t} else {\n\t\t\tseq->count = offs;\n\t\t\tif (offs == 0) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\tn = min(seq->count, size);\n\terr = copy_to_user(buf, seq->buf, n);\n\tif (err) {\n\t\terr = -EFAULT;\n\t\tgoto done;\n\t}\n\tcopied = n;\n\tseq->count -= n;\n\tseq->from = n;\ndone:\n\tif (!copied)\n\t\tcopied = err;\n\telse\n\t\t*ppos += copied;\n\tmutex_unlock(&seq->lock);\n\treturn copied;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MAX_ITER_OBJECTS\t1000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&seq->lock"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "seq->buf",
            "n"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "seq->count",
            "size"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "__reg_combine_min_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "9059-9087",
          "snippet": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_iter_done_stop",
          "args": [
            "seq"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_done_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "61-68",
          "snippet": "static void bpf_iter_done_stop(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->done_stop = true;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic void bpf_iter_done_stop(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->done_stop = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "seq"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq->op->stop",
          "args": [
            "seq",
            "p"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq->op->stop",
          "args": [
            "seq",
            "p"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "seq"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_iter_dec_seq_num",
          "args": [
            "seq"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_dec_seq_num",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "52-59",
          "snippet": "static void bpf_iter_dec_seq_num(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->seq_num--;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic void bpf_iter_dec_seq_num(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->seq_num--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq->op->show",
          "args": [
            "seq",
            "p"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq->op->stop",
          "args": [
            "seq",
            "p"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_iter_inc_seq_num",
          "args": [
            "seq"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_inc_seq_num",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "43-50",
          "snippet": "static void bpf_iter_inc_seq_num(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->seq_num++;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic void bpf_iter_inc_seq_num(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->seq_num++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "p"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info_ratelimited",
          "args": [
            "\"buggy seq_file .next function %ps \"\n\t\t\t\t\"did not updated position index\\n\"",
            "seq->op->next"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq->op->next",
          "args": [
            "seq",
            "p",
            "&seq->index"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_iter_support_resched",
          "args": [
            "seq"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_support_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "70-77",
          "snippet": "static bool bpf_iter_support_resched(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\treturn iter_priv->tinfo->reg_info->feature & BPF_ITER_RESCHED;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic bool bpf_iter_support_resched(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\treturn iter_priv->tinfo->reg_info->feature & BPF_ITER_RESCHED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq->op->stop",
          "args": [
            "seq",
            "p"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "seq"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq->op->show",
          "args": [
            "seq",
            "p"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq->op->stop",
          "args": [
            "seq",
            "p"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq->op->start",
          "args": [
            "seq",
            "&seq->index"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "seq->size",
            "GFP_KERNEL"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&seq->lock"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\n#define MAX_ITER_OBJECTS\t1000000\n\nstatic ssize_t bpf_seq_read(struct file *file, char __user *buf, size_t size,\n\t\t\t    loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tsize_t n, offs, copied = 0;\n\tint err = 0, num_objs = 0;\n\tbool can_resched;\n\tvoid *p;\n\n\tmutex_lock(&seq->lock);\n\n\tif (!seq->buf) {\n\t\tseq->size = PAGE_SIZE << 3;\n\t\tseq->buf = kvmalloc(seq->size, GFP_KERNEL);\n\t\tif (!seq->buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (seq->count) {\n\t\tn = min(seq->count, size);\n\t\terr = copy_to_user(buf, seq->buf + seq->from, n);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tseq->count -= n;\n\t\tseq->from += n;\n\t\tcopied = n;\n\t\tgoto done;\n\t}\n\n\tseq->from = 0;\n\tp = seq->op->start(seq, &seq->index);\n\tif (!p)\n\t\tgoto stop;\n\tif (IS_ERR(p)) {\n\t\terr = PTR_ERR(p);\n\t\tseq->op->stop(seq, p);\n\t\tseq->count = 0;\n\t\tgoto done;\n\t}\n\n\terr = seq->op->show(seq, p);\n\tif (err > 0) {\n\t\t/* object is skipped, decrease seq_num, so next\n\t\t * valid object can reuse the same seq_num.\n\t\t */\n\t\tbpf_iter_dec_seq_num(seq);\n\t\tseq->count = 0;\n\t} else if (err < 0 || seq_has_overflowed(seq)) {\n\t\tif (!err)\n\t\t\terr = -E2BIG;\n\t\tseq->op->stop(seq, p);\n\t\tseq->count = 0;\n\t\tgoto done;\n\t}\n\n\tcan_resched = bpf_iter_support_resched(seq);\n\twhile (1) {\n\t\tloff_t pos = seq->index;\n\n\t\tnum_objs++;\n\t\toffs = seq->count;\n\t\tp = seq->op->next(seq, p, &seq->index);\n\t\tif (pos == seq->index) {\n\t\t\tpr_info_ratelimited(\"buggy seq_file .next function %ps \"\n\t\t\t\t\"did not updated position index\\n\",\n\t\t\t\tseq->op->next);\n\t\t\tseq->index++;\n\t\t}\n\n\t\tif (IS_ERR_OR_NULL(p))\n\t\t\tbreak;\n\n\t\t/* got a valid next object, increase seq_num */\n\t\tbpf_iter_inc_seq_num(seq);\n\n\t\tif (seq->count >= size)\n\t\t\tbreak;\n\n\t\tif (num_objs >= MAX_ITER_OBJECTS) {\n\t\t\tif (offs == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tseq->op->stop(seq, p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\terr = seq->op->show(seq, p);\n\t\tif (err > 0) {\n\t\t\tbpf_iter_dec_seq_num(seq);\n\t\t\tseq->count = offs;\n\t\t} else if (err < 0 || seq_has_overflowed(seq)) {\n\t\t\tseq->count = offs;\n\t\t\tif (offs == 0) {\n\t\t\t\tif (!err)\n\t\t\t\t\terr = -E2BIG;\n\t\t\t\tseq->op->stop(seq, p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (can_resched)\n\t\t\tcond_resched();\n\t}\nstop:\n\toffs = seq->count;\n\t/* bpf program called if !p */\n\tseq->op->stop(seq, p);\n\tif (!p) {\n\t\tif (!seq_has_overflowed(seq)) {\n\t\t\tbpf_iter_done_stop(seq);\n\t\t} else {\n\t\t\tseq->count = offs;\n\t\t\tif (offs == 0) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\tn = min(seq->count, size);\n\terr = copy_to_user(buf, seq->buf, n);\n\tif (err) {\n\t\terr = -EFAULT;\n\t\tgoto done;\n\t}\n\tcopied = n;\n\tseq->count -= n;\n\tseq->from = n;\ndone:\n\tif (!copied)\n\t\tcopied = err;\n\telse\n\t\t*ppos += copied;\n\tmutex_unlock(&seq->lock);\n\treturn copied;\n}"
  },
  {
    "function_name": "bpf_iter_support_resched",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "70-77",
    "snippet": "static bool bpf_iter_support_resched(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\treturn iter_priv->tinfo->reg_info->feature & BPF_ITER_RESCHED;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "seq->private",
            "structbpf_iter_priv_data",
            "target_private"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic bool bpf_iter_support_resched(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\treturn iter_priv->tinfo->reg_info->feature & BPF_ITER_RESCHED;\n}"
  },
  {
    "function_name": "bpf_iter_done_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "61-68",
    "snippet": "static void bpf_iter_done_stop(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->done_stop = true;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "seq->private",
            "structbpf_iter_priv_data",
            "target_private"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic void bpf_iter_done_stop(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->done_stop = true;\n}"
  },
  {
    "function_name": "bpf_iter_dec_seq_num",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "52-59",
    "snippet": "static void bpf_iter_dec_seq_num(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->seq_num--;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "seq->private",
            "structbpf_iter_priv_data",
            "target_private"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic void bpf_iter_dec_seq_num(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->seq_num--;\n}"
  },
  {
    "function_name": "bpf_iter_inc_seq_num",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
    "lines": "43-50",
    "snippet": "static void bpf_iter_inc_seq_num(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->seq_num++;\n}",
    "includes": [
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "seq->private",
            "structbpf_iter_priv_data",
            "target_private"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic void bpf_iter_inc_seq_num(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->seq_num++;\n}"
  }
]