[
  {
    "function_name": "running_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "479-482",
    "snippet": "u64 __weak running_clock(void)\n{\n\treturn local_clock();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nu64 __weak running_clock(void)\n{\n\treturn local_clock();\n}"
  },
  {
    "function_name": "sched_clock_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "461-467",
    "snippet": "u64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_likely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&sched_clock_running"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nu64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_likely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}"
  },
  {
    "function_name": "sched_clock_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "453-459",
    "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_sched_clock_init",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "generic_sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/sched_clock.c",
          "lines": "228-246",
          "snippet": "void __init generic_sched_clock_init(void)\n{\n\t/*\n\t * If no sched_clock() function has been provided at that point,\n\t * make it the final one.\n\t */\n\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)\n\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);\n\n\tupdate_sched_clock();\n\n\t/*\n\t * Start the timer to keep sched_clock() properly updated and\n\t * sets the initial epoch.\n\t */\n\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\tsched_clock_timer.function = sched_clock_poll;\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hrtimer sched_clock_timer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\n\nvoid __init generic_sched_clock_init(void)\n{\n\t/*\n\t * If no sched_clock() function has been provided at that point,\n\t * make it the final one.\n\t */\n\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)\n\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);\n\n\tupdate_sched_clock();\n\n\t/*\n\t * Start the timer to keep sched_clock() properly updated and\n\t * sets the initial epoch.\n\t */\n\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\tsched_clock_timer.function = sched_clock_poll;\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&sched_clock_running"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "sched_clock_idle_wakeup_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "435-448",
    "snippet": "void sched_clock_idle_wakeup_event(void)\n{\n\tunsigned long flags;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (unlikely(timekeeping_suspended))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tsched_clock_tick();\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_tick",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_tick_stable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "406-421",
          "snippet": "void sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_stable",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sched_clock_stable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "189-197",
          "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_idle_wakeup_event(void)\n{\n\tunsigned long flags;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (unlikely(timekeeping_suspended))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tsched_clock_tick();\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "sched_clock_idle_sleep_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "426-429",
    "snippet": "void sched_clock_idle_sleep_event(void)\n{\n\tsched_clock_cpu(smp_processor_id());\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "461-467",
          "snippet": "u64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_likely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nu64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_likely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_idle_sleep_event(void)\n{\n\tsched_clock_cpu(smp_processor_id());\n}"
  },
  {
    "function_name": "sched_clock_tick_stable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "406-421",
    "snippet": "void sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sched_clock_gtod_offset",
          "args": [],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_clock_gtod_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "199-205",
          "snippet": "static void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_stable",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sched_clock_stable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "189-197",
          "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "sched_clock_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "389-404",
    "snippet": "void sched_clock_tick(void)\n{\n\tstruct sched_clock_data *scd;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (!static_branch_likely(&sched_clock_running))\n\t\treturn;\n\n\tlockdep_assert_irqs_disabled();\n\n\tscd = this_scd();\n\t__scd_stamp(scd);\n\tsched_clock_local(scd);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock_local",
          "args": [
            "scd"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "265-296",
          "snippet": "static u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__scd_stamp",
          "args": [
            "scd"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__scd_stamp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "113-117",
          "snippet": "static void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_scd",
          "args": [],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "this_scd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "98-101",
          "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&sched_clock_running"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_stable",
          "args": [],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sched_clock_stable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "189-197",
          "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid sched_clock_tick(void)\n{\n\tstruct sched_clock_data *scd;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (!static_branch_likely(&sched_clock_running))\n\t\treturn;\n\n\tlockdep_assert_irqs_disabled();\n\n\tscd = this_scd();\n\t__scd_stamp(scd);\n\tsched_clock_local(scd);\n}"
  },
  {
    "function_name": "sched_clock_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "365-386",
    "snippet": "u64 sched_clock_cpu(int cpu)\n{\n\tstruct sched_clock_data *scd;\n\tu64 clock;\n\n\tif (sched_clock_stable())\n\t\treturn sched_clock() + __sched_clock_offset;\n\n\tif (!static_branch_likely(&sched_clock_running))\n\t\treturn sched_clock();\n\n\tpreempt_disable_notrace();\n\tscd = cpu_sdc(cpu);\n\n\tif (cpu != smp_processor_id())\n\t\tclock = sched_clock_remote(scd);\n\telse\n\t\tclock = sched_clock_local(scd);\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_local",
          "args": [
            "scd"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "265-296",
          "snippet": "static u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_remote",
          "args": [
            "scd"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_remote",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "298-358",
          "snippet": "static u64 sched_clock_remote(struct sched_clock_data *scd)\n{\n\tstruct sched_clock_data *my_scd = this_scd();\n\tu64 this_clock, remote_clock;\n\tu64 *ptr, old_val, val;\n\n#if BITS_PER_LONG != 64\nagain:\n\t/*\n\t * Careful here: The local and the remote clock values need to\n\t * be read out atomic as we need to compare the values and\n\t * then update either the local or the remote side. So the\n\t * cmpxchg64 below only protects one readout.\n\t *\n\t * We must reread via sched_clock_local() in the retry case on\n\t * 32-bit kernels as an NMI could use sched_clock_local() via the\n\t * tracer and hit between the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tthis_clock = sched_clock_local(my_scd);\n\t/*\n\t * We must enforce atomic readout on 32-bit, otherwise the\n\t * update on the remote CPU can hit inbetween the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tremote_clock = cmpxchg64(&scd->clock, 0, 0);\n#else\n\t/*\n\t * On 64-bit kernels the read of [my]scd->clock is atomic versus the\n\t * update, so we can avoid the above 32-bit dance.\n\t */\n\tsched_clock_local(my_scd);\nagain:\n\tthis_clock = my_scd->clock;\n\tremote_clock = scd->clock;\n#endif\n\n\t/*\n\t * Use the opportunity that we have both locks\n\t * taken to couple the two clocks: we take the\n\t * larger time as the latest time for both\n\t * runqueues. (this creates monotonic movement)\n\t */\n\tif (likely((s64)(remote_clock - this_clock) < 0)) {\n\t\tptr = &scd->clock;\n\t\told_val = remote_clock;\n\t\tval = this_clock;\n\t} else {\n\t\t/*\n\t\t * Should be rare, but possible:\n\t\t */\n\t\tptr = &my_scd->clock;\n\t\told_val = this_clock;\n\t\tval = remote_clock;\n\t}\n\n\tif (cmpxchg64(ptr, old_val, val) != old_val)\n\t\tgoto again;\n\n\treturn val;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_remote(struct sched_clock_data *scd)\n{\n\tstruct sched_clock_data *my_scd = this_scd();\n\tu64 this_clock, remote_clock;\n\tu64 *ptr, old_val, val;\n\n#if BITS_PER_LONG != 64\nagain:\n\t/*\n\t * Careful here: The local and the remote clock values need to\n\t * be read out atomic as we need to compare the values and\n\t * then update either the local or the remote side. So the\n\t * cmpxchg64 below only protects one readout.\n\t *\n\t * We must reread via sched_clock_local() in the retry case on\n\t * 32-bit kernels as an NMI could use sched_clock_local() via the\n\t * tracer and hit between the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tthis_clock = sched_clock_local(my_scd);\n\t/*\n\t * We must enforce atomic readout on 32-bit, otherwise the\n\t * update on the remote CPU can hit inbetween the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tremote_clock = cmpxchg64(&scd->clock, 0, 0);\n#else\n\t/*\n\t * On 64-bit kernels the read of [my]scd->clock is atomic versus the\n\t * update, so we can avoid the above 32-bit dance.\n\t */\n\tsched_clock_local(my_scd);\nagain:\n\tthis_clock = my_scd->clock;\n\tremote_clock = scd->clock;\n#endif\n\n\t/*\n\t * Use the opportunity that we have both locks\n\t * taken to couple the two clocks: we take the\n\t * larger time as the latest time for both\n\t * runqueues. (this creates monotonic movement)\n\t */\n\tif (likely((s64)(remote_clock - this_clock) < 0)) {\n\t\tptr = &scd->clock;\n\t\told_val = remote_clock;\n\t\tval = this_clock;\n\t} else {\n\t\t/*\n\t\t * Should be rare, but possible:\n\t\t */\n\t\tptr = &my_scd->clock;\n\t\told_val = this_clock;\n\t\tval = remote_clock;\n\t}\n\n\tif (cmpxchg64(ptr, old_val, val) != old_val)\n\t\tgoto again;\n\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_sdc",
          "args": [
            "cpu"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_sdc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "103-106",
          "snippet": "static inline struct sched_clock_data *cpu_sdc(int cpu)\n{\n\treturn &per_cpu(sched_clock_data, cpu);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *cpu_sdc(int cpu)\n{\n\treturn &per_cpu(sched_clock_data, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&sched_clock_running"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_stable",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sched_clock_stable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "189-197",
          "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nu64 sched_clock_cpu(int cpu)\n{\n\tstruct sched_clock_data *scd;\n\tu64 clock;\n\n\tif (sched_clock_stable())\n\t\treturn sched_clock() + __sched_clock_offset;\n\n\tif (!static_branch_likely(&sched_clock_running))\n\t\treturn sched_clock();\n\n\tpreempt_disable_notrace();\n\tscd = cpu_sdc(cpu);\n\n\tif (cpu != smp_processor_id())\n\t\tclock = sched_clock_remote(scd);\n\telse\n\t\tclock = sched_clock_local(scd);\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}"
  },
  {
    "function_name": "sched_clock_remote",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "298-358",
    "snippet": "static u64 sched_clock_remote(struct sched_clock_data *scd)\n{\n\tstruct sched_clock_data *my_scd = this_scd();\n\tu64 this_clock, remote_clock;\n\tu64 *ptr, old_val, val;\n\n#if BITS_PER_LONG != 64\nagain:\n\t/*\n\t * Careful here: The local and the remote clock values need to\n\t * be read out atomic as we need to compare the values and\n\t * then update either the local or the remote side. So the\n\t * cmpxchg64 below only protects one readout.\n\t *\n\t * We must reread via sched_clock_local() in the retry case on\n\t * 32-bit kernels as an NMI could use sched_clock_local() via the\n\t * tracer and hit between the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tthis_clock = sched_clock_local(my_scd);\n\t/*\n\t * We must enforce atomic readout on 32-bit, otherwise the\n\t * update on the remote CPU can hit inbetween the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tremote_clock = cmpxchg64(&scd->clock, 0, 0);\n#else\n\t/*\n\t * On 64-bit kernels the read of [my]scd->clock is atomic versus the\n\t * update, so we can avoid the above 32-bit dance.\n\t */\n\tsched_clock_local(my_scd);\nagain:\n\tthis_clock = my_scd->clock;\n\tremote_clock = scd->clock;\n#endif\n\n\t/*\n\t * Use the opportunity that we have both locks\n\t * taken to couple the two clocks: we take the\n\t * larger time as the latest time for both\n\t * runqueues. (this creates monotonic movement)\n\t */\n\tif (likely((s64)(remote_clock - this_clock) < 0)) {\n\t\tptr = &scd->clock;\n\t\told_val = remote_clock;\n\t\tval = this_clock;\n\t} else {\n\t\t/*\n\t\t * Should be rare, but possible:\n\t\t */\n\t\tptr = &my_scd->clock;\n\t\told_val = this_clock;\n\t\tval = remote_clock;\n\t}\n\n\tif (cmpxchg64(ptr, old_val, val) != old_val)\n\t\tgoto again;\n\n\treturn val;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg64",
          "args": [
            "ptr",
            "old_val",
            "val"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "(s64)(remote_clock - this_clock) < 0"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "remote_clock - this_clock"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_local",
          "args": [
            "my_scd"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "265-296",
          "snippet": "static u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg64",
          "args": [
            "&scd->clock",
            "0",
            "0"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_scd",
          "args": [],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "this_scd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "98-101",
          "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_remote(struct sched_clock_data *scd)\n{\n\tstruct sched_clock_data *my_scd = this_scd();\n\tu64 this_clock, remote_clock;\n\tu64 *ptr, old_val, val;\n\n#if BITS_PER_LONG != 64\nagain:\n\t/*\n\t * Careful here: The local and the remote clock values need to\n\t * be read out atomic as we need to compare the values and\n\t * then update either the local or the remote side. So the\n\t * cmpxchg64 below only protects one readout.\n\t *\n\t * We must reread via sched_clock_local() in the retry case on\n\t * 32-bit kernels as an NMI could use sched_clock_local() via the\n\t * tracer and hit between the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tthis_clock = sched_clock_local(my_scd);\n\t/*\n\t * We must enforce atomic readout on 32-bit, otherwise the\n\t * update on the remote CPU can hit inbetween the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tremote_clock = cmpxchg64(&scd->clock, 0, 0);\n#else\n\t/*\n\t * On 64-bit kernels the read of [my]scd->clock is atomic versus the\n\t * update, so we can avoid the above 32-bit dance.\n\t */\n\tsched_clock_local(my_scd);\nagain:\n\tthis_clock = my_scd->clock;\n\tremote_clock = scd->clock;\n#endif\n\n\t/*\n\t * Use the opportunity that we have both locks\n\t * taken to couple the two clocks: we take the\n\t * larger time as the latest time for both\n\t * runqueues. (this creates monotonic movement)\n\t */\n\tif (likely((s64)(remote_clock - this_clock) < 0)) {\n\t\tptr = &scd->clock;\n\t\told_val = remote_clock;\n\t\tval = this_clock;\n\t} else {\n\t\t/*\n\t\t * Should be rare, but possible:\n\t\t */\n\t\tptr = &my_scd->clock;\n\t\told_val = this_clock;\n\t\tval = remote_clock;\n\t}\n\n\tif (cmpxchg64(ptr, old_val, val) != old_val)\n\t\tgoto again;\n\n\treturn val;\n}"
  },
  {
    "function_name": "sched_clock_local",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "265-296",
    "snippet": "static u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg64",
          "args": [
            "&scd->clock",
            "old_clock",
            "clock"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrap_min",
          "args": [
            "clock",
            "max_clock"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_min",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "249-252",
          "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrap_max",
          "args": [
            "clock",
            "min_clock"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "254-257",
          "snippet": "static inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta < 0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}"
  },
  {
    "function_name": "wrap_max",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "254-257",
    "snippet": "static inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "x - y"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}"
  },
  {
    "function_name": "wrap_min",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "249-252",
    "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "x - y"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
  },
  {
    "function_name": "sched_clock_init_late",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "226-242",
    "snippet": "static int __init sched_clock_init_late(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\t/*\n\t * Ensure that it is impossible to not do a static_key update.\n\t *\n\t * Either {set,clear}_sched_clock_stable() must see sched_clock_running\n\t * and do the update, or we must see their __sched_clock_stable_early\n\t * and do the update, or both.\n\t */\n\tsmp_mb(); /* matches {set,clear}_sched_clock_stable() */\n\n\tif (__sched_clock_stable_early)\n\t\t__set_sched_clock_stable();\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_sched_clock_stable",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "__set_sched_clock_stable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "119-141",
          "snippet": "static void __set_sched_clock_stable(void)\n{\n\tstruct sched_clock_data *scd;\n\n\t/*\n\t * Since we're still unstable and the tick is already running, we have\n\t * to disable IRQs in order to get a consistent scd->tick* reading.\n\t */\n\tlocal_irq_disable();\n\tscd = this_scd();\n\t/*\n\t * Attempt to make the (initial) unstable->stable transition continuous.\n\t */\n\t__sched_clock_offset = (scd->tick_gtod + __gtod_offset) - (scd->tick_raw);\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"sched_clock: Marking stable (%lld, %lld)->(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_enable(&__sched_clock_stable);\n\ttick_dep_clear(TICK_DEP_BIT_CLOCK_UNSTABLE);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __set_sched_clock_stable(void)\n{\n\tstruct sched_clock_data *scd;\n\n\t/*\n\t * Since we're still unstable and the tick is already running, we have\n\t * to disable IRQs in order to get a consistent scd->tick* reading.\n\t */\n\tlocal_irq_disable();\n\tscd = this_scd();\n\t/*\n\t * Attempt to make the (initial) unstable->stable transition continuous.\n\t */\n\t__sched_clock_offset = (scd->tick_gtod + __gtod_offset) - (scd->tick_raw);\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"sched_clock: Marking stable (%lld, %lld)->(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_enable(&__sched_clock_stable);\n\ttick_dep_clear(TICK_DEP_BIT_CLOCK_UNSTABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&sched_clock_running"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nstatic int __init sched_clock_init_late(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\t/*\n\t * Ensure that it is impossible to not do a static_key update.\n\t *\n\t * Either {set,clear}_sched_clock_stable() must see sched_clock_running\n\t * and do the update, or we must see their __sched_clock_stable_early\n\t * and do the update, or both.\n\t */\n\tsmp_mb(); /* matches {set,clear}_sched_clock_stable() */\n\n\tif (__sched_clock_stable_early)\n\t\t__set_sched_clock_stable();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_clock_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "207-221",
    "snippet": "void __init sched_clock_init(void)\n{\n\t/*\n\t * Set __gtod_offset such that once we mark sched_clock_running,\n\t * sched_clock_tick() continues where sched_clock() left off.\n\t *\n\t * Even if TSC is buggered, we're still UP at this point so it\n\t * can't really be out of sync.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n\n\tstatic_branch_inc(&sched_clock_running);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&sched_clock_running"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sched_clock_gtod_offset",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_clock_gtod_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "199-205",
          "snippet": "static void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\t/*\n\t * Set __gtod_offset such that once we mark sched_clock_running,\n\t * sched_clock_tick() continues where sched_clock() left off.\n\t *\n\t * Even if TSC is buggered, we're still UP at this point so it\n\t * can't really be out of sync.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n\n\tstatic_branch_inc(&sched_clock_running);\n}"
  },
  {
    "function_name": "__sched_clock_gtod_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "199-205",
    "snippet": "static void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__scd_stamp",
          "args": [
            "scd"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "__scd_stamp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "113-117",
          "snippet": "static void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_scd",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "this_scd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "98-101",
          "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}"
  },
  {
    "function_name": "clear_sched_clock_stable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "189-197",
    "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_sched_clock_stable",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_sched_clock_stable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "180-187",
          "snippet": "static void __clear_sched_clock_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\ttick_dep_set(TICK_DEP_BIT_CLOCK_UNSTABLE);\n\tschedule_work(&sched_clock_work);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __clear_sched_clock_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\ttick_dep_set(TICK_DEP_BIT_CLOCK_UNSTABLE);\n\tschedule_work(&sched_clock_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_count",
          "args": [
            "&sched_clock_running.key"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "104-113",
          "snippet": "int static_key_count(struct static_key *key)\n{\n\t/*\n\t * -1 means the first static_key_slow_inc() is in progress.\n\t *  static_key_enabled() must return true, so return 1 here.\n\t */\n\tint n = atomic_read(&key->enabled);\n\n\treturn n >= 0 ? n : 1;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void jump_label_update(struct static_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key);\n\nint static_key_count(struct static_key *key)\n{\n\t/*\n\t * -1 means the first static_key_slow_inc() is in progress.\n\t *  static_key_enabled() must return true, so return 1 here.\n\t */\n\tint n = atomic_read(&key->enabled);\n\n\treturn n >= 0 ? n : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
  },
  {
    "function_name": "__clear_sched_clock_stable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "180-187",
    "snippet": "static void __clear_sched_clock_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\ttick_dep_set(TICK_DEP_BIT_CLOCK_UNSTABLE);\n\tschedule_work(&sched_clock_work);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&sched_clock_work"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_dep_set",
          "args": [
            "TICK_DEP_BIT_CLOCK_UNSTABLE"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_stable",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sched_clock_stable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "189-197",
          "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __clear_sched_clock_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\ttick_dep_set(TICK_DEP_BIT_CLOCK_UNSTABLE);\n\tschedule_work(&sched_clock_work);\n}"
  },
  {
    "function_name": "__sched_clock_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "154-176",
    "snippet": "static void __sched_clock_work(struct work_struct *work)\n{\n\tstruct sched_clock_data *scd;\n\tint cpu;\n\n\t/* take a current timestamp and set 'now' */\n\tpreempt_disable();\n\tscd = this_scd();\n\t__scd_stamp(scd);\n\tscd->clock = scd->tick_gtod + __gtod_offset;\n\tpreempt_enable();\n\n\t/* clone to all CPUs */\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(sched_clock_data, cpu) = *scd;\n\n\tprintk(KERN_WARNING \"TSC found unstable after boot, most likely due to broken BIOS. Use 'tsc=unstable'.\\n\");\n\tprintk(KERN_INFO \"sched_clock: Marking unstable (%lld, %lld)<-(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_disable(&__sched_clock_stable);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&__sched_clock_stable"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"sched_clock: Marking unstable (%lld, %lld)<-(%lld, %lld)\\n\"",
            "scd->tick_gtod",
            "__gtod_offset",
            "scd->tick_raw",
            "__sched_clock_offset"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"TSC found unstable after boot, most likely due to broken BIOS. Use 'tsc=unstable'.\\n\""
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__scd_stamp",
          "args": [
            "scd"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "__scd_stamp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "113-117",
          "snippet": "static void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_scd",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "this_scd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "98-101",
          "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __sched_clock_work(struct work_struct *work)\n{\n\tstruct sched_clock_data *scd;\n\tint cpu;\n\n\t/* take a current timestamp and set 'now' */\n\tpreempt_disable();\n\tscd = this_scd();\n\t__scd_stamp(scd);\n\tscd->clock = scd->tick_gtod + __gtod_offset;\n\tpreempt_enable();\n\n\t/* clone to all CPUs */\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(sched_clock_data, cpu) = *scd;\n\n\tprintk(KERN_WARNING \"TSC found unstable after boot, most likely due to broken BIOS. Use 'tsc=unstable'.\\n\");\n\tprintk(KERN_INFO \"sched_clock: Marking unstable (%lld, %lld)<-(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_disable(&__sched_clock_stable);\n}"
  },
  {
    "function_name": "__set_sched_clock_stable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "119-141",
    "snippet": "static void __set_sched_clock_stable(void)\n{\n\tstruct sched_clock_data *scd;\n\n\t/*\n\t * Since we're still unstable and the tick is already running, we have\n\t * to disable IRQs in order to get a consistent scd->tick* reading.\n\t */\n\tlocal_irq_disable();\n\tscd = this_scd();\n\t/*\n\t * Attempt to make the (initial) unstable->stable transition continuous.\n\t */\n\t__sched_clock_offset = (scd->tick_gtod + __gtod_offset) - (scd->tick_raw);\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"sched_clock: Marking stable (%lld, %lld)->(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_enable(&__sched_clock_stable);\n\ttick_dep_clear(TICK_DEP_BIT_CLOCK_UNSTABLE);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_clear",
          "args": [
            "TICK_DEP_BIT_CLOCK_UNSTABLE"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&__sched_clock_stable"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"sched_clock: Marking stable (%lld, %lld)->(%lld, %lld)\\n\"",
            "scd->tick_gtod",
            "__gtod_offset",
            "scd->tick_raw",
            "__sched_clock_offset"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_scd",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "this_scd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "98-101",
          "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __set_sched_clock_stable(void)\n{\n\tstruct sched_clock_data *scd;\n\n\t/*\n\t * Since we're still unstable and the tick is already running, we have\n\t * to disable IRQs in order to get a consistent scd->tick* reading.\n\t */\n\tlocal_irq_disable();\n\tscd = this_scd();\n\t/*\n\t * Attempt to make the (initial) unstable->stable transition continuous.\n\t */\n\t__sched_clock_offset = (scd->tick_gtod + __gtod_offset) - (scd->tick_raw);\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"sched_clock: Marking stable (%lld, %lld)->(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_enable(&__sched_clock_stable);\n\ttick_dep_clear(TICK_DEP_BIT_CLOCK_UNSTABLE);\n}"
  },
  {
    "function_name": "__scd_stamp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "113-117",
    "snippet": "static void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_ns",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}"
  },
  {
    "function_name": "sched_clock_stable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "108-111",
    "snippet": "int sched_clock_stable(void)\n{\n\treturn static_branch_likely(&__sched_clock_stable);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&__sched_clock_stable"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nint sched_clock_stable(void)\n{\n\treturn static_branch_likely(&__sched_clock_stable);\n}"
  },
  {
    "function_name": "cpu_sdc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "103-106",
    "snippet": "static inline struct sched_clock_data *cpu_sdc(int cpu)\n{\n\treturn &per_cpu(sched_clock_data, cpu);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "sched_clock_data",
            "cpu"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *cpu_sdc(int cpu)\n{\n\treturn &per_cpu(sched_clock_data, cpu);\n}"
  },
  {
    "function_name": "this_scd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "98-101",
    "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&sched_clock_data"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
  },
  {
    "function_name": "sched_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
    "lines": "64-68",
    "snippet": "unsigned long long __weak sched_clock(void)\n{\n\treturn (unsigned long long)(jiffies - INITIAL_JIFFIES)\n\t\t\t\t\t* (NSEC_PER_SEC / HZ);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nunsigned long long __weak sched_clock(void)\n{\n\treturn (unsigned long long)(jiffies - INITIAL_JIFFIES)\n\t\t\t\t\t* (NSEC_PER_SEC / HZ);\n}"
  }
]