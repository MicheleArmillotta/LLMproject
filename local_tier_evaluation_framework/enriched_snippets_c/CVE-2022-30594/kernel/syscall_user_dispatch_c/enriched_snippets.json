[
  {
    "function_name": "set_syscall_user_dispatch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/syscall_user_dispatch.c",
    "lines": "71-108",
    "snippet": "int set_syscall_user_dispatch(unsigned long mode, unsigned long offset,\n\t\t\t      unsigned long len, char __user *selector)\n{\n\tswitch (mode) {\n\tcase PR_SYS_DISPATCH_OFF:\n\t\tif (offset || len || selector)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PR_SYS_DISPATCH_ON:\n\t\t/*\n\t\t * Validate the direct dispatcher region just for basic\n\t\t * sanity against overflow and a 0-sized dispatcher\n\t\t * region.  If the user is able to submit a syscall from\n\t\t * an address, that address is obviously valid.\n\t\t */\n\t\tif (offset && offset + len <= offset)\n\t\t\treturn -EINVAL;\n\n\t\tif (selector && !access_ok(selector, sizeof(*selector)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcurrent->syscall_dispatch.selector = selector;\n\tcurrent->syscall_dispatch.offset = offset;\n\tcurrent->syscall_dispatch.len = len;\n\tcurrent->syscall_dispatch.on_dispatch = false;\n\n\tif (mode == PR_SYS_DISPATCH_ON)\n\t\tset_syscall_work(SYSCALL_USER_DISPATCH);\n\telse\n\t\tclear_syscall_work(SYSCALL_USER_DISPATCH);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/elf.h>",
      "#include <linux/signal.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscall_user_dispatch.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_syscall_work",
          "args": [
            "SYSCALL_USER_DISPATCH"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_syscall_work",
          "args": [
            "SYSCALL_USER_DISPATCH"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "selector",
            "sizeof(*selector)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <asm/syscall.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/elf.h>\n#include <linux/signal.h>\n#include <linux/uaccess.h>\n#include <linux/syscall_user_dispatch.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n\nint set_syscall_user_dispatch(unsigned long mode, unsigned long offset,\n\t\t\t      unsigned long len, char __user *selector)\n{\n\tswitch (mode) {\n\tcase PR_SYS_DISPATCH_OFF:\n\t\tif (offset || len || selector)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PR_SYS_DISPATCH_ON:\n\t\t/*\n\t\t * Validate the direct dispatcher region just for basic\n\t\t * sanity against overflow and a 0-sized dispatcher\n\t\t * region.  If the user is able to submit a syscall from\n\t\t * an address, that address is obviously valid.\n\t\t */\n\t\tif (offset && offset + len <= offset)\n\t\t\treturn -EINVAL;\n\n\t\tif (selector && !access_ok(selector, sizeof(*selector)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcurrent->syscall_dispatch.selector = selector;\n\tcurrent->syscall_dispatch.offset = offset;\n\tcurrent->syscall_dispatch.len = len;\n\tcurrent->syscall_dispatch.on_dispatch = false;\n\n\tif (mode == PR_SYS_DISPATCH_ON)\n\t\tset_syscall_work(SYSCALL_USER_DISPATCH);\n\telse\n\t\tclear_syscall_work(SYSCALL_USER_DISPATCH);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "syscall_user_dispatch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/syscall_user_dispatch.c",
    "lines": "34-69",
    "snippet": "bool syscall_user_dispatch(struct pt_regs *regs)\n{\n\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;\n\tchar state;\n\n\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))\n\t\treturn false;\n\n\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))\n\t\treturn false;\n\n\tif (likely(sd->selector)) {\n\t\t/*\n\t\t * access_ok() is performed once, at prctl time, when\n\t\t * the selector is loaded by userspace.\n\t\t */\n\t\tif (unlikely(__get_user(state, sd->selector))) {\n\t\t\tforce_exit_sig(SIGSEGV);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))\n\t\t\treturn false;\n\n\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {\n\t\t\tforce_exit_sig(SIGSYS);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tsd->on_dispatch = true;\n\tsyscall_rollback(current, regs);\n\ttrigger_sigsys(regs);\n\n\treturn true;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/elf.h>",
      "#include <linux/signal.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscall_user_dispatch.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trigger_sigsys",
          "args": [
            "regs"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_sigsys",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/syscall_user_dispatch.c",
          "lines": "19-32",
          "snippet": "static void trigger_sigsys(struct pt_regs *regs)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSYS;\n\tinfo.si_code = SYS_USER_DISPATCH;\n\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo.si_errno = 0;\n\tinfo.si_arch = syscall_get_arch(current);\n\tinfo.si_syscall = syscall_get_nr(current, regs);\n\n\tforce_sig_info(&info);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <asm/syscall.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/elf.h>",
            "#include <linux/signal.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscall_user_dispatch.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <asm/syscall.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/elf.h>\n#include <linux/signal.h>\n#include <linux/uaccess.h>\n#include <linux/syscall_user_dispatch.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n\nstatic void trigger_sigsys(struct pt_regs *regs)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSYS;\n\tinfo.si_code = SYS_USER_DISPATCH;\n\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo.si_errno = 0;\n\tinfo.si_arch = syscall_get_arch(current);\n\tinfo.si_syscall = syscall_get_nr(current, regs);\n\n\tforce_sig_info(&info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_rollback",
          "args": [
            "current",
            "regs"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_exit_sig",
          "args": [
            "SIGSYS"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "force_exit_sig",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1677-1688",
          "snippet": "void force_exit_sig(int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_KERNEL;\n\tinfo.si_pid = 0;\n\tinfo.si_uid = 0;\n\tforce_sig_info_to_task(&info, current, HANDLER_EXIT);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_exit_sig(int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_KERNEL;\n\tinfo.si_pid = 0;\n\tinfo.si_uid = 0;\n\tforce_sig_info_to_task(&info, current, HANDLER_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "state == SYSCALL_DISPATCH_FILTER_ALLOW"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__get_user(state, sd->selector)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "state",
            "sd->selector"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sd->selector"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "arch_syscall_is_vdso_sigreturn(regs)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_syscall_is_vdso_sigreturn",
          "args": [
            "regs"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "instruction_pointer(regs) - sd->offset < sd->len"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <asm/syscall.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/elf.h>\n#include <linux/signal.h>\n#include <linux/uaccess.h>\n#include <linux/syscall_user_dispatch.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n\nbool syscall_user_dispatch(struct pt_regs *regs)\n{\n\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;\n\tchar state;\n\n\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))\n\t\treturn false;\n\n\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))\n\t\treturn false;\n\n\tif (likely(sd->selector)) {\n\t\t/*\n\t\t * access_ok() is performed once, at prctl time, when\n\t\t * the selector is loaded by userspace.\n\t\t */\n\t\tif (unlikely(__get_user(state, sd->selector))) {\n\t\t\tforce_exit_sig(SIGSEGV);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))\n\t\t\treturn false;\n\n\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {\n\t\t\tforce_exit_sig(SIGSYS);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tsd->on_dispatch = true;\n\tsyscall_rollback(current, regs);\n\ttrigger_sigsys(regs);\n\n\treturn true;\n}"
  },
  {
    "function_name": "trigger_sigsys",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/syscall_user_dispatch.c",
    "lines": "19-32",
    "snippet": "static void trigger_sigsys(struct pt_regs *regs)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSYS;\n\tinfo.si_code = SYS_USER_DISPATCH;\n\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo.si_errno = 0;\n\tinfo.si_arch = syscall_get_arch(current);\n\tinfo.si_syscall = syscall_get_nr(current, regs);\n\n\tforce_sig_info(&info);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <asm/syscall.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/elf.h>",
      "#include <linux/signal.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscall_user_dispatch.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "&info"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1355-1358",
          "snippet": "int force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "current",
            "regs"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_arch",
          "args": [
            "current"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KSTK_EIP",
          "args": [
            "current"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <asm/syscall.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/elf.h>\n#include <linux/signal.h>\n#include <linux/uaccess.h>\n#include <linux/syscall_user_dispatch.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n\nstatic void trigger_sigsys(struct pt_regs *regs)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSYS;\n\tinfo.si_code = SYS_USER_DISPATCH;\n\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo.si_errno = 0;\n\tinfo.si_arch = syscall_get_arch(current);\n\tinfo.si_syscall = syscall_get_nr(current, regs);\n\n\tforce_sig_info(&info);\n}"
  }
]