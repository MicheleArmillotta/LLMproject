[
  {
    "function_name": "init_wakeup_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "799-816",
    "snippet": "__init static int init_wakeup_tracer(void)\n{\n\tint ret;\n\n\tret = register_tracer(&wakeup_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_tracer(&wakeup_rt_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_tracer(&wakeup_dl_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&wakeup_dl_tracer"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2037-2120",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n__init static int init_wakeup_tracer(void)\n{\n\tint ret;\n\n\tret = register_tracer(&wakeup_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_tracer(&wakeup_rt_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_tracer(&wakeup_dl_tracer);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wakeup_tracer_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "734-737",
    "snippet": "static void wakeup_tracer_stop(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_tracer_stop(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n}"
  },
  {
    "function_name": "wakeup_tracer_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "728-732",
    "snippet": "static void wakeup_tracer_start(struct trace_array *tr)\n{\n\twakeup_reset(tr);\n\ttracer_enabled = 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_reset",
          "args": [
            "tr"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "509-520",
          "snippet": "static void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_tracer_start(struct trace_array *tr)\n{\n\twakeup_reset(tr);\n\ttracer_enabled = 1;\n}"
  },
  {
    "function_name": "wakeup_tracer_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "713-726",
    "snippet": "static void wakeup_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\n\tstop_wakeup_tracer(tr);\n\t/* make sure we put back any tasks we are tracing */\n\twakeup_reset(tr);\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tftrace_reset_array_ops(tr);\n\twakeup_busy = false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static int save_flags;",
      "static bool wakeup_busy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_reset_array_ops",
          "args": [
            "tr"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_reset_array_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7225-7228",
          "snippet": "void ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tracer_flag",
          "args": [
            "tr",
            "TRACE_ITER_OVERWRITE",
            "overwrite_flag"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "set_tracer_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "5267-5333",
          "snippet": "int set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\tint *map;\n\n\tif ((mask == TRACE_ITER_RECORD_TGID) ||\n\t    (mask == TRACE_ITER_RECORD_CMD))\n\t\tlockdep_assert_held(&event_mutex);\n\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map) {\n\t\t\ttgid_map_max = pid_max;\n\t\t\tmap = kvcalloc(tgid_map_max + 1, sizeof(*tgid_map),\n\t\t\t\t       GFP_KERNEL);\n\n\t\t\t/*\n\t\t\t * Pairs with smp_load_acquire() in\n\t\t\t * trace_find_tgid_ptr() to ensure that if it observes\n\t\t\t * the tgid_map we just allocated then it also observes\n\t\t\t * the corresponding tgid_map_max value.\n\t\t\t */\n\t\t\tsmp_store_release(&tgid_map, map);\n\t\t}\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->array_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static int *tgid_map;",
            "static size_t tgid_map_max;",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic int *tgid_map;\nstatic size_t tgid_map_max;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\tint *map;\n\n\tif ((mask == TRACE_ITER_RECORD_TGID) ||\n\t    (mask == TRACE_ITER_RECORD_CMD))\n\t\tlockdep_assert_held(&event_mutex);\n\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map) {\n\t\t\ttgid_map_max = pid_max;\n\t\t\tmap = kvcalloc(tgid_map_max + 1, sizeof(*tgid_map),\n\t\t\t\t       GFP_KERNEL);\n\n\t\t\t/*\n\t\t\t * Pairs with smp_load_acquire() in\n\t\t\t * trace_find_tgid_ptr() to ensure that if it observes\n\t\t\t * the tgid_map we just allocated then it also observes\n\t\t\t * the corresponding tgid_map_max value.\n\t\t\t */\n\t\t\tsmp_store_release(&tgid_map, map);\n\t\t}\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->array_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_reset",
          "args": [
            "tr"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "509-520",
          "snippet": "static void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_wakeup_tracer",
          "args": [
            "tr"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "stop_wakeup_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "654-662",
          "snippet": "static void stop_wakeup_tracer(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n\tstop_func_tracer(tr, is_graph(tr));\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n\tunregister_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void stop_wakeup_tracer(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n\tstop_func_tracer(tr, is_graph(tr));\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n\tunregister_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int save_flags;\nstatic bool wakeup_busy;\n\nstatic void wakeup_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\n\tstop_wakeup_tracer(tr);\n\t/* make sure we put back any tasks we are tracing */\n\twakeup_reset(tr);\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tftrace_reset_array_ops(tr);\n\twakeup_busy = false;\n}"
  },
  {
    "function_name": "wakeup_dl_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "703-711",
    "snippet": "static int wakeup_dl_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = true;\n\twakeup_rt = false;\n\treturn __wakeup_tracer_init(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool\t\t\twakeup_rt;",
      "static bool\t\t\twakeup_dl;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static bool wakeup_busy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wakeup_tracer_init",
          "args": [
            "tr"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "666-681",
          "snippet": "static int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array\t*wakeup_trace;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int save_flags;",
            "static bool wakeup_busy;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int save_flags;\nstatic bool wakeup_busy;\n\nstatic int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool\t\t\twakeup_rt;\nstatic bool\t\t\twakeup_dl;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic bool wakeup_busy;\n\nstatic int wakeup_dl_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = true;\n\twakeup_rt = false;\n\treturn __wakeup_tracer_init(tr);\n}"
  },
  {
    "function_name": "wakeup_rt_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "693-701",
    "snippet": "static int wakeup_rt_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = false;\n\twakeup_rt = true;\n\treturn __wakeup_tracer_init(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool\t\t\twakeup_rt;",
      "static bool\t\t\twakeup_dl;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static bool wakeup_busy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wakeup_tracer_init",
          "args": [
            "tr"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "666-681",
          "snippet": "static int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array\t*wakeup_trace;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int save_flags;",
            "static bool wakeup_busy;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int save_flags;\nstatic bool wakeup_busy;\n\nstatic int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool\t\t\twakeup_rt;\nstatic bool\t\t\twakeup_dl;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic bool wakeup_busy;\n\nstatic int wakeup_rt_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = false;\n\twakeup_rt = true;\n\treturn __wakeup_tracer_init(tr);\n}"
  },
  {
    "function_name": "wakeup_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "683-691",
    "snippet": "static int wakeup_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = false;\n\twakeup_rt = false;\n\treturn __wakeup_tracer_init(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool\t\t\twakeup_rt;",
      "static bool\t\t\twakeup_dl;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static bool wakeup_busy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wakeup_tracer_init",
          "args": [
            "tr"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "666-681",
          "snippet": "static int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array\t*wakeup_trace;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int save_flags;",
            "static bool wakeup_busy;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int save_flags;\nstatic bool wakeup_busy;\n\nstatic int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool\t\t\twakeup_rt;\nstatic bool\t\t\twakeup_dl;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic bool wakeup_busy;\n\nstatic int wakeup_tracer_init(struct trace_array *tr)\n{\n\tif (wakeup_busy)\n\t\treturn -EBUSY;\n\n\twakeup_dl = false;\n\twakeup_rt = false;\n\treturn __wakeup_tracer_init(tr);\n}"
  },
  {
    "function_name": "__wakeup_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "666-681",
    "snippet": "static int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static int save_flags;",
      "static bool wakeup_busy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_wakeup_tracer",
          "args": [
            "tr"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "start_wakeup_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "599-652",
          "snippet": "static void start_wakeup_tracer(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\tret = register_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_migrate_task\\n\");\n\t\tgoto fail_deprobe_sched_switch;\n\t}\n\n\twakeup_reset(tr);\n\n\t/*\n\t * Don't let the tracer_enabled = 1 show up before\n\t * the wakeup_task is reset. This may be overkill since\n\t * wakeup_reset does a spin_unlock after setting the\n\t * wakeup_task to NULL, but I want to be safe.\n\t * This is a slow path anyway.\n\t */\n\tsmp_wmb();\n\n\tif (start_func_tracer(tr, is_graph(tr)))\n\t\tprintk(KERN_ERR \"failed to start wakeup tracer\\n\");\n\n\treturn;\nfail_deprobe_sched_switch:\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void start_wakeup_tracer(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\tret = register_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_migrate_task\\n\");\n\t\tgoto fail_deprobe_sched_switch;\n\t}\n\n\twakeup_reset(tr);\n\n\t/*\n\t * Don't let the tracer_enabled = 1 show up before\n\t * the wakeup_task is reset. This may be overkill since\n\t * wakeup_reset does a spin_unlock after setting the\n\t * wakeup_task to NULL, but I want to be safe.\n\t * This is a slow path anyway.\n\t */\n\tsmp_wmb();\n\n\tif (start_func_tracer(tr, is_graph(tr)))\n\t\tprintk(KERN_ERR \"failed to start wakeup tracer\\n\");\n\n\treturn;\nfail_deprobe_sched_switch:\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_init_array_ops",
          "args": [
            "tr",
            "wakeup_tracer_call"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_init_array_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7213-7223",
          "snippet": "void ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tracer_flag",
          "args": [
            "tr",
            "TRACE_ITER_LATENCY_FMT",
            "1"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "set_tracer_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "5267-5333",
          "snippet": "int set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\tint *map;\n\n\tif ((mask == TRACE_ITER_RECORD_TGID) ||\n\t    (mask == TRACE_ITER_RECORD_CMD))\n\t\tlockdep_assert_held(&event_mutex);\n\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map) {\n\t\t\ttgid_map_max = pid_max;\n\t\t\tmap = kvcalloc(tgid_map_max + 1, sizeof(*tgid_map),\n\t\t\t\t       GFP_KERNEL);\n\n\t\t\t/*\n\t\t\t * Pairs with smp_load_acquire() in\n\t\t\t * trace_find_tgid_ptr() to ensure that if it observes\n\t\t\t * the tgid_map we just allocated then it also observes\n\t\t\t * the corresponding tgid_map_max value.\n\t\t\t */\n\t\t\tsmp_store_release(&tgid_map, map);\n\t\t}\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->array_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static int *tgid_map;",
            "static size_t tgid_map_max;",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic int *tgid_map;\nstatic size_t tgid_map_max;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\tint *map;\n\n\tif ((mask == TRACE_ITER_RECORD_TGID) ||\n\t    (mask == TRACE_ITER_RECORD_CMD))\n\t\tlockdep_assert_held(&event_mutex);\n\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map) {\n\t\t\ttgid_map_max = pid_max;\n\t\t\tmap = kvcalloc(tgid_map_max + 1, sizeof(*tgid_map),\n\t\t\t\t       GFP_KERNEL);\n\n\t\t\t/*\n\t\t\t * Pairs with smp_load_acquire() in\n\t\t\t * trace_find_tgid_ptr() to ensure that if it observes\n\t\t\t * the tgid_map we just allocated then it also observes\n\t\t\t * the corresponding tgid_map_max value.\n\t\t\t */\n\t\t\tsmp_store_release(&tgid_map, map);\n\t\t}\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->array_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int save_flags;\nstatic bool wakeup_busy;\n\nstatic int __wakeup_tracer_init(struct trace_array *tr)\n{\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\n\ttr->max_latency = 0;\n\twakeup_trace = tr;\n\tftrace_init_array_ops(tr, wakeup_tracer_call);\n\tstart_wakeup_tracer(tr);\n\n\twakeup_busy = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "stop_wakeup_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "654-662",
    "snippet": "static void stop_wakeup_tracer(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n\tstop_func_tracer(tr, is_graph(tr));\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n\tunregister_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_migrate_task",
          "args": [
            "probe_wakeup_migrate_task",
            "NULL"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup_new",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "probe_wakeup_sched_switch",
            "NULL"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_func_tracer",
          "args": [
            "tr",
            "is_graph(tr)"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "stop_func_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "340-345",
          "snippet": "static void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int start_func_tracer(struct trace_array *tr, int graph);",
            "static void stop_func_tracer(struct trace_array *tr, int graph);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void stop_wakeup_tracer(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n\tstop_func_tracer(tr, is_graph(tr));\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n\tunregister_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n}"
  },
  {
    "function_name": "start_wakeup_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "599-652",
    "snippet": "static void start_wakeup_tracer(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\tret = register_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_migrate_task\\n\");\n\t\tgoto fail_deprobe_sched_switch;\n\t}\n\n\twakeup_reset(tr);\n\n\t/*\n\t * Don't let the tracer_enabled = 1 show up before\n\t * the wakeup_task is reset. This may be overkill since\n\t * wakeup_reset does a spin_unlock after setting the\n\t * wakeup_task to NULL, but I want to be safe.\n\t * This is a slow path anyway.\n\t */\n\tsmp_wmb();\n\n\tif (start_func_tracer(tr, is_graph(tr)))\n\t\tprintk(KERN_ERR \"failed to start wakeup tracer\\n\");\n\n\treturn;\nfail_deprobe_sched_switch:\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct\t*wakeup_task;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup_new",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "probe_wakeup_sched_switch",
            "NULL"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"failed to start wakeup tracer\\n\""
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_func_tracer",
          "args": [
            "tr",
            "is_graph(tr)"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "start_func_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "326-338",
          "snippet": "static int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int start_func_tracer(struct trace_array *tr, int graph);",
            "static void stop_func_tracer(struct trace_array *tr, int graph);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_reset",
          "args": [
            "tr"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "509-520",
          "snippet": "static void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_migrate_task\\n\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_migrate_task",
          "args": [
            "probe_wakeup_migrate_task",
            "NULL"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\""
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_switch",
          "args": [
            "probe_wakeup_sched_switch",
            "NULL"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\""
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_wakeup_new",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_wakeup",
          "args": [
            "probe_wakeup",
            "NULL"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void start_wakeup_tracer(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_wakeup_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\tret = register_trace_sched_migrate_task(probe_wakeup_migrate_task, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_migrate_task\\n\");\n\t\tgoto fail_deprobe_sched_switch;\n\t}\n\n\twakeup_reset(tr);\n\n\t/*\n\t * Don't let the tracer_enabled = 1 show up before\n\t * the wakeup_task is reset. This may be overkill since\n\t * wakeup_reset does a spin_unlock after setting the\n\t * wakeup_task to NULL, but I want to be safe.\n\t * This is a slow path anyway.\n\t */\n\tsmp_wmb();\n\n\tif (start_func_tracer(tr, is_graph(tr)))\n\t\tprintk(KERN_ERR \"failed to start wakeup tracer\\n\");\n\n\treturn;\nfail_deprobe_sched_switch:\n\tunregister_trace_sched_switch(probe_wakeup_sched_switch, NULL);\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_wakeup, NULL);\n}"
  },
  {
    "function_name": "probe_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "522-597",
    "snippet": "static void\nprobe_wakeup(void *ignore, struct task_struct *p)\n{\n\tstruct trace_array_cpu *data;\n\tint cpu = smp_processor_id();\n\tlong disabled;\n\tunsigned int trace_ctx;\n\n\tif (likely(!tracer_enabled))\n\t\treturn;\n\n\ttracing_record_cmdline(p);\n\ttracing_record_cmdline(current);\n\n\t/*\n\t * Semantic is like this:\n\t *  - wakeup tracer handles all tasks in the system, independently\n\t *    from their scheduling class;\n\t *  - wakeup_rt tracer handles tasks belonging to sched_dl and\n\t *    sched_rt class;\n\t *  - wakeup_dl handles tasks belonging to sched_dl class only.\n\t */\n\tif (tracing_dl || (wakeup_dl && !dl_task(p)) ||\n\t    (wakeup_rt && !dl_task(p) && !rt_task(p)) ||\n\t    (!dl_task(p) && (p->prio >= wakeup_prio || p->prio >= current->prio)))\n\t\treturn;\n\n\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\t/* interrupts should be off from try_to_wake_up */\n\tarch_spin_lock(&wakeup_lock);\n\n\t/* check for races. */\n\tif (!tracer_enabled || tracing_dl ||\n\t    (!dl_task(p) && p->prio >= wakeup_prio))\n\t\tgoto out_locked;\n\n\t/* reset the trace */\n\t__wakeup_reset(wakeup_trace);\n\n\twakeup_cpu = task_cpu(p);\n\twakeup_current_cpu = wakeup_cpu;\n\twakeup_prio = p->prio;\n\n\t/*\n\t * Once you start tracing a -deadline task, don't bother tracing\n\t * another task until the first one wakes up.\n\t */\n\tif (dl_task(p))\n\t\ttracing_dl = true;\n\telse\n\t\ttracing_dl = false;\n\n\twakeup_task = get_task_struct(p);\n\n\tdata = per_cpu_ptr(wakeup_trace->array_buffer.data, wakeup_cpu);\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\ttracing_sched_wakeup_trace(wakeup_trace, p, current, trace_ctx);\n\t__trace_stack(wakeup_trace, trace_ctx, 0);\n\n\t/*\n\t * We must be careful in using CALLER_ADDR2. But since wake_up\n\t * is not called by an assembly function  (where as schedule is)\n\t * it should be safe to use it here.\n\t */\n\t__trace_function(wakeup_trace, CALLER_ADDR1, CALLER_ADDR2, trace_ctx);\n\nout_locked:\n\tarch_spin_unlock(&wakeup_lock);\nout:\n\tatomic_dec(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static struct task_struct\t*wakeup_task;",
      "static int\t\t\twakeup_cpu;",
      "static int\t\t\twakeup_current_cpu;",
      "static unsigned\t\t\twakeup_prio = -1;",
      "static bool\t\t\twakeup_rt;",
      "static bool\t\t\twakeup_dl;",
      "static bool\t\t\ttracing_dl;",
      "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->array_buffer.data",
            "cpu"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_function",
          "args": [
            "wakeup_trace",
            "CALLER_ADDR1",
            "CALLER_ADDR2",
            "trace_ctx"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "300-309",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_stack",
          "args": [
            "wakeup_trace",
            "trace_ctx",
            "0"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3078-3100",
          "snippet": "void __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nvoid __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_sched_wakeup_trace",
          "args": [
            "wakeup_trace",
            "p",
            "current",
            "trace_ctx"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_sched_wakeup_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "399-425",
          "snippet": "static void\ntracing_sched_wakeup_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *wakee,\n\t\t\t   struct task_struct *curr,\n\t\t\t   unsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_wakeup;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_WAKE,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= curr->pid;\n\tentry->prev_prio\t\t= curr->prio;\n\tentry->prev_state\t\t= task_state_index(curr);\n\tentry->next_pid\t\t\t= wakee->pid;\n\tentry->next_prio\t\t= wakee->prio;\n\tentry->next_state\t\t= task_state_index(wakee);\n\tentry->next_cpu\t\t\t= task_cpu(wakee);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\ntracing_sched_wakeup_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *wakee,\n\t\t\t   struct task_struct *curr,\n\t\t\t   unsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_wakeup;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_WAKE,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= curr->pid;\n\tentry->prev_prio\t\t= curr->prio;\n\tentry->prev_state\t\t= task_state_index(curr);\n\tentry->next_pid\t\t\t= wakee->pid;\n\tentry->next_prio\t\t= wakee->prio;\n\tentry->next_state\t\t= task_state_index(wakee);\n\tentry->next_cpu\t\t\t= task_cpu(wakee);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_now",
          "args": [
            "cpu"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "765-768",
          "snippet": "u64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.array_buffer, cpu);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nu64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.array_buffer, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->array_buffer.data",
            "wakeup_cpu"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wakeup_reset",
          "args": [
            "wakeup_trace"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "497-507",
          "snippet": "static void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = false;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_cpu;",
            "static unsigned\t\t\twakeup_prio = -1;",
            "static bool\t\t\ttracing_dl;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic unsigned\t\t\twakeup_prio = -1;\nstatic bool\t\t\ttracing_dl;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = false;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "disabled != 1"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->array_buffer.data",
            "cpu"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "p"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_task_sighand_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1417-1428",
          "snippet": "void lockdep_assert_task_sighand_held(struct task_struct *task)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tsighand = rcu_dereference(task->sighand);\n\tif (sighand)\n\t\tlockdep_assert_held(&sighand->siglock);\n\telse\n\t\tWARN_ON_ONCE(1);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid lockdep_assert_task_sighand_held(struct task_struct *task)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tsighand = rcu_dereference(task->sighand);\n\tif (sighand)\n\t\tlockdep_assert_held(&sighand->siglock);\n\telse\n\t\tWARN_ON_ONCE(1);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_record_cmdline",
          "args": [
            "current"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_record_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2562-2565",
          "snippet": "void tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!tracer_enabled"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic int\t\t\twakeup_current_cpu;\nstatic unsigned\t\t\twakeup_prio = -1;\nstatic bool\t\t\twakeup_rt;\nstatic bool\t\t\twakeup_dl;\nstatic bool\t\t\ttracing_dl;\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic void\nprobe_wakeup(void *ignore, struct task_struct *p)\n{\n\tstruct trace_array_cpu *data;\n\tint cpu = smp_processor_id();\n\tlong disabled;\n\tunsigned int trace_ctx;\n\n\tif (likely(!tracer_enabled))\n\t\treturn;\n\n\ttracing_record_cmdline(p);\n\ttracing_record_cmdline(current);\n\n\t/*\n\t * Semantic is like this:\n\t *  - wakeup tracer handles all tasks in the system, independently\n\t *    from their scheduling class;\n\t *  - wakeup_rt tracer handles tasks belonging to sched_dl and\n\t *    sched_rt class;\n\t *  - wakeup_dl handles tasks belonging to sched_dl class only.\n\t */\n\tif (tracing_dl || (wakeup_dl && !dl_task(p)) ||\n\t    (wakeup_rt && !dl_task(p) && !rt_task(p)) ||\n\t    (!dl_task(p) && (p->prio >= wakeup_prio || p->prio >= current->prio)))\n\t\treturn;\n\n\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\t/* interrupts should be off from try_to_wake_up */\n\tarch_spin_lock(&wakeup_lock);\n\n\t/* check for races. */\n\tif (!tracer_enabled || tracing_dl ||\n\t    (!dl_task(p) && p->prio >= wakeup_prio))\n\t\tgoto out_locked;\n\n\t/* reset the trace */\n\t__wakeup_reset(wakeup_trace);\n\n\twakeup_cpu = task_cpu(p);\n\twakeup_current_cpu = wakeup_cpu;\n\twakeup_prio = p->prio;\n\n\t/*\n\t * Once you start tracing a -deadline task, don't bother tracing\n\t * another task until the first one wakes up.\n\t */\n\tif (dl_task(p))\n\t\ttracing_dl = true;\n\telse\n\t\ttracing_dl = false;\n\n\twakeup_task = get_task_struct(p);\n\n\tdata = per_cpu_ptr(wakeup_trace->array_buffer.data, wakeup_cpu);\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\ttracing_sched_wakeup_trace(wakeup_trace, p, current, trace_ctx);\n\t__trace_stack(wakeup_trace, trace_ctx, 0);\n\n\t/*\n\t * We must be careful in using CALLER_ADDR2. But since wake_up\n\t * is not called by an assembly function  (where as schedule is)\n\t * it should be safe to use it here.\n\t */\n\t__trace_function(wakeup_trace, CALLER_ADDR1, CALLER_ADDR2, trace_ctx);\n\nout_locked:\n\tarch_spin_unlock(&wakeup_lock);\nout:\n\tatomic_dec(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);\n}"
  },
  {
    "function_name": "wakeup_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "509-520",
    "snippet": "static void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wakeup_reset",
          "args": [
            "tr"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "497-507",
          "snippet": "static void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = false;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_cpu;",
            "static unsigned\t\t\twakeup_prio = -1;",
            "static bool\t\t\ttracing_dl;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic unsigned\t\t\twakeup_prio = -1;\nstatic bool\t\t\ttracing_dl;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = false;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_reset_online_cpus",
          "args": [
            "&tr->array_buffer"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2138-2155",
          "snippet": "void tracing_reset_online_cpus(struct array_buffer *buf)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tring_buffer_reset_online_cpus(buffer);\n\n\tring_buffer_record_enable(buffer);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nvoid tracing_reset_online_cpus(struct array_buffer *buf)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tring_buffer_reset_online_cpus(buffer);\n\n\tring_buffer_record_enable(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__wakeup_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "497-507",
    "snippet": "static void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = false;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct\t*wakeup_task;",
      "static int\t\t\twakeup_cpu;",
      "static unsigned\t\t\twakeup_prio = -1;",
      "static bool\t\t\ttracing_dl;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "wakeup_task"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic unsigned\t\t\twakeup_prio = -1;\nstatic bool\t\t\ttracing_dl;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = false;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}"
  },
  {
    "function_name": "probe_wakeup_sched_switch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "427-495",
    "snippet": "static void notrace\nprobe_wakeup_sched_switch(void *ignore, bool preempt,\n\t\t\t  struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array_cpu *data;\n\tu64 T0, T1, delta;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tunsigned int trace_ctx;\n\n\ttracing_record_cmdline(prev);\n\n\tif (unlikely(!tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * When we start a new trace, we set wakeup_task to NULL\n\t * and then set tracer_enabled = 1. We want to make sure\n\t * that another CPU does not see the tracer_enabled = 1\n\t * and the wakeup_task with an older task, that might\n\t * actually be the same as next.\n\t */\n\tsmp_rmb();\n\n\tif (next != wakeup_task)\n\t\treturn;\n\n\t/* disable local data, not wakeup_cpu data */\n\tcpu = raw_smp_processor_id();\n\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);\n\tif (likely(disabled != 1))\n\t\tgoto out;\n\n\tlocal_irq_save(flags);\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\n\tarch_spin_lock(&wakeup_lock);\n\n\t/* We could race with grabbing wakeup_lock */\n\tif (unlikely(!tracer_enabled || next != wakeup_task))\n\t\tgoto out_unlock;\n\n\t/* The task we are waiting for is waking up */\n\tdata = per_cpu_ptr(wakeup_trace->array_buffer.data, wakeup_cpu);\n\n\t__trace_function(wakeup_trace, CALLER_ADDR0, CALLER_ADDR1, trace_ctx);\n\ttracing_sched_switch_trace(wakeup_trace, prev, next, trace_ctx);\n\t__trace_stack(wakeup_trace, trace_ctx, 0);\n\n\tT0 = data->preempt_timestamp;\n\tT1 = ftrace_now(cpu);\n\tdelta = T1-T0;\n\n\tif (!report_latency(wakeup_trace, delta))\n\t\tgoto out_unlock;\n\n\tif (likely(!is_tracing_stopped())) {\n\t\twakeup_trace->max_latency = delta;\n\t\tupdate_max_tr(wakeup_trace, wakeup_task, wakeup_cpu, NULL);\n\t}\n\nout_unlock:\n\t__wakeup_reset(wakeup_trace);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\nout:\n\tatomic_dec(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static struct task_struct\t*wakeup_task;",
      "static int\t\t\twakeup_cpu;",
      "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->array_buffer.data",
            "cpu"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wakeup_reset",
          "args": [
            "wakeup_trace"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "497-507",
          "snippet": "static void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = false;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_cpu;",
            "static unsigned\t\t\twakeup_prio = -1;",
            "static bool\t\t\ttracing_dl;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic unsigned\t\t\twakeup_prio = -1;\nstatic bool\t\t\ttracing_dl;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void __wakeup_reset(struct trace_array *tr)\n{\n\twakeup_cpu = -1;\n\twakeup_prio = -1;\n\ttracing_dl = false;\n\n\tif (wakeup_task)\n\t\tput_task_struct(wakeup_task);\n\n\twakeup_task = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_max_tr",
          "args": [
            "wakeup_trace",
            "wakeup_task",
            "wakeup_cpu",
            "NULL"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1788-1821",
          "snippet": "void\nupdate_max_tr(struct trace_array *tr, struct task_struct *tsk, int cpu,\n\t      void *cond_data)\n{\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\t/* Inherit the recordable setting from array_buffer */\n\tif (ring_buffer_record_is_set_on(tr->array_buffer.buffer))\n\t\tring_buffer_record_on(tr->max_buffer.buffer);\n\telse\n\t\tring_buffer_record_off(tr->max_buffer.buffer);\n\n#ifdef CONFIG_TRACER_SNAPSHOT\n\tif (tr->cond_snapshot && !tr->cond_snapshot->update(tr, cond_data))\n\t\tgoto out_unlock;\n#endif\n\tswap(tr->array_buffer.buffer, tr->max_buffer.buffer);\n\n\t__update_max_tr(tr, tsk, cpu);\n\n out_unlock:\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid\nupdate_max_tr(struct trace_array *tr, struct task_struct *tsk, int cpu,\n\t      void *cond_data)\n{\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\t/* Inherit the recordable setting from array_buffer */\n\tif (ring_buffer_record_is_set_on(tr->array_buffer.buffer))\n\t\tring_buffer_record_on(tr->max_buffer.buffer);\n\telse\n\t\tring_buffer_record_off(tr->max_buffer.buffer);\n\n#ifdef CONFIG_TRACER_SNAPSHOT\n\tif (tr->cond_snapshot && !tr->cond_snapshot->update(tr, cond_data))\n\t\tgoto out_unlock;\n#endif\n\tswap(tr->array_buffer.buffer, tr->max_buffer.buffer);\n\n\t__update_max_tr(tr, tsk, cpu);\n\n out_unlock:\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!is_tracing_stopped()"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_tracing_stopped",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "is_tracing_stopped",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2247-2250",
          "snippet": "int is_tracing_stopped(void)\n{\n\treturn global_trace.stop_count;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint is_tracing_stopped(void)\n{\n\treturn global_trace.stop_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_latency",
          "args": [
            "wakeup_trace",
            "delta"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "report_latency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "350-360",
          "snippet": "static bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_now",
          "args": [
            "cpu"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "765-768",
          "snippet": "u64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.array_buffer, cpu);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nu64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.array_buffer, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_stack",
          "args": [
            "wakeup_trace",
            "trace_ctx",
            "0"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3078-3100",
          "snippet": "void __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nvoid __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_sched_switch_trace",
          "args": [
            "wakeup_trace",
            "prev",
            "next",
            "trace_ctx"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_sched_switch_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "371-397",
          "snippet": "static void\ntracing_sched_switch_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *prev,\n\t\t\t   struct task_struct *next,\n\t\t\t   unsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_context_switch;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_CTX,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= prev->pid;\n\tentry->prev_prio\t\t= prev->prio;\n\tentry->prev_state\t\t= task_state_index(prev);\n\tentry->next_pid\t\t\t= next->pid;\n\tentry->next_prio\t\t= next->prio;\n\tentry->next_state\t\t= task_state_index(next);\n\tentry->next_cpu\t= task_cpu(next);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\ntracing_sched_switch_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *prev,\n\t\t\t   struct task_struct *next,\n\t\t\t   unsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_context_switch;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_CTX,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= prev->pid;\n\tentry->prev_prio\t\t= prev->prio;\n\tentry->prev_state\t\t= task_state_index(prev);\n\tentry->next_pid\t\t\t= next->pid;\n\tentry->next_prio\t\t= next->prio;\n\tentry->next_state\t\t= task_state_index(next);\n\tentry->next_cpu\t= task_cpu(next);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_function",
          "args": [
            "wakeup_trace",
            "CALLER_ADDR0",
            "CALLER_ADDR1",
            "trace_ctx"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "300-309",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->array_buffer.data",
            "wakeup_cpu"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tracer_enabled || next != wakeup_task"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&wakeup_lock"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "flags"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "disabled != 1"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wakeup_trace->array_buffer.data",
            "cpu"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tracer_enabled"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_record_cmdline",
          "args": [
            "prev"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_record_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2562-2565",
          "snippet": "void tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_cpu;\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic void notrace\nprobe_wakeup_sched_switch(void *ignore, bool preempt,\n\t\t\t  struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array_cpu *data;\n\tu64 T0, T1, delta;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tunsigned int trace_ctx;\n\n\ttracing_record_cmdline(prev);\n\n\tif (unlikely(!tracer_enabled))\n\t\treturn;\n\n\t/*\n\t * When we start a new trace, we set wakeup_task to NULL\n\t * and then set tracer_enabled = 1. We want to make sure\n\t * that another CPU does not see the tracer_enabled = 1\n\t * and the wakeup_task with an older task, that might\n\t * actually be the same as next.\n\t */\n\tsmp_rmb();\n\n\tif (next != wakeup_task)\n\t\treturn;\n\n\t/* disable local data, not wakeup_cpu data */\n\tcpu = raw_smp_processor_id();\n\tdisabled = atomic_inc_return(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);\n\tif (likely(disabled != 1))\n\t\tgoto out;\n\n\tlocal_irq_save(flags);\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\n\tarch_spin_lock(&wakeup_lock);\n\n\t/* We could race with grabbing wakeup_lock */\n\tif (unlikely(!tracer_enabled || next != wakeup_task))\n\t\tgoto out_unlock;\n\n\t/* The task we are waiting for is waking up */\n\tdata = per_cpu_ptr(wakeup_trace->array_buffer.data, wakeup_cpu);\n\n\t__trace_function(wakeup_trace, CALLER_ADDR0, CALLER_ADDR1, trace_ctx);\n\ttracing_sched_switch_trace(wakeup_trace, prev, next, trace_ctx);\n\t__trace_stack(wakeup_trace, trace_ctx, 0);\n\n\tT0 = data->preempt_timestamp;\n\tT1 = ftrace_now(cpu);\n\tdelta = T1-T0;\n\n\tif (!report_latency(wakeup_trace, delta))\n\t\tgoto out_unlock;\n\n\tif (likely(!is_tracing_stopped())) {\n\t\twakeup_trace->max_latency = delta;\n\t\tupdate_max_tr(wakeup_trace, wakeup_task, wakeup_cpu, NULL);\n\t}\n\nout_unlock:\n\t__wakeup_reset(wakeup_trace);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\nout:\n\tatomic_dec(&per_cpu_ptr(wakeup_trace->array_buffer.data, cpu)->disabled);\n}"
  },
  {
    "function_name": "tracing_sched_wakeup_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "399-425",
    "snippet": "static void\ntracing_sched_wakeup_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *wakee,\n\t\t\t   struct task_struct *curr,\n\t\t\t   unsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_wakeup;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_WAKE,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= curr->pid;\n\tentry->prev_prio\t\t= curr->prio;\n\tentry->prev_state\t\t= task_state_index(curr);\n\tentry->next_pid\t\t\t= wakee->pid;\n\tentry->next_prio\t\t= wakee->prio;\n\tentry->next_state\t\t= task_state_index(wakee);\n\tentry->next_cpu\t\t\t= task_cpu(wakee);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "tr",
            "buffer",
            "event",
            "trace_ctx"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1322-1328",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "502-513",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "wakee"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_state_index",
          "args": [
            "wakee"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_state_index",
          "args": [
            "curr"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_WAKE",
            "sizeof(*entry)",
            "trace_ctx"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\ntracing_sched_wakeup_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *wakee,\n\t\t\t   struct task_struct *curr,\n\t\t\t   unsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_wakeup;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_WAKE,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= curr->pid;\n\tentry->prev_prio\t\t= curr->prio;\n\tentry->prev_state\t\t= task_state_index(curr);\n\tentry->next_pid\t\t\t= wakee->pid;\n\tentry->next_prio\t\t= wakee->prio;\n\tentry->next_state\t\t= task_state_index(wakee);\n\tentry->next_cpu\t\t\t= task_cpu(wakee);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}"
  },
  {
    "function_name": "tracing_sched_switch_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "371-397",
    "snippet": "static void\ntracing_sched_switch_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *prev,\n\t\t\t   struct task_struct *next,\n\t\t\t   unsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_context_switch;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_CTX,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= prev->pid;\n\tentry->prev_prio\t\t= prev->prio;\n\tentry->prev_state\t\t= task_state_index(prev);\n\tentry->next_pid\t\t\t= next->pid;\n\tentry->next_prio\t\t= next->prio;\n\tentry->next_state\t\t= task_state_index(next);\n\tentry->next_cpu\t= task_cpu(next);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "tr",
            "buffer",
            "event",
            "trace_ctx"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1322-1328",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "502-513",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "next"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_state_index",
          "args": [
            "next"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_state_index",
          "args": [
            "prev"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_CTX",
            "sizeof(*entry)",
            "trace_ctx"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\ntracing_sched_switch_trace(struct trace_array *tr,\n\t\t\t   struct task_struct *prev,\n\t\t\t   struct task_struct *next,\n\t\t\t   unsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_context_switch;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ctx_switch_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_CTX,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->prev_pid\t\t\t= prev->pid;\n\tentry->prev_prio\t\t= prev->prio;\n\tentry->prev_state\t\t= task_state_index(prev);\n\tentry->next_pid\t\t\t= next->pid;\n\tentry->next_prio\t\t= next->prio;\n\tentry->next_state\t\t= task_state_index(next);\n\tentry->next_cpu\t= task_cpu(next);\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}"
  },
  {
    "function_name": "probe_wakeup_migrate_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "362-369",
    "snippet": "static void\nprobe_wakeup_migrate_task(void *ignore, struct task_struct *task, int cpu)\n{\n\tif (task != wakeup_task)\n\t\treturn;\n\n\twakeup_current_cpu = cpu;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct\t*wakeup_task;",
      "static int\t\t\twakeup_current_cpu;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_current_cpu;\n\nstatic void\nprobe_wakeup_migrate_task(void *ignore, struct task_struct *task, int cpu)\n{\n\tif (task != wakeup_task)\n\t\treturn;\n\n\twakeup_current_cpu = cpu;\n}"
  },
  {
    "function_name": "report_latency",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "350-360",
    "snippet": "static bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "stop_func_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "340-345",
    "snippet": "static void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static int start_func_tracer(struct trace_array *tr, int graph);",
      "static void stop_func_tracer(struct trace_array *tr, int graph);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_wakeup_function",
          "args": [
            "tr",
            "graph"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_wakeup_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "278-278",
          "snippet": "static void unregister_wakeup_function(struct trace_array *tr, int graph) { }",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int start_func_tracer(struct trace_array *tr, int graph);",
            "static void stop_func_tracer(struct trace_array *tr, int graph);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic void unregister_wakeup_function(struct trace_array *tr, int graph) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}"
  },
  {
    "function_name": "start_func_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "326-338",
    "snippet": "static int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static int start_func_tracer(struct trace_array *tr, int graph);",
      "static void stop_func_tracer(struct trace_array *tr, int graph);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_is_enabled",
          "args": [],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "779-788",
          "snippet": "int tracing_is_enabled(void)\n{\n\t/*\n\t * For quick access (irqsoff uses this in fast path), just\n\t * return the mirror variable of the state of the ring buffer.\n\t * It's a little racy, but we don't really care.\n\t */\n\tsmp_rmb();\n\treturn !global_trace.buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracing_is_enabled(void)\n{\n\t/*\n\t * For quick access (irqsoff uses this in fast path), just\n\t * return the mirror variable of the state of the ring buffer.\n\t * It's a little racy, but we don't really care.\n\t */\n\tsmp_rmb();\n\treturn !global_trace.buffer_disabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_wakeup_function",
          "args": [
            "tr",
            "graph",
            "0"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "register_wakeup_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "274-277",
          "snippet": "static int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int start_func_tracer(struct trace_array *tr, int graph);",
            "static void stop_func_tracer(struct trace_array *tr, int graph);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wakeup_flag_changed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "311-324",
    "snippet": "static int wakeup_flag_changed(struct trace_array *tr, u32 mask, int set)\n{\n\tstruct tracer *tracer = tr->current_trace;\n\n\tif (wakeup_function_set(tr, mask, set))\n\t\treturn 0;\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (mask & TRACE_ITER_DISPLAY_GRAPH)\n\t\treturn wakeup_display_graph(tr, set);\n#endif\n\n\treturn trace_keep_overwrite(tracer, mask, set);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_keep_overwrite",
          "args": [
            "tracer",
            "mask",
            "set"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "trace_keep_overwrite",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "5259-5265",
          "snippet": "int trace_keep_overwrite(struct tracer *tracer, u32 mask, int set)\n{\n\tif (tracer->enabled && (mask & TRACE_ITER_OVERWRITE) && !set)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint trace_keep_overwrite(struct tracer *tracer, u32 mask, int set)\n{\n\tif (tracer->enabled && (mask & TRACE_ITER_OVERWRITE) && !set)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_display_graph",
          "args": [
            "tr",
            "set"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_display_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "102-113",
          "snippet": "static int wakeup_display_graph(struct trace_array *tr, int set)\n{\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_func_tracer(tr, !set);\n\n\twakeup_reset(wakeup_trace);\n\ttr->max_latency = 0;\n\n\treturn start_func_tracer(tr, set);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array\t*wakeup_trace;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_display_graph(struct trace_array *tr, int set)\n{\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_func_tracer(tr, !set);\n\n\twakeup_reset(wakeup_trace);\n\ttr->max_latency = 0;\n\n\treturn start_func_tracer(tr, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_function_set",
          "args": [
            "tr",
            "mask",
            "set"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_function_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "279-282",
          "snippet": "static int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_flag_changed(struct trace_array *tr, u32 mask, int set)\n{\n\tstruct tracer *tracer = tr->current_trace;\n\n\tif (wakeup_function_set(tr, mask, set))\n\t\treturn 0;\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (mask & TRACE_ITER_DISPLAY_GRAPH)\n\t\treturn wakeup_display_graph(tr, set);\n#endif\n\n\treturn trace_keep_overwrite(tracer, mask, set);\n}"
  },
  {
    "function_name": "__trace_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "300-309",
    "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "300-309",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "trace_graph_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "trace_graph_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "208-214",
          "snippet": "void\ntrace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long parent_ip,\n\t\tunsigned int trace_ctx)\n{\n\t__trace_graph_function(tr, ip, trace_ctx);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid\ntrace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long parent_ip,\n\t\tunsigned int trace_ctx)\n{\n\t__trace_graph_function(tr, ip, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}"
  },
  {
    "function_name": "wakeup_print_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "294-297",
    "snippet": "static void wakeup_print_header(struct seq_file *s)\n{\n\ttrace_default_header(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_default_header",
          "args": [
            "s"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "trace_default_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4546-4572",
          "snippet": "void trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->array_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->array_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->array_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->array_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_print_header(struct seq_file *s)\n{\n\ttrace_default_header(s);\n}"
  },
  {
    "function_name": "wakeup_trace_close",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "292-292",
    "snippet": "static void wakeup_trace_close(struct trace_iterator *iter) { }",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_trace_close(struct trace_iterator *iter) { }"
  },
  {
    "function_name": "wakeup_trace_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "291-291",
    "snippet": "static void wakeup_trace_open(struct trace_iterator *iter) { }",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_trace_open(struct trace_iterator *iter) { }"
  },
  {
    "function_name": "wakeup_print_line",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "286-289",
    "snippet": "static enum print_line_t wakeup_print_line(struct trace_iterator *iter)\n{\n\treturn TRACE_TYPE_UNHANDLED;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic enum print_line_t wakeup_print_line(struct trace_iterator *iter)\n{\n\treturn TRACE_TYPE_UNHANDLED;\n}"
  },
  {
    "function_name": "wakeup_function_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "279-282",
    "snippet": "static int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "unregister_wakeup_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "278-278",
    "snippet": "static void unregister_wakeup_function(struct trace_array *tr, int graph) { }",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static int start_func_tracer(struct trace_array *tr, int graph);",
      "static void stop_func_tracer(struct trace_array *tr, int graph);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic void unregister_wakeup_function(struct trace_array *tr, int graph) { }"
  },
  {
    "function_name": "register_wakeup_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "274-277",
    "snippet": "static int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static int start_func_tracer(struct trace_array *tr, int graph);",
      "static void stop_func_tracer(struct trace_array *tr, int graph);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "wakeup_function_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "262-272",
    "snippet": "static int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\tif (!(mask & TRACE_ITER_FUNCTION))\n\t\treturn 0;\n\n\tif (set)\n\t\tregister_wakeup_function(tr, is_graph(tr), 1);\n\telse\n\t\tunregister_wakeup_function(tr, is_graph(tr));\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_wakeup_function",
          "args": [
            "tr",
            "is_graph(tr)"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_wakeup_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "278-278",
          "snippet": "static void unregister_wakeup_function(struct trace_array *tr, int graph) { }",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int start_func_tracer(struct trace_array *tr, int graph);",
            "static void stop_func_tracer(struct trace_array *tr, int graph);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic void unregister_wakeup_function(struct trace_array *tr, int graph) { }"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_wakeup_function",
          "args": [
            "tr",
            "is_graph(tr)",
            "1"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "register_wakeup_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "274-277",
          "snippet": "static int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int start_func_tracer(struct trace_array *tr, int graph);",
            "static void stop_func_tracer(struct trace_array *tr, int graph);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\tif (!(mask & TRACE_ITER_FUNCTION))\n\t\treturn 0;\n\n\tif (set)\n\t\tregister_wakeup_function(tr, is_graph(tr), 1);\n\telse\n\t\tunregister_wakeup_function(tr, is_graph(tr));\n\treturn 1;\n}"
  },
  {
    "function_name": "unregister_wakeup_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "249-260",
    "snippet": "static void unregister_wakeup_function(struct trace_array *tr, int graph)\n{\n\tif (!function_enabled)\n\t\treturn;\n\n\tif (graph)\n\t\tunregister_ftrace_graph(&fgraph_wakeup_ops);\n\telse\n\t\tunregister_ftrace_function(tr->ops);\n\n\tfunction_enabled = false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static int start_func_tracer(struct trace_array *tr, int graph);",
      "static void stop_func_tracer(struct trace_array *tr, int graph);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_graph",
          "args": [
            "&fgraph_wakeup_ops"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "636-653",
          "snippet": "void unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_graph_active;",
            "static struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};",
            "static struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};",
            "trace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;",
            "trace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;",
            "static trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nint ftrace_graph_active;\nstatic struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};\nstatic struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};\ntrace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;\ntrace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;\nstatic trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;\n\nvoid unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic void unregister_wakeup_function(struct trace_array *tr, int graph)\n{\n\tif (!function_enabled)\n\t\treturn;\n\n\tif (graph)\n\t\tunregister_ftrace_graph(&fgraph_wakeup_ops);\n\telse\n\t\tunregister_ftrace_function(tr->ops);\n\n\tfunction_enabled = false;\n}"
  },
  {
    "function_name": "register_wakeup_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "230-247",
    "snippet": "static int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\tint ret;\n\n\t/* 'set' is set if TRACE_ITER_FUNCTION is about to be set */\n\tif (function_enabled || (!set && !(tr->trace_flags & TRACE_ITER_FUNCTION)))\n\t\treturn 0;\n\n\tif (graph)\n\t\tret = register_ftrace_graph(&fgraph_wakeup_ops);\n\telse\n\t\tret = register_ftrace_function(tr->ops);\n\n\tif (!ret)\n\t\tfunction_enabled = true;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static int start_func_tracer(struct trace_array *tr, int graph);",
      "static void stop_func_tracer(struct trace_array *tr, int graph);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_ftrace_graph",
          "args": [
            "&fgraph_wakeup_ops"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "636-653",
          "snippet": "void unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_graph_active;",
            "static struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};",
            "static struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};",
            "trace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;",
            "trace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;",
            "static trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nint ftrace_graph_active;\nstatic struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};\nstatic struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};\ntrace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;\ntrace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;\nstatic trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;\n\nvoid unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic int register_wakeup_function(struct trace_array *tr, int graph, int set)\n{\n\tint ret;\n\n\t/* 'set' is set if TRACE_ITER_FUNCTION is about to be set */\n\tif (function_enabled || (!set && !(tr->trace_flags & TRACE_ITER_FUNCTION)))\n\t\treturn 0;\n\n\tif (graph)\n\t\tret = register_ftrace_graph(&fgraph_wakeup_ops);\n\telse\n\t\tret = register_ftrace_function(tr->ops);\n\n\tif (!ret)\n\t\tfunction_enabled = true;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wakeup_tracer_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "210-228",
    "snippet": "static void\nwakeup_tracer_call(unsigned long ip, unsigned long parent_ip,\n\t\t   struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\n\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\tlocal_irq_restore(flags);\n\n\tatomic_dec(&data->disabled);\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "300-309",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_prolog_preempt_disable",
          "args": [
            "tr",
            "&data",
            "&trace_ctx"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "func_prolog_preempt_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "67-98",
          "snippet": "static int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    unsigned int *trace_ctx)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*trace_ctx = tracing_gen_ctx();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_current_cpu;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_current_cpu;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    unsigned int *trace_ctx)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*trace_ctx = tracing_gen_ctx();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void\nwakeup_tracer_call(unsigned long ip, unsigned long parent_ip,\n\t\t   struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\n\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\tlocal_irq_restore(flags);\n\n\tatomic_dec(&data->disabled);\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "wakeup_print_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "198-204",
    "snippet": "static void wakeup_print_header(struct seq_file *s)\n{\n\tif (is_graph(wakeup_trace))\n\t\tprint_graph_headers_flags(s, GRAPH_TRACER_FLAGS);\n\telse\n\t\ttrace_default_header(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_CPU |  \\\n\t\t\t    TRACE_GRAPH_PRINT_REL_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION | \\\n\t\t\t    TRACE_GRAPH_PRINT_OVERHEAD | \\\n\t\t\t    TRACE_GRAPH_PRINT_IRQS)"
    ],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_default_header",
          "args": [
            "s"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "trace_default_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4546-4572",
          "snippet": "void trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->array_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->array_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->array_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->array_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_headers_flags",
          "args": [
            "s",
            "GRAPH_TRACER_FLAGS"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_headers_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1179-1196",
          "snippet": "void print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "wakeup_trace"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_CPU |  \\\n\t\t\t    TRACE_GRAPH_PRINT_REL_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION | \\\n\t\t\t    TRACE_GRAPH_PRINT_OVERHEAD | \\\n\t\t\t    TRACE_GRAPH_PRINT_IRQS)\n\nstatic struct trace_array\t*wakeup_trace;\n\nstatic void wakeup_print_header(struct seq_file *s)\n{\n\tif (is_graph(wakeup_trace))\n\t\tprint_graph_headers_flags(s, GRAPH_TRACER_FLAGS);\n\telse\n\t\ttrace_default_header(s);\n}"
  },
  {
    "function_name": "wakeup_print_line",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "186-196",
    "snippet": "static enum print_line_t wakeup_print_line(struct trace_iterator *iter)\n{\n\t/*\n\t * In graph mode call the graph tracer output function,\n\t * otherwise go with the TRACE_FN event handler\n\t */\n\tif (is_graph(iter->tr))\n\t\treturn print_graph_function_flags(iter, GRAPH_TRACER_FLAGS);\n\n\treturn TRACE_TYPE_UNHANDLED;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_CPU |  \\\n\t\t\t    TRACE_GRAPH_PRINT_REL_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION | \\\n\t\t\t    TRACE_GRAPH_PRINT_OVERHEAD | \\\n\t\t\t    TRACE_GRAPH_PRINT_IRQS)"
    ],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);",
      "static int start_func_tracer(struct trace_array *tr, int graph);",
      "static void stop_func_tracer(struct trace_array *tr, int graph);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_function_flags",
          "args": [
            "iter",
            "GRAPH_TRACER_FLAGS"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_function_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1036-1095",
          "snippet": "enum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nenum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "iter->tr"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_CPU |  \\\n\t\t\t    TRACE_GRAPH_PRINT_REL_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION | \\\n\t\t\t    TRACE_GRAPH_PRINT_OVERHEAD | \\\n\t\t\t    TRACE_GRAPH_PRINT_IRQS)\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic enum print_line_t wakeup_print_line(struct trace_iterator *iter)\n{\n\t/*\n\t * In graph mode call the graph tracer output function,\n\t * otherwise go with the TRACE_FN event handler\n\t */\n\tif (is_graph(iter->tr))\n\t\treturn print_graph_function_flags(iter, GRAPH_TRACER_FLAGS);\n\n\treturn TRACE_TYPE_UNHANDLED;\n}"
  },
  {
    "function_name": "wakeup_trace_close",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "173-177",
    "snippet": "static void wakeup_trace_close(struct trace_iterator *iter)\n{\n\tif (iter->private)\n\t\tgraph_trace_close(iter);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "graph_trace_close",
          "args": [
            "iter"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "graph_trace_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1240-1248",
          "snippet": "void graph_trace_close(struct trace_iterator *iter)\n{\n\tstruct fgraph_data *data = iter->private;\n\n\tif (data) {\n\t\tfree_percpu(data->cpu_data);\n\t\tkfree(data);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid graph_trace_close(struct trace_iterator *iter)\n{\n\tstruct fgraph_data *data = iter->private;\n\n\tif (data) {\n\t\tfree_percpu(data->cpu_data);\n\t\tkfree(data);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_trace_close(struct trace_iterator *iter)\n{\n\tif (iter->private)\n\t\tgraph_trace_close(iter);\n}"
  },
  {
    "function_name": "wakeup_trace_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "167-171",
    "snippet": "static void wakeup_trace_open(struct trace_iterator *iter)\n{\n\tif (is_graph(iter->tr))\n\t\tgraph_trace_open(iter);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "graph_trace_open",
          "args": [
            "iter"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "graph_trace_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1198-1238",
          "snippet": "void graph_trace_open(struct trace_iterator *iter)\n{\n\t/* pid and depth on the last trace processed */\n\tstruct fgraph_data *data;\n\tgfp_t gfpflags;\n\tint cpu;\n\n\titer->private = NULL;\n\n\t/* We can be called in atomic context via ftrace_dump() */\n\tgfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tdata = kzalloc(sizeof(*data), gfpflags);\n\tif (!data)\n\t\tgoto out_err;\n\n\tdata->cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);\n\tif (!data->cpu_data)\n\t\tgoto out_err_free;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpid_t *pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\t\tint *depth = &(per_cpu_ptr(data->cpu_data, cpu)->depth);\n\t\tint *ignore = &(per_cpu_ptr(data->cpu_data, cpu)->ignore);\n\t\tint *depth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t\t*pid = -1;\n\t\t*depth = 0;\n\t\t*ignore = 0;\n\t\t*depth_irq = -1;\n\t}\n\n\titer->private = data;\n\n\treturn;\n\n out_err_free:\n\tkfree(data);\n out_err:\n\tpr_warn(\"function graph tracer: not enough memory\\n\");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid graph_trace_open(struct trace_iterator *iter)\n{\n\t/* pid and depth on the last trace processed */\n\tstruct fgraph_data *data;\n\tgfp_t gfpflags;\n\tint cpu;\n\n\titer->private = NULL;\n\n\t/* We can be called in atomic context via ftrace_dump() */\n\tgfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tdata = kzalloc(sizeof(*data), gfpflags);\n\tif (!data)\n\t\tgoto out_err;\n\n\tdata->cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);\n\tif (!data->cpu_data)\n\t\tgoto out_err_free;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpid_t *pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\t\tint *depth = &(per_cpu_ptr(data->cpu_data, cpu)->depth);\n\t\tint *ignore = &(per_cpu_ptr(data->cpu_data, cpu)->ignore);\n\t\tint *depth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t\t*pid = -1;\n\t\t*depth = 0;\n\t\t*ignore = 0;\n\t\t*depth_irq = -1;\n\t}\n\n\titer->private = data;\n\n\treturn;\n\n out_err_free:\n\tkfree(data);\n out_err:\n\tpr_warn(\"function graph tracer: not enough memory\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "iter->tr"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_trace_open(struct trace_iterator *iter)\n{\n\tif (is_graph(iter->tr))\n\t\tgraph_trace_open(iter);\n}"
  },
  {
    "function_name": "wakeup_graph_return",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "144-160",
    "snippet": "static void wakeup_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tftrace_graph_addr_finish(trace);\n\n\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))\n\t\treturn;\n\n\t__trace_graph_return(tr, trace, trace_ctx);\n\tatomic_dec(&data->disabled);\n\n\tpreempt_enable_notrace();\n\treturn;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_graph_return",
          "args": [
            "tr",
            "trace",
            "trace_ctx"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "216-233",
          "snippet": "void __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "func_prolog_preempt_disable",
          "args": [
            "tr",
            "&data",
            "&trace_ctx"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "func_prolog_preempt_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "67-98",
          "snippet": "static int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    unsigned int *trace_ctx)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*trace_ctx = tracing_gen_ctx();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_current_cpu;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_current_cpu;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    unsigned int *trace_ctx)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*trace_ctx = tracing_gen_ctx();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_addr_finish",
          "args": [
            "trace"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_addr_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "947-948",
          "snippet": "static inline void ftrace_graph_addr_finish(struct ftrace_graph_ret *trace)\n{ }",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void ftrace_graph_addr_finish(struct ftrace_graph_ret *trace)\n{ }"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tftrace_graph_addr_finish(trace);\n\n\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))\n\t\treturn;\n\n\t__trace_graph_return(tr, trace, trace_ctx);\n\tatomic_dec(&data->disabled);\n\n\tpreempt_enable_notrace();\n\treturn;\n}"
  },
  {
    "function_name": "wakeup_graph_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "115-142",
    "snippet": "static int wakeup_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\tint ret = 0;\n\n\tif (ftrace_graph_ignore_func(trace))\n\t\treturn 0;\n\t/*\n\t * Do not trace a function if it's filtered by set_graph_notrace.\n\t * Make the index of ret stack negative to indicate that it should\n\t * ignore further functions.  But it needs its own ret stack entry\n\t * to recover the original index in order to continue tracing after\n\t * returning from the function.\n\t */\n\tif (ftrace_graph_notrace_addr(trace->func))\n\t\treturn 1;\n\n\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))\n\t\treturn 0;\n\n\tret = __trace_graph_entry(tr, trace, trace_ctx);\n\tatomic_dec(&data->disabled);\n\tpreempt_enable_notrace();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_graph_entry",
          "args": [
            "tr",
            "trace",
            "trace_ctx"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "97-116",
          "snippet": "int __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nint __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "func_prolog_preempt_disable",
          "args": [
            "tr",
            "&data",
            "&trace_ctx"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "func_prolog_preempt_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "67-98",
          "snippet": "static int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    unsigned int *trace_ctx)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*trace_ctx = tracing_gen_ctx();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct\t*wakeup_task;",
            "static int\t\t\twakeup_current_cpu;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_current_cpu;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    unsigned int *trace_ctx)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*trace_ctx = tracing_gen_ctx();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_notrace_addr",
          "args": [
            "trace->func"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_notrace_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "943-946",
          "snippet": "static inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_ignore_func",
          "args": [
            "trace"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_ignore_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "953-960",
          "snippet": "static inline bool ftrace_graph_ignore_func(struct ftrace_graph_ent *trace)\n{\n\t/* trace it when it is-nested-in or is a function enabled. */\n\treturn !(trace_recursion_test(TRACE_GRAPH_BIT) ||\n\t\t ftrace_graph_addr(trace)) ||\n\t\t(trace->depth < 0) ||\n\t\t(fgraph_max_depth && trace->depth >= fgraph_max_depth);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool ftrace_graph_ignore_func(struct ftrace_graph_ent *trace)\n{\n\t/* trace it when it is-nested-in or is a function enabled. */\n\treturn !(trace_recursion_test(TRACE_GRAPH_BIT) ||\n\t\t ftrace_graph_addr(trace)) ||\n\t\t(trace->depth < 0) ||\n\t\t(fgraph_max_depth && trace->depth >= fgraph_max_depth);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct trace_array *tr = wakeup_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\tint ret = 0;\n\n\tif (ftrace_graph_ignore_func(trace))\n\t\treturn 0;\n\t/*\n\t * Do not trace a function if it's filtered by set_graph_notrace.\n\t * Make the index of ret stack negative to indicate that it should\n\t * ignore further functions.  But it needs its own ret stack entry\n\t * to recover the original index in order to continue tracing after\n\t * returning from the function.\n\t */\n\tif (ftrace_graph_notrace_addr(trace->func))\n\t\treturn 1;\n\n\tif (!func_prolog_preempt_disable(tr, &data, &trace_ctx))\n\t\treturn 0;\n\n\tret = __trace_graph_entry(tr, trace, trace_ctx);\n\tatomic_dec(&data->disabled);\n\tpreempt_enable_notrace();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wakeup_display_graph",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "102-113",
    "snippet": "static int wakeup_display_graph(struct trace_array *tr, int set)\n{\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_func_tracer(tr, !set);\n\n\twakeup_reset(wakeup_trace);\n\ttr->max_latency = 0;\n\n\treturn start_func_tracer(tr, set);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array\t*wakeup_trace;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_func_tracer",
          "args": [
            "tr",
            "set"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "start_func_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "326-338",
          "snippet": "static int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int start_func_tracer(struct trace_array *tr, int graph);",
            "static void stop_func_tracer(struct trace_array *tr, int graph);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic int start_func_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_wakeup_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_reset",
          "args": [
            "wakeup_trace"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "509-520",
          "snippet": "static void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;",
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic arch_spinlock_t wakeup_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic void wakeup_reset(struct trace_array *tr)\n{\n\tunsigned long flags;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&wakeup_lock);\n\t__wakeup_reset(tr);\n\tarch_spin_unlock(&wakeup_lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_func_tracer",
          "args": [
            "tr",
            "!set"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "stop_func_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
          "lines": "340-345",
          "snippet": "static void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_reset(struct trace_array *tr);",
            "static void __wakeup_reset(struct trace_array *tr);",
            "static int start_func_tracer(struct trace_array *tr, int graph);",
            "static void stop_func_tracer(struct trace_array *tr, int graph);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\nstatic int start_func_tracer(struct trace_array *tr, int graph);\nstatic void stop_func_tracer(struct trace_array *tr, int graph);\n\nstatic void stop_func_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_wakeup_function(tr, graph);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_array\t*wakeup_trace;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int wakeup_display_graph(struct trace_array *tr, int set)\n{\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_func_tracer(tr, !set);\n\n\twakeup_reset(wakeup_trace);\n\ttr->max_latency = 0;\n\n\treturn start_func_tracer(tr, set);\n}"
  },
  {
    "function_name": "func_prolog_preempt_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_wakeup.c",
    "lines": "67-98",
    "snippet": "static int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    unsigned int *trace_ctx)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*trace_ctx = tracing_gen_ctx();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct\t*wakeup_task;",
      "static int\t\t\twakeup_current_cpu;",
      "static void wakeup_reset(struct trace_array *tr);",
      "static void __wakeup_reset(struct trace_array *tr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&(*data)->disabled"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "disabled != 1"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&(*data)->disabled"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "cpu"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!wakeup_task"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct task_struct\t*wakeup_task;\nstatic int\t\t\twakeup_current_cpu;\nstatic void wakeup_reset(struct trace_array *tr);\nstatic void __wakeup_reset(struct trace_array *tr);\n\nstatic int\nfunc_prolog_preempt_disable(struct trace_array *tr,\n\t\t\t    struct trace_array_cpu **data,\n\t\t\t    unsigned int *trace_ctx)\n{\n\tlong disabled;\n\tint cpu;\n\n\tif (likely(!wakeup_task))\n\t\treturn 0;\n\n\t*trace_ctx = tracing_gen_ctx();\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\tif (cpu != wakeup_current_cpu)\n\t\tgoto out_enable;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\tif (unlikely(disabled != 1))\n\t\tgoto out;\n\n\treturn 1;\n\nout:\n\tatomic_dec(&(*data)->disabled);\n\nout_enable:\n\tpreempt_enable_notrace();\n\treturn 0;\n}"
  }
]