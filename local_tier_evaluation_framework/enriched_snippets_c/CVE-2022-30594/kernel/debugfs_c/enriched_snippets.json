[
  {
    "function_name": "kcsan_debugfs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
    "lines": "269-273",
    "snippet": "static int __init kcsan_debugfs_init(void)\n{\n\tdebugfs_create_file(\"kcsan\", 0644, NULL, NULL, &debugfs_ops);\n\treturn 0;\n}",
    "includes": [
      "#include \"kcsan.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bug.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations debugfs_ops =\n{\n\t.read\t = seq_read,\n\t.open\t = debugfs_open,\n\t.write\t = debugfs_write,\n\t.release = single_release\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"kcsan\"",
            "0644",
            "NULL",
            "NULL",
            "&debugfs_ops"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic const struct file_operations debugfs_ops =\n{\n\t.read\t = seq_read,\n\t.open\t = debugfs_open,\n\t.write\t = debugfs_write,\n\t.release = single_release\n};\n\nstatic int __init kcsan_debugfs_init(void)\n{\n\tdebugfs_create_file(\"kcsan\", 0644, NULL, NULL, &debugfs_ops);\n\treturn 0;\n}"
  },
  {
    "function_name": "debugfs_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
    "lines": "223-259",
    "snippet": "static ssize_t\ndebugfs_write(struct file *file, const char __user *buf, size_t count, loff_t *off)\n{\n\tchar kbuf[KSYM_NAME_LEN];\n\tchar *arg;\n\tint read_len = count < (sizeof(kbuf) - 1) ? count : (sizeof(kbuf) - 1);\n\n\tif (copy_from_user(kbuf, buf, read_len))\n\t\treturn -EFAULT;\n\tkbuf[read_len] = '\\0';\n\targ = strstrip(kbuf);\n\n\tif (!strcmp(arg, \"on\")) {\n\t\tWRITE_ONCE(kcsan_enabled, true);\n\t} else if (!strcmp(arg, \"off\")) {\n\t\tWRITE_ONCE(kcsan_enabled, false);\n\t} else if (str_has_prefix(arg, \"microbench=\")) {\n\t\tunsigned long iters;\n\n\t\tif (kstrtoul(&arg[strlen(\"microbench=\")], 0, &iters))\n\t\t\treturn -EINVAL;\n\t\tmicrobenchmark(iters);\n\t} else if (!strcmp(arg, \"whitelist\")) {\n\t\tset_report_filterlist_whitelist(true);\n\t} else if (!strcmp(arg, \"blacklist\")) {\n\t\tset_report_filterlist_whitelist(false);\n\t} else if (arg[0] == '!') {\n\t\tssize_t ret = insert_report_filterlist(&arg[1]);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"kcsan.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bug.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_report_filterlist",
          "args": [
            "&arg[1]"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "insert_report_filterlist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "144-192",
          "snippet": "static ssize_t insert_report_filterlist(const char *func)\n{\n\tunsigned long flags;\n\tunsigned long addr = kallsyms_lookup_name(func);\n\tssize_t ret = 0;\n\n\tif (!addr) {\n\t\tpr_err(\"could not find function: '%s'\\n\", func);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\n\tif (report_filterlist.addrs == NULL) {\n\t\t/* initial allocation */\n\t\treport_filterlist.addrs =\n\t\t\tkmalloc_array(report_filterlist.size,\n\t\t\t\t      sizeof(unsigned long), GFP_ATOMIC);\n\t\tif (report_filterlist.addrs == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (report_filterlist.used == report_filterlist.size) {\n\t\t/* resize filterlist */\n\t\tsize_t new_size = report_filterlist.size * 2;\n\t\tunsigned long *new_addrs =\n\t\t\tkrealloc(report_filterlist.addrs,\n\t\t\t\t new_size * sizeof(unsigned long), GFP_ATOMIC);\n\n\t\tif (new_addrs == NULL) {\n\t\t\t/* leave filterlist itself untouched */\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\treport_filterlist.size = new_size;\n\t\treport_filterlist.addrs = new_addrs;\n\t}\n\n\t/* Note: deduplicating should be done in userspace. */\n\treport_filterlist.addrs[report_filterlist.used++] =\n\t\tkallsyms_lookup_name(func);\n\treport_filterlist.sorted = false;\n\nout:\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};",
            "static DEFINE_SPINLOCK(report_filterlist_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};\nstatic DEFINE_SPINLOCK(report_filterlist_lock);\n\nstatic ssize_t insert_report_filterlist(const char *func)\n{\n\tunsigned long flags;\n\tunsigned long addr = kallsyms_lookup_name(func);\n\tssize_t ret = 0;\n\n\tif (!addr) {\n\t\tpr_err(\"could not find function: '%s'\\n\", func);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\n\tif (report_filterlist.addrs == NULL) {\n\t\t/* initial allocation */\n\t\treport_filterlist.addrs =\n\t\t\tkmalloc_array(report_filterlist.size,\n\t\t\t\t      sizeof(unsigned long), GFP_ATOMIC);\n\t\tif (report_filterlist.addrs == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (report_filterlist.used == report_filterlist.size) {\n\t\t/* resize filterlist */\n\t\tsize_t new_size = report_filterlist.size * 2;\n\t\tunsigned long *new_addrs =\n\t\t\tkrealloc(report_filterlist.addrs,\n\t\t\t\t new_size * sizeof(unsigned long), GFP_ATOMIC);\n\n\t\tif (new_addrs == NULL) {\n\t\t\t/* leave filterlist itself untouched */\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\treport_filterlist.size = new_size;\n\t\treport_filterlist.addrs = new_addrs;\n\t}\n\n\t/* Note: deduplicating should be done in userspace. */\n\treport_filterlist.addrs[report_filterlist.used++] =\n\t\tkallsyms_lookup_name(func);\n\treport_filterlist.sorted = false;\n\nout:\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_report_filterlist_whitelist",
          "args": [
            "false"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "set_report_filterlist_whitelist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "134-141",
          "snippet": "static void set_report_filterlist_whitelist(bool whitelist)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\treport_filterlist.whitelist = whitelist;\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};",
            "static DEFINE_SPINLOCK(report_filterlist_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};\nstatic DEFINE_SPINLOCK(report_filterlist_lock);\n\nstatic void set_report_filterlist_whitelist(bool whitelist)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\treport_filterlist.whitelist = whitelist;\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"blacklist\""
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "microbenchmark",
          "args": [
            "iters"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "microbenchmark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "63-93",
          "snippet": "static noinline void microbenchmark(unsigned long iters)\n{\n\tconst struct kcsan_ctx ctx_save = current->kcsan_ctx;\n\tconst bool was_enabled = READ_ONCE(kcsan_enabled);\n\tu64 cycles;\n\n\t/* We may have been called from an atomic region; reset context. */\n\tmemset(&current->kcsan_ctx, 0, sizeof(current->kcsan_ctx));\n\t/*\n\t * Disable to benchmark fast-path for all accesses, and (expected\n\t * negligible) call into slow-path, but never set up watchpoints.\n\t */\n\tWRITE_ONCE(kcsan_enabled, false);\n\n\tpr_info(\"%s begin | iters: %lu\\n\", __func__, iters);\n\n\tcycles = get_cycles();\n\twhile (iters--) {\n\t\tunsigned long addr = iters & ((PAGE_SIZE << 8) - 1);\n\t\tint type = !(iters & 0x7f) ? KCSAN_ACCESS_ATOMIC :\n\t\t\t\t(!(iters & 0xf) ? KCSAN_ACCESS_WRITE : 0);\n\t\t__kcsan_check_access((void *)addr, sizeof(long), type);\n\t}\n\tcycles = get_cycles() - cycles;\n\n\tpr_info(\"%s end   | cycles: %llu\\n\", __func__, cycles);\n\n\tWRITE_ONCE(kcsan_enabled, was_enabled);\n\t/* restore context */\n\tcurrent->kcsan_ctx = ctx_save;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic noinline void microbenchmark(unsigned long iters)\n{\n\tconst struct kcsan_ctx ctx_save = current->kcsan_ctx;\n\tconst bool was_enabled = READ_ONCE(kcsan_enabled);\n\tu64 cycles;\n\n\t/* We may have been called from an atomic region; reset context. */\n\tmemset(&current->kcsan_ctx, 0, sizeof(current->kcsan_ctx));\n\t/*\n\t * Disable to benchmark fast-path for all accesses, and (expected\n\t * negligible) call into slow-path, but never set up watchpoints.\n\t */\n\tWRITE_ONCE(kcsan_enabled, false);\n\n\tpr_info(\"%s begin | iters: %lu\\n\", __func__, iters);\n\n\tcycles = get_cycles();\n\twhile (iters--) {\n\t\tunsigned long addr = iters & ((PAGE_SIZE << 8) - 1);\n\t\tint type = !(iters & 0x7f) ? KCSAN_ACCESS_ATOMIC :\n\t\t\t\t(!(iters & 0xf) ? KCSAN_ACCESS_WRITE : 0);\n\t\t__kcsan_check_access((void *)addr, sizeof(long), type);\n\t}\n\tcycles = get_cycles() - cycles;\n\n\tpr_info(\"%s end   | cycles: %llu\\n\", __func__, cycles);\n\n\tWRITE_ONCE(kcsan_enabled, was_enabled);\n\t/* restore context */\n\tcurrent->kcsan_ctx = ctx_save;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "&arg[strlen(\"microbench=\")]",
            "0",
            "&iters"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"microbench=\""
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "arg",
            "\"microbench=\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "kcsan_enabled",
            "false"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "kcsan_enabled",
            "true"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "kbuf"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kbuf",
            "buf",
            "read_len"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic ssize_t\ndebugfs_write(struct file *file, const char __user *buf, size_t count, loff_t *off)\n{\n\tchar kbuf[KSYM_NAME_LEN];\n\tchar *arg;\n\tint read_len = count < (sizeof(kbuf) - 1) ? count : (sizeof(kbuf) - 1);\n\n\tif (copy_from_user(kbuf, buf, read_len))\n\t\treturn -EFAULT;\n\tkbuf[read_len] = '\\0';\n\targ = strstrip(kbuf);\n\n\tif (!strcmp(arg, \"on\")) {\n\t\tWRITE_ONCE(kcsan_enabled, true);\n\t} else if (!strcmp(arg, \"off\")) {\n\t\tWRITE_ONCE(kcsan_enabled, false);\n\t} else if (str_has_prefix(arg, \"microbench=\")) {\n\t\tunsigned long iters;\n\n\t\tif (kstrtoul(&arg[strlen(\"microbench=\")], 0, &iters))\n\t\t\treturn -EINVAL;\n\t\tmicrobenchmark(iters);\n\t} else if (!strcmp(arg, \"whitelist\")) {\n\t\tset_report_filterlist_whitelist(true);\n\t} else if (!strcmp(arg, \"blacklist\")) {\n\t\tset_report_filterlist_whitelist(false);\n\t} else if (arg[0] == '!') {\n\t\tssize_t ret = insert_report_filterlist(&arg[1]);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "debugfs_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
    "lines": "218-221",
    "snippet": "static int debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, show_info, NULL);\n}",
    "includes": [
      "#include \"kcsan.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bug.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "show_info",
            "NULL"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, show_info, NULL);\n}"
  },
  {
    "function_name": "show_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
    "lines": "194-216",
    "snippet": "static int show_info(struct seq_file *file, void *v)\n{\n\tint i;\n\tunsigned long flags;\n\n\t/* show stats */\n\tseq_printf(file, \"enabled: %i\\n\", READ_ONCE(kcsan_enabled));\n\tfor (i = 0; i < KCSAN_COUNTER_COUNT; ++i) {\n\t\tseq_printf(file, \"%s: %ld\\n\", counter_names[i],\n\t\t\t   atomic_long_read(&kcsan_counters[i]));\n\t}\n\n\t/* show filter functions, and filter type */\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\tseq_printf(file, \"\\n%s functions: %s\\n\",\n\t\t   report_filterlist.whitelist ? \"whitelisted\" : \"blacklisted\",\n\t\t   report_filterlist.used == 0 ? \"none\" : \"\");\n\tfor (i = 0; i < report_filterlist.used; ++i)\n\t\tseq_printf(file, \" %ps\\n\", (void *)report_filterlist.addrs[i]);\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kcsan.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bug.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_long_t kcsan_counters[KCSAN_COUNTER_COUNT];",
      "static const char *const counter_names[] = {\n\t[KCSAN_COUNTER_USED_WATCHPOINTS]\t\t= \"used_watchpoints\",\n\t[KCSAN_COUNTER_SETUP_WATCHPOINTS]\t\t= \"setup_watchpoints\",\n\t[KCSAN_COUNTER_DATA_RACES]\t\t\t= \"data_races\",\n\t[KCSAN_COUNTER_ASSERT_FAILURES]\t\t\t= \"assert_failures\",\n\t[KCSAN_COUNTER_NO_CAPACITY]\t\t\t= \"no_capacity\",\n\t[KCSAN_COUNTER_REPORT_RACES]\t\t\t= \"report_races\",\n\t[KCSAN_COUNTER_RACES_UNKNOWN_ORIGIN]\t\t= \"races_unknown_origin\",\n\t[KCSAN_COUNTER_UNENCODABLE_ACCESSES]\t\t= \"unencodable_accesses\",\n\t[KCSAN_COUNTER_ENCODING_FALSE_POSITIVES]\t= \"encoding_false_positives\",\n};",
      "static struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};",
      "static DEFINE_SPINLOCK(report_filterlist_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&report_filterlist_lock",
            "flags"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "file",
            "\" %ps\\n\"",
            "(void *)report_filterlist.addrs[i]"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&report_filterlist_lock",
            "flags"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&kcsan_counters[i]"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "kcsan_enabled"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\natomic_long_t kcsan_counters[KCSAN_COUNTER_COUNT];\nstatic const char *const counter_names[] = {\n\t[KCSAN_COUNTER_USED_WATCHPOINTS]\t\t= \"used_watchpoints\",\n\t[KCSAN_COUNTER_SETUP_WATCHPOINTS]\t\t= \"setup_watchpoints\",\n\t[KCSAN_COUNTER_DATA_RACES]\t\t\t= \"data_races\",\n\t[KCSAN_COUNTER_ASSERT_FAILURES]\t\t\t= \"assert_failures\",\n\t[KCSAN_COUNTER_NO_CAPACITY]\t\t\t= \"no_capacity\",\n\t[KCSAN_COUNTER_REPORT_RACES]\t\t\t= \"report_races\",\n\t[KCSAN_COUNTER_RACES_UNKNOWN_ORIGIN]\t\t= \"races_unknown_origin\",\n\t[KCSAN_COUNTER_UNENCODABLE_ACCESSES]\t\t= \"unencodable_accesses\",\n\t[KCSAN_COUNTER_ENCODING_FALSE_POSITIVES]\t= \"encoding_false_positives\",\n};\nstatic struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};\nstatic DEFINE_SPINLOCK(report_filterlist_lock);\n\nstatic int show_info(struct seq_file *file, void *v)\n{\n\tint i;\n\tunsigned long flags;\n\n\t/* show stats */\n\tseq_printf(file, \"enabled: %i\\n\", READ_ONCE(kcsan_enabled));\n\tfor (i = 0; i < KCSAN_COUNTER_COUNT; ++i) {\n\t\tseq_printf(file, \"%s: %ld\\n\", counter_names[i],\n\t\t\t   atomic_long_read(&kcsan_counters[i]));\n\t}\n\n\t/* show filter functions, and filter type */\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\tseq_printf(file, \"\\n%s functions: %s\\n\",\n\t\t   report_filterlist.whitelist ? \"whitelisted\" : \"blacklisted\",\n\t\t   report_filterlist.used == 0 ? \"none\" : \"\");\n\tfor (i = 0; i < report_filterlist.used; ++i)\n\t\tseq_printf(file, \" %ps\\n\", (void *)report_filterlist.addrs[i]);\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "insert_report_filterlist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
    "lines": "144-192",
    "snippet": "static ssize_t insert_report_filterlist(const char *func)\n{\n\tunsigned long flags;\n\tunsigned long addr = kallsyms_lookup_name(func);\n\tssize_t ret = 0;\n\n\tif (!addr) {\n\t\tpr_err(\"could not find function: '%s'\\n\", func);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\n\tif (report_filterlist.addrs == NULL) {\n\t\t/* initial allocation */\n\t\treport_filterlist.addrs =\n\t\t\tkmalloc_array(report_filterlist.size,\n\t\t\t\t      sizeof(unsigned long), GFP_ATOMIC);\n\t\tif (report_filterlist.addrs == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (report_filterlist.used == report_filterlist.size) {\n\t\t/* resize filterlist */\n\t\tsize_t new_size = report_filterlist.size * 2;\n\t\tunsigned long *new_addrs =\n\t\t\tkrealloc(report_filterlist.addrs,\n\t\t\t\t new_size * sizeof(unsigned long), GFP_ATOMIC);\n\n\t\tif (new_addrs == NULL) {\n\t\t\t/* leave filterlist itself untouched */\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\treport_filterlist.size = new_size;\n\t\treport_filterlist.addrs = new_addrs;\n\t}\n\n\t/* Note: deduplicating should be done in userspace. */\n\treport_filterlist.addrs[report_filterlist.used++] =\n\t\tkallsyms_lookup_name(func);\n\treport_filterlist.sorted = false;\n\nout:\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"kcsan.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bug.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};",
      "static DEFINE_SPINLOCK(report_filterlist_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&report_filterlist_lock",
            "flags"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "func"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4466-4487",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "report_filterlist.addrs",
            "new_size * sizeof(unsigned long)",
            "GFP_ATOMIC"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "report_filterlist.size",
            "sizeof(unsigned long)",
            "GFP_ATOMIC"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&report_filterlist_lock",
            "flags"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"could not find function: '%s'\\n\"",
            "func"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};\nstatic DEFINE_SPINLOCK(report_filterlist_lock);\n\nstatic ssize_t insert_report_filterlist(const char *func)\n{\n\tunsigned long flags;\n\tunsigned long addr = kallsyms_lookup_name(func);\n\tssize_t ret = 0;\n\n\tif (!addr) {\n\t\tpr_err(\"could not find function: '%s'\\n\", func);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\n\tif (report_filterlist.addrs == NULL) {\n\t\t/* initial allocation */\n\t\treport_filterlist.addrs =\n\t\t\tkmalloc_array(report_filterlist.size,\n\t\t\t\t      sizeof(unsigned long), GFP_ATOMIC);\n\t\tif (report_filterlist.addrs == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (report_filterlist.used == report_filterlist.size) {\n\t\t/* resize filterlist */\n\t\tsize_t new_size = report_filterlist.size * 2;\n\t\tunsigned long *new_addrs =\n\t\t\tkrealloc(report_filterlist.addrs,\n\t\t\t\t new_size * sizeof(unsigned long), GFP_ATOMIC);\n\n\t\tif (new_addrs == NULL) {\n\t\t\t/* leave filterlist itself untouched */\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\treport_filterlist.size = new_size;\n\t\treport_filterlist.addrs = new_addrs;\n\t}\n\n\t/* Note: deduplicating should be done in userspace. */\n\treport_filterlist.addrs[report_filterlist.used++] =\n\t\tkallsyms_lookup_name(func);\n\treport_filterlist.sorted = false;\n\nout:\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "set_report_filterlist_whitelist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
    "lines": "134-141",
    "snippet": "static void set_report_filterlist_whitelist(bool whitelist)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\treport_filterlist.whitelist = whitelist;\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n}",
    "includes": [
      "#include \"kcsan.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bug.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};",
      "static DEFINE_SPINLOCK(report_filterlist_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&report_filterlist_lock",
            "flags"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&report_filterlist_lock",
            "flags"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};\nstatic DEFINE_SPINLOCK(report_filterlist_lock);\n\nstatic void set_report_filterlist_whitelist(bool whitelist)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\treport_filterlist.whitelist = whitelist;\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n}"
  },
  {
    "function_name": "kcsan_skip_report_debugfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
    "lines": "103-132",
    "snippet": "bool kcsan_skip_report_debugfs(unsigned long func_addr)\n{\n\tunsigned long symbolsize, offset;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tif (!kallsyms_lookup_size_offset(func_addr, &symbolsize, &offset))\n\t\treturn false;\n\tfunc_addr -= offset; /* Get function start */\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\tif (report_filterlist.used == 0)\n\t\tgoto out;\n\n\t/* Sort array if it is unsorted, and then do a binary search. */\n\tif (!report_filterlist.sorted) {\n\t\tsort(report_filterlist.addrs, report_filterlist.used,\n\t\t     sizeof(unsigned long), cmp_filterlist_addrs, NULL);\n\t\treport_filterlist.sorted = true;\n\t}\n\tret = !!bsearch(&func_addr, report_filterlist.addrs,\n\t\t\treport_filterlist.used, sizeof(unsigned long),\n\t\t\tcmp_filterlist_addrs);\n\tif (report_filterlist.whitelist)\n\t\tret = !ret;\n\nout:\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"kcsan.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bug.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};",
      "static DEFINE_SPINLOCK(report_filterlist_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&report_filterlist_lock",
            "flags"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&func_addr",
            "report_filterlist.addrs",
            "report_filterlist.used",
            "sizeof(unsigned long)",
            "cmp_filterlist_addrs"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "report_filterlist.addrs",
            "report_filterlist.used",
            "sizeof(unsigned long)",
            "cmp_filterlist_addrs",
            "NULL"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&report_filterlist_lock",
            "flags"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_size_offset",
          "args": [
            "func_addr",
            "&symbolsize",
            "&offset"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup_size_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "315-326",
          "snippet": "int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};\nstatic DEFINE_SPINLOCK(report_filterlist_lock);\n\nbool kcsan_skip_report_debugfs(unsigned long func_addr)\n{\n\tunsigned long symbolsize, offset;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tif (!kallsyms_lookup_size_offset(func_addr, &symbolsize, &offset))\n\t\treturn false;\n\tfunc_addr -= offset; /* Get function start */\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\tif (report_filterlist.used == 0)\n\t\tgoto out;\n\n\t/* Sort array if it is unsorted, and then do a binary search. */\n\tif (!report_filterlist.sorted) {\n\t\tsort(report_filterlist.addrs, report_filterlist.used,\n\t\t     sizeof(unsigned long), cmp_filterlist_addrs, NULL);\n\t\treport_filterlist.sorted = true;\n\t}\n\tret = !!bsearch(&func_addr, report_filterlist.addrs,\n\t\t\treport_filterlist.used, sizeof(unsigned long),\n\t\t\tcmp_filterlist_addrs);\n\tif (report_filterlist.whitelist)\n\t\tret = !ret;\n\nout:\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "cmp_filterlist_addrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
    "lines": "95-101",
    "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
    "includes": [
      "#include \"kcsan.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bug.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
  },
  {
    "function_name": "microbenchmark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
    "lines": "63-93",
    "snippet": "static noinline void microbenchmark(unsigned long iters)\n{\n\tconst struct kcsan_ctx ctx_save = current->kcsan_ctx;\n\tconst bool was_enabled = READ_ONCE(kcsan_enabled);\n\tu64 cycles;\n\n\t/* We may have been called from an atomic region; reset context. */\n\tmemset(&current->kcsan_ctx, 0, sizeof(current->kcsan_ctx));\n\t/*\n\t * Disable to benchmark fast-path for all accesses, and (expected\n\t * negligible) call into slow-path, but never set up watchpoints.\n\t */\n\tWRITE_ONCE(kcsan_enabled, false);\n\n\tpr_info(\"%s begin | iters: %lu\\n\", __func__, iters);\n\n\tcycles = get_cycles();\n\twhile (iters--) {\n\t\tunsigned long addr = iters & ((PAGE_SIZE << 8) - 1);\n\t\tint type = !(iters & 0x7f) ? KCSAN_ACCESS_ATOMIC :\n\t\t\t\t(!(iters & 0xf) ? KCSAN_ACCESS_WRITE : 0);\n\t\t__kcsan_check_access((void *)addr, sizeof(long), type);\n\t}\n\tcycles = get_cycles() - cycles;\n\n\tpr_info(\"%s end   | cycles: %llu\\n\", __func__, cycles);\n\n\tWRITE_ONCE(kcsan_enabled, was_enabled);\n\t/* restore context */\n\tcurrent->kcsan_ctx = ctx_save;\n}",
    "includes": [
      "#include \"kcsan.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bug.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "kcsan_enabled",
            "was_enabled"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s end   | cycles: %llu\\n\"",
            "__func__",
            "cycles"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cycles",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kcsan_check_access",
          "args": [
            "(void *)addr",
            "sizeof(long)",
            "type"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "__kcsan_check_access",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "945-948",
          "snippet": "void __kcsan_check_access(const volatile void *ptr, size_t size, int type)\n{\n\tcheck_access(ptr, size, type, _RET_IP_);\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __tsan_read_range(void *ptr, size_t size);",
            "void __tsan_write_range(void *ptr, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid __tsan_read_range(void *ptr, size_t size);\nvoid __tsan_write_range(void *ptr, size_t size);\n\nvoid __kcsan_check_access(const volatile void *ptr, size_t size, int type)\n{\n\tcheck_access(ptr, size, type, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cycles",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s begin | iters: %lu\\n\"",
            "__func__",
            "iters"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "kcsan_enabled",
            "false"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&current->kcsan_ctx",
            "0",
            "sizeof(current->kcsan_ctx)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "kcsan_enabled"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic noinline void microbenchmark(unsigned long iters)\n{\n\tconst struct kcsan_ctx ctx_save = current->kcsan_ctx;\n\tconst bool was_enabled = READ_ONCE(kcsan_enabled);\n\tu64 cycles;\n\n\t/* We may have been called from an atomic region; reset context. */\n\tmemset(&current->kcsan_ctx, 0, sizeof(current->kcsan_ctx));\n\t/*\n\t * Disable to benchmark fast-path for all accesses, and (expected\n\t * negligible) call into slow-path, but never set up watchpoints.\n\t */\n\tWRITE_ONCE(kcsan_enabled, false);\n\n\tpr_info(\"%s begin | iters: %lu\\n\", __func__, iters);\n\n\tcycles = get_cycles();\n\twhile (iters--) {\n\t\tunsigned long addr = iters & ((PAGE_SIZE << 8) - 1);\n\t\tint type = !(iters & 0x7f) ? KCSAN_ACCESS_ATOMIC :\n\t\t\t\t(!(iters & 0xf) ? KCSAN_ACCESS_WRITE : 0);\n\t\t__kcsan_check_access((void *)addr, sizeof(long), type);\n\t}\n\tcycles = get_cycles() - cycles;\n\n\tpr_info(\"%s end   | cycles: %llu\\n\", __func__, cycles);\n\n\tWRITE_ONCE(kcsan_enabled, was_enabled);\n\t/* restore context */\n\tcurrent->kcsan_ctx = ctx_save;\n}"
  }
]