[
  {
    "function_name": "kexec_load_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec.c",
    "lines": "193-229",
    "snippet": "static inline int kexec_load_check(unsigned long nr_segments,\n\t\t\t\t   unsigned long flags)\n{\n\tint result;\n\n\t/* We only trust the superuser with rebooting the system. */\n\tif (!capable(CAP_SYS_BOOT) || kexec_load_disabled)\n\t\treturn -EPERM;\n\n\t/* Permit LSMs and IMA to fail the kexec */\n\tresult = security_kernel_load_data(LOADING_KEXEC_IMAGE, false);\n\tif (result < 0)\n\t\treturn result;\n\n\t/*\n\t * kexec can be used to circumvent module loading restrictions, so\n\t * prevent loading in that case\n\t */\n\tresult = security_locked_down(LOCKDOWN_KEXEC);\n\tif (result)\n\t\treturn result;\n\n\t/*\n\t * Verify we have a legal set of flags\n\t * This leaves us room for future extensions.\n\t */\n\tif ((flags & KEXEC_FLAGS) != (flags & ~KEXEC_ARCH_MASK))\n\t\treturn -EINVAL;\n\n\t/* Put an artificial cap on the number\n\t * of segments passed to kexec_load.\n\t */\n\tif (nr_segments > KEXEC_SEGMENT_MAX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_KEXEC"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_kernel_load_data",
          "args": [
            "LOADING_KEXEC_IMAGE",
            "false"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_BOOT"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic inline int kexec_load_check(unsigned long nr_segments,\n\t\t\t\t   unsigned long flags)\n{\n\tint result;\n\n\t/* We only trust the superuser with rebooting the system. */\n\tif (!capable(CAP_SYS_BOOT) || kexec_load_disabled)\n\t\treturn -EPERM;\n\n\t/* Permit LSMs and IMA to fail the kexec */\n\tresult = security_kernel_load_data(LOADING_KEXEC_IMAGE, false);\n\tif (result < 0)\n\t\treturn result;\n\n\t/*\n\t * kexec can be used to circumvent module loading restrictions, so\n\t * prevent loading in that case\n\t */\n\tresult = security_locked_down(LOCKDOWN_KEXEC);\n\tif (result)\n\t\treturn result;\n\n\t/*\n\t * Verify we have a legal set of flags\n\t * This leaves us room for future extensions.\n\t */\n\tif ((flags & KEXEC_FLAGS) != (flags & ~KEXEC_ARCH_MASK))\n\t\treturn -EINVAL;\n\n\t/* Put an artificial cap on the number\n\t * of segments passed to kexec_load.\n\t */\n\tif (nr_segments > KEXEC_SEGMENT_MAX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_kexec_load",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec.c",
    "lines": "87-170",
    "snippet": "static int do_kexec_load(unsigned long entry, unsigned long nr_segments,\n\t\tstruct kexec_segment *segments, unsigned long flags)\n{\n\tstruct kimage **dest_image, *image;\n\tunsigned long i;\n\tint ret;\n\n\t/*\n\t * Because we write directly to the reserved memory region when loading\n\t * crash kernels we need a mutex here to prevent multiple crash kernels\n\t * from attempting to load simultaneously, and to prevent a crash kernel\n\t * from loading over the top of a in use crash kernel.\n\t *\n\t * KISS: always take the mutex.\n\t */\n\tif (!mutex_trylock(&kexec_mutex))\n\t\treturn -EBUSY;\n\n\tif (flags & KEXEC_ON_CRASH) {\n\t\tdest_image = &kexec_crash_image;\n\t\tif (kexec_crash_image)\n\t\t\tarch_kexec_unprotect_crashkres();\n\t} else {\n\t\tdest_image = &kexec_image;\n\t}\n\n\tif (nr_segments == 0) {\n\t\t/* Uninstall image */\n\t\tkimage_free(xchg(dest_image, NULL));\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\tif (flags & KEXEC_ON_CRASH) {\n\t\t/*\n\t\t * Loading another kernel to switch to if this one\n\t\t * crashes.  Free any current crash dump kernel before\n\t\t * we corrupt it.\n\t\t */\n\t\tkimage_free(xchg(&kexec_crash_image, NULL));\n\t}\n\n\tret = kimage_alloc_init(&image, entry, nr_segments, segments, flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (flags & KEXEC_PRESERVE_CONTEXT)\n\t\timage->preserve_context = 1;\n\n\tret = machine_kexec_prepare(image);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Some architecture(like S390) may touch the crash memory before\n\t * machine_kexec_prepare(), we must copy vmcoreinfo data after it.\n\t */\n\tret = kimage_crash_copy_vmcoreinfo(image);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tret = kimage_load_segment(image, &image->segment[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tkimage_terminate(image);\n\n\tret = machine_kexec_post_load(image);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Install the new kernel and uninstall the old */\n\timage = xchg(dest_image, image);\n\nout:\n\tif ((flags & KEXEC_ON_CRASH) && kexec_crash_image)\n\t\tarch_kexec_protect_crashkres();\n\n\tkimage_free(image);\nout_unlock:\n\tmutex_unlock(&kexec_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kexec_mutex"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_free",
          "args": [
            "image"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "620-664",
          "snippet": "void kimage_free(struct kimage *image)\n{\n\tkimage_entry_t *ptr, entry;\n\tkimage_entry_t ind = 0;\n\n\tif (!image)\n\t\treturn;\n\n\tif (image->vmcoreinfo_data_copy) {\n\t\tcrash_update_vmcoreinfo_safecopy(NULL);\n\t\tvunmap(image->vmcoreinfo_data_copy);\n\t}\n\n\tkimage_free_extra_pages(image);\n\tfor_each_kimage_entry(image, ptr, entry) {\n\t\tif (entry & IND_INDIRECTION) {\n\t\t\t/* Free the previous indirection page */\n\t\t\tif (ind & IND_INDIRECTION)\n\t\t\t\tkimage_free_entry(ind);\n\t\t\t/* Save this indirection page until we are\n\t\t\t * done with it.\n\t\t\t */\n\t\t\tind = entry;\n\t\t} else if (entry & IND_SOURCE)\n\t\t\tkimage_free_entry(entry);\n\t}\n\t/* Free the final indirection page */\n\tif (ind & IND_INDIRECTION)\n\t\tkimage_free_entry(ind);\n\n\t/* Handle any machine specific cleanup */\n\tmachine_kexec_cleanup(image);\n\n\t/* Free the kexec control pages... */\n\tkimage_free_page_list(&image->control_pages);\n\n\t/*\n\t * Free up any temporary buffers allocated. This might hit if\n\t * error occurred much later after buffer allocation.\n\t */\n\tif (image->file_mode)\n\t\tkimage_file_post_load_cleanup(image);\n\n\tkfree(image);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free(struct kimage *image)\n{\n\tkimage_entry_t *ptr, entry;\n\tkimage_entry_t ind = 0;\n\n\tif (!image)\n\t\treturn;\n\n\tif (image->vmcoreinfo_data_copy) {\n\t\tcrash_update_vmcoreinfo_safecopy(NULL);\n\t\tvunmap(image->vmcoreinfo_data_copy);\n\t}\n\n\tkimage_free_extra_pages(image);\n\tfor_each_kimage_entry(image, ptr, entry) {\n\t\tif (entry & IND_INDIRECTION) {\n\t\t\t/* Free the previous indirection page */\n\t\t\tif (ind & IND_INDIRECTION)\n\t\t\t\tkimage_free_entry(ind);\n\t\t\t/* Save this indirection page until we are\n\t\t\t * done with it.\n\t\t\t */\n\t\t\tind = entry;\n\t\t} else if (entry & IND_SOURCE)\n\t\t\tkimage_free_entry(entry);\n\t}\n\t/* Free the final indirection page */\n\tif (ind & IND_INDIRECTION)\n\t\tkimage_free_entry(ind);\n\n\t/* Handle any machine specific cleanup */\n\tmachine_kexec_cleanup(image);\n\n\t/* Free the kexec control pages... */\n\tkimage_free_page_list(&image->control_pages);\n\n\t/*\n\t * Free up any temporary buffers allocated. This might hit if\n\t * error occurred much later after buffer allocation.\n\t */\n\tif (image->file_mode)\n\t\tkimage_file_post_load_cleanup(image);\n\n\tkfree(image);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_kexec_protect_crashkres",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kexec_protect_crashkres",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "1216-1217",
          "snippet": "void __weak arch_kexec_protect_crashkres(void)\n{}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid __weak arch_kexec_protect_crashkres(void)\n{}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "dest_image",
            "image"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "machine_kexec_post_load",
          "args": [
            "image"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "machine_kexec_post_load",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "594-597",
          "snippet": "int __weak machine_kexec_post_load(struct kimage *image)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint __weak machine_kexec_post_load(struct kimage *image)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_terminate",
          "args": [
            "image"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_terminate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "599-605",
          "snippet": "void kimage_terminate(struct kimage *image)\n{\n\tif (*image->entry != 0)\n\t\timage->entry++;\n\n\t*image->entry = IND_DONE;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_terminate(struct kimage *image)\n{\n\tif (*image->entry != 0)\n\t\timage->entry++;\n\n\t*image->entry = IND_DONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_load_segment",
          "args": [
            "image",
            "&image->segment[i]"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_load_segment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "919-934",
          "snippet": "int kimage_load_segment(struct kimage *image,\n\t\t\t\tstruct kexec_segment *segment)\n{\n\tint result = -ENOMEM;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tresult = kimage_load_normal_segment(image, segment);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tresult = kimage_load_crash_segment(image, segment);\n\t\tbreak;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kimage_load_segment(struct kimage *image,\n\t\t\t\tstruct kexec_segment *segment)\n{\n\tint result = -ENOMEM;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tresult = kimage_load_normal_segment(image, segment);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tresult = kimage_load_crash_segment(image, segment);\n\t\tbreak;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_crash_copy_vmcoreinfo",
          "args": [
            "image"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_crash_copy_vmcoreinfo",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "501-533",
          "snippet": "int kimage_crash_copy_vmcoreinfo(struct kimage *image)\n{\n\tstruct page *vmcoreinfo_page;\n\tvoid *safecopy;\n\n\tif (image->type != KEXEC_TYPE_CRASH)\n\t\treturn 0;\n\n\t/*\n\t * For kdump, allocate one vmcoreinfo safe copy from the\n\t * crash memory. as we have arch_kexec_protect_crashkres()\n\t * after kexec syscall, we naturally protect it from write\n\t * (even read) access under kernel direct mapping. But on\n\t * the other hand, we still need to operate it when crash\n\t * happens to generate vmcoreinfo note, hereby we rely on\n\t * vmap for this purpose.\n\t */\n\tvmcoreinfo_page = kimage_alloc_control_pages(image, 0);\n\tif (!vmcoreinfo_page) {\n\t\tpr_warn(\"Could not allocate vmcoreinfo buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsafecopy = vmap(&vmcoreinfo_page, 1, VM_MAP, PAGE_KERNEL);\n\tif (!safecopy) {\n\t\tpr_warn(\"Could not vmap vmcoreinfo buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\timage->vmcoreinfo_data_copy = safecopy;\n\tcrash_update_vmcoreinfo_safecopy(safecopy);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kimage_crash_copy_vmcoreinfo(struct kimage *image)\n{\n\tstruct page *vmcoreinfo_page;\n\tvoid *safecopy;\n\n\tif (image->type != KEXEC_TYPE_CRASH)\n\t\treturn 0;\n\n\t/*\n\t * For kdump, allocate one vmcoreinfo safe copy from the\n\t * crash memory. as we have arch_kexec_protect_crashkres()\n\t * after kexec syscall, we naturally protect it from write\n\t * (even read) access under kernel direct mapping. But on\n\t * the other hand, we still need to operate it when crash\n\t * happens to generate vmcoreinfo note, hereby we rely on\n\t * vmap for this purpose.\n\t */\n\tvmcoreinfo_page = kimage_alloc_control_pages(image, 0);\n\tif (!vmcoreinfo_page) {\n\t\tpr_warn(\"Could not allocate vmcoreinfo buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsafecopy = vmap(&vmcoreinfo_page, 1, VM_MAP, PAGE_KERNEL);\n\tif (!safecopy) {\n\t\tpr_warn(\"Could not vmap vmcoreinfo buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\timage->vmcoreinfo_data_copy = safecopy;\n\tcrash_update_vmcoreinfo_safecopy(safecopy);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "machine_kexec_prepare",
          "args": [
            "image"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_alloc_init",
          "args": [
            "&image",
            "entry",
            "nr_segments",
            "segments",
            "flags"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec.c",
          "lines": "22-85",
          "snippet": "static int kimage_alloc_init(struct kimage **rimage, unsigned long entry,\n\t\t\t     unsigned long nr_segments,\n\t\t\t     struct kexec_segment *segments,\n\t\t\t     unsigned long flags)\n{\n\tint ret;\n\tstruct kimage *image;\n\tbool kexec_on_panic = flags & KEXEC_ON_CRASH;\n\n\tif (kexec_on_panic) {\n\t\t/* Verify we have a valid entry point */\n\t\tif ((entry < phys_to_boot_phys(crashk_res.start)) ||\n\t\t    (entry > phys_to_boot_phys(crashk_res.end)))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/* Allocate and initialize a controlling structure */\n\timage = do_kimage_alloc_init();\n\tif (!image)\n\t\treturn -ENOMEM;\n\n\timage->start = entry;\n\timage->nr_segments = nr_segments;\n\tmemcpy(image->segment, segments, nr_segments * sizeof(*segments));\n\n\tif (kexec_on_panic) {\n\t\t/* Enable special crash kernel control page alloc policy. */\n\t\timage->control_page = crashk_res.start;\n\t\timage->type = KEXEC_TYPE_CRASH;\n\t}\n\n\tret = sanity_check_segment_list(image);\n\tif (ret)\n\t\tgoto out_free_image;\n\n\t/*\n\t * Find a location for the control code buffer, and add it\n\t * the vector of segments so that it's pages will also be\n\t * counted as destination pages.\n\t */\n\tret = -ENOMEM;\n\timage->control_code_page = kimage_alloc_control_pages(image,\n\t\t\t\t\t   get_order(KEXEC_CONTROL_PAGE_SIZE));\n\tif (!image->control_code_page) {\n\t\tpr_err(\"Could not allocate control_code_buffer\\n\");\n\t\tgoto out_free_image;\n\t}\n\n\tif (!kexec_on_panic) {\n\t\timage->swap_page = kimage_alloc_control_pages(image, 0);\n\t\tif (!image->swap_page) {\n\t\t\tpr_err(\"Could not allocate swap buffer\\n\");\n\t\t\tgoto out_free_control_pages;\n\t\t}\n\t}\n\n\t*rimage = image;\n\treturn 0;\nout_free_control_pages:\n\tkimage_free_page_list(&image->control_pages);\nout_free_image:\n\tkfree(image);\n\treturn ret;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/security.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kimage_alloc_init(struct kimage **rimage, unsigned long entry,\n\t\t\t     unsigned long nr_segments,\n\t\t\t     struct kexec_segment *segments,\n\t\t\t     unsigned long flags)\n{\n\tint ret;\n\tstruct kimage *image;\n\tbool kexec_on_panic = flags & KEXEC_ON_CRASH;\n\n\tif (kexec_on_panic) {\n\t\t/* Verify we have a valid entry point */\n\t\tif ((entry < phys_to_boot_phys(crashk_res.start)) ||\n\t\t    (entry > phys_to_boot_phys(crashk_res.end)))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/* Allocate and initialize a controlling structure */\n\timage = do_kimage_alloc_init();\n\tif (!image)\n\t\treturn -ENOMEM;\n\n\timage->start = entry;\n\timage->nr_segments = nr_segments;\n\tmemcpy(image->segment, segments, nr_segments * sizeof(*segments));\n\n\tif (kexec_on_panic) {\n\t\t/* Enable special crash kernel control page alloc policy. */\n\t\timage->control_page = crashk_res.start;\n\t\timage->type = KEXEC_TYPE_CRASH;\n\t}\n\n\tret = sanity_check_segment_list(image);\n\tif (ret)\n\t\tgoto out_free_image;\n\n\t/*\n\t * Find a location for the control code buffer, and add it\n\t * the vector of segments so that it's pages will also be\n\t * counted as destination pages.\n\t */\n\tret = -ENOMEM;\n\timage->control_code_page = kimage_alloc_control_pages(image,\n\t\t\t\t\t   get_order(KEXEC_CONTROL_PAGE_SIZE));\n\tif (!image->control_code_page) {\n\t\tpr_err(\"Could not allocate control_code_buffer\\n\");\n\t\tgoto out_free_image;\n\t}\n\n\tif (!kexec_on_panic) {\n\t\timage->swap_page = kimage_alloc_control_pages(image, 0);\n\t\tif (!image->swap_page) {\n\t\t\tpr_err(\"Could not allocate swap buffer\\n\");\n\t\t\tgoto out_free_control_pages;\n\t\t}\n\t}\n\n\t*rimage = image;\n\treturn 0;\nout_free_control_pages:\n\tkimage_free_page_list(&image->control_pages);\nout_free_image:\n\tkfree(image);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_kexec_unprotect_crashkres",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kexec_unprotect_crashkres",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "1219-1220",
          "snippet": "void __weak arch_kexec_unprotect_crashkres(void)\n{}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid __weak arch_kexec_unprotect_crashkres(void)\n{}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&kexec_mutex"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1278-1284",
          "snippet": "static __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int do_kexec_load(unsigned long entry, unsigned long nr_segments,\n\t\tstruct kexec_segment *segments, unsigned long flags)\n{\n\tstruct kimage **dest_image, *image;\n\tunsigned long i;\n\tint ret;\n\n\t/*\n\t * Because we write directly to the reserved memory region when loading\n\t * crash kernels we need a mutex here to prevent multiple crash kernels\n\t * from attempting to load simultaneously, and to prevent a crash kernel\n\t * from loading over the top of a in use crash kernel.\n\t *\n\t * KISS: always take the mutex.\n\t */\n\tif (!mutex_trylock(&kexec_mutex))\n\t\treturn -EBUSY;\n\n\tif (flags & KEXEC_ON_CRASH) {\n\t\tdest_image = &kexec_crash_image;\n\t\tif (kexec_crash_image)\n\t\t\tarch_kexec_unprotect_crashkres();\n\t} else {\n\t\tdest_image = &kexec_image;\n\t}\n\n\tif (nr_segments == 0) {\n\t\t/* Uninstall image */\n\t\tkimage_free(xchg(dest_image, NULL));\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\tif (flags & KEXEC_ON_CRASH) {\n\t\t/*\n\t\t * Loading another kernel to switch to if this one\n\t\t * crashes.  Free any current crash dump kernel before\n\t\t * we corrupt it.\n\t\t */\n\t\tkimage_free(xchg(&kexec_crash_image, NULL));\n\t}\n\n\tret = kimage_alloc_init(&image, entry, nr_segments, segments, flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (flags & KEXEC_PRESERVE_CONTEXT)\n\t\timage->preserve_context = 1;\n\n\tret = machine_kexec_prepare(image);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Some architecture(like S390) may touch the crash memory before\n\t * machine_kexec_prepare(), we must copy vmcoreinfo data after it.\n\t */\n\tret = kimage_crash_copy_vmcoreinfo(image);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tret = kimage_load_segment(image, &image->segment[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tkimage_terminate(image);\n\n\tret = machine_kexec_post_load(image);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Install the new kernel and uninstall the old */\n\timage = xchg(dest_image, image);\n\nout:\n\tif ((flags & KEXEC_ON_CRASH) && kexec_crash_image)\n\t\tarch_kexec_protect_crashkres();\n\n\tkimage_free(image);\nout_unlock:\n\tmutex_unlock(&kexec_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "kimage_alloc_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec.c",
    "lines": "22-85",
    "snippet": "static int kimage_alloc_init(struct kimage **rimage, unsigned long entry,\n\t\t\t     unsigned long nr_segments,\n\t\t\t     struct kexec_segment *segments,\n\t\t\t     unsigned long flags)\n{\n\tint ret;\n\tstruct kimage *image;\n\tbool kexec_on_panic = flags & KEXEC_ON_CRASH;\n\n\tif (kexec_on_panic) {\n\t\t/* Verify we have a valid entry point */\n\t\tif ((entry < phys_to_boot_phys(crashk_res.start)) ||\n\t\t    (entry > phys_to_boot_phys(crashk_res.end)))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/* Allocate and initialize a controlling structure */\n\timage = do_kimage_alloc_init();\n\tif (!image)\n\t\treturn -ENOMEM;\n\n\timage->start = entry;\n\timage->nr_segments = nr_segments;\n\tmemcpy(image->segment, segments, nr_segments * sizeof(*segments));\n\n\tif (kexec_on_panic) {\n\t\t/* Enable special crash kernel control page alloc policy. */\n\t\timage->control_page = crashk_res.start;\n\t\timage->type = KEXEC_TYPE_CRASH;\n\t}\n\n\tret = sanity_check_segment_list(image);\n\tif (ret)\n\t\tgoto out_free_image;\n\n\t/*\n\t * Find a location for the control code buffer, and add it\n\t * the vector of segments so that it's pages will also be\n\t * counted as destination pages.\n\t */\n\tret = -ENOMEM;\n\timage->control_code_page = kimage_alloc_control_pages(image,\n\t\t\t\t\t   get_order(KEXEC_CONTROL_PAGE_SIZE));\n\tif (!image->control_code_page) {\n\t\tpr_err(\"Could not allocate control_code_buffer\\n\");\n\t\tgoto out_free_image;\n\t}\n\n\tif (!kexec_on_panic) {\n\t\timage->swap_page = kimage_alloc_control_pages(image, 0);\n\t\tif (!image->swap_page) {\n\t\t\tpr_err(\"Could not allocate swap buffer\\n\");\n\t\t\tgoto out_free_control_pages;\n\t\t}\n\t}\n\n\t*rimage = image;\n\treturn 0;\nout_free_control_pages:\n\tkimage_free_page_list(&image->control_pages);\nout_free_image:\n\tkfree(image);\n\treturn ret;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "image"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_free_page_list",
          "args": [
            "&image->control_pages"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "341-349",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Could not allocate swap buffer\\n\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_alloc_control_pages",
          "args": [
            "image",
            "0"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_control_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "484-499",
          "snippet": "struct page *kimage_alloc_control_pages(struct kimage *image,\n\t\t\t\t\t unsigned int order)\n{\n\tstruct page *pages = NULL;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tpages = kimage_alloc_normal_control_pages(image, order);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tpages = kimage_alloc_crash_control_pages(image, order);\n\t\tbreak;\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct page *kimage_alloc_control_pages(struct kimage *image,\n\t\t\t\t\t unsigned int order)\n{\n\tstruct page *pages = NULL;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tpages = kimage_alloc_normal_control_pages(image, order);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tpages = kimage_alloc_crash_control_pages(image, order);\n\t\tbreak;\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Could not allocate control_code_buffer\\n\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "KEXEC_CONTROL_PAGE_SIZE"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanity_check_segment_list",
          "args": [
            "image"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "sanity_check_segment_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "149-253",
          "snippet": "int sanity_check_segment_list(struct kimage *image)\n{\n\tint i;\n\tunsigned long nr_segments = image->nr_segments;\n\tunsigned long total_pages = 0;\n\tunsigned long nr_pages = totalram_pages();\n\n\t/*\n\t * Verify we have good destination addresses.  The caller is\n\t * responsible for making certain we don't attempt to load\n\t * the new image into invalid or reserved areas of RAM.  This\n\t * just verifies it is an address we can use.\n\t *\n\t * Since the kernel does everything in page size chunks ensure\n\t * the destination addresses are page aligned.  Too many\n\t * special cases crop of when we don't do this.  The most\n\t * insidious is getting overlapping destination addresses\n\t * simply because addresses are changed to page size\n\t * granularity.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tif (mstart > mend)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif ((mstart & ~PAGE_MASK) || (mend & ~PAGE_MASK))\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif (mend >= KEXEC_DESTINATION_MEMORY_LIMIT)\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/* Verify our destination addresses do not overlap.\n\t * If we alloed overlapping destination addresses\n\t * through very weird things can happen with no\n\t * easy explanation as one segment stops on another.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\t\tunsigned long j;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tunsigned long pstart, pend;\n\n\t\t\tpstart = image->segment[j].mem;\n\t\t\tpend   = pstart + image->segment[j].memsz;\n\t\t\t/* Do the segments overlap ? */\n\t\t\tif ((mend > pstart) && (mstart < pend))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Ensure our buffer sizes are strictly less than\n\t * our memory sizes.  This should always be the case,\n\t * and it is easier to check up front than to be surprised\n\t * later on.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (image->segment[i].bufsz > image->segment[i].memsz)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Verify that no more than half of memory will be consumed. If the\n\t * request from userspace is too large, a large amount of time will be\n\t * wasted allocating pages, which can cause a soft lockup.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (PAGE_COUNT(image->segment[i].memsz) > nr_pages / 2)\n\t\t\treturn -EINVAL;\n\n\t\ttotal_pages += PAGE_COUNT(image->segment[i].memsz);\n\t}\n\n\tif (total_pages > nr_pages / 2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Verify we have good destination addresses.  Normally\n\t * the caller is responsible for making certain we don't\n\t * attempt to load the new image into invalid or reserved\n\t * areas of RAM.  But crash kernels are preloaded into a\n\t * reserved area of ram.  We must ensure the addresses\n\t * are in the reserved area otherwise preloading the\n\t * kernel could corrupt things.\n\t */\n\n\tif (image->type == KEXEC_TYPE_CRASH) {\n\t\tfor (i = 0; i < nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->segment[i].mem;\n\t\t\tmend = mstart + image->segment[i].memsz - 1;\n\t\t\t/* Ensure we are within the crash kernel limits */\n\t\t\tif ((mstart < phys_to_boot_phys(crashk_res.start)) ||\n\t\t\t    (mend > phys_to_boot_phys(crashk_res.end)))\n\t\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};\n\nint sanity_check_segment_list(struct kimage *image)\n{\n\tint i;\n\tunsigned long nr_segments = image->nr_segments;\n\tunsigned long total_pages = 0;\n\tunsigned long nr_pages = totalram_pages();\n\n\t/*\n\t * Verify we have good destination addresses.  The caller is\n\t * responsible for making certain we don't attempt to load\n\t * the new image into invalid or reserved areas of RAM.  This\n\t * just verifies it is an address we can use.\n\t *\n\t * Since the kernel does everything in page size chunks ensure\n\t * the destination addresses are page aligned.  Too many\n\t * special cases crop of when we don't do this.  The most\n\t * insidious is getting overlapping destination addresses\n\t * simply because addresses are changed to page size\n\t * granularity.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tif (mstart > mend)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif ((mstart & ~PAGE_MASK) || (mend & ~PAGE_MASK))\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif (mend >= KEXEC_DESTINATION_MEMORY_LIMIT)\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/* Verify our destination addresses do not overlap.\n\t * If we alloed overlapping destination addresses\n\t * through very weird things can happen with no\n\t * easy explanation as one segment stops on another.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\t\tunsigned long j;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tunsigned long pstart, pend;\n\n\t\t\tpstart = image->segment[j].mem;\n\t\t\tpend   = pstart + image->segment[j].memsz;\n\t\t\t/* Do the segments overlap ? */\n\t\t\tif ((mend > pstart) && (mstart < pend))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Ensure our buffer sizes are strictly less than\n\t * our memory sizes.  This should always be the case,\n\t * and it is easier to check up front than to be surprised\n\t * later on.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (image->segment[i].bufsz > image->segment[i].memsz)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Verify that no more than half of memory will be consumed. If the\n\t * request from userspace is too large, a large amount of time will be\n\t * wasted allocating pages, which can cause a soft lockup.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (PAGE_COUNT(image->segment[i].memsz) > nr_pages / 2)\n\t\t\treturn -EINVAL;\n\n\t\ttotal_pages += PAGE_COUNT(image->segment[i].memsz);\n\t}\n\n\tif (total_pages > nr_pages / 2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Verify we have good destination addresses.  Normally\n\t * the caller is responsible for making certain we don't\n\t * attempt to load the new image into invalid or reserved\n\t * areas of RAM.  But crash kernels are preloaded into a\n\t * reserved area of ram.  We must ensure the addresses\n\t * are in the reserved area otherwise preloading the\n\t * kernel could corrupt things.\n\t */\n\n\tif (image->type == KEXEC_TYPE_CRASH) {\n\t\tfor (i = 0; i < nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->segment[i].mem;\n\t\t\tmend = mstart + image->segment[i].memsz - 1;\n\t\t\t/* Ensure we are within the crash kernel limits */\n\t\t\tif ((mstart < phys_to_boot_phys(crashk_res.start)) ||\n\t\t\t    (mend > phys_to_boot_phys(crashk_res.end)))\n\t\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "image->segment",
            "segments",
            "nr_segments * sizeof(*segments)"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_kimage_alloc_init",
          "args": [],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "do_kimage_alloc_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "255-280",
          "snippet": "struct kimage *do_kimage_alloc_init(void)\n{\n\tstruct kimage *image;\n\n\t/* Allocate a controlling structure */\n\timage = kzalloc(sizeof(*image), GFP_KERNEL);\n\tif (!image)\n\t\treturn NULL;\n\n\timage->head = 0;\n\timage->entry = &image->head;\n\timage->last_entry = &image->head;\n\timage->control_page = ~0; /* By default this does not apply */\n\timage->type = KEXEC_TYPE_DEFAULT;\n\n\t/* Initialize the list of control pages */\n\tINIT_LIST_HEAD(&image->control_pages);\n\n\t/* Initialize the list of destination pages */\n\tINIT_LIST_HEAD(&image->dest_pages);\n\n\t/* Initialize the list of unusable pages */\n\tINIT_LIST_HEAD(&image->unusable_pages);\n\n\treturn image;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct kimage *do_kimage_alloc_init(void)\n{\n\tstruct kimage *image;\n\n\t/* Allocate a controlling structure */\n\timage = kzalloc(sizeof(*image), GFP_KERNEL);\n\tif (!image)\n\t\treturn NULL;\n\n\timage->head = 0;\n\timage->entry = &image->head;\n\timage->last_entry = &image->head;\n\timage->control_page = ~0; /* By default this does not apply */\n\timage->type = KEXEC_TYPE_DEFAULT;\n\n\t/* Initialize the list of control pages */\n\tINIT_LIST_HEAD(&image->control_pages);\n\n\t/* Initialize the list of destination pages */\n\tINIT_LIST_HEAD(&image->dest_pages);\n\n\t/* Initialize the list of unusable pages */\n\tINIT_LIST_HEAD(&image->unusable_pages);\n\n\treturn image;\n}"
        }
      },
      {
        "call_info": {
          "callee": "phys_to_boot_phys",
          "args": [
            "crashk_res.end"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_boot_phys",
          "args": [
            "crashk_res.start"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kimage_alloc_init(struct kimage **rimage, unsigned long entry,\n\t\t\t     unsigned long nr_segments,\n\t\t\t     struct kexec_segment *segments,\n\t\t\t     unsigned long flags)\n{\n\tint ret;\n\tstruct kimage *image;\n\tbool kexec_on_panic = flags & KEXEC_ON_CRASH;\n\n\tif (kexec_on_panic) {\n\t\t/* Verify we have a valid entry point */\n\t\tif ((entry < phys_to_boot_phys(crashk_res.start)) ||\n\t\t    (entry > phys_to_boot_phys(crashk_res.end)))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/* Allocate and initialize a controlling structure */\n\timage = do_kimage_alloc_init();\n\tif (!image)\n\t\treturn -ENOMEM;\n\n\timage->start = entry;\n\timage->nr_segments = nr_segments;\n\tmemcpy(image->segment, segments, nr_segments * sizeof(*segments));\n\n\tif (kexec_on_panic) {\n\t\t/* Enable special crash kernel control page alloc policy. */\n\t\timage->control_page = crashk_res.start;\n\t\timage->type = KEXEC_TYPE_CRASH;\n\t}\n\n\tret = sanity_check_segment_list(image);\n\tif (ret)\n\t\tgoto out_free_image;\n\n\t/*\n\t * Find a location for the control code buffer, and add it\n\t * the vector of segments so that it's pages will also be\n\t * counted as destination pages.\n\t */\n\tret = -ENOMEM;\n\timage->control_code_page = kimage_alloc_control_pages(image,\n\t\t\t\t\t   get_order(KEXEC_CONTROL_PAGE_SIZE));\n\tif (!image->control_code_page) {\n\t\tpr_err(\"Could not allocate control_code_buffer\\n\");\n\t\tgoto out_free_image;\n\t}\n\n\tif (!kexec_on_panic) {\n\t\timage->swap_page = kimage_alloc_control_pages(image, 0);\n\t\tif (!image->swap_page) {\n\t\t\tpr_err(\"Could not allocate swap buffer\\n\");\n\t\t\tgoto out_free_control_pages;\n\t\t}\n\t}\n\n\t*rimage = image;\n\treturn 0;\nout_free_control_pages:\n\tkimage_free_page_list(&image->control_pages);\nout_free_image:\n\tkfree(image);\n\treturn ret;\n}"
  },
  {
    "function_name": "kexec_load",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec.c",
    "lines": "231-254",
    "snippet": "SYSCALL_DEFINE4(kexec_load, unsigned long, entry, unsigned long, nr_segments,\n\t\tstruct kexec_segment __user *, segments, unsigned long, flags)\n{\n\tstruct kexec_segment *ksegments;\n\tunsigned long result;\n\n\tresult = kexec_load_check(nr_segments, flags);\n\tif (result)\n\t\treturn result;\n\n\t/* Verify we are on the appropriate architecture */\n\tif (((flags & KEXEC_ARCH_MASK) != KEXEC_ARCH) &&\n\t\t((flags & KEXEC_ARCH_MASK) != KEXEC_ARCH_DEFAULT))\n\t\treturn -EINVAL;\n\n\tksegments = memdup_user(segments, nr_segments * sizeof(ksegments[0]));\n\tif (IS_ERR(ksegments))\n\t\treturn PTR_ERR(ksegments);\n\n\tresult = do_kexec_load(entry, nr_segments, ksegments, flags);\n\tkfree(ksegments);\n\n\treturn result;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nSYSCALL_DEFINE4(kexec_load, unsigned long, entry, unsigned long, nr_segments,\n\t\tstruct kexec_segment __user *, segments, unsigned long, flags)\n{\n\tstruct kexec_segment *ksegments;\n\tunsigned long result;\n\n\tresult = kexec_load_check(nr_segments, flags);\n\tif (result)\n\t\treturn result;\n\n\t/* Verify we are on the appropriate architecture */\n\tif (((flags & KEXEC_ARCH_MASK) != KEXEC_ARCH) &&\n\t\t((flags & KEXEC_ARCH_MASK) != KEXEC_ARCH_DEFAULT))\n\t\treturn -EINVAL;\n\n\tksegments = memdup_user(segments, nr_segments * sizeof(ksegments[0]));\n\tif (IS_ERR(ksegments))\n\t\treturn PTR_ERR(ksegments);\n\n\tresult = do_kexec_load(entry, nr_segments, ksegments, flags);\n\tkfree(ksegments);\n\n\treturn result;\n}"
  },
  {
    "function_name": "kexec_load",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec.c",
    "lines": "257-297",
    "snippet": "SYSCALL_DEFINE4(kexec_load, compat_ulong_t, entry,\n\t\t       compat_ulong_t, nr_segments,\n\t\t       struct compat_kexec_segment __user *, segments,\n\t\t       compat_ulong_t, flags)\n{\n\tstruct compat_kexec_segment in;\n\tstruct kexec_segment *ksegments;\n\tunsigned long i, result;\n\n\tresult = kexec_load_check(nr_segments, flags);\n\tif (result)\n\t\treturn result;\n\n\t/* Don't allow clients that don't understand the native\n\t * architecture to do anything.\n\t */\n\tif ((flags & KEXEC_ARCH_MASK) == KEXEC_ARCH_DEFAULT)\n\t\treturn -EINVAL;\n\n\tksegments = kmalloc_array(nr_segments, sizeof(ksegments[0]),\n\t\t\tGFP_KERNEL);\n\tif (!ksegments)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tresult = copy_from_user(&in, &segments[i], sizeof(in));\n\t\tif (result)\n\t\t\tgoto fail;\n\n\t\tksegments[i].buf   = compat_ptr(in.buf);\n\t\tksegments[i].bufsz = in.bufsz;\n\t\tksegments[i].mem   = in.mem;\n\t\tksegments[i].memsz = in.memsz;\n\t}\n\n\tresult = do_kexec_load(entry, nr_segments, ksegments, flags);\n\nfail:\n\tkfree(ksegments);\n\treturn result;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/security.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nSYSCALL_DEFINE4(kexec_load, compat_ulong_t, entry,\n\t\t       compat_ulong_t, nr_segments,\n\t\t       struct compat_kexec_segment __user *, segments,\n\t\t       compat_ulong_t, flags)\n{\n\tstruct compat_kexec_segment in;\n\tstruct kexec_segment *ksegments;\n\tunsigned long i, result;\n\n\tresult = kexec_load_check(nr_segments, flags);\n\tif (result)\n\t\treturn result;\n\n\t/* Don't allow clients that don't understand the native\n\t * architecture to do anything.\n\t */\n\tif ((flags & KEXEC_ARCH_MASK) == KEXEC_ARCH_DEFAULT)\n\t\treturn -EINVAL;\n\n\tksegments = kmalloc_array(nr_segments, sizeof(ksegments[0]),\n\t\t\tGFP_KERNEL);\n\tif (!ksegments)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tresult = copy_from_user(&in, &segments[i], sizeof(in));\n\t\tif (result)\n\t\t\tgoto fail;\n\n\t\tksegments[i].buf   = compat_ptr(in.buf);\n\t\tksegments[i].bufsz = in.bufsz;\n\t\tksegments[i].mem   = in.mem;\n\t\tksegments[i].memsz = in.memsz;\n\t}\n\n\tresult = do_kexec_load(entry, nr_segments, ksegments, flags);\n\nfail:\n\tkfree(ksegments);\n\treturn result;\n}"
  }
]